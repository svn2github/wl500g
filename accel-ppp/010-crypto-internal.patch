--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,7 +6,7 @@ project(accel-ppp C)
 
 include(cmake/cpack.cmake)
 
-SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -fvisibility=hidden -fno-strict-aliasing -D_GNU_SOURCE -fPIC -rdynamic")
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -fno-strict-aliasing -D_GNU_SOURCE -fPIC -rdynamic")
 
 IF (NOT DEFINED LIB_SUFFIX)
 	EXECUTE_PROCESS(
@@ -50,7 +50,8 @@ if (NOT BUILD_DRIVER_ONLY)
 		set(crypto_lib crypto ssl)
 	elseif (CRYPTO STREQUAL TOMCRYPT)
 		add_definitions(-DCRYPTO_TOMCRYPT)
-		set(crypto_lib tomcrypt)
+		INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/crypto)
+		set(crypto_lib tomcrypt internal-crypto)
 	elseif (CRYPTO STREQUAL INTERNAL)
 		INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/crypto)
 		set(crypto_lib internal-crypto)
--- a/accel-pppd/CMakeLists.txt
+++ b/accel-pppd/CMakeLists.txt
@@ -1,3 +1,4 @@
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fvisibility=hidden")
 ADD_DEFINITIONS(-DPTHREAD_SPINLOCK)
 
 INCLUDE_DIRECTORIES(include)
--- a/accel-pppd/auth/CMakeLists.txt
+++ b/accel-pppd/auth/CMakeLists.txt
@@ -3,10 +3,6 @@ ADD_LIBRARY(auth_chap_md5 SHARED auth_chap_md5.c)
 ADD_LIBRARY(auth_mschap_v1 SHARED auth_mschap_v1.c)
 ADD_LIBRARY(auth_mschap_v2 SHARED auth_mschap_v2.c)
 
-TARGET_LINK_LIBRARIES(auth_chap_md5 ${crypto_lib})
-TARGET_LINK_LIBRARIES(auth_mschap_v1 ${crypto_lib})
-TARGET_LINK_LIBRARIES(auth_mschap_v2 ${crypto_lib})
-
 INSTALL(TARGETS auth_pap auth_chap_md5 auth_mschap_v1 auth_mschap_v2
 	LIBRARY DESTINATION lib${LIB_SUFFIX}/accel-ppp
 )
--- a/accel-pppd/ctrl/pppoe/CMakeLists.txt
+++ b/accel-pppd/ctrl/pppoe/CMakeLists.txt
@@ -12,6 +12,5 @@ SET(sources ${sources} tr101.c)
 ENDIF(RADIUS)
 
 ADD_LIBRARY(pppoe SHARED ${sources})
-TARGET_LINK_LIBRARIES(pppoe ${crypto_lib})
 
 INSTALL(TARGETS pppoe LIBRARY DESTINATION lib${LIB_SUFFIX}/accel-ppp)
--- a/accel-pppd/extra/chap-secrets.c
+++ b/accel-pppd/extra/chap-secrets.c
@@ -30,11 +30,13 @@ static int conf_netmask;
 static void *pd_key;
 static struct ipdb_t ipdb;
 
+#ifdef CRYPTO_OPENSSL
 struct hash_chain
 {
 	struct list_head entry;
 	const EVP_MD *md;
 };
+#endif
 
 struct cs_pd_t
 {
@@ -44,7 +46,9 @@ struct cs_pd_t
 	char *rate;
 };
 
+#ifdef CRYPTO_OPENSSL
 static LIST_HEAD(hash_chain);
+#endif
 
 static char *skip_word(char *ptr)
 {
--- a/crypto/CMakeLists.txt
+++ b/crypto/CMakeLists.txt
@@ -1,17 +1,21 @@
-IF (CRYPTO STREQUAL INTERNAL)
+INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR})
+
+SET(sources crypto.c)
 
+IF (CRYPTO STREQUAL INTERNAL)
 	SET(sources
+		${sources}
 		crypto.c
 		md4.c
 		md5.c
 		sha1.c
 		des.c
 	)
+ENDIF(CRYPTO STREQUAL INTERNAL)
 
-	ADD_LIBRARY(internal-crypto SHARED ${sources})
-
-	INSTALL(TARGETS internal-crypto
-		LIBRARY DESTINATION lib/accel-ppp
-	)
+ADD_LIBRARY(internal-crypto SHARED ${sources})
+IF (CRYPTO STREQUAL TOMCRYPT)
+	TARGET_LINK_LIBRARIES(internal-crypto tomcrypt)
+ENDIF(CRYPTO STREQUAL TOMCRYPT)
 
-ENDIF (CRYPTO STREQUAL INTERNAL)
+INSTALL(TARGETS internal-crypto LIBRARY DESTINATION lib${LIB_SUFFIX}/accel-ppp )
--- a/crypto/des.c
+++ b/crypto/des.c
@@ -34,6 +34,7 @@ const struct ltc_cipher_descriptor des_desc =
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 
+#ifdef LTC_DES3
 const struct ltc_cipher_descriptor des3_desc =
 {
     "3des",
@@ -47,6 +48,7 @@ const struct ltc_cipher_descriptor des3_desc =
     &des3_keysize,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
+#endif
 
 static const ulong32 bytebit[8] =
 {
@@ -1545,6 +1547,7 @@ int des_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_ke
     return CRYPT_OK;
 }
 
+#ifdef LTC_DES3
  /**
     Initialize the 3LTC_DES-EDE block cipher
     @param key The symmetric key you wish to pass
@@ -1576,6 +1579,7 @@ int des3_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_k
 
     return CRYPT_OK;
 }
+#endif
 
 /**
   Encrypts a block of text with LTC_DES
@@ -1619,6 +1623,7 @@ int des_ecb_decrypt(const unsigned char *ct, unsigned char *pt, symmetric_key *s
     return CRYPT_OK;
 }
 
+#ifdef LTC_DES3
 /**
   Encrypts a block of text with 3LTC_DES-EDE
   @param pt The input plaintext (8 bytes)
@@ -1665,6 +1670,7 @@ int des3_ecb_decrypt(const unsigned char *ct, unsigned char *pt, symmetric_key *
     STORE32H(work[1],pt+4);
     return CRYPT_OK;
 }
+#endif
 
 /**
   Performs a self-test of the LTC_DES block cipher
@@ -1813,6 +1819,7 @@ int des_test(void)
   #endif
 }
 
+#ifdef LTC_DES3
 int des3_test(void)
 {
  #ifndef LTC_TEST
@@ -1848,6 +1855,7 @@ int des3_test(void)
    return CRYPT_OK;
  #endif
 }
+#endif
 
 /** Terminate the context 
    @param skey    The scheduled key
@@ -1856,12 +1864,14 @@ void des_done(symmetric_key *skey)
 {
 }
 
+#ifdef LTC_DES3
 /** Terminate the context 
    @param skey    The scheduled key
 */
 void des3_done(symmetric_key *skey)
 {
 }
+#endif
 
 
 /**
@@ -1879,6 +1889,7 @@ int des_keysize(int *keysize)
     return CRYPT_OK;
 }
 
+#ifdef LTC_DES3
 /**
   Gets suitable key size
   @param keysize [in/out] The length of the recommended key (in bytes).  This function will store the suitable size back in this variable.
@@ -1893,6 +1904,7 @@ int des3_keysize(int *keysize)
     *keysize = 24;
     return CRYPT_OK;
 }
+#endif
 
 #endif
 
--- a/crypto/tomcrypt_cipher.h
+++ b/crypto/tomcrypt_cipher.h
@@ -91,11 +91,12 @@ struct rc2_key { unsigned xkey[64]; };
 struct des_key {
     ulong32 ek[32], dk[32];
 };
-
+#ifdef LTC_DES3
 struct des3_key {
     ulong32 ek[3][32], dk[3][32];
 };
 #endif
+#endif
 
 #ifdef LTC_CAST5
 struct cast5_key {
@@ -141,10 +142,11 @@ struct multi2_key {
 typedef union Symmetric_key {
 #ifdef LTC_DES
    struct des_key des;
+#ifdef LTC_DES3
    struct des3_key des3;
 #endif
+#endif
 #ifdef LTC_RC2
-	 aa
    struct rc2_key rc2;
 #endif
 #ifdef LTC_SAFER
@@ -667,13 +669,16 @@ int des_ecb_decrypt(const unsigned char *ct, unsigned char *pt, symmetric_key *s
 int des_test(void);
 void des_done(symmetric_key *skey);
 int des_keysize(int *keysize);
+extern const struct ltc_cipher_descriptor des_desc;
+#ifdef LTC_DES3
 int des3_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey);
 int des3_ecb_encrypt(const unsigned char *pt, unsigned char *ct, symmetric_key *skey);
 int des3_ecb_decrypt(const unsigned char *ct, unsigned char *pt, symmetric_key *skey);
 int des3_test(void);
 void des3_done(symmetric_key *skey);
 int des3_keysize(int *keysize);
-extern const struct ltc_cipher_descriptor des_desc, des3_desc;
+extern const struct ltc_cipher_descriptor des3_desc;
+#endif
 #endif
 
 #ifdef LTC_CAST5
--- a/crypto/tomcrypt_custom.h
+++ b/crypto/tomcrypt_custom.h
@@ -16,6 +16,7 @@
 #define LTC_MD5
 #define LTC_SHA1
 #define LTC_DES
+#undef  LTC_DES3
 
 /* macros for various libc functions you can change for embedded targets */
 #ifndef XMALLOC
@@ -88,6 +89,7 @@
    #define LTC_RIJNDAEL
    #define LTC_BLOWFISH
    #define LTC_DES
+   #define LTC_DES3
    #define LTC_CAST5
    
    #define LTC_NO_MODES
@@ -163,6 +165,7 @@
 /* #define LTC_TWOFISH_SMALL */
 /* LTC_DES includes EDE triple-LTC_DES */
 #define LTC_DES
+#define LTC_DES3
 #define LTC_CAST5
 #define LTC_NOEKEON
 #define LTC_SKIPJACK
--- /dev/null
+++ b/crypto/tomcrypt_macros.h
@@ -0,0 +1,424 @@
+/* fix for MSVC ...evil! */
+#ifdef _MSC_VER
+   #define CONST64(n) n ## ui64
+   typedef unsigned __int64 ulong64;
+#else
+   #define CONST64(n) n ## ULL
+   typedef unsigned long long ulong64;
+#endif
+
+/* this is the "32-bit at least" data type 
+ * Re-define it to suit your platform but it must be at least 32-bits 
+ */
+#if defined(__x86_64__) || (defined(__sparc__) && defined(__arch64__))
+   typedef unsigned ulong32;
+#else
+   typedef unsigned long ulong32;
+#endif
+
+/* ---- HELPER MACROS ---- */
+#ifdef ENDIAN_NEUTRAL
+
+#define STORE32L(x, y)                                                                     \
+     { (y)[3] = (unsigned char)(((x)>>24)&255); (y)[2] = (unsigned char)(((x)>>16)&255);   \
+       (y)[1] = (unsigned char)(((x)>>8)&255); (y)[0] = (unsigned char)((x)&255); }
+
+#define LOAD32L(x, y)                            \
+     { x = ((unsigned long)((y)[3] & 255)<<24) | \
+           ((unsigned long)((y)[2] & 255)<<16) | \
+           ((unsigned long)((y)[1] & 255)<<8)  | \
+           ((unsigned long)((y)[0] & 255)); }
+
+#define STORE64L(x, y)                                                                     \
+     { (y)[7] = (unsigned char)(((x)>>56)&255); (y)[6] = (unsigned char)(((x)>>48)&255);   \
+       (y)[5] = (unsigned char)(((x)>>40)&255); (y)[4] = (unsigned char)(((x)>>32)&255);   \
+       (y)[3] = (unsigned char)(((x)>>24)&255); (y)[2] = (unsigned char)(((x)>>16)&255);   \
+       (y)[1] = (unsigned char)(((x)>>8)&255); (y)[0] = (unsigned char)((x)&255); }
+
+#define LOAD64L(x, y)                                                       \
+     { x = (((ulong64)((y)[7] & 255))<<56)|(((ulong64)((y)[6] & 255))<<48)| \
+           (((ulong64)((y)[5] & 255))<<40)|(((ulong64)((y)[4] & 255))<<32)| \
+           (((ulong64)((y)[3] & 255))<<24)|(((ulong64)((y)[2] & 255))<<16)| \
+           (((ulong64)((y)[1] & 255))<<8)|(((ulong64)((y)[0] & 255))); }
+
+#define STORE32H(x, y)                                                                     \
+     { (y)[0] = (unsigned char)(((x)>>24)&255); (y)[1] = (unsigned char)(((x)>>16)&255);   \
+       (y)[2] = (unsigned char)(((x)>>8)&255); (y)[3] = (unsigned char)((x)&255); }
+
+#define LOAD32H(x, y)                            \
+     { x = ((unsigned long)((y)[0] & 255)<<24) | \
+           ((unsigned long)((y)[1] & 255)<<16) | \
+           ((unsigned long)((y)[2] & 255)<<8)  | \
+           ((unsigned long)((y)[3] & 255)); }
+
+#define STORE64H(x, y)                                                                     \
+   { (y)[0] = (unsigned char)(((x)>>56)&255); (y)[1] = (unsigned char)(((x)>>48)&255);     \
+     (y)[2] = (unsigned char)(((x)>>40)&255); (y)[3] = (unsigned char)(((x)>>32)&255);     \
+     (y)[4] = (unsigned char)(((x)>>24)&255); (y)[5] = (unsigned char)(((x)>>16)&255);     \
+     (y)[6] = (unsigned char)(((x)>>8)&255); (y)[7] = (unsigned char)((x)&255); }
+
+#define LOAD64H(x, y)                                                      \
+   { x = (((ulong64)((y)[0] & 255))<<56)|(((ulong64)((y)[1] & 255))<<48) | \
+         (((ulong64)((y)[2] & 255))<<40)|(((ulong64)((y)[3] & 255))<<32) | \
+         (((ulong64)((y)[4] & 255))<<24)|(((ulong64)((y)[5] & 255))<<16) | \
+         (((ulong64)((y)[6] & 255))<<8)|(((ulong64)((y)[7] & 255))); }
+
+#endif /* ENDIAN_NEUTRAL */
+
+#ifdef ENDIAN_LITTLE
+
+#if !defined(LTC_NO_BSWAP) && (defined(INTEL_CC) || (defined(__GNUC__) && (defined(__DJGPP__) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__i386__) || defined(__x86_64__))))
+
+#define STORE32H(x, y)           \
+asm __volatile__ (               \
+   "bswapl %0     \n\t"          \
+   "movl   %0,(%1)\n\t"          \
+   "bswapl %0     \n\t"          \
+      ::"r"(x), "r"(y));
+
+#define LOAD32H(x, y)          \
+asm __volatile__ (             \
+   "movl (%1),%0\n\t"          \
+   "bswapl %0\n\t"             \
+   :"=r"(x): "r"(y));
+
+#else
+
+#define STORE32H(x, y)                                                                     \
+     { (y)[0] = (unsigned char)(((x)>>24)&255); (y)[1] = (unsigned char)(((x)>>16)&255);   \
+       (y)[2] = (unsigned char)(((x)>>8)&255); (y)[3] = (unsigned char)((x)&255); }
+
+#define LOAD32H(x, y)                            \
+     { x = ((unsigned long)((y)[0] & 255)<<24) | \
+           ((unsigned long)((y)[1] & 255)<<16) | \
+           ((unsigned long)((y)[2] & 255)<<8)  | \
+           ((unsigned long)((y)[3] & 255)); }
+
+#endif
+
+
+/* x86_64 processor */
+#if !defined(LTC_NO_BSWAP) && (defined(__GNUC__) && defined(__x86_64__))
+
+#define STORE64H(x, y)           \
+asm __volatile__ (               \
+   "bswapq %0     \n\t"          \
+   "movq   %0,(%1)\n\t"          \
+   "bswapq %0     \n\t"          \
+      ::"r"(x), "r"(y));
+
+#define LOAD64H(x, y)          \
+asm __volatile__ (             \
+   "movq (%1),%0\n\t"          \
+   "bswapq %0\n\t"             \
+   :"=r"(x): "r"(y));
+
+#else
+
+#define STORE64H(x, y)                                                                     \
+   { (y)[0] = (unsigned char)(((x)>>56)&255); (y)[1] = (unsigned char)(((x)>>48)&255);     \
+     (y)[2] = (unsigned char)(((x)>>40)&255); (y)[3] = (unsigned char)(((x)>>32)&255);     \
+     (y)[4] = (unsigned char)(((x)>>24)&255); (y)[5] = (unsigned char)(((x)>>16)&255);     \
+     (y)[6] = (unsigned char)(((x)>>8)&255); (y)[7] = (unsigned char)((x)&255); }
+
+#define LOAD64H(x, y)                                                      \
+   { x = (((ulong64)((y)[0] & 255))<<56)|(((ulong64)((y)[1] & 255))<<48) | \
+         (((ulong64)((y)[2] & 255))<<40)|(((ulong64)((y)[3] & 255))<<32) | \
+         (((ulong64)((y)[4] & 255))<<24)|(((ulong64)((y)[5] & 255))<<16) | \
+         (((ulong64)((y)[6] & 255))<<8)|(((ulong64)((y)[7] & 255))); }
+
+#endif
+
+#ifdef ENDIAN_32BITWORD 
+
+#define STORE32L(x, y)        \
+     { ulong32  __t = (x); XMEMCPY(y, &__t, 4); }
+
+#define LOAD32L(x, y)         \
+     XMEMCPY(&(x), y, 4);
+
+#define STORE64L(x, y)                                                                     \
+     { (y)[7] = (unsigned char)(((x)>>56)&255); (y)[6] = (unsigned char)(((x)>>48)&255);   \
+       (y)[5] = (unsigned char)(((x)>>40)&255); (y)[4] = (unsigned char)(((x)>>32)&255);   \
+       (y)[3] = (unsigned char)(((x)>>24)&255); (y)[2] = (unsigned char)(((x)>>16)&255);   \
+       (y)[1] = (unsigned char)(((x)>>8)&255); (y)[0] = (unsigned char)((x)&255); }
+
+#define LOAD64L(x, y)                                                       \
+     { x = (((ulong64)((y)[7] & 255))<<56)|(((ulong64)((y)[6] & 255))<<48)| \
+           (((ulong64)((y)[5] & 255))<<40)|(((ulong64)((y)[4] & 255))<<32)| \
+           (((ulong64)((y)[3] & 255))<<24)|(((ulong64)((y)[2] & 255))<<16)| \
+           (((ulong64)((y)[1] & 255))<<8)|(((ulong64)((y)[0] & 255))); }
+
+#else /* 64-bit words then  */
+
+#define STORE32L(x, y)        \
+     { ulong32 __t = (x); XMEMCPY(y, &__t, 4); }
+
+#define LOAD32L(x, y)         \
+     { XMEMCPY(&(x), y, 4); x &= 0xFFFFFFFF; }
+
+#define STORE64L(x, y)        \
+     { ulong64 __t = (x); XMEMCPY(y, &__t, 8); }
+
+#define LOAD64L(x, y)         \
+    { XMEMCPY(&(x), y, 8); }
+
+#endif /* ENDIAN_64BITWORD */
+
+#endif /* ENDIAN_LITTLE */
+
+#ifdef ENDIAN_BIG
+#define STORE32L(x, y)                                                                     \
+     { (y)[3] = (unsigned char)(((x)>>24)&255); (y)[2] = (unsigned char)(((x)>>16)&255);   \
+       (y)[1] = (unsigned char)(((x)>>8)&255); (y)[0] = (unsigned char)((x)&255); }
+
+#define LOAD32L(x, y)                            \
+     { x = ((unsigned long)((y)[3] & 255)<<24) | \
+           ((unsigned long)((y)[2] & 255)<<16) | \
+           ((unsigned long)((y)[1] & 255)<<8)  | \
+           ((unsigned long)((y)[0] & 255)); }
+
+#define STORE64L(x, y)                                                                     \
+   { (y)[7] = (unsigned char)(((x)>>56)&255); (y)[6] = (unsigned char)(((x)>>48)&255);     \
+     (y)[5] = (unsigned char)(((x)>>40)&255); (y)[4] = (unsigned char)(((x)>>32)&255);     \
+     (y)[3] = (unsigned char)(((x)>>24)&255); (y)[2] = (unsigned char)(((x)>>16)&255);     \
+     (y)[1] = (unsigned char)(((x)>>8)&255); (y)[0] = (unsigned char)((x)&255); }
+
+#define LOAD64L(x, y)                                                      \
+   { x = (((ulong64)((y)[7] & 255))<<56)|(((ulong64)((y)[6] & 255))<<48) | \
+         (((ulong64)((y)[5] & 255))<<40)|(((ulong64)((y)[4] & 255))<<32) | \
+         (((ulong64)((y)[3] & 255))<<24)|(((ulong64)((y)[2] & 255))<<16) | \
+         (((ulong64)((y)[1] & 255))<<8)|(((ulong64)((y)[0] & 255))); }
+
+#ifdef ENDIAN_32BITWORD 
+
+#define STORE32H(x, y)        \
+     { ulong32 __t = (x); XMEMCPY(y, &__t, 4); }
+
+#define LOAD32H(x, y)         \
+     XMEMCPY(&(x), y, 4);
+
+#define STORE64H(x, y)                                                                     \
+     { (y)[0] = (unsigned char)(((x)>>56)&255); (y)[1] = (unsigned char)(((x)>>48)&255);   \
+       (y)[2] = (unsigned char)(((x)>>40)&255); (y)[3] = (unsigned char)(((x)>>32)&255);   \
+       (y)[4] = (unsigned char)(((x)>>24)&255); (y)[5] = (unsigned char)(((x)>>16)&255);   \
+       (y)[6] = (unsigned char)(((x)>>8)&255);  (y)[7] = (unsigned char)((x)&255); }
+
+#define LOAD64H(x, y)                                                       \
+     { x = (((ulong64)((y)[0] & 255))<<56)|(((ulong64)((y)[1] & 255))<<48)| \
+           (((ulong64)((y)[2] & 255))<<40)|(((ulong64)((y)[3] & 255))<<32)| \
+           (((ulong64)((y)[4] & 255))<<24)|(((ulong64)((y)[5] & 255))<<16)| \
+           (((ulong64)((y)[6] & 255))<<8)| (((ulong64)((y)[7] & 255))); }
+
+#else /* 64-bit words then  */
+
+#define STORE32H(x, y)        \
+     { ulong32 __t = (x); XMEMCPY(y, &__t, 4); }
+
+#define LOAD32H(x, y)         \
+     { XMEMCPY(&(x), y, 4); x &= 0xFFFFFFFF; }
+
+#define STORE64H(x, y)        \
+     { ulong64 __t = (x); XMEMCPY(y, &__t, 8); }
+
+#define LOAD64H(x, y)         \
+    { XMEMCPY(&(x), y, 8); }
+
+#endif /* ENDIAN_64BITWORD */
+#endif /* ENDIAN_BIG */
+
+#define BSWAP(x)  ( ((x>>24)&0x000000FFUL) | ((x<<24)&0xFF000000UL)  | \
+                    ((x>>8)&0x0000FF00UL)  | ((x<<8)&0x00FF0000UL) )
+
+
+/* 32-bit Rotates */
+#if defined(_MSC_VER)
+
+/* instrinsic rotate */
+#include <stdlib.h>
+#pragma intrinsic(_lrotr,_lrotl)
+#define ROR(x,n) _lrotr(x,n)
+#define ROL(x,n) _lrotl(x,n)
+#define RORc(x,n) _lrotr(x,n)
+#define ROLc(x,n) _lrotl(x,n)
+
+#elif !defined(__STRICT_ANSI__) && defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)) && !defined(INTEL_CC) && !defined(LTC_NO_ASM)
+
+static inline unsigned ROL(unsigned word, int i)
+{
+   asm ("roll %%cl,%0"
+      :"=r" (word)
+      :"0" (word),"c" (i));
+   return word;
+}
+
+static inline unsigned ROR(unsigned word, int i)
+{
+   asm ("rorl %%cl,%0"
+      :"=r" (word)
+      :"0" (word),"c" (i));
+   return word;
+}
+
+#ifndef LTC_NO_ROLC
+
+static inline unsigned ROLc(unsigned word, const int i)
+{
+   asm ("roll %2,%0"
+      :"=r" (word)
+      :"0" (word),"I" (i));
+   return word;
+}
+
+static inline unsigned RORc(unsigned word, const int i)
+{
+   asm ("rorl %2,%0"
+      :"=r" (word)
+      :"0" (word),"I" (i));
+   return word;
+}
+
+#else
+
+#define ROLc ROL
+#define RORc ROR
+
+#endif
+
+#elif !defined(__STRICT_ANSI__) && defined(LTC_PPC32)
+
+static inline unsigned ROL(unsigned word, int i)
+{
+   asm ("rotlw %0,%0,%2"
+      :"=r" (word)
+      :"0" (word),"r" (i));
+   return word;
+}
+
+static inline unsigned ROR(unsigned word, int i)
+{
+   asm ("rotlw %0,%0,%2"
+      :"=r" (word)
+      :"0" (word),"r" (32-i));
+   return word;
+}
+
+#ifndef LTC_NO_ROLC
+
+static inline unsigned ROLc(unsigned word, const int i)
+{
+   asm ("rotlwi %0,%0,%2"
+      :"=r" (word)
+      :"0" (word),"I" (i));
+   return word;
+}
+
+static inline unsigned RORc(unsigned word, const int i)
+{
+   asm ("rotrwi %0,%0,%2"
+      :"=r" (word)
+      :"0" (word),"I" (i));
+   return word;
+}
+
+#else
+
+#define ROLc ROL
+#define RORc ROR
+
+#endif
+
+
+#else
+
+/* rotates the hard way */
+#define ROL(x, y) ( (((unsigned long)(x)<<(unsigned long)((y)&31)) | (((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
+#define ROR(x, y) ( ((((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)((y)&31)) | ((unsigned long)(x)<<(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
+#define ROLc(x, y) ( (((unsigned long)(x)<<(unsigned long)((y)&31)) | (((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
+#define RORc(x, y) ( ((((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)((y)&31)) | ((unsigned long)(x)<<(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
+
+#endif
+
+
+/* 64-bit Rotates */
+#if !defined(__STRICT_ANSI__) && defined(__GNUC__) && defined(__x86_64__) && !defined(LTC_NO_ASM)
+
+static inline unsigned long ROL64(unsigned long word, int i)
+{
+   asm("rolq %%cl,%0"
+      :"=r" (word)
+      :"0" (word),"c" (i));
+   return word;
+}
+
+static inline unsigned long ROR64(unsigned long word, int i)
+{
+   asm("rorq %%cl,%0"
+      :"=r" (word)
+      :"0" (word),"c" (i));
+   return word;
+}
+
+#ifndef LTC_NO_ROLC
+
+static inline unsigned long ROL64c(unsigned long word, const int i)
+{
+   asm("rolq %2,%0"
+      :"=r" (word)
+      :"0" (word),"J" (i));
+   return word;
+}
+
+static inline unsigned long ROR64c(unsigned long word, const int i)
+{
+   asm("rorq %2,%0"
+      :"=r" (word)
+      :"0" (word),"J" (i));
+   return word;
+}
+
+#else /* LTC_NO_ROLC */
+
+#define ROL64c ROL64
+#define ROR64c ROR64
+
+#endif
+
+#else /* Not x86_64  */
+
+#define ROL64(x, y) \
+    ( (((x)<<((ulong64)(y)&63)) | \
+      (((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((ulong64)64-((y)&63)))) & CONST64(0xFFFFFFFFFFFFFFFF))
+
+#define ROR64(x, y) \
+    ( ((((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((ulong64)(y)&CONST64(63))) | \
+      ((x)<<((ulong64)(64-((y)&CONST64(63)))))) & CONST64(0xFFFFFFFFFFFFFFFF))
+
+#define ROL64c(x, y) \
+    ( (((x)<<((ulong64)(y)&63)) | \
+      (((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((ulong64)64-((y)&63)))) & CONST64(0xFFFFFFFFFFFFFFFF))
+
+#define ROR64c(x, y) \
+    ( ((((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((ulong64)(y)&CONST64(63))) | \
+      ((x)<<((ulong64)(64-((y)&CONST64(63)))))) & CONST64(0xFFFFFFFFFFFFFFFF))
+
+#endif
+
+#ifndef MAX
+   #define MAX(x, y) ( ((x)>(y))?(x):(y) )
+#endif
+
+#ifndef MIN
+   #define MIN(x, y) ( ((x)<(y))?(x):(y) )
+#endif
+
+/* extract a byte portably */
+#ifdef _MSC_VER
+   #define byte(x, n) ((unsigned char)((x) >> (8 * (n))))
+#else
+   #define byte(x, n) (((x) >> (8 * (n))) & 255)
+#endif   
+
+/* $Source: /cvs/libtom/libtomcrypt/src/headers/tomcrypt_macros.h,v $ */
+/* $Revision: 1.15 $ */
+/* $Date: 2006/11/29 23:43:57 $ */
--- a/crypto/tomcrypt_math.h
+++ /dev/null
@@ -1,500 +0,0 @@
-/** math functions **/
-
-#define LTC_MP_LT   -1
-#define LTC_MP_EQ    0
-#define LTC_MP_GT    1
-
-#define LTC_MP_NO    0
-#define LTC_MP_YES   1
-
-#ifndef LTC_MECC
-   typedef void ecc_point;
-#endif
-
-#ifndef LTC_MRSA
-   typedef void rsa_key;
-#endif
-
-/** math descriptor */
-typedef struct {
-   /** Name of the math provider */
-   char *name;
-
-   /** Bits per digit, amount of bits must fit in an unsigned long */
-   int  bits_per_digit;
-
-/* ---- init/deinit functions ---- */
-
-   /** initialize a bignum
-     @param   a     The number to initialize
-     @return  CRYPT_OK on success
-   */
-   int (*init)(void **a);
-   
-   /** init copy 
-     @param  dst    The number to initialize and write to
-     @param  src    The number to copy from
-     @return CRYPT_OK on success
-   */
-   int (*init_copy)(void **dst, void *src);
-
-   /** deinit 
-      @param   a    The number to free
-      @return CRYPT_OK on success
-   */
-   void (*deinit)(void *a);
-
-/* ---- data movement ---- */
-
-   /** negate
-      @param   src   The number to negate
-      @param   dst   The destination
-      @return CRYPT_OK on success
-   */
-   int (*neg)(void *src, void *dst);
-   
-   /** copy 
-      @param   src   The number to copy from
-      @param   dst   The number to write to 
-      @return CRYPT_OK on success
-   */
-   int (*copy)(void *src, void *dst);
-
-/* ---- trivial low level functions ---- */
-
-   /** set small constant 
-      @param a    Number to write to
-      @param n    Source upto bits_per_digit (actually meant for very small constants) 
-      @return CRYPT_OK on succcess
-   */
-   int (*set_int)(void *a, unsigned long n);
-
-   /** get small constant 
-      @param a    Number to read, only fetches upto bits_per_digit from the number
-      @return  The lower bits_per_digit of the integer (unsigned)
-   */
-   unsigned long (*get_int)(void *a);
-
-   /** get digit n 
-     @param a  The number to read from
-     @param n  The number of the digit to fetch
-     @return  The bits_per_digit  sized n'th digit of a
-   */
-   unsigned long (*get_digit)(void *a, int n);
-
-   /** Get the number of digits that represent the number
-     @param a   The number to count
-     @return The number of digits used to represent the number
-   */
-   int (*get_digit_count)(void *a);
-
-   /** compare two integers
-     @param a   The left side integer
-     @param b   The right side integer
-     @return LTC_MP_LT if a < b, LTC_MP_GT if a > b and LTC_MP_EQ otherwise.  (signed comparison)
-   */
-   int (*compare)(void *a, void *b);
-
-   /** compare against int 
-     @param a   The left side integer
-     @param b   The right side integer (upto bits_per_digit)
-     @return LTC_MP_LT if a < b, LTC_MP_GT if a > b and LTC_MP_EQ otherwise.  (signed comparison)
-   */
-   int (*compare_d)(void *a, unsigned long n);
-
-   /** Count the number of bits used to represent the integer
-     @param a   The integer to count
-     @return The number of bits required to represent the integer
-   */
-   int (*count_bits)(void * a);
-
-   /** Count the number of LSB bits which are zero 
-     @param a   The integer to count
-     @return The number of contiguous zero LSB bits
-   */
-   int (*count_lsb_bits)(void *a);
-
-   /** Compute a power of two
-     @param a  The integer to store the power in
-     @param n  The power of two you want to store (a = 2^n)
-     @return CRYPT_OK on success
-   */
-   int (*twoexpt)(void *a , int n);
-
-/* ---- radix conversions ---- */
-   
-   /** read ascii string 
-     @param a     The integer to store into
-     @param str   The string to read
-     @param radix The radix the integer has been represented in (2-64)
-     @return CRYPT_OK on success
-   */
-   int (*read_radix)(void *a, const char *str, int radix);
-
-   /** write number to string
-     @param a     The integer to store
-     @param str   The destination for the string
-     @param radix The radix the integer is to be represented in (2-64)
-     @return CRYPT_OK on success
-   */
-   int (*write_radix)(void *a, char *str, int radix);
-
-   /** get size as unsigned char string 
-     @param a     The integer to get the size (when stored in array of octets)
-     @return The length of the integer
-   */
-   unsigned long (*unsigned_size)(void *a);
-
-   /** store an integer as an array of octets 
-     @param src   The integer to store
-     @param dst   The buffer to store the integer in
-     @return CRYPT_OK on success
-   */
-   int (*unsigned_write)(void *src, unsigned char *dst);
-
-   /** read an array of octets and store as integer
-     @param dst   The integer to load
-     @param src   The array of octets 
-     @param len   The number of octets 
-     @return CRYPT_OK on success
-   */
-   int (*unsigned_read)(void *dst, unsigned char *src, unsigned long len);
-
-/* ---- basic math ---- */
-
-   /** add two integers 
-     @param a   The first source integer
-     @param b   The second source integer
-     @param c   The destination of "a + b"
-     @return CRYPT_OK on success
-   */
-   int (*add)(void *a, void *b, void *c);
-
-
-   /** add two integers 
-     @param a   The first source integer
-     @param b   The second source integer (single digit of upto bits_per_digit in length)
-     @param c   The destination of "a + b"
-     @return CRYPT_OK on success
-   */
-   int (*addi)(void *a, unsigned long b, void *c);
-
-   /** subtract two integers 
-     @param a   The first source integer
-     @param b   The second source integer
-     @param c   The destination of "a - b"
-     @return CRYPT_OK on success
-   */
-   int (*sub)(void *a, void *b, void *c);
-
-   /** subtract two integers 
-     @param a   The first source integer
-     @param b   The second source integer (single digit of upto bits_per_digit in length)
-     @param c   The destination of "a - b"
-     @return CRYPT_OK on success
-   */
-   int (*subi)(void *a, unsigned long b, void *c);
-
-   /** multiply two integers 
-     @param a   The first source integer
-     @param b   The second source integer (single digit of upto bits_per_digit in length)
-     @param c   The destination of "a * b"
-     @return CRYPT_OK on success
-   */
-   int (*mul)(void *a, void *b, void *c);
-
-   /** multiply two integers 
-     @param a   The first source integer
-     @param b   The second source integer (single digit of upto bits_per_digit in length)
-     @param c   The destination of "a * b"
-     @return CRYPT_OK on success
-   */
-   int (*muli)(void *a, unsigned long b, void *c);
-
-   /** Square an integer
-     @param a    The integer to square
-     @param b    The destination
-     @return CRYPT_OK on success
-   */
-   int (*sqr)(void *a, void *b);
-
-   /** Divide an integer
-     @param a    The dividend
-     @param b    The divisor
-     @param c    The quotient (can be NULL to signify don't care)
-     @param d    The remainder (can be NULL to signify don't care)
-     @return CRYPT_OK on success
-   */
-   int (*mpdiv)(void *a, void *b, void *c, void *d);
-
-   /** divide by two 
-      @param  a   The integer to divide (shift right)
-      @param  b   The destination 
-      @return CRYPT_OK on success
-   */
-   int (*div_2)(void *a, void *b);
-
-   /** Get remainder (small value)
-      @param  a    The integer to reduce
-      @param  b    The modulus (upto bits_per_digit in length)
-      @param  c    The destination for the residue
-      @return CRYPT_OK on success
-   */
-   int (*modi)(void *a, unsigned long b, unsigned long *c);
-
-   /** gcd 
-      @param  a     The first integer
-      @param  b     The second integer
-      @param  c     The destination for (a, b)
-      @return CRYPT_OK on success
-   */
-   int (*gcd)(void *a, void *b, void *c);
-
-   /** lcm 
-      @param  a     The first integer
-      @param  b     The second integer
-      @param  c     The destination for [a, b]
-      @return CRYPT_OK on success
-   */
-   int (*lcm)(void *a, void *b, void *c);
-
-   /** Modular multiplication
-      @param  a     The first source
-      @param  b     The second source 
-      @param  c     The modulus
-      @param  d     The destination (a*b mod c)
-      @return CRYPT_OK on success
-   */
-   int (*mulmod)(void *a, void *b, void *c, void *d);
-
-   /** Modular squaring
-      @param  a     The first source
-      @param  b     The modulus
-      @param  c     The destination (a*a mod b)
-      @return CRYPT_OK on success
-   */
-   int (*sqrmod)(void *a, void *b, void *c);
-
-   /** Modular inversion
-      @param  a     The value to invert
-      @param  b     The modulus 
-      @param  c     The destination (1/a mod b)
-      @return CRYPT_OK on success
-   */
-   int (*invmod)(void *, void *, void *);
-
-/* ---- reduction ---- */
-
-   /** setup montgomery
-       @param a  The modulus 
-       @param b  The destination for the reduction digit 
-       @return CRYPT_OK on success
-   */
-   int (*montgomery_setup)(void *a, void **b);
-
-   /** get normalization value 
-       @param a   The destination for the normalization value
-       @param b   The modulus
-       @return  CRYPT_OK on success
-   */
-   int (*montgomery_normalization)(void *a, void *b);
-
-   /** reduce a number
-       @param a   The number [and dest] to reduce
-       @param b   The modulus
-       @param c   The value "b" from montgomery_setup()
-       @return CRYPT_OK on success
-   */
-   int (*montgomery_reduce)(void *a, void *b, void *c);
-
-   /** clean up  (frees memory)
-       @param a   The value "b" from montgomery_setup()
-       @return CRYPT_OK on success
-   */      
-   void (*montgomery_deinit)(void *a);
-
-/* ---- exponentiation ---- */
-
-   /** Modular exponentiation
-       @param a    The base integer
-       @param b    The power (can be negative) integer
-       @param c    The modulus integer
-       @param d    The destination
-       @return CRYPT_OK on success
-   */
-   int (*exptmod)(void *a, void *b, void *c, void *d);
-
-   /** Primality testing
-       @param a     The integer to test
-       @param b     The destination of the result (FP_YES if prime)
-       @return CRYPT_OK on success
-   */
-   int (*isprime)(void *a, int *b);
-
-/* ----  (optional) ecc point math ---- */
-
-   /** ECC GF(p) point multiplication (from the NIST curves)
-       @param k   The integer to multiply the point by
-       @param G   The point to multiply
-       @param R   The destination for kG  
-       @param modulus  The modulus for the field
-       @param map Boolean indicated whether to map back to affine or not (can be ignored if you work in affine only)
-       @return CRYPT_OK on success
-   */
-   int (*ecc_ptmul)(void *k, ecc_point *G, ecc_point *R, void *modulus, int map);
-
-   /** ECC GF(p) point addition 
-       @param P    The first point
-       @param Q    The second point
-       @param R    The destination of P + Q
-       @param modulus  The modulus
-       @param mp   The "b" value from montgomery_setup()
-       @return CRYPT_OK on success
-   */
-   int (*ecc_ptadd)(ecc_point *P, ecc_point *Q, ecc_point *R, void *modulus, void *mp);
-
-   /** ECC GF(p) point double 
-       @param P    The first point
-       @param R    The destination of 2P
-       @param modulus  The modulus
-       @param mp   The "b" value from montgomery_setup()
-       @return CRYPT_OK on success
-   */
-   int (*ecc_ptdbl)(ecc_point *P, ecc_point *R, void *modulus, void *mp);
-
-   /** ECC mapping from projective to affine, currently uses (x,y,z) => (x/z^2, y/z^3, 1)
-       @param P     The point to map
-       @param modulus The modulus
-       @param mp    The "b" value from montgomery_setup()
-       @return CRYPT_OK on success
-       @remark  The mapping can be different but keep in mind a ecc_point only has three 
-                integers (x,y,z) so if you use a different mapping you have to make it fit.
-   */
-   int (*ecc_map)(ecc_point *P, void *modulus, void *mp);
-
-   /** Computes kA*A + kB*B = C using Shamir's Trick
-       @param A        First point to multiply
-       @param kA       What to multiple A by
-       @param B        Second point to multiply
-       @param kB       What to multiple B by
-       @param C        [out] Destination point (can overlap with A or B
-       @param modulus  Modulus for curve 
-       @return CRYPT_OK on success
-   */ 
-   int (*ecc_mul2add)(ecc_point *A, void *kA,
-                      ecc_point *B, void *kB,
-                      ecc_point *C,
-                           void *modulus);
-
-/* ---- (optional) rsa optimized math (for internal CRT) ---- */
-
-   /** RSA Key Generation 
-       @param prng     An active PRNG state
-       @param wprng    The index of the PRNG desired
-       @param size     The size of the modulus (key size) desired (octets)
-       @param e        The "e" value (public key).  e==65537 is a good choice
-       @param key      [out] Destination of a newly created private key pair
-       @return CRYPT_OK if successful, upon error all allocated ram is freed
-    */
-    int (*rsa_keygen)(prng_state *prng, int wprng, int size, long e, rsa_key *key);
-   
-
-   /** RSA exponentiation
-      @param in       The octet array representing the base
-      @param inlen    The length of the input
-      @param out      The destination (to be stored in an octet array format)
-      @param outlen   The length of the output buffer and the resulting size (zero padded to the size of the modulus)
-      @param which    PK_PUBLIC for public RSA and PK_PRIVATE for private RSA
-      @param key      The RSA key to use 
-      @return CRYPT_OK on success
-   */
-   int (*rsa_me)(const unsigned char *in,   unsigned long inlen,
-                       unsigned char *out,  unsigned long *outlen, int which,
-                       rsa_key *key);
-} ltc_math_descriptor;
-
-extern ltc_math_descriptor ltc_mp;
-
-int ltc_init_multi(void **a, ...);
-void ltc_deinit_multi(void *a, ...);
-
-#ifdef LTM_DESC
-extern const ltc_math_descriptor ltm_desc;
-#endif
-
-#ifdef TFM_DESC
-extern const ltc_math_descriptor tfm_desc;
-#endif
-
-#ifdef GMP_DESC
-extern const ltc_math_descriptor gmp_desc;
-#endif
-
-#if !defined(DESC_DEF_ONLY) && defined(LTC_SOURCE)
-
-#define MP_DIGIT_BIT                 ltc_mp.bits_per_digit
-
-/* some handy macros */
-#define mp_init(a)                   ltc_mp.init(a)
-#define mp_init_multi                ltc_init_multi
-#define mp_clear(a)                  ltc_mp.deinit(a)
-#define mp_clear_multi               ltc_deinit_multi
-#define mp_init_copy(a, b)           ltc_mp.init_copy(a, b)
-
-#define mp_neg(a, b)                 ltc_mp.neg(a, b)
-#define mp_copy(a, b)                ltc_mp.copy(a, b)
-
-#define mp_set(a, b)                 ltc_mp.set_int(a, b)
-#define mp_set_int(a, b)             ltc_mp.set_int(a, b)
-#define mp_get_int(a)                ltc_mp.get_int(a)
-#define mp_get_digit(a, n)           ltc_mp.get_digit(a, n)
-#define mp_get_digit_count(a)        ltc_mp.get_digit_count(a)
-#define mp_cmp(a, b)                 ltc_mp.compare(a, b)
-#define mp_cmp_d(a, b)               ltc_mp.compare_d(a, b)
-#define mp_count_bits(a)             ltc_mp.count_bits(a)
-#define mp_cnt_lsb(a)                ltc_mp.count_lsb_bits(a)
-#define mp_2expt(a, b)               ltc_mp.twoexpt(a, b)
-
-#define mp_read_radix(a, b, c)       ltc_mp.read_radix(a, b, c)
-#define mp_toradix(a, b, c)          ltc_mp.write_radix(a, b, c)
-#define mp_unsigned_bin_size(a)      ltc_mp.unsigned_size(a)
-#define mp_to_unsigned_bin(a, b)     ltc_mp.unsigned_write(a, b)
-#define mp_read_unsigned_bin(a, b, c) ltc_mp.unsigned_read(a, b, c)
-
-#define mp_add(a, b, c)              ltc_mp.add(a, b, c)
-#define mp_add_d(a, b, c)            ltc_mp.addi(a, b, c)
-#define mp_sub(a, b, c)              ltc_mp.sub(a, b, c)
-#define mp_sub_d(a, b, c)            ltc_mp.subi(a, b, c)
-#define mp_mul(a, b, c)              ltc_mp.mul(a, b, c)
-#define mp_mul_d(a, b, c)            ltc_mp.muli(a, b, c)
-#define mp_sqr(a, b)                 ltc_mp.sqr(a, b)
-#define mp_div(a, b, c, d)           ltc_mp.mpdiv(a, b, c, d)
-#define mp_div_2(a, b)               ltc_mp.div_2(a, b)
-#define mp_mod(a, b, c)              ltc_mp.mpdiv(a, b, NULL, c)
-#define mp_mod_d(a, b, c)            ltc_mp.modi(a, b, c)
-#define mp_gcd(a, b, c)              ltc_mp.gcd(a, b, c)
-#define mp_lcm(a, b, c)              ltc_mp.lcm(a, b, c)
-
-#define mp_mulmod(a, b, c, d)        ltc_mp.mulmod(a, b, c, d)
-#define mp_sqrmod(a, b, c)           ltc_mp.sqrmod(a, b, c)
-#define mp_invmod(a, b, c)           ltc_mp.invmod(a, b, c)
-
-#define mp_montgomery_setup(a, b)    ltc_mp.montgomery_setup(a, b)
-#define mp_montgomery_normalization(a, b) ltc_mp.montgomery_normalization(a, b)
-#define mp_montgomery_reduce(a, b, c)   ltc_mp.montgomery_reduce(a, b, c)
-#define mp_montgomery_free(a)        ltc_mp.montgomery_deinit(a)
-
-#define mp_exptmod(a,b,c,d)          ltc_mp.exptmod(a,b,c,d)
-#define mp_prime_is_prime(a, b, c)   ltc_mp.isprime(a, c)
-
-#define mp_iszero(a)                 (mp_cmp_d(a, 0) == LTC_MP_EQ ? LTC_MP_YES : LTC_MP_NO)
-#define mp_isodd(a)                  (mp_get_digit_count(a) > 0 ? (mp_get_digit(a, 0) & 1 ? LTC_MP_YES : LTC_MP_NO) : LTC_MP_NO)
-#define mp_exch(a, b)                do { void *ABC__tmp = a; a = b; b = ABC__tmp; } while(0);
-
-#define mp_tohex(a, b)               mp_toradix(a, b, 16)
-
-#endif
-
-/* $Source: /cvs/libtom/libtomcrypt/src/headers/tomcrypt_math.h,v $ */
-/* $Revision: 1.44 $ */
-/* $Date: 2007/05/12 14:32:35 $ */
