diff -ur et-4.108.9/sys/etc47xx.c et/sys/etc47xx.c
--- et-4.108.9/sys/etc47xx.c	2006-05-22 07:26:27.000000000 +0400
+++ et/sys/etc47xx.c	2007-04-08 23:29:54.271003352 +0400
@@ -96,7 +96,7 @@
 static void chipphyadvertise(struct bcm4xxx *ch, uint phyaddr);
 
 /* chip interrupt bit error summary */
-#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU)
+#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU | I_TO)
 #define	DEF_INTMASK	(I_XI | I_RI | I_ERRORS)
 
 struct chops bcm47xx_et_chops = {
@@ -186,6 +186,10 @@
 	etc->nicmode = !(sb_bus(ch->sbh) == SB_BUS);
 	etc->coreunit = sb_coreunit(ch->sbh);
 	etc->boardflags = getintvar(ch->vars, "boardflags");
+	
+	/* set boardflags for 5365 and 5350 */
+	if (etc->chip == BCM5365_CHIP_ID || etc->chip == BCM5350_CHIP_ID)
+		etc->boardflags |= BFL_ENETROBO | BFL_ENETVLAN;
 
 	boardflags = etc->boardflags;
 	boardtype = sb_boardtype(ch->sbh);
@@ -586,6 +590,9 @@
 
 	/* set tx watermark */
 	W_REG(ch->osh, &regs->txwatermark, 56);
+	
+	/* set tx duplex */
+	W_REG(ch->osh, &regs->txcontrol, etc->duplex ? EXC_FD : 0);
 
 	/*
 	 * Optionally, disable phy autonegotiation and force our speed/duplex
@@ -604,6 +611,9 @@
 		/* post dma receive buffers */
 		dma_rxfill(ch->di);
 
+		/* setup timer interrupt */
+		W_REG(ch->osh, &regs->gptimer, 0);
+		
 		/* lastly, enable interrupts */
 		et_intrson(etc->et);
 	}
@@ -714,6 +724,15 @@
 		events |= INTR_ERROR;
 	if (intstatus & I_TO)
 		events |= INTR_TO;
+	
+	/* check for rx after tx for 3 seconds on the unit 1, */
+	/* schedule reset if it's missing - possible rx stuck */
+	if (ch->etc->chip == BCM4710_CHIP_ID && ch->etc->unit == 1) {
+		if (intstatus & I_RI)
+			W_REG(ch->osh, &regs->gptimer, 0);
+		else if (!R_REG(ch->osh, &regs->gptimer))
+			W_REG(ch->osh, &regs->gptimer, 3 * 125000000);
+	}
 
 	return (events);
 }
@@ -778,6 +797,10 @@
 		ET_ERROR(("et%d: transmit fifo underflow\n", etc->unit));
 		etc->txuflo++;
 	}
+	
+	if (intstatus & I_TO) {
+                ET_ERROR(("et%d: rx stuck suspected\n", etc->unit));
+	}
 
 	return (TRUE);
 }
@@ -1050,9 +1073,17 @@
 
 	phyid = chipphyrd(ch, phyaddr, 0x2);
 	phyid |=  chipphyrd(ch, phyaddr, 0x3) << 16;
+
 	if (phyid == 0x55210022) {
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd(ch, phyaddr, 28) & 0x0fff));
 		chipphywr(ch, phyaddr, 30, (uint16) (chipphyrd(ch, phyaddr, 30) | 0x3000));
 		chipphywr(ch, phyaddr, 22, (uint16) (chipphyrd(ch, phyaddr, 22) & 0xffdf));
+
+		chipphywr(ch, phyaddr, 28, (uint16) ((chipphyrd(ch, phyaddr, 28) & 0x0fff) | 0x1000));
+		chipphywr(ch, phyaddr, 29, 1);
+		chipphywr(ch, phyaddr, 30, 4);
+
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd( ch, phyaddr, 28) & 0x0fff));
 	}
 }
 
@@ -1093,6 +1124,13 @@
 	}
 
 	chipphywr(ch, phyaddr, 0, ctl);
+
+	/* force Auto MDI-X for the AC101L phy */
+	if (chipphyrd(ch, phyaddr, 2) == 0x0022 && 
+		chipphyrd(ch, phyaddr, 3) == 0x5521)
+	{
+		chipphywr(ch, phyaddr, 23, 0x8000);
+	}
 }
 
 /* set selected capability bits in autonegotiation advertisement */
diff -ur et-4.108.9/sys/etc.c et/sys/etc.c
--- et-4.108.9/sys/etc.c	2006-05-22 07:26:27.000000000 +0400
+++ et/sys/etc.c	2007-04-08 23:29:54.320995752 +0400
@@ -248,6 +248,7 @@
 void
 etc_watchdog(etc_info_t *etc)
 {
+	uint16 control;
 	uint16 status;
 	uint16 adv;
 	uint16 lpa;
@@ -256,23 +257,43 @@
 
 	/* no local phy registers */
 	if (etc->phyaddr == EPHY_NOREG) {
-		etc->linkstate = TRUE;
-		etc->speed = 100;
-		etc->duplex = 1;
-		return;
+		control = CTL_SPEED | CTL_DUPLEX;
+		status = STAT_LINK;
+	} else {
+		control = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 0);
+		status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
 	}
 
-	status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
-	adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
-	lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
-
 	/* check for bad mdio read */
-	if (status == 0xffff) {
+	if (control == 0xffff || status == 0xffff) {
 		ET_ERROR(("et%d: etc_watchdog: bad mdio read: phyaddr %d mdcport %d\n",
 			etc->unit, etc->phyaddr, etc->mdcport));
 		return;
 	}
 
+	/* update current speed and duplex */
+	if (control & CTL_ANENAB) {
+		adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
+		lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
+	
+		if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
+			etc->speed = 100;
+			etc->duplex = 1;
+		} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
+			etc->speed = 100;
+			etc->duplex = 0;
+		} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
+			etc->speed = 10;
+			etc->duplex = 1;
+		} else {
+			etc->speed = 10;
+			etc->duplex = 0;
+		}
+	} else {
+		etc->speed = (control & CTL_SPEED) ? 100 : 10;
+		etc->duplex = (control & CTL_DUPLEX) ? 1 : 0;
+	}
+
 	/* monitor link state */
 	if (!etc->linkstate && (status & STAT_LINK)) {
 		etc->linkstate = TRUE;
@@ -280,27 +301,16 @@
 		if (etc->pm_modechange)
 			etc->pm_modechange = FALSE;
 		else
+		{
 			et_link_up(etc->et);
+		}
 	}
 	else if (etc->linkstate && !(status & STAT_LINK)) {
 		etc->linkstate = FALSE;
 		if (!etc->pm_modechange)
+		{
 			et_link_down(etc->et);
-	}
-
-	/* update current speed and duplex */
-	if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
-		etc->speed = 100;
-		etc->duplex = 1;
-	} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
-		etc->speed = 100;
-		etc->duplex = 0;
-	} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
-		etc->speed = 10;
-		etc->duplex = 1;
-	} else {
-		etc->speed = 10;
-		etc->duplex = 0;
+		}	
 	}
 
 	/* keep emac txcontrol duplex bit consistent with current phy duplex */
diff -ur et-4.108.9/sys/et_dbg.h et/sys/et_dbg.h
--- et-4.108.9/sys/et_dbg.h	2006-05-22 07:26:27.000000000 +0400
+++ et/sys/et_dbg.h	2007-04-08 23:29:54.342992408 +0400
@@ -16,8 +16,8 @@
 #ifndef _et_dbg_
 #define _et_dbg_
 
-#define	ET_ERROR(args)
-#define	ET_TRACE(args)
+#define	ET_ERROR(args)  if (!(et_msg_level & 1)) ; else printf args
+#define	ET_TRACE(args)  if (!(et_msg_level & 2)) ; else printf args
 #define	ET_PRHDR(msg, eh, len, unit)
 #define	ET_PRPKT(msg, buf, len, unit)
 
diff -ur et-4.108.9/sys/et_linux.c et/sys/et_linux.c
--- et-4.108.9/sys/et_linux.c	2006-05-22 07:26:27.000000000 +0400
+++ et/sys/et_linux.c	2007-04-08 23:33:43.750117224 +0400
@@ -36,6 +36,7 @@
 #ifdef SIOCETHTOOL
 #include <linux/ethtool.h>
 #endif /* SIOCETHTOOL */
+#include <linux/mii.h>
 #include <linux/ip.h>
 
 #include <asm/system.h>
@@ -693,6 +694,7 @@
 	char *buf;
 	int size;
 	bool get, set;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
 
 	et = ET_INFO(dev);
 
@@ -720,6 +722,14 @@
 		size = sizeof(int) * 2;
 		get = FALSE; set = TRUE;
 		break;
+	case SIOCGMIIPHY:
+		data->phy_id = et->etc->phyaddr;
+	case SIOCGMIIREG:
+		data->val_out = (*et->etc->chops->phyrd)(et->etc->ch, data->phy_id, data->reg_num);
+		return 0;
+	case SIOCSMIIREG:
+		(*et->etc->chops->phywr)(et->etc->ch, data->phy_id, data->reg_num, data->val_in);
+		return 0;
 	default:
 		size = sizeof(int);
 		get = FALSE; set = TRUE;
@@ -1013,6 +1023,25 @@
 	if (flags & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV))
 		goto err;
 
+	/* check for invalid data on the unit 1, workaround hw bug */
+	if (etc->chip == BCM4710_CHIP_ID && etc->unit == 1) 
+	{
+		uint8 *ether_dhost = ((struct ether_header*)skb->data)->ether_dhost;
+		if (	!(flags & (RXF_MULT | RXF_BRDCAST)) != !ETHER_ISMULTI(ether_dhost) ||
+			!(flags & RXF_BRDCAST) != !ETHER_ISBCAST(ether_dhost) ||
+			((flags & (RXF_MULT | RXF_BRDCAST | RXF_MISS)) == 0 &&
+				ether_cmp(ether_dhost, &etc->cur_etheraddr)))
+		{
+			bcm_ether_ntoa((struct ether_addr*)ether_dhost, eabuf);
+			ET_ERROR(("et%d: rx: bad dest address %s [%c%c%c]\n", 
+				etc->unit, eabuf, (flags & RXF_MULT) ? 'M' : ' ', 
+				(flags & RXF_BRDCAST) ? 'B' : ' ', (flags & RXF_MISS) ? 'P' : ' '));
+			/* schedule reset */
+			et->events |= INTR_ERROR;
+			goto err;
+		}
+	}
+
 	/* Extract priority from payload and store it out-of-band in skb->priority */
 	if (et->etc->qos)
 		pktsetprio(skb, TRUE);
