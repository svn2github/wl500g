diff -urB et-4.108.9/sys/etc47xx.c et/sys/etc47xx.c
--- et-4.108.9/sys/etc47xx.c	2007-03-20 15:22:00.000000000 +0300
+++ et/sys/etc47xx.c	2009-03-21 22:17:24.000000000 +0300
@@ -96,7 +96,7 @@
 static void chipphyadvertise(struct bcm4xxx *ch, uint phyaddr);
 
 /* chip interrupt bit error summary */
-#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU)
+#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU | I_TO)
 #define	DEF_INTMASK	(I_XI | I_RI | I_ERRORS)
 
 struct chops bcm47xx_et_chops = {
@@ -196,6 +196,10 @@
 	etc->nicmode = !(sb_bus(ch->sbh) == SB_BUS);
 	etc->coreunit = sb_coreunit(ch->sbh);
 	etc->boardflags = getintvar(ch->vars, "boardflags");
+	
+	/* set boardflags for 5365 and 5350 */
+	if (etc->chip == BCM5365_CHIP_ID || etc->chip == BCM5350_CHIP_ID)
+		etc->boardflags |= BFL_ENETROBO | BFL_ENETVLAN;
 
 	boardflags = etc->boardflags;
 	boardtype = sb_boardtype(ch->sbh);
@@ -601,6 +605,9 @@
 
 	/* set tx watermark */
 	W_REG(ch->osh, &regs->txwatermark, 56);
+	
+	/* set tx duplex */
+	W_REG(ch->osh, &regs->txcontrol, etc->duplex ? EXC_FD : 0);
 
 	/*
 	 * Optionally, disable phy autonegotiation and force our speed/duplex
@@ -619,6 +626,9 @@
 		/* post dma receive buffers */
 		dma_rxfill(ch->di);
 
+		/* setup timer interrupt */
+		W_REG(ch->osh, &regs->gptimer, 0);
+		
 		/* lastly, enable interrupts */
 		et_intrson(etc->et);
 	}
@@ -729,6 +739,15 @@
 		events |= INTR_ERROR;
 	if (intstatus & I_TO)
 		events |= INTR_TO;
+	
+	/* check for rx after tx for 3 seconds on the unit 1, */
+	/* schedule reset if it's missing - possible rx stuck */
+	if (ch->etc->chip == BCM4710_CHIP_ID && ch->etc->unit == 1) {
+		if (intstatus & I_RI)
+			W_REG(ch->osh, &regs->gptimer, 0);
+		else if (!R_REG(ch->osh, &regs->gptimer))
+			W_REG(ch->osh, &regs->gptimer, 3 * 125000000);
+	}
 
 	return (events);
 }
@@ -793,6 +812,10 @@
 		ET_ERROR(("et%d: transmit fifo underflow\n", etc->unit));
 		etc->txuflo++;
 	}
+	
+	if (intstatus & I_TO) {
+                ET_ERROR(("et%d: rx stuck suspected\n", etc->unit));
+	}
 
 	return (TRUE);
 }
@@ -1065,9 +1088,17 @@
 
 	phyid = chipphyrd(ch, phyaddr, 0x2);
 	phyid |=  chipphyrd(ch, phyaddr, 0x3) << 16;
+
 	if (phyid == 0x55210022) {
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd(ch, phyaddr, 28) & 0x0fff));
 		chipphywr(ch, phyaddr, 30, (uint16) (chipphyrd(ch, phyaddr, 30) | 0x3000));
 		chipphywr(ch, phyaddr, 22, (uint16) (chipphyrd(ch, phyaddr, 22) & 0xffdf));
+
+		chipphywr(ch, phyaddr, 28, (uint16) ((chipphyrd(ch, phyaddr, 28) & 0x0fff) | 0x1000));
+		chipphywr(ch, phyaddr, 29, 1);
+		chipphywr(ch, phyaddr, 30, 4);
+
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd( ch, phyaddr, 28) & 0x0fff));
 	}
 }
 
@@ -1108,6 +1139,13 @@
 	}
 
 	chipphywr(ch, phyaddr, 0, ctl);
+
+	/* force Auto MDI-X for the AC101L phy */
+	if (chipphyrd(ch, phyaddr, 2) == 0x0022 && 
+		chipphyrd(ch, phyaddr, 3) == 0x5521)
+	{
+		chipphywr(ch, phyaddr, 23, 0x8000);
+	}
 }
 
 /* set selected capability bits in autonegotiation advertisement */
diff -urB et-4.108.9/sys/etc.c et/sys/etc.c
--- et-4.108.9/sys/etc.c	2007-03-20 15:22:00.000000000 +0300
+++ et/sys/etc.c	2009-03-28 20:30:32.000000000 +0300
@@ -174,6 +174,52 @@
 	return (callback);
 }
 
+unsigned int etc_arl_dump(etc_info_t *etc, char *buff, int maxno)
+{
+	uint8 val;
+	uint8 res_reg[8];
+	uint8 res_ext_reg;
+	int size=0;
+	int offset=0;
+	int count=0;
+	int port_id = -1;
+	
+	robo_info_t *robo = (robo_info_t *)etc->robo;
+	
+	if (etc->robo) 
+	{ 
+		robo->ops->read_reg(etc->robo, 0x04, 0x0, &val, 1);
+		// ARL Search Control Register page=5 addr=0x20
+		// start
+		val = 0x80;	
+		robo->ops->write_reg(etc->robo, 0x05, 0x20, &val, 1);
+		while(1) 
+		{	
+			robo->ops->read_reg(etc->robo, 0x05, 0x20, &val, 1);
+			if(val&0x80)
+			{
+				if(val&0x01)
+				{
+					robo->ops->read_reg(etc->robo, 0x05, 0x2c, &res_ext_reg, 1);	
+					robo->ops->read_reg(etc->robo, 0x05, 0x24, res_reg, 8);
+					port_id = -1;
+					port_id = (int)res_reg[6];
+					if(port_id < 0 || port_id > 8)
+						continue;
+					size = sprintf(buff+offset, "%02x:%02x:%02x:%02x:%02x:%02x  %02x  %02x  %02x\n", res_reg[5], res_reg[4], res_reg[3], res_reg[2], res_reg[1], res_reg[0], res_reg[6], res_reg[7], res_ext_reg);
+					//printk("rreg: %s\n", buff+offset);
+					offset+=size;
+					count++;
+					if(count>=maxno) break;
+				}
+			}
+			else break;
+		} 
+	}
+	//printk("%x %x %x %x\n", offset, count, maxno, *len);
+	return offset;
+}
+
 /* common ioctl handler.  return: 0=ok, -1=error */
 int
 etc_ioctl(etc_info_t *etc, int cmd, void *arg)
@@ -320,6 +366,7 @@
 void
 etc_watchdog(etc_info_t *etc)
 {
+	uint16 control;
 	uint16 status;
 	uint16 adv;
 	uint16 lpa;
@@ -328,23 +375,43 @@
 
 	/* no local phy registers */
 	if (etc->phyaddr == EPHY_NOREG) {
-		etc->linkstate = TRUE;
-		etc->speed = 100;
-		etc->duplex = 1;
-		return;
+		control = CTL_SPEED | CTL_DUPLEX;
+		status = STAT_LINK;
+	} else {
+		control = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 0);
+		status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
 	}
 
-	status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
-	adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
-	lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
-
 	/* check for bad mdio read */
-	if (status == 0xffff) {
+	if (control == 0xffff || status == 0xffff) {
 		ET_ERROR(("et%d: etc_watchdog: bad mdio read: phyaddr %d mdcport %d\n",
 			etc->unit, etc->phyaddr, etc->mdcport));
 		return;
 	}
 
+	/* update current speed and duplex */
+	if (control & CTL_ANENAB) {
+		adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
+		lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
+	
+		if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
+			etc->speed = 100;
+			etc->duplex = 1;
+		} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
+			etc->speed = 100;
+			etc->duplex = 0;
+		} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
+			etc->speed = 10;
+			etc->duplex = 1;
+		} else {
+			etc->speed = 10;
+			etc->duplex = 0;
+		}
+	} else {
+		etc->speed = (control & CTL_SPEED) ? 100 : 10;
+		etc->duplex = (control & CTL_DUPLEX) ? 1 : 0;
+	}
+
 	/* monitor link state */
 	if (!etc->linkstate && (status & STAT_LINK)) {
 		etc->linkstate = TRUE;
@@ -352,27 +419,16 @@
 		if (etc->pm_modechange)
 			etc->pm_modechange = FALSE;
 		else
+		{
 			et_link_up(etc->et);
+		}
 	}
 	else if (etc->linkstate && !(status & STAT_LINK)) {
 		etc->linkstate = FALSE;
 		if (!etc->pm_modechange)
+		{
 			et_link_down(etc->et);
-	}
-
-	/* update current speed and duplex */
-	if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
-		etc->speed = 100;
-		etc->duplex = 1;
-	} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
-		etc->speed = 100;
-		etc->duplex = 0;
-	} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
-		etc->speed = 10;
-		etc->duplex = 1;
-	} else {
-		etc->speed = 10;
-		etc->duplex = 0;
+		}	
 	}
 
 	/* keep emac txcontrol duplex bit consistent with current phy duplex */
diff -urB et-4.108.9/sys/et_dbg.h et/sys/et_dbg.h
--- et-4.108.9/sys/et_dbg.h	2007-03-20 15:22:00.000000000 +0300
+++ et/sys/et_dbg.h	2009-03-21 22:17:24.000000000 +0300
@@ -16,8 +16,8 @@
 #ifndef _et_dbg_
 #define _et_dbg_
 
-#define	ET_ERROR(args)
-#define	ET_TRACE(args)
+#define	ET_ERROR(args)  if (!(et_msg_level & 1)) ; else printf args
+#define	ET_TRACE(args)  if (!(et_msg_level & 2)) ; else printf args
 #define	ET_PRHDR(msg, eh, len, unit)
 #define	ET_PRPKT(msg, buf, len, unit)
 
diff -urB et-4.108.9/sys/et_linux.c et/sys/et_linux.c
--- et-4.108.9/sys/et_linux.c	2007-03-20 15:22:00.000000000 +0300
+++ et/sys/et_linux.c	2009-03-28 14:16:10.000000000 +0300
@@ -36,6 +36,7 @@
 #ifdef SIOCETHTOOL
 #include <linux/ethtool.h>
 #endif /* SIOCETHTOOL */
+#include <linux/mii.h>
 #include <linux/ip.h>
 
 #include <asm/system.h>
@@ -59,6 +60,8 @@
 #include <et_dbg.h>
 #include <etc.h>
 
+#include <linux/proc_fs.h>
+
 typedef struct et_info {
 	etc_info_t	*etc;		/* pointer to common os-independent data */
 	struct net_device *dev;		/* backpoint to device */
@@ -102,6 +105,8 @@
 void et_down(et_info_t *et, int reset);
 void et_dump(et_info_t *et, struct bcmstrbuf *b);
 
+unsigned int etc_arl_dump(etc_info_t *etc, char *buffer, int maxno);
+
 /* local prototypes */
 static void et_free(et_info_t *et);
 static int et_open(struct net_device *dev);
@@ -129,6 +134,9 @@
 	},
 	{ 0, }
 };
+
+et_info_t *et_g=NULL;
+
 MODULE_DEVICE_TABLE(pci, et_id_table);
 
 
@@ -310,6 +318,43 @@
 	}
 }
 
+#define TBUFFER_LEN 32
+#define TBUFFER_COUNT 96
+
+static int et_arl_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	int len=0;
+	int size=0;
+	char tbuffer[TBUFFER_LEN*TBUFFER_COUNT];
+	
+	if(!et_g || !et_g->etc) return -ENOSYS;
+
+
+	len  = sprintf(tbuffer,"[MAC Address]     [PO][ST][EXT]\n");
+	/*XX:XX:XX:XX:XX:XX  XX  XX  XX   */
+	
+	size = etc_arl_dump(et_g->etc, tbuffer+len, TBUFFER_COUNT);
+
+	len += size;
+	len += sprintf(tbuffer+len,"\n");
+
+	//printk("arl_get_info start %x %x %x\n", (int)offset, length, len);
+
+	strncpy(buffer, tbuffer, len+1);
+	//printk("*** test buffer %s. ***\n", buffer);
+	if(offset>len)
+		offset = len;
+
+	*start = buffer + offset;	/* Start of wanted data */
+
+	if(offset+length>len)
+		length = len-offset;
+	//printk("arl_get_info %x %x\n", (int)offset, length);
+	//printk("\n%s\n", tbuffer);
+
+	return length;
+}
+
 static struct pci_driver et_pci_driver = {
 	name:		"et",
 	probe:		et_probe,
@@ -327,6 +372,7 @@
 static int __init
 et_module_init(void)
 {
+	proc_net_create ("arl", 0, et_arl_get_info);
 	return pci_module_init(&et_pci_driver);
 }
 
@@ -395,6 +441,7 @@
 	et_info_t *et;
 
 	et = ET_INFO(dev);
+	et_g = et;
 
 	ET_TRACE(("et%d: et_open\n", et->etc->unit));
 
@@ -415,6 +462,7 @@
 	et_info_t *et;
 
 	et = ET_INFO(dev);
+	et_g = NULL;
 
 	ET_TRACE(("et%d: et_close\n", et->etc->unit));
 
@@ -694,6 +742,7 @@
 	char *buf;
 	int size;
 	bool get, set;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
 
 	et = ET_INFO(dev);
 
@@ -714,13 +763,25 @@
 		get = TRUE; set = FALSE;
 		break;
 	case SIOCGETCPHYRD:
+	case SIOCGETCPHYRD2:
+	case SIOCGETCROBORD:
 		size = sizeof(int) * 2;
 		get = TRUE; set = TRUE;
 		break;
 	case SIOCSETCPHYWR:
+	case SIOCSETCPHYWR2:
+	case SIOCSETCROBOWR:
 		size = sizeof(int) * 2;
 		get = FALSE; set = TRUE;
 		break;
+	case SIOCGMIIPHY:
+		data->phy_id = et->etc->phyaddr;
+	case SIOCGMIIREG:
+		data->val_out = (*et->etc->chops->phyrd)(et->etc->ch, data->phy_id, data->reg_num);
+		return 0;
+	case SIOCSMIIREG:
+		(*et->etc->chops->phywr)(et->etc->ch, data->phy_id, data->reg_num, data->val_in);
+		return 0;
 	default:
 		size = sizeof(int);
 		get = FALSE; set = TRUE;
@@ -1014,6 +1075,25 @@
 	if (flags & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV))
 		goto err;
 
+	/* check for invalid data on the unit 1, workaround hw bug */
+	if (etc->chip == BCM4710_CHIP_ID && etc->unit == 1) 
+	{
+		uint8 *ether_dhost = ((struct ether_header*)skb->data)->ether_dhost;
+		if (	!(flags & (RXF_MULT | RXF_BRDCAST)) != !ETHER_ISMULTI(ether_dhost) ||
+			!(flags & RXF_BRDCAST) != !ETHER_ISBCAST(ether_dhost) ||
+			((flags & (RXF_MULT | RXF_BRDCAST | RXF_MISS)) == 0 &&
+				ether_cmp(ether_dhost, &etc->cur_etheraddr)))
+		{
+			bcm_ether_ntoa((struct ether_addr*)ether_dhost, eabuf);
+			ET_ERROR(("et%d: rx: bad dest address %s [%c%c%c]\n", 
+				etc->unit, eabuf, (flags & RXF_MULT) ? 'M' : ' ', 
+				(flags & RXF_BRDCAST) ? 'B' : ' ', (flags & RXF_MISS) ? 'P' : ' '));
+			/* schedule reset */
+			et->events |= INTR_ERROR;
+			goto err;
+		}
+	}
+
 	/* Extract priority from payload and store it out-of-band in skb->priority */
 	if (et->etc->qos)
 		pktsetprio(skb, TRUE);
