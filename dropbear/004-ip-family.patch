diff -BurpN dropbear.orig/cli-main.c dropbear/cli-main.c
--- dropbear.orig/cli-main.c	2008-11-11 14:09:02.000000000 +0000
+++ dropbear/cli-main.c	2010-03-12 23:32:05.000000000 +0000
@@ -66,7 +66,8 @@ int main(int argc, char ** argv) {
 	} else
 #endif
 	{
-		int sock = connect_remote(cli_opts.remotehost, cli_opts.remoteport, 
+		int sock = connect_remote(cli_opts.ipfamily,
+				cli_opts.remotehost, cli_opts.remoteport, 
 				0, &error);
 		sock_in = sock_out = sock;
 	}
diff -BurpN dropbear.orig/cli-runopts.c dropbear/cli-runopts.c
--- dropbear.orig/cli-runopts.c	2008-11-11 14:09:02.000000000 +0000
+++ dropbear/cli-runopts.c	2010-03-12 23:48:53.000000000 +0000
@@ -55,6 +55,9 @@ static void printhelp() {
 					"Usage: %s [options] [user@]host[/port] [command]\n"
 #endif
 					"Options are:\n"
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+					"-4,-6 Explicitly force IPv4 or IPv6 usage\n"
+#endif
 					"-p <remoteport>\n"
 					"-l <username>\n"
 					"-t    Allocate a pty\n"
@@ -137,10 +140,7 @@ void cli_getopts(int argc, char ** argv)
 #ifdef ENABLE_CLI_PROXYCMD
 	cli_opts.proxycmd = NULL;
 #endif
-	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
-	*/
+	cli_opts.ipfamily = AF_UNSPEC;
 	opts.recv_window = DEFAULT_RECV_WINDOW;
 
 	fill_own_user();
@@ -196,6 +196,14 @@ void cli_getopts(int argc, char ** argv)
 				case 'y': /* always accept the remote hostkey */
 					cli_opts.always_accept_key = 1;
 					break;
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+				case '4':
+					cli_opts.ipfamily = AF_INET;
+					break;
+				case '6':
+					cli_opts.ipfamily = AF_INET6;
+					break;
+#endif
 				case 'p': /* remoteport */
 					next = &cli_opts.remoteport;
 					break;
diff -BurpN dropbear.orig/cli-tcpfwd.c dropbear/cli-tcpfwd.c
--- dropbear.orig/cli-tcpfwd.c	2008-11-11 14:09:02.000000000 +0000
+++ dropbear/cli-tcpfwd.c	2010-03-12 23:33:05.000000000 +0000
@@ -229,7 +229,7 @@ static int newtcpforwarded(struct Channe
 	}
 	
 	snprintf(portstring, sizeof(portstring), "%d", iter->connectport);
-	sock = connect_remote(iter->connectaddr, portstring, 1, NULL);
+	sock = connect_remote(AF_UNSPEC, iter->connectaddr, portstring, 1, NULL);
 	if (sock < 0) {
 		TRACE(("leave newtcpdirect: sock failed"))
 		err = SSH_OPEN_CONNECT_FAILED;
diff -BurpN dropbear.orig/dbutil.c dropbear/dbutil.c
--- dropbear.orig/dbutil.c	2008-11-11 14:09:02.000000000 +0000
+++ dropbear/dbutil.c	2010-03-12 23:34:40.000000000 +0000
@@ -183,7 +183,7 @@ static void set_sock_priority(int sock) 
  * Returns the number of sockets bound on success, or -1 on failure. On
  * failure, if errstring wasn't NULL, it'll be a newly malloced error
  * string.*/
-int dropbear_listen(const char* address, const char* port,
+int dropbear_listen(int family, const char* address, const char* port,
 		int *socks, unsigned int sockcount, char **errstring, int *maxfd) {
 
 	struct addrinfo hints, *res = NULL, *res0 = NULL;
@@ -196,7 +196,7 @@ int dropbear_listen(const char* address,
 	TRACE(("enter dropbear_listen"))
 	
 	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = AF_UNSPEC; /* TODO: let them flag v4 only etc */
+	hints.ai_family = family;
 	hints.ai_socktype = SOCK_STREAM;
 
 	/* for calling getaddrinfo:
@@ -300,7 +300,7 @@ int dropbear_listen(const char* address,
  * wasn't null, it will be a newly malloced error message */
 
 /* TODO: maxfd */
-int connect_remote(const char* remotehost, const char* remoteport,
+int connect_remote(int family, const char* remotehost, const char* remoteport,
 		int nonblocking, char ** errstring) {
 
 	struct addrinfo *res0 = NULL, *res = NULL, hints;
@@ -315,7 +315,7 @@ int connect_remote(const char* remotehos
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_family = PF_UNSPEC;
+	hints.ai_family = family;
 
 	err = getaddrinfo(remotehost, remoteport, &hints, &res0);
 	if (err) {
diff -BurpN dropbear.orig/dbutil.h dropbear/dbutil.h
--- dropbear.orig/dbutil.h	2008-11-11 14:09:02.000000000 +0000
+++ dropbear/dbutil.h	2010-03-12 23:32:34.000000000 +0000
@@ -47,12 +47,12 @@ extern int debug_trace;
 #endif
 char * stripcontrol(const char * text);
 unsigned char * getaddrstring(struct sockaddr_storage* addr, int withport);
-int dropbear_listen(const char* address, const char* port,
+int dropbear_listen(int family, const char* address, const char* port,
 		int *socks, unsigned int sockcount, char **errstring, int *maxfd);
 int spawn_command(void(*exec_fn)(void *user_data), void *exec_data,
 		int *writefd, int *readfd, int *errfd, pid_t *pid);
 void run_shell_command(const char* cmd, unsigned int maxfd, char* usershell);
-int connect_remote(const char* remotehost, const char* remoteport,
+int connect_remote(int family, const char* remotehost, const char* remoteport,
 		int nonblocking, char ** errstring);
 char* getaddrhostname(struct sockaddr_storage * addr);
 int buf_readfile(buffer* buf, const char* filename);
diff -BurpN dropbear.orig/runopts.h dropbear/runopts.h
--- dropbear.orig/runopts.h	2008-11-11 14:09:03.000000000 +0000
+++ dropbear/runopts.h	2010-03-13 00:01:09.000000000 +0000
@@ -62,11 +62,8 @@ typedef struct svr_runopts {
 
 	int inetdmode;
 
-	/* Flags indicating whether to use ipv4 and ipv6 */
-	/* not used yet
-	int ipv4;
-	int ipv6;
-	*/
+	/* ip protocol family to use */
+	int ipfamily;
 
 #ifdef DO_MOTD
 	/* whether to print the MOTD */
@@ -99,6 +96,10 @@ void loadhostkeys();
 typedef struct cli_runopts {
 
 	char *progname;
+
+	/* ip protocol family to use */
+	int ipfamily;
+
 	char *remotehost;
 	char *remoteport;
 
diff -BurpN dropbear.orig/svr-main.c dropbear/svr-main.c
--- dropbear.orig/svr-main.c	2010-03-12 00:00:00.000000000 +0000
+++ dropbear/svr-main.c	2010-03-12 22:52:31.000000000 +0000
@@ -408,7 +408,8 @@ static size_t listensockets(int *sock, s
 
 		TRACE(("listening on '%s:%s'", svr_opts.addresses[i], svr_opts.ports[i]))
 
-		nsock = dropbear_listen(svr_opts.addresses[i], svr_opts.ports[i], &sock[sockpos], 
+		nsock = dropbear_listen(svr_opts.ipfamily,
+				svr_opts.addresses[i], svr_opts.ports[i], &sock[sockpos],
 				sockcount - sockpos,
 				&errstring, maxfd);
 
diff -BurpN dropbear.orig/svr-runopts.c dropbear/svr-runopts.c
--- dropbear.orig/svr-runopts.c	2008-11-11 14:09:03.000000000 +0000
+++ dropbear/svr-runopts.c	2010-03-12 23:56:52.000000000 +0000
@@ -71,6 +71,9 @@ static void printhelp(const char * progn
 					"-k		Disable remote port forwarding\n"
 					"-a		Allow connections to forwarded ports from any host\n"
 #endif
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+					"-4,-6		Explicitly force IPv4 or IPv6 usage\n"
+#endif
 					"-p [address:]port\n"
 					"		Listen on specified tcp port (and optionally address),\n"
 					"		up to %d can be specified\n"
@@ -125,10 +128,7 @@ void svr_getopts(int argc, char ** argv)
 #ifdef ENABLE_SVR_REMOTETCPFWD
 	svr_opts.noremotetcp = 0;
 #endif
-	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
-	*/
+	svr_opts.ipfamily = AF_UNSPEC;
 #ifdef DO_MOTD
 	svr_opts.domotd = 1;
 #endif
@@ -200,9 +200,17 @@ void svr_getopts(int argc, char ** argv)
 					svr_opts.inetdmode = 1;
 					break;
 #endif
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+				case '4':
+					svr_opts.ipfamily = AF_INET;
+					break;
+				case '6':
+					svr_opts.ipfamily = AF_INET6;
+					break;
+#endif
 				case 'p':
-				  nextisport = 1;
-				  break;
+					nextisport = 1;
+					break;
 				case 'P':
 					next = &svr_opts.pidfile;
 					break;
diff -BurpN dropbear.orig/svr-tcpfwd.c dropbear/svr-tcpfwd.c
--- dropbear.orig/svr-tcpfwd.c	2008-11-11 14:09:03.000000000 +0000
+++ dropbear/svr-tcpfwd.c	2010-03-12 23:34:25.000000000 +0000
@@ -265,7 +265,7 @@ static int newtcpdirect(struct Channel *
 	}
 
 	snprintf(portstring, sizeof(portstring), "%d", destport);
-	sock = connect_remote(desthost, portstring, 1, NULL);
+	sock = connect_remote(AF_UNSPEC, desthost, portstring, 1, NULL);
 	if (sock < 0) {
 		err = SSH_OPEN_CONNECT_FAILED;
 		TRACE(("leave newtcpdirect: sock failed"))
diff -BurpN dropbear.orig/tcp-accept.c dropbear/tcp-accept.c
--- dropbear.orig/tcp-accept.c	2008-11-11 14:09:03.000000000 +0000
+++ dropbear/tcp-accept.c	2010-03-12 22:55:01.000000000 +0000
@@ -118,7 +118,7 @@ int listen_tcpfwd(struct TCPListener* tc
 		listen_spec = tcpinfo->listenaddr;
 	}
 
-	nsocks = dropbear_listen(listen_spec, portstring, socks, 
+	nsocks = dropbear_listen(AF_UNSPEC, listen_spec, portstring, socks, 
 			DROPBEAR_MAX_SOCKS, &errstring, &ses.maxfd);
 	if (nsocks < 0) {
 		dropbear_log(LOG_INFO, "TCP forward failed: %s", errstring);
