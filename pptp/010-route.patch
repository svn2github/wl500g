diff -urbB pptp-1.7.1/pptp.c pptp.route/pptp.c
--- pptp-1.7.1/pptp.c	2006-02-13 06:07:42.000000000 +0300
+++ pptp.route/pptp.c	2008-12-01 17:23:02.000000000 +0300
@@ -22,6 +22,8 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <sys/un.h>
+#include <net/route.h>
+#include <sys/ioctl.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <string.h>
@@ -57,6 +59,8 @@
 #define PPPD_BINARY "pppd"
 #endif
 
+#define sin_addr(s) (((struct sockaddr_in *)(s))->sin_addr)
+
 int syncppp = 0;
 int log_level = 1;
 int disable_buffer = 0;
@@ -68,6 +72,9 @@
 		 u_int16_t *call_id, u_int16_t *peer_call_id);
 void launch_pppd(char *ttydev, int argc, char **argv);
 
+static int route_add(const struct in_addr inetaddr, struct rtentry *rt);
+static int route_del(struct rtentry *rt);
+
 /*** print usage and exit *****************************************************/
 void usage(char *progname)
 {
@@ -93,7 +100,8 @@
             "  --max-echo-wait		Time to wait before giving up on lack of reply\n"
             "  --logstring <name>	Use <name> instead of 'anon' in syslog messages\n"
             "  --localbind <addr>	Bind to specified IP address instead of wildcard\n"
-            "  --loglevel <level>	Sets the debugging level (0=low, 1=default, 2=high)\n",
+            "  --loglevel <level>	Sets the debugging level (0=low, 1=default, 2=high)\n"
+            "  --no-host-route		Disable adding host route to server",
 
             version, progname, progname);
     log("%s called with wrong arguments, program not started.", progname);
@@ -149,6 +157,7 @@
 int main(int argc, char **argv, char **envp)
 {
     struct in_addr inetaddr;
+    struct rtentry rt;
     volatile int callmgr_sock = -1;
     char ttydev[PATH_MAX];
     int pty_fd, tty_fd, gre_fd, rc;
@@ -160,7 +169,7 @@
     char phonenrbuf[65]; /* maximum length of field plus one for the trailing
                           * '\0' */
     char * volatile phonenr = NULL;
-    volatile int launchpppd = 1, debug = 0;
+    volatile int launchpppd = 1, debug = 0, add_host_route = 1;
 
     while(1){ 
         /* structure with all recognised options for pptp */
@@ -178,6 +187,7 @@
 	    {"idle-wait", 1, 0, 0},
 	    {"max-echo-wait", 1, 0, 0},
 	    {"version", 0, 0, 0},
+	    {"no-host-route", 0, 0, 0},
             {0, 0, 0, 0}
         };
         int option_index = 0;
@@ -253,6 +263,8 @@
 		    fprintf(stdout, "%s\n", version);
 		    exit(0);
-                }
+                } else if (option_index == 13) { /* --no-host-route */
+		    add_host_route = 0;
+                }
                 break;
             case '?': /* unrecognised option */
                 /* fall through */
@@ -275,6 +288,12 @@
     pppdargv = argv + optind;
     log("The synchronous pptp option is %sactivated\n", syncppp ? "" : "NOT ");
 
+    if (add_host_route) {
+        /* Add a route to inetaddr */
+        memset(&rt, 0, sizeof(rt));
+        route_add(inetaddr, &rt);
+    }
+
     /* Now we have the peer address, bind the GRE socket early,
        before starting pppd. This prevents the ICMP Unreachable bug
        documented in <1026868263.2855.67.camel@jander> */
@@ -377,6 +396,11 @@
         kill(parent_pid, SIGTERM);
     close(pty_fd);
     close(callmgr_sock);
+/*
+    if (add_host_route) {
+        route_del(&rt); // don't delete, as otherwise it would try to use pppX in demand mode (since 1.9.2.7-9)
+    }
+*/
     exit(0);
 }
 
@@ -520,3 +544,99 @@
     execvp(new_argv[0], new_argv);
 }
 
+/*** route manipulation *******************************************************/
+
+static int
+route_ctrl(int ctrl, struct rtentry *rt)
+{
+	int s;
+
+	/* Open a raw socket to the kernel */
+	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||	ioctl(s, ctrl, rt) < 0)
+	        warn("route_ctrl: %s", strerror(errno));
+	else errno = 0;
+
+	close(s);
+	return errno;
+}
+
+static int
+route_del(struct rtentry *rt)
+{
+	if (rt->rt_dev) {
+		route_ctrl(SIOCDELRT, rt);
+		free(rt->rt_dev), rt->rt_dev = NULL;
+	}
+	
+	return 0;
+}
+
+static int
+route_add(const struct in_addr inetaddr, struct rtentry *rt)
+{
+	char buf[256], dev[64];
+	int metric, flags;
+	u_int32_t dest, mask;
+	
+	FILE *f = fopen("/proc/net/route", "r");
+	if (f == NULL) {
+	        warn("/proc/net/route: %s", strerror(errno));
+		return -1;
+	}
+
+	while (fgets(buf, sizeof(buf), f)) 
+	{
+		if (sscanf(buf, "%63s %x %x %X %*s %*s %d %x", dev, &dest,
+		    	&sin_addr(&rt->rt_gateway).s_addr, &flags, &metric, &mask) != 6)
+			continue;
+		if ((flags & RTF_UP) == RTF_UP && (inetaddr.s_addr & mask) == dest &&
+			(dest || strncmp(dev, "ppp", 3)) /* avoid default via pppX to avoid on-demand loops*/)
+		{
+			rt->rt_metric = metric;
+			rt->rt_gateway.sa_family = AF_INET;
+			break;
+		}
+	}
+	
+	fclose(f);
+
+	/* check for no route */
+	if (rt->rt_gateway.sa_family != AF_INET) 
+	{
+	        /* warn("route_add: no route to host"); */
+		return -1;
+	}
+
+	/* check for existing route to this host, 
+	add if missing based on the existing routes */
+	if (flags & RTF_HOST) {
+	        /* warn("route_add: not adding existing route"); */
+		return -1;
+	}
+
+	sin_addr(&rt->rt_dst) = inetaddr;
+	rt->rt_dst.sa_family = AF_INET;
+
+	sin_addr(&rt->rt_genmask).s_addr = INADDR_BROADCAST;
+	rt->rt_genmask.sa_family = AF_INET;
+
+	rt->rt_flags = RTF_UP | RTF_HOST;
+	if (flags & RTF_GATEWAY)
+		rt->rt_flags |= RTF_GATEWAY;
+
+	rt->rt_metric++;
+	rt->rt_dev = strdup(dev);
+
+	if (!rt->rt_dev)
+	{
+	        warn("route_add: no memory");
+		return -1;
+	}
+	
+	if (!route_ctrl(SIOCADDRT, rt))
+		return 0;
+
+	free(rt->rt_dev), rt->rt_dev = NULL;
+
+	return -1;
+}
