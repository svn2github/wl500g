--- pptp/pptp.c	2008-01-20 21:47:43.000000000 +0300
+++ pptp.n_hdlc/pptp.c	2008-01-20 21:46:01.000000000 +0300
@@ -41,6 +41,9 @@
 #include <getopt.h>
 #endif
 #include <limits.h>
+#ifndef N_HDLC
+#include <linux/termios.h>
+#endif
 #include "config.h"
 #include "pptp_callmgr.h"
 #include "pptp_gre.h"
@@ -165,6 +168,8 @@
     char * volatile phonenr = NULL;
     volatile int launchpppd = 1, debug = 0;
 
+    int disc = N_HDLC;
+
     while(1){ 
         /* structure with all recognised options for pptp */
         static struct option long_options[] = {
@@ -367,6 +372,14 @@
     signal(SIGCHLD, sighandler);
     signal(SIGUSR1, sigstats);
 
+    if (syncppp) {
+        if (ioctl(pty_fd, TIOCSETD, &disc) < 0) {
+            fatal("Unable to set line discipline to N_HDLC");
+        } else {
+            log("Changed pty line discipline to N_HDLC for synchronous mode");
+        }
+    }
+
     /* Do GRE copy until close. */
     pptp_gre_copy(call_id, peer_call_id, pty_fd, gre_fd);
 
--- pptp/pptp_gre.c	2005-02-18 04:42:45.000000000 +0300
+++ pptp.n_hdlc/pptp_gre.c	2008-01-20 21:44:14.000000000 +0300
@@ -223,19 +223,10 @@
             warn( "The ppp mode is synchronous, "
                     "yet no pptp --sync option is specified!\n");
     }
-    /* in synchronous mode there are no hdlc control characters nor checksum
-     * bytes. Find end of packet with the length information in the PPP packet
-     */
     if ( syncppp ){
-        while ( start + 8 < end) {
-            len = ntoh16(*(short int *)(buffer + start + 6)) + 4;
-            /* note: the buffer may contain an incomplete packet at the end
-             * this packet will be read again at the next read() */
-            if ( start + len <= end)
-                if ((status = cb (cl, buffer + start, len)) < 0)
-                    return status; /* error-check */
-            start += len;
-        }
+    	/* this handling is pretty simple thanks to N_HDLC */
+        if ((status = cb (cl, buffer, end)) < 0)
+            return status; /* error-check */
         return 0;
     }
     /* asynchronous mode */
