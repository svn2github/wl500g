diff -BurpN accel-pptp.orig/pppd_plugin/src/pptp.c accel-pptp/pppd_plugin/src/pptp.c
--- accel-pptp.orig/pppd_plugin/src/pptp.c	2009-10-03 08:42:10.000000000 +0000
+++ accel-pptp/pppd_plugin/src/pptp.c	2009-10-03 09:08:18.000000000 +0000
@@ -53,7 +53,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-
+#include <net/route.h>
+#define sin_addr(s) (((struct sockaddr_in *)(s))->sin_addr)
 
 extern char** environ;
 
@@ -67,6 +68,7 @@ char *pptp_phone = NULL;
 int pptp_sock=-1;
 int pptp_timeout=100000;
 struct in_addr localbind = { INADDR_NONE };
+struct rtentry rt;
 
 static int callmgr_sock;
 static int pptp_fd;
@@ -77,6 +79,9 @@ static int open_callmgr(int call_id,stru
 static void launch_callmgr(int call_is,struct in_addr inetaddr, char *phonenr,int window);
 static int get_call_id(int sock, pid_t gre, pid_t pppd, u_int16_t *peer_call_id);
 
+static int route_add(const struct in_addr inetaddr, struct rtentry *rt);
+static int route_del(struct rtentry *rt);
+
 //static int pptp_devname_hook(char *cmd, char **argv, int doit);
 static option_t Options[] =
 {
@@ -132,6 +137,10 @@ static int pptp_start_client(void)
 		return -1;
 	}
 	dst_addr.sa_addr.pptp.sin_addr=*(struct in_addr*)hostinfo->h_addr;
+
+ 	memset(&rt, 0, sizeof(rt));
+ 	route_add(dst_addr.sa_addr.pptp.sin_addr, &rt);
+
 	{
 		int sock;
 		struct sockaddr_in addr;
@@ -224,6 +233,7 @@ static void pptp_disconnect(void)
 {
 	if (pptp_server) close(callmgr_sock);
 	close(pptp_fd);
+	//route_del(&rt); // don't delete, as otherwise it would try to use pppX in demand mode
 }
 
 static int open_callmgr(int call_id,struct in_addr inetaddr, char *phonenr,int window)
@@ -348,3 +358,97 @@ void plugin_init(void)
     modem = 0;
 }
 
+static int
+route_ctrl(int ctrl, struct rtentry *rt)
+{
+	int s;
+
+	/* Open a raw socket to the kernel */
+	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||	ioctl(s, ctrl, rt) < 0)
+	        warn("route_ctrl: %s", strerror(errno));
+	else errno = 0;
+
+	close(s);
+	return errno;
+}
+
+static int
+route_del(struct rtentry *rt)
+{
+	if (rt->rt_dev) {
+		route_ctrl(SIOCDELRT, rt);
+		free(rt->rt_dev), rt->rt_dev = NULL;
+	}
+
+	return 0;
+}
+
+static int
+route_add(const struct in_addr inetaddr, struct rtentry *rt)
+{
+	char buf[256], dev[64];
+	int metric, flags;
+	u_int32_t dest, mask;
+
+	FILE *f = fopen("/proc/net/route", "r");
+	if (f == NULL) {
+	        warn("/proc/net/route: %s", strerror(errno));
+		return -1;
+	}
+
+	while (fgets(buf, sizeof(buf), f)) 
+	{
+		if (sscanf(buf, "%63s %x %x %X %*s %*s %d %x", dev, &dest,
+		    	&sin_addr(&rt->rt_gateway).s_addr, &flags, &metric, &mask) != 6)
+			continue;
+		if ((flags & RTF_UP) == RTF_UP && (inetaddr.s_addr & mask) == dest &&
+			(dest || strncmp(dev, "ppp", 3)) /* avoid default via pppX to avoid on-demand loops*/)
+		{
+			rt->rt_metric = metric;
+			rt->rt_gateway.sa_family = AF_INET;
+			break;
+		}
+	}
+
+	fclose(f);
+
+	/* check for no route */
+	if (rt->rt_gateway.sa_family != AF_INET) 
+	{
+		/* warn("route_add: no route to host"); */
+		return -1;
+	}
+
+	/* check for existing route to this host, 
+	add if missing based on the existing routes */
+	if (flags & RTF_HOST) {
+		/* warn("route_add: not adding existing route"); */
+		return -1;
+	}
+
+	sin_addr(&rt->rt_dst) = inetaddr;
+	rt->rt_dst.sa_family = AF_INET;
+
+	sin_addr(&rt->rt_genmask).s_addr = INADDR_BROADCAST;
+	rt->rt_genmask.sa_family = AF_INET;
+
+	rt->rt_flags = RTF_UP | RTF_HOST;
+	if (flags & RTF_GATEWAY)
+		rt->rt_flags |= RTF_GATEWAY;
+
+	rt->rt_metric++;
+	rt->rt_dev = strdup(dev);
+
+	if (!rt->rt_dev)
+	{
+	        warn("route_add: no memory");
+		return -1;
+	}
+
+	if (!route_ctrl(SIOCADDRT, rt))
+		return 0;
+
+	free(rt->rt_dev), rt->rt_dev = NULL;
+
+	return -1;
+}
