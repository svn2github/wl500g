From b8b72f02f01017d0f9584666fa572221f2b58613
From: Denys Vlasenko
Date: Sun, 30 May 2010 22:45:09 +0000
Subject: dhcp: truncate packets instead of padding them to 574 bytes. closes bug 1849

function                                             old     new   delta
udhcp_send_raw_packet                                411     456     +45
udhcp_send_kernel_packet                             259     271     +12

Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
---
diff --git a/networking/udhcp/packet.c b/networking/udhcp/packet.c
--- a/networking/udhcp/packet.c
+++ b/networking/udhcp/packet.c
@@ -178,6 +178,7 @@ int FAST_FUNC udhcp_send_raw_packet(stru
 {
 	struct sockaddr_ll dest;
 	struct ip_udp_dhcp_packet packet;
+	unsigned padding;
 	int fd;
 	int result = -1;
 	const char *msg;
@@ -207,29 +208,36 @@ int FAST_FUNC udhcp_send_raw_packet(stru
 		goto ret_close;
 	}
 
+	/* We were sending full-sized DHCP packets (zero padded),
+	 * but some badly configured servers were seen dropping them.
+	 * Apparently they drop all DHCP packets >576 *ethernet* octets big,
+	 * whereas they may only drop packets >576 *IP* octets big
+	 * (which for typical Ethernet II means 590 octets: 6+6+2 + 576).
+	 *
+	 * In order to work with those buggy servers,
+	 * we truncate packets after end option byte.
+	 */
+	padding = DHCP_OPTIONS_BUFSIZE - 1 - udhcp_end_option(packet.data.options);
+
 	packet.ip.protocol = IPPROTO_UDP;
 	packet.ip.saddr = source_ip;
 	packet.ip.daddr = dest_ip;
 	packet.udp.source = htons(source_port);
 	packet.udp.dest = htons(dest_port);
 	/* size, excluding IP header: */
-	packet.udp.len = htons(UPD_DHCP_SIZE);
+	packet.udp.len = htons(UPD_DHCP_SIZE - padding);
 	/* for UDP checksumming, ip.len is set to UDP packet len */
 	packet.ip.tot_len = packet.udp.len;
-	packet.udp.check = udhcp_checksum(&packet, IP_UPD_DHCP_SIZE);
+	packet.udp.check = udhcp_checksum(&packet, IP_UPD_DHCP_SIZE - padding);
 	/* but for sending, it is set to IP packet len */
-	packet.ip.tot_len = htons(IP_UPD_DHCP_SIZE);
+	packet.ip.tot_len = htons(IP_UPD_DHCP_SIZE - padding);
 	packet.ip.ihl = sizeof(packet.ip) >> 2;
 	packet.ip.version = IPVERSION;
 	packet.ip.ttl = IPDEFTTL;
 	packet.ip.check = udhcp_checksum(&packet.ip, sizeof(packet.ip));
 
-	/* Currently we send full-sized DHCP packets (zero padded).
-	 * If you need to change this: last byte of the packet is
-	 * packet.data.options[end_option(packet.data.options)]
-	 */
 	udhcp_dump_packet(dhcp_pkt);
-	result = sendto(fd, &packet, IP_UPD_DHCP_SIZE, 0,
+	result = sendto(fd, &packet, IP_UPD_DHCP_SIZE - padding, /*flags:*/ 0,
 				(struct sockaddr *) &dest, sizeof(dest));
 	msg = "sendto";
  ret_close:
@@ -247,6 +255,7 @@ int FAST_FUNC udhcp_send_kernel_packet(s
 		uint32_t dest_ip, int dest_port)
 {
 	struct sockaddr_in client;
+	unsigned padding;
 	int fd;
 	int result = -1;
 	const char *msg;
@@ -280,9 +289,10 @@ int FAST_FUNC udhcp_send_kernel_packet(s
 		goto ret_close;
 	}
 
-	/* Currently we send full-sized DHCP packets (see above) */
 	udhcp_dump_packet(dhcp_pkt);
-	result = safe_write(fd, dhcp_pkt, DHCP_SIZE);
+
+	padding = DHCP_OPTIONS_BUFSIZE - 1 - udhcp_end_option(dhcp_pkt->options);
+	result = safe_write(fd, dhcp_pkt, DHCP_SIZE - padding);
 	msg = "write";
  ret_close:
 	close(fd);
--
cgit v0.8.2.1
