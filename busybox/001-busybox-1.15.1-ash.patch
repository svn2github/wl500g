diff -urpN busybox-1.15.1/shell/ash.c busybox-1.15.1-ash/shell/ash.c
--- busybox-1.15.1/shell/ash.c	2009-09-12 17:56:11.000000000 +0200
+++ busybox-1.15.1-ash/shell/ash.c	2009-09-23 03:27:09.000000000 +0200
@@ -4560,7 +4560,52 @@ forkchild(struct job *jp, union node *n,
 	 * Do we do it correctly? */
 
 	closescript();
-	clear_traps();
+
+	if (mode == FORK_NOJOB          /* is it `xxx` ? */
+	 && n && n->type == NCMD        /* is it single cmd? */
+	/* && n->ncmd.args->type == NARG - always true? */
+	 && strcmp(n->ncmd.args->narg.text, "trap") == 0
+	 && n->ncmd.args->narg.next == NULL /* "trap" with no arguments */
+	/* && n->ncmd.args->narg.backquote == NULL - do we need to check this? */
+	) {
+		TRACE(("Trap hack\n"));
+		/* Awful hack for `trap` or $(trap).
+		 *
+		 * http://www.opengroup.org/onlinepubs/009695399/utilities/trap.html
+		 * contains an example where "trap" is executed in a subshell:
+		 *
+		 * save_traps=$(trap)
+		 * ...
+		 * eval "$save_traps"
+		 *
+		 * Standard does not say that "trap" in subshell shall print
+		 * parent shell's traps. It only says that its output
+		 * must have suitable form, but then, in the above example
+		 * (which is not supposed to be normative), it implies that.
+		 *
+		 * bash (and probably other shell) does implement it
+		 * (traps are reset to defaults, but "trap" still shows them),
+		 * but as a result, "trap" logic is hopelessly messed up:
+		 *
+		 * # trap
+		 * trap -- 'echo Ho' SIGWINCH  <--- we have a handler
+		 * # (trap)        <--- trap is in subshell - no output (correct, traps are reset)
+		 * # true | trap   <--- trap is in subshell - no output (ditto)
+		 * # echo `true | trap`    <--- in subshell - output (but traps are reset!)
+		 * trap -- 'echo Ho' SIGWINCH
+		 * # echo `(trap)`         <--- in subshell in subshell - output
+		 * trap -- 'echo Ho' SIGWINCH
+		 * # echo `true | (trap)`  <--- in subshell in subshell in subshell - output!
+		 * trap -- 'echo Ho' SIGWINCH
+		 *
+		 * The rules when to forget and when to not forget traps
+		 * get really complex and nonsensical.
+		 *
+		 * Our solution: ONLY bare $(trap) or `trap` is special.
+		 */
+	} else {
+		clear_traps();
+	}
 #if JOBS
 	/* do job control only in root shell */
 	doing_jobctl = 0;
@@ -4604,8 +4649,14 @@ forkchild(struct job *jp, union node *n,
 		setsignal(SIGQUIT);
 	}
 #if JOBS
-	if (n && n->type == NCMD && strcmp(n->ncmd.args->narg.text, "jobs") == 0) {
+	if (n && n->type == NCMD
+	 && strcmp(n->ncmd.args->narg.text, "jobs") == 0
+	) {
 		TRACE(("Job hack\n"));
+		/* "jobs": we do not want to clear job list for it,
+		 * instead we remove only _its_ own_ job from job list.
+		 * This makes "jobs .... | cat" more useful.
+		 */
 		freejob(curjob);
 		return;
 	}
@@ -5553,7 +5604,7 @@ exptilde(char *startp, char *p, int flag
 	char *name;
 	struct passwd *pw;
 	const char *home;
-	int quotes = flag & (EXP_FULL | EXP_CASE);
+	int quotes = flag & (EXP_FULL | EXP_CASE | EXP_REDIR);
 	int startloc;
 
 	name = p + 1;
@@ -6321,7 +6372,7 @@ varvalue(char *name, int varflags, int f
 	int syntax;
 	int quoted = varflags & VSQUOTE;
 	int subtype = varflags & VSTYPE;
-	int quotes = flags & (EXP_FULL | EXP_CASE);
+	int quotes = flags & (EXP_FULL | EXP_CASE | EXP_REDIR);
 
 	if (quoted && (flags & EXP_FULL))
 		sep = 1 << CHAR_BIT;
@@ -6558,6 +6609,7 @@ evalvar(char *p, int flag, struct strlis
 		patloc = expdest - (char *)stackblock();
 		if (0 == subevalvar(p, /* str: */ NULL, patloc, subtype,
 				startloc, varflags,
+//TODO: | EXP_REDIR too? All other such places do it too
 				/* quotes: */ flag & (EXP_FULL | EXP_CASE),
 				var_str_list)
 		) {
@@ -12203,7 +12255,7 @@ trapcmd(int argc UNUSED_PARAM, char **ar
 	if (!*ap) {
 		for (signo = 0; signo < NSIG; signo++) {
 			if (trap[signo] != NULL) {
-				out1fmt("trap -- %s %s\n",
+				out1fmt("trap -- %s SIG%s\n",
 						single_quote(trap[signo]),
 						get_signame(signo));
 			}
diff -urpN busybox-1.15.1/shell/ash_test/ash-signals/signal1.right busybox-1.15.1-ash/shell/ash_test/ash-signals/signal1.right
--- busybox-1.15.1/shell/ash_test/ash-signals/signal1.right	2009-09-12 17:55:36.000000000 +0200
+++ busybox-1.15.1-ash/shell/ash_test/ash-signals/signal1.right	2009-09-23 03:24:05.000000000 +0200
@@ -1,20 +1,20 @@
 got signal
-trap -- 'echo got signal' USR1
+trap -- 'echo got signal' SIGUSR1
 sent 1 signal
 got signal
 wait interrupted
-trap -- 'echo got signal' USR1
+trap -- 'echo got signal' SIGUSR1
 sent 2 signal
 got signal
 wait interrupted
-trap -- 'echo got signal' USR1
+trap -- 'echo got signal' SIGUSR1
 sent 3 signal
 got signal
 wait interrupted
-trap -- 'echo got signal' USR1
+trap -- 'echo got signal' SIGUSR1
 sent 4 signal
 got signal
 wait interrupted
-trap -- 'echo got signal' USR1
+trap -- 'echo got signal' SIGUSR1
 sent 5 signal
 sleep completed
