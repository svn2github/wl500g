From e8f36330d9bb27f9f7e66aa6f01ff92c07d86f62
From: Baruch Siach
Date: Wed, 07 Sep 2011 15:52:37 +0000
Subject: networking: consolidate the IP checksum code. -129 bytes.

Signed-off-by: Baruch Siach <baruch@tkos.co.il>
Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
---

0d0260fd1e55c39525660370094d090bc5412fe5 inet_cksum: big-endian fix

diff --git a/include/libbb.h b/include/libbb.h
index 1ca4489..f60f427 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -640,6 +640,7 @@ ssize_t recv_from_to(int fd, void *buf, size_t len, int flags,
 		struct sockaddr *to,
 		socklen_t sa_size) FAST_FUNC;
 
+uint16_t inet_cksum(uint16_t *addr, int len) FAST_FUNC;
 
 char *xstrdup(const char *s) FAST_FUNC RETURNS_MALLOC;
 char *xstrndup(const char *s, int n) FAST_FUNC RETURNS_MALLOC;
diff --git a/libbb/Kbuild.src b/libbb/Kbuild.src
index 875d024..335b341 100644
--- a/libbb/Kbuild.src
+++ b/libbb/Kbuild.src
@@ -166,6 +166,12 @@ lib-$(CONFIG_IOSTAT) += get_cpu_count.o
 lib-$(CONFIG_MPSTAT) += get_cpu_count.o
 lib-$(CONFIG_POWERTOP) += get_cpu_count.o
 
+lib-$(CONFIG_PING) += inet_cksum.o
+lib-$(CONFIG_TRACEROUTE) += inet_cksum.o
+lib-$(CONFIG_TRACEROUTE6) += inet_cksum.o
+lib-$(CONFIG_UDHCPC) += inet_cksum.o
+lib-$(CONFIG_UDHCPD) += inet_cksum.o
+
 # We shouldn't build xregcomp.c if we don't need it - this ensures we don't
 # require regex.h to be in the include dir even if we don't need it thereby
 # allowing us to build busybox even if uclibc regex support is disabled.
diff --git a/libbb/inet_cksum.c b/libbb/inet_cksum.c
new file mode 100644
--- a/dev/null
+++ b/libbb/inet_cksum.c
@@ -0,0 +1,36 @@
+/*
+ * Checksum routine for Internet Protocol family headers (C Version)
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+#include "libbb.h"
+
+uint16_t FAST_FUNC inet_cksum(uint16_t *addr, int nleft)
+{
+	/*
+	 * Our algorithm is simple, using a 32 bit accumulator,
+	 * we add sequential 16 bit words to it, and at the end, fold
+	 * back all the carry bits from the top 16 bits into the lower
+	 * 16 bits.
+	 */
+	unsigned sum = 0;
+	while (nleft > 1) {
+		sum += *addr++;
+		nleft -= 2;
+	}
+
+	/* Mop up an odd byte, if necessary */
+	if (nleft == 1) {
+		if (BB_LITTLE_ENDIAN)
+			sum += *(uint8_t*)addr;
+		else
+			sum += *(uint8_t*)addr << 8;
+	}
+
+	/* Add back carry outs from top 16 bits to low 16 bits */
+	sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
+	sum += (sum >> 16);                     /* add carry */
+
+	return (uint16_t)~sum;
+}
diff --git a/networking/ping.c b/networking/ping.c
index efd4f21..a1fd9df 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -149,31 +149,6 @@ enum {
 	PINGINTERVAL = 1, /* 1 second */
 };
 
-/* Common routines */
-
-static int in_cksum(unsigned short *buf, int sz)
-{
-	int nleft = sz;
-	int sum = 0;
-	unsigned short *w = buf;
-	unsigned short ans = 0;
-
-	while (nleft > 1) {
-		sum += *w++;
-		nleft -= 2;
-	}
-
-	if (nleft == 1) {
-		*(unsigned char *) (&ans) = *(unsigned char *) w;
-		sum += ans;
-	}
-
-	sum = (sum >> 16) + (sum & 0xFFFF);
-	sum += (sum >> 16);
-	ans = ~sum;
-	return ans;
-}
-
 #if !ENABLE_FEATURE_FANCY_PING
 
 /* Simple version */
@@ -201,7 +176,7 @@ static void ping4(len_and_sockaddr *lsa)
 	pkt = (struct icmp *) G.packet;
 	memset(pkt, 0, sizeof(G.packet));
 	pkt->icmp_type = ICMP_ECHO;
-	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(G.packet));
+	pkt->icmp_cksum = inet_cksum((uint16_t *) pkt, sizeof(G.packet));
 
 	xsendto(pingsock, G.packet, DEFDATALEN + ICMP_MINLEN, &lsa->u.sa, lsa->len);
 
@@ -493,7 +468,7 @@ static void sendping4(int junk UNUSED_PARAM)
 		/* No hton: we'll read it back on the same machine */
 		*(uint32_t*)&pkt->icmp_dun = monotonic_us();
 
-	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, datalen + ICMP_MINLEN);
+	pkt->icmp_cksum = inet_cksum((uint16_t *) pkt, datalen + ICMP_MINLEN);
 
 	sendping_tail(sendping4, ICMP_MINLEN);
 }
@@ -512,7 +487,7 @@ static void sendping6(int junk UNUSED_PARAM)
 	/*if (datalen >= 4)*/
 		*(uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();
 
-	//TODO? pkt->icmp_cksum = in_cksum(...);
+	//TODO? pkt->icmp_cksum = inet_cksum(...);
 
 	sendping_tail(sendping6, sizeof(struct icmp6_hdr));
 }
diff --git a/networking/traceroute.c b/networking/traceroute.c
index c321035..d197e54 100644
--- a/networking/traceroute.c
+++ b/networking/traceroute.c
@@ -418,39 +418,6 @@ wait_for_reply(len_and_sockaddr *from_lsa, struct sockaddr *to, unsigned *timest
 	return read_len;
 }
 
-/*
- * Checksum routine for Internet Protocol family headers (C Version)
- */
-static uint16_t
-in_cksum(uint16_t *addr, int len)
-{
-	int nleft = len;
-	uint16_t *w = addr;
-	uint16_t answer;
-	int sum = 0;
-
-	/*
-	 * Our algorithm is simple, using a 32 bit accumulator (sum),
-	 * we add sequential 16 bit words to it, and at the end, fold
-	 * back all the carry bits from the top 16 bits into the lower
-	 * 16 bits.
-	 */
-	while (nleft > 1) {
-		sum += *w++;
-		nleft -= 2;
-	}
-
-	/* mop up an odd byte, if necessary */
-	if (nleft == 1)
-		sum += *(unsigned char *)w;
-
-	/* add back carry outs from top 16 bits to low 16 bits */
-	sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
-	sum += (sum >> 16);                     /* add carry */
-	answer = ~sum;                          /* truncate to 16 bits */
-	return answer;
-}
-
 static void
 send_probe(int seq, int ttl)
 {
@@ -477,7 +444,7 @@ send_probe(int seq, int ttl)
 
 			/* Always calculate checksum for icmp packets */
 			outicmp->icmp_cksum = 0;
-			outicmp->icmp_cksum = in_cksum((uint16_t *)outicmp,
+			outicmp->icmp_cksum = inet_cksum((uint16_t *)outicmp,
 						packlen - (sizeof(*outip) + optlen));
 			if (outicmp->icmp_cksum == 0)
 				outicmp->icmp_cksum = 0xffff;
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index 4d755e6..3be09f4 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -739,7 +739,7 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	/* verify IP checksum */
 	check = packet.ip.check;
 	packet.ip.check = 0;
-	if (check != udhcp_checksum(&packet.ip, sizeof(packet.ip))) {
+	if (check != inet_cksum((uint16_t *)&packet.ip, sizeof(packet.ip))) {
 		log1("Bad IP header checksum, ignoring");
 		return -2;
 	}
@@ -750,7 +750,7 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	packet.ip.tot_len = packet.udp.len; /* yes, this is needed */
 	check = packet.udp.check;
 	packet.udp.check = 0;
-	if (check && check != udhcp_checksum(&packet, bytes)) {
+	if (check && check != inet_cksum((uint16_t *)&packet, bytes)) {
 		log1("Packet with bad UDP checksum received, ignoring");
 		return -2;
 	}
diff --git a/networking/udhcp/packet.c b/networking/udhcp/packet.c
index 66b42c5..4d5ff06 100644
--- a/networking/udhcp/packet.c
+++ b/networking/udhcp/packet.c
@@ -129,35 +129,6 @@ int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)
 	return bytes;
 }
 
-uint16_t FAST_FUNC udhcp_checksum(void *addr, int count)
-{
-	/* Compute Internet Checksum for "count" bytes
-	 * beginning at location "addr".
-	 */
-	int32_t sum = 0;
-	uint16_t *source = (uint16_t *) addr;
-
-	while (count > 1)  {
-		/*  This is the inner loop */
-		sum += *source++;
-		count -= 2;
-	}
-
-	/*  Add left-over byte, if any */
-	if (count > 0) {
-		/* Make sure that the left-over byte is added correctly both
-		 * with little and big endian hosts */
-		uint16_t tmp = 0;
-		*(uint8_t*)&tmp = *(uint8_t*)source;
-		sum += tmp;
-	}
-	/*  Fold 32-bit sum to 16 bits */
-	while (sum >> 16)
-		sum = (sum & 0xffff) + (sum >> 16);
-
-	return ~sum;
-}
-
 /* Construct a ip/udp header for a packet, send packet */
 int FAST_FUNC udhcp_send_raw_packet(struct dhcp_packet *dhcp_pkt,
 		uint32_t source_nip, int source_port,
@@ -212,13 +183,14 @@ int FAST_FUNC udhcp_send_raw_packet(struct dhcp_packet *dhcp_pkt,
 	packet.udp.len = htons(UDP_DHCP_SIZE - padding);
 	/* for UDP checksumming, ip.len is set to UDP packet len */
 	packet.ip.tot_len = packet.udp.len;
-	packet.udp.check = udhcp_checksum(&packet, IP_UDP_DHCP_SIZE - padding);
+	packet.udp.check = inet_cksum((uint16_t *)&packet,
+			IP_UDP_DHCP_SIZE - padding);
 	/* but for sending, it is set to IP packet len */
 	packet.ip.tot_len = htons(IP_UDP_DHCP_SIZE - padding);
 	packet.ip.ihl = sizeof(packet.ip) >> 2;
 	packet.ip.version = IPVERSION;
 	packet.ip.ttl = IPDEFTTL;
-	packet.ip.check = udhcp_checksum(&packet.ip, sizeof(packet.ip));
+	packet.ip.check = inet_cksum((uint16_t *)&packet.ip, sizeof(packet.ip));
 
 	udhcp_dump_packet(dhcp_pkt);
 	result = sendto(fd, &packet, IP_UDP_DHCP_SIZE - padding, /*flags:*/ 0,
--
cgit v0.9.0.1-2-gef13
