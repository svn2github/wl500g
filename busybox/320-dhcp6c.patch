dhcp6c: DHCPv6 client

 Port of wide-dhcpv6-20080615


 Depends on: 180-libbb-base64-str.patch
			 300-udhcp-sprint_nip6.patch
			 304-udhcp-verbose.patch

diff -urNBp a/examples/udhcp/dhcp6c.conf b/examples/udhcp/dhcp6c.conf
--- a/examples/udhcp/dhcp6c.conf	1970-01-01 03:00:00.000000000 +0300
+++ b/examples/udhcp/dhcp6c.conf	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,230 @@
+# Sample dhcp6c configuration file (/etc/dhcp6c.conf)
+# Values shown are defaults
+#
+# NB! Major limitation of busybox applet
+#  - both keyword & it's arguments MUST reside on the same line
+
+# Interface statement
+#  An interface statement specifies configuration parameters on the interface.
+#  The generic format of an interface statement is as follows:
+#
+#  interface interface { substatements };
+#     send send-options ;
+#			This statement specifies DHCPv6 options to be sent to the
+#			server(s).  Some options can only appear in particular
+#			messages according to the specification, in which case
+#			the appearance of the options is limited to be compliant
+#			with the specification.
+#
+#			send-options is a comma-separated list of options, each
+#			of which should be specified as described above. Multiple
+#			send statements can also be specified, in which case
+#			all the specified options will be sent.
+#
+#	rapid-commit
+#			When rapid-commit is specified, dhcp6c will include a
+#			rapid-commit option in solicit messages and wait for an
+#			immediate reply instead of advertisements.
+#	ia-pd ID
+#			When ia-pd is specified, dhcp6c will initiate prefix del-
+#			egation as a requesting router by including an IA_PD
+#			option with the specified ID in solicit messages.
+#	ia-na ID
+#			When ia-na is specified, dhcp6c will initiate stateful
+#			address assignment by including an IA_NA option with the
+#			specified ID in solicit messages.
+#	authentication authname
+#			means an authentication option. authname is a string specifying
+#			parameters of the authentication protocol. An authentication
+#			statement for authname must be provided.
+#			In either case, a corresponding identity association
+#			statement must exist with the same ID.
+#
+#     request request-options;
+#			This statement specifies DHCPv6 options to be included in
+#			an option-request option. request-options is a comma
+#			separated list of options, which can consist of the fol-
+#			lowing options.
+#
+#		domain-name-servers
+#			requests a list of Domain Name Server addresses.
+#		domain-name
+#			requests a DNS search path.
+#		ntp-servers
+#			requests a list of NTP server addresses. As of
+#			this writing, the option type for this option is
+#			not officially assigned. dhcp6c will reject this
+#			option unless it is explicitly built to accept
+#			the option.
+#		sip-server-address
+#			requests a list of SIP server addresses.
+#		sip-domain-name
+#			requests a SIP server domain name.
+#		nis-server-address
+#			requests a list of NIS server addresses.
+#		nis-domain-name
+#			requests a NIS domain name.
+#		nisp-server-address
+#			requests a list of NIS+ server addresses.
+#		nisp-domain-name
+#			requests a NIS+ domain name.
+#		bcmcs-server-address
+#			requests a list of BCMCS server addresses.
+#		bcmcs-domain-name
+#			requests a BCMCS domain name.
+#		refreshtime
+#			means an information refresh time option. This
+#			can only be specified when sent with information
+#			request messages; dhcp6c will ignore this option
+#			for other messages.
+#			Multiple request statements can also be specified, in
+#			which case all the specified options will be requested.
+#     information-only;
+#  			This statement specifies dhcp6c to only exchange informa-
+#			tional configuration parameters with servers. A list of
+#			DNS server addresses is an example of such parameters.
+#			This statement is useful when the client does not need
+#			stateful configuration parameters such as IPv6 addresses
+#			or prefixes.
+#     script "script-name";
+#			This statement specifies a path to script invoked by
+#			dhcp6c on a certain condition including when the daemon
+#			receives a reply message. script-name must be the absolute
+#			path from root to the script file, be a regular
+#			file, and be created by the same owner who runs the daemon.
+#
+# Identity association statement
+#  Identity association (IA) is a key notion of DHCPv6. An IA is uniquely
+#  identified in a client by a pair of IA type and IA identifier (IAID). An
+#  IA is associated with configuration information dependent on the IA type.
+#  An identity association statement defines a single IA with some client-
+#  side configuration parameters. Its format is as follows:
+#
+#  id-assoc type [ID] { substatements };
+#		type is a string for the type of this IA. The current implemen-
+#		tation supports <oq>na<cq> (non-temporary address allocation) <oq>pd<cq>
+#		(prefix delegation) for the IA type. ID is a decimal number of
+#		IAID. If omitted, the value 0 will be used by default.
+#		substatements is a sequence of statements that specifies configu-
+#		ration parameters for this IA. Each statement may or may not be
+#		specific to the type of IA.
+#
+#	The followings are possible substatements for an IA of type na.
+#     address ipv6-address pltime [vltime];
+#			specifies an address and related parameters that the
+#			client wants to be allocated. Multiple addresses can be
+#			specified, each of which is described as a separate
+#			address substatement. dhcp6c will include all the
+#			addresses (and related parameters) in Solicit messages,
+#			as an IA_NA prefix option encapsulated in the correspond-
+#			ing IA_NA option. Note, however, that the server may or
+#			may not respect the specified prefix parameters.
+#	The followings are possible substatements for an IA of type pd.
+#     prefix_interface_statement
+#			specifies the client's local configuration of how dele-
+#			gated prefixes should be used (see below).
+#     prefix ipv6-prefix pltime [vltime];
+#			specifies a prefix and related parameters that the client
+#			wants to be delegated. Multiple prefixes can be speci-
+#			fied, each of which is described as a separate prefix
+#			substatement. dhcp6c will include all the prefixes (and
+#			related parameters) in Solicit messages, as an IA_PD pre-
+#			fix option encapsulated in the corresponding IA_PD
+#			option. Note, however, that the server may or may not
+#			respect the specified prefix parameters.
+#
+# Prefix interface statement
+#  A prefix interface statement specifies configuration parameters of pre-
+#  fixes on local interfaces that are derived from delegated prefixes. A
+#  prefix interface statement can only appear as a substatement of an iden-
+#  tity association statement with the type pd. The generic format of an
+#  interface statement is as follows:
+#
+#  prefix-interface interface { substatements };
+#		When an IPv6 prefix is delegated from a DHCPv6 server, dhcp6c
+#		will assign a prefix on the interface unless the interface
+#		receives the DHCPv6 message that contains the prefix with the
+#		delegated prefix and the parameters provided in substatements.
+#		Possible substatements are as follows:
+#     sla-id ID ;
+#			This statement specifies the identifier value of the
+#			site-level aggregator (SLA) on the interface.
+#     sla-len length ;
+#			This statement specifies the length of the SLA ID in
+#			bits. length must be a decimal number between 0 and 128.
+#			If the length is not specified by this statement, the
+#			default value 16 will be used.
+#
+# Authentication statement
+#  An authentication statement defines a set of authentication parameters
+#  used in DHCPv6 exchanges with the server(s). The format of an authenti-
+#  cation statement is as follows:
+#
+#  authentication authname { substatements };
+#		authname is a string which is unique among all authentication
+#		statements in the configuration file. It will specify a particu-
+#		lar set of authentication parameters when authentication option
+#		is specified in the interface statement. Possible substatements
+#		of the authentication statement are as follows:
+#     protocol authprotocol ;
+#			specifies the authentication protocol. Currently, the
+#			only available protocol as authprotocol is delayed, which
+#			means the DHCPv6 delayed authentication protocol.
+#     algorithm authalgorithm ;
+#			specifies the algorithm for this authentication. Cur-
+#			rently, the only available algorithm is HMAC-MD5, which
+#			can be specified as one of the followings: hmac-md5,
+#			HMAC-MD5, hmacmd5, or HMACMD5. This substatement can be
+#			omitted. In this case, HMAC-MD5 will be used as the
+#			algorithm.
+#     rdm replay-detection-method ;
+#			specifies the replay protection method for this authenti-
+#			cation. Currently, the only available method is
+#			monocounter, which means the use of a monotonically
+#			increasing counter. If this method is specified, dhcp6c
+#			will use an NTP-format timestamp when it authenticates
+#			the message. This substatement can be omitted, in which
+#			case monocounter will be used as the method.
+#
+# Keyinfo statement
+#  A keyinfo statement defines a secret key shared with the server(s) to
+#  authenticate DHCPv6 messages. The format of a keyinfo statement is as
+#  follows:
+#
+#  keyinfo keyname { substatements };
+#		keyname is an arbitrary string. It does not affect client's
+#		behavior but is provided for readability of log messages. Possi-
+#		ble substatements of the keyinfo statement are as follows:
+#     realm "realmname" ;
+#			specifies the DHCP realm. realmname is an arbitrary
+#			string, but is typically expected to be a domain name
+#			like "kame.net" .
+#     keyid ID ;
+#			specifies the key identifier, ID, as a decimal number. A
+#			secret key is uniquely identified within the client by
+#			the DHCP realm and the key identifier.
+#     secret "secret-value" ;
+#			specifies the shared secret of this key. "secret-value"
+#			is a base-64 encoded string of the secret.
+#     expire "expiration-time" ;
+#			specifies the expiration time of this key.
+#			"expiration-time" should be formatted in one of the fol-
+#			lowings: yyyy-mm-dd HH:MM, mm-dd HH:MM, or HH:MM, where
+#			yyyy is the year with century (e.g., 2004), mm is the
+#			month, dd is the day of the month, HH is the hour of
+#			24-hour clock, and MM is the minute, each of which is
+#			given as a decimal number. Additionally, a special key-
+#			word forever can be specified as expiration-time, which
+#			means the key has an infinite lifetime and never expires.
+#			This substatement can be omitted, in which case forever
+#			will be used by default.
+
+
+interface ppp0 {
+  send ia-pd 0;
+};
+id-assoc pd {
+  prefix-interface ne0 {
+   sla-id 1;
+  };
+};
diff -urNBp a/include/applets.src.h b/include/applets.src.h
--- a/include/applets.src.h	2010-07-25 22:48:26.000000000 +0400
+++ b/include/applets.src.h	2011-10-31 16:08:11.000000000 +0300
@@ -117,6 +117,7 @@ IF_DELUSER(APPLET(deluser, BB_DIR_BIN, B
 IF_DEVFSD(APPLET(devfsd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DEVMEM(APPLET(devmem, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DF(APPLET(df, BB_DIR_BIN, BB_SUID_DROP))
+IF_DHCP6C(APPLET(dhcp6c, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DHCPRELAY(APPLET(dhcprelay, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DIFF(APPLET(diff, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DIRNAME(APPLET_NOFORK(dirname, dirname, BB_DIR_USR_BIN, BB_SUID_DROP, dirname))
diff -urNBp a/libbb/Kbuild.src b/libbb/Kbuild.src
--- a/libbb/Kbuild.src	2011-10-31 03:00:00.000000000 +0300
+++ b/libbb/Kbuild.src	2011-10-19 19:47:42.000000000 +0400
@@ -134,6 +134,7 @@ lib-$(CONFIG_TFTPD) += udp_io.o
 lib-$(CONFIG_TCPSVD) += udp_io.o
 lib-$(CONFIG_UDPSVD) += udp_io.o
 lib-$(CONFIG_TRACEROUTE) += udp_io.o
+lib-$(CONFIG_DHCP6C) += udp_io.o
 
 lib-$(CONFIG_LOSETUP) += loop.o
 lib-$(CONFIG_FEATURE_MOUNT_LOOP) += loop.o
diff -urNBp a/networking/udhcp/auth6.c b/networking/udhcp/auth6.c
--- a/networking/udhcp/auth6.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/auth6.c	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,234 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (C) 2000, 2001  Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
+ * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "common.h"
+#include "dhcp6.h"
+#include "auth6.h"
+
+#define HMACMD5_KEYLENGTH	64
+#define MD5_DIGESTLENGTH	16
+
+typedef struct {
+	md5_ctx_t md5ctx;
+	unsigned char key[HMACMD5_KEYLENGTH];
+} hmacmd5_t;
+
+
+static void hmacmd5_init(hmacmd5_t *, const unsigned char *, unsigned int);
+static void hmacmd5_sign(hmacmd5_t *, unsigned char *);
+static int hmacmd5_verify(hmacmd5_t *, unsigned char *);
+
+
+int dhcp6_validate_key(struct keyinfo *key)
+{
+	time_t now;
+
+	if (key->expire == 0)	/* never expire */
+		return 0;
+
+	time(&now);
+	if (now > key->expire)
+		return -1;
+
+	return 0;
+}
+
+int dhcp6_calc_mac(char *buf, size_t len, int proto UNUSED_PARAM,
+		int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return -1;
+
+	if (off + MD5_DIGESTLENGTH > len) {
+		/*
+		 * this should be assured by the caller, but check it here
+		 * for safety.
+		 */
+		return -2;
+	}
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	md5_hash(&ctx.md5ctx, buf, len);
+	hmacmd5_sign(&ctx, digest);
+
+	memcpy(buf + off, digest, MD5_DIGESTLENGTH);
+
+	return 0;
+}
+
+int dhcp6_verify_mac(char *buf, ssize_t len, int proto UNUSED_PARAM,
+		 int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+	int result;
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return -1;
+
+	if (off + MD5_DIGESTLENGTH > len)
+		return -1;
+
+	/*
+	 * Copy the MAC value and clear the field.
+	 * XXX: should we make a local working copy?
+	 */
+	memcpy(digest, buf + off, sizeof(digest));
+	memset(buf + off, 0, sizeof(digest));
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	md5_hash(&ctx.md5ctx, buf, len);
+	result = hmacmd5_verify(&ctx, digest);
+
+	/* copy back the digest value (XXX) */
+	memcpy(buf + off, digest, sizeof(digest));
+
+	return result;
+}
+
+int dhcp6_auth_replaycheck(int method, uint64_t prev, uint64_t current)
+{
+
+	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection method (%d)", method);
+		return -1;
+	}
+
+	log1("previous: %llx, current: %llx", SWAP_BE64(prev), SWAP_BE64(current));
+
+	prev = SWAP_BE64(prev);
+	current = SWAP_BE64(current);
+
+	/*
+	 * we call the singular point guilty, since we cannot guess
+	 * whether the serial number is increasing or not.
+	 */
+	if (prev == (current ^ 0x8000000000000000ULL)) {
+		bb_info_msg("detected a singular point");
+		return 1;
+	}
+
+	return (((int64_t )(current - prev) > 0) ? 0 : 1);
+}
+
+
+/*
+ * This code implements the HMAC-MD5 keyed hash algorithm
+ * described in RFC 2104.
+ */
+
+#define PADLEN 64
+#define IPAD   0x36
+#define OPAD   0x5C
+
+/*
+ * Start HMAC-MD5 process.  Initialize an md5 context and digest the key.
+ */
+static void hmacmd5_init(hmacmd5_t *ctx,
+				 const unsigned char *key, unsigned int len)
+{
+	unsigned char ipad[PADLEN];
+	int i;
+
+	memset(ctx->key, 0, sizeof(ctx->key));
+	if (len > sizeof(ctx->key)) {
+		md5_ctx_t md5ctx;
+
+		md5_begin(&md5ctx);
+		md5_hash(&md5ctx, key, len);
+		md5_end(&md5ctx, ctx->key);
+	} else {
+		memcpy(ctx->key, key, len);
+	}
+
+	md5_begin(&ctx->md5ctx);
+	memset(ipad, IPAD, sizeof(ipad));
+	for (i = 0; i < PADLEN; i++) {
+		ipad[i] ^= ctx->key[i];
+	}
+
+	md5_hash(&ctx->md5ctx, ipad, sizeof(ipad));
+}
+
+/*
+ * Compute signature - finalize MD5 operation and reapply MD5.
+ */
+static void hmacmd5_sign(hmacmd5_t *ctx, unsigned char *digest)
+{
+	unsigned char opad[PADLEN];
+	int i;
+
+	md5_end(&ctx->md5ctx, digest);
+
+	memset(opad, OPAD, sizeof(opad));
+	for (i = 0; i < PADLEN; i++) {
+		opad[i] ^= ctx->key[i];
+	}
+
+	md5_begin(&ctx->md5ctx);
+	md5_hash(&ctx->md5ctx, opad, sizeof(opad));
+	md5_hash(&ctx->md5ctx, digest, MD5_DIGESTLENGTH);
+	md5_end(&ctx->md5ctx, digest);
+	memset(ctx, 0, sizeof(*ctx));
+}
+
+/*
+ * Verify signature - finalize MD5 operation and reapply MD5, then
+ * compare to the supplied digest.
+ */
+static int hmacmd5_verify(hmacmd5_t *ctx, unsigned char *digest) {
+	unsigned char newdigest[MD5_DIGESTLENGTH];
+
+	hmacmd5_sign(ctx, newdigest);
+	return memcmp(digest, newdigest, MD5_DIGESTLENGTH);
+}
diff -urNBp a/networking/udhcp/auth6.h b/networking/udhcp/auth6.h
--- a/networking/udhcp/auth6.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/auth6.h	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,51 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+/* secret key information for delayed authentication */
+struct keyinfo {
+	struct keyinfo *next;
+
+	char *name;				/* key name */
+
+	struct dhcp6_vbuf realm;/* DHCP realm */
+	uint32_t keyid;			/* key ID */
+	unsigned char *secret;	/* binary key */
+	size_t secretlen;		/* length of the key */
+	time_t expire;			/* expiration time (0 means forever) */
+};
+
+int dhcp6_validate_key(struct keyinfo *);
+int dhcp6_calc_mac(char *, size_t, int, int, size_t, struct keyinfo *);
+int dhcp6_verify_mac(char *, ssize_t, int, int, size_t, struct keyinfo *);
+int dhcp6_auth_replaycheck(int, uint64_t, uint64_t);
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urNBp a/networking/udhcp/common6.c b/networking/udhcp/common6.c
--- a/networking/udhcp/common6.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/common6.c	2011-10-31 16:08:11.000000000 +0300
@@ -0,0 +1,1772 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <limits.h>
+#include <netdb.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "timer.h"
+
+/* dhcp6c.c */
+extern struct dhcp6_timer *client6_timo(void *);
+extern void destruct_iadata(struct dhcp6_eventdata *evd);
+
+
+static int copyin_option(int, struct dhcp6opt *, struct dhcp6opt *,
+    struct dhcp6_list *);
+static int copy_option(uint16_t, uint16_t, void *, struct dhcp6opt **,
+    struct dhcp6opt *, int *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int copyout_auth(struct dhcp6_optinfo *optinfo,
+		struct dhcp6opt **pp, struct dhcp6opt *bp, struct dhcp6opt *ep,
+		int *totallenp);
+# if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *);
+# endif
+#endif
+
+const struct dhcp6_option_typelen_t dhcp6_option_typelens[DH6OPT__MAX+1] = {
+	[DH6OPT_CLIENTID]       = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_SERVERID]       = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_IA_NA]          = { DHCP6_LISTVAL_IA, sizeof(struct dhcp6opt_ia)-4 },
+//	[DH6OPT_IA_TA]          = { 0, 0 },
+	[DH6OPT_IAADDR]         = { DHCP6_LISTVAL_STATEFULADDR6, sizeof(struct dhcp6opt_ia_addr)-4 },
+	[DH6OPT_ORO]            = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[DH6OPT_PREFERENCE]     = { DHCP6_LISTVAL_NUM8, 1                          },
+	[DH6OPT_ELAPSED_TIME]   = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[DH6OPT_RELAY_MSG]      = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_AUTH]           = { 0, sizeof(struct dhcp6opt_auth)-4              },
+//	[DH6OPT_UNICAST]		= { 0, 0 },
+	[DH6OPT_STATUS_CODE]    = { DHCP6_LISTVAL_NUM16, sizeof(uint16_t)          },
+	[DH6OPT_RAPID_COMMIT]   = { DHCP6_LISTVAL_NUM8, 0                          },
+//	[DH6OPT_USER_CLASS]     = { 0, 0 },
+//	[DH6OPT_VENDOR_CLASS]   = { 0, 0 },
+//	[DH6OPT_VENDOR_OPTS]    = { 0, 0 },
+	[DH6OPT_INTERFACE_ID]   = { DHCP6_LISTVAL_VBUF, 1                          },
+//	[DH6OPT_RECONF_MSG]     = { 0, 0 },
+	[DH6OPT_SIP_SERVER_D]   = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_SIP_SERVER_A]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[DH6OPT_DNS]            = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[DH6OPT_DNSNAME]        = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_IA_PD]          = { DHCP6_LISTVAL_IA, sizeof(struct dhcp6opt_ia)-4 },
+	[DH6OPT_IA_PD_PREFIX]   = { DHCP6_LISTVAL_PREFIX6, sizeof(struct dhcp6opt_ia_pd_prefix)-4 },
+	[DH6OPT_NIS_SERVERS]    = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr) },
+	[DH6OPT_NISP_SERVERS]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr) },
+	[DH6OPT_NIS_DOMAIN]     = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_NISP_DOMAIN]    = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_SNTP_SERVERS]   = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+	[DH6OPT_REFRESHTIME]    = { DHCP6_LISTVAL_NUM,	sizeof(uint32_t)           },
+	[DH6OPT_BCMCS_SERVER_D] = { DHCP6_LISTVAL_VBUF, 1                          },
+	[DH6OPT_BCMCS_SERVER_A] = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+//	[DH6OPT_GEOCONF_CIVIC]  = { 0, 0 },
+//	[DH6OPT_REMOTE_ID]      = { 0, 0 },
+//	[DH6OPT_SUBSCRIBER_ID]  = { 0, 0 },
+//	[DH6OPT_CLIENT_FQDN]    = { 0, 0 },
+	[DH6OPT_NTP_SERVER]     = { DHCP6_LISTVAL_ADDR6, sizeof(struct in6_addr)   },
+};
+
+int dhcp6_copy_list(struct dhcp6_list *dst, const struct dhcp6_list *src)
+{
+	struct dhcp6_listval *ent;
+
+	TAILQ_FOREACH(ent, src, link) {
+		if (dhcp6_add_listval(dst, ent->dh6optype, ent->lvtype,
+		    &ent->uv, &ent->sublist) == NULL)
+			return -1;
+	}
+
+	return 0;
+}
+
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *lv;
+
+	while ((lv = TAILQ_FIRST(src)) != NULL) {
+		TAILQ_REMOVE(src, lv, link);
+		TAILQ_INSERT_TAIL(dst, lv, link);
+	}
+}
+
+void dhcp6_clear_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *lv;
+
+	while ((lv = TAILQ_FIRST(head)) != NULL) {
+		TAILQ_REMOVE(head, lv, link);
+		dhcp6_clear_listval(lv);
+	}
+}
+
+void dhcp6_clear_listval(struct dhcp6_listval *lv)
+{
+	dhcp6_clear_list(&lv->sublist);
+	switch (lv->lvtype) {
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_free(&lv->val_vbuf);
+		break;
+	default:		/* nothing to do */
+		break;
+	}
+	free(lv);
+}
+
+/*
+ * Note: this function only searches for the first entry that matches
+ * VAL.  It also does not care about sublists.
+ */
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+		int type, const void *val, int option)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, head, link) {
+		if (option & MATCHLIST_DH6OPTYPE) {
+			if (lv->dh6optype != type)
+				continue;
+		} else {
+			if (lv->lvtype != type)
+				continue;
+		}
+
+		switch (lv->lvtype) {
+		case DHCP6_LISTVAL_NUM:
+			if (lv->val_num == *(int32_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_NUM16:
+			if (lv->val_num16 == *(uint16_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_NUM8:
+			if (lv->val_num8 == *(uint8_t *)val)
+				return lv;
+			break;
+		case DHCP6_LISTVAL_ADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_addr6, (struct in6_addr *)val)) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_PREFIX6:
+			if ((option & MATCHLIST_PREFIXLEN) &&
+			    lv->val_prefix6.plen == ((struct dhcp6_prefix *)val)->plen) {
+				return lv;
+			} else if (IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr,
+			    &((struct dhcp6_prefix *)val)->addr) &&
+			    lv->val_prefix6.plen == ((struct dhcp6_prefix *)val)->plen) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
+			    &((struct dhcp6_prefix *)val)->addr)) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_IA:
+			if (lv->val_ia.iaid == ((struct dhcp6_ia *)val)->iaid) {
+				return lv;
+			}
+			break;
+		case DHCP6_LISTVAL_VBUF:
+			if (dhcp6_vbuf_cmp(&lv->val_vbuf, (struct dhcp6_vbuf *)val) == 0) {
+				return lv;
+			}
+			break;
+		}
+	}
+
+	return NULL;
+}
+
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+		int dh6optype, dhcp6_listval_type_t lvtype,
+		const void *val, struct dhcp6_list *sublist)
+{
+	struct dhcp6_listval *lv;
+
+	lv = xzalloc(sizeof(*lv));
+	lv->dh6optype = dh6optype;
+	lv->lvtype = lvtype;
+	TAILQ_INIT(&lv->sublist);
+
+	switch (lvtype) {
+	case DHCP6_LISTVAL_NUM:
+		lv->val_num = *(int *)val;
+		break;
+	case DHCP6_LISTVAL_NUM16:
+		lv->val_num16 = *(uint16_t *)val;
+		break;
+	case DHCP6_LISTVAL_NUM8:
+		lv->val_num8 = *(uint8_t *)val;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		lv->val_addr6 = *(struct in6_addr *)val;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		lv->val_prefix6 = *(struct dhcp6_prefix *)val;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		lv->val_statefuladdr6 = *(struct dhcp6_statefuladdr *)val;
+		break;
+	case DHCP6_LISTVAL_IA:
+		lv->val_ia = *(struct dhcp6_ia *)val;
+		break;
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_copy(&lv->val_vbuf, (struct dhcp6_vbuf *)val);
+		break;
+	default:
+		bb_error_msg("option '%s': unexpected list value type (%d)",
+				dhcp6optstr(dh6optype), lvtype);
+		free(lv);
+		return NULL;
+	}
+
+	if (sublist)
+		dhcp6_copy_list(&lv->sublist, sublist);
+
+	TAILQ_INSERT_TAIL(head, lv, link);
+	return lv;
+}
+
+void dhcp6_vbuf_copy(struct dhcp6_vbuf *dst, struct dhcp6_vbuf *src)
+{
+	dst->dv_len = src->dv_len;
+	if (dst->dv_len == 0)
+		return;
+
+	dst->dv_buf = xmalloc(dst->dv_len);
+	memcpy(dst->dv_buf, src->dv_buf, dst->dv_len);
+}
+
+void dhcp6_vbuf_free(struct dhcp6_vbuf *vbuf)
+{
+	free(vbuf->dv_buf);
+
+	vbuf->dv_len = 0;
+	vbuf->dv_buf = NULL;
+}
+
+/* Domain names stored in RFC1035 format */
+#if ENABLE_FEATURE_UDHCP_RFC3397
+static int dhcp6_get_domain(int optlen, void *cp, int dh6optype,
+			    struct dhcp6_list *list)
+{
+	char *names, *p, *n;
+
+	names = dname_dec(cp, optlen, "");
+	if (names == NULL) {
+		bb_info_msg("can't decode %s", dhcp6optstr(dh6optype));
+		return -1;
+	}
+
+	log2("  domains: '%s'", names);
+
+	p = names;
+	while (*p) {
+		struct dhcp6_vbuf vb;
+
+		n = strchrnul(p, ' ');
+		vb.dv_buf = p;
+		vb.dv_len = n - p + 1;
+		if (*n)
+			*(n++) = '\0';
+
+		if (dhcp6_add_listval(list, dh6optype, DHCP6_LISTVAL_VBUF,
+				&vb, NULL) == NULL) {
+			free(names);
+			return -2;
+		}
+		p = n;
+	}
+	free(names);
+
+	return 0;
+}
+#endif /* FEATURE_UDHCP_RFC3397 */
+
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *ifp, int state)
+{
+	struct dhcp6_event *ev;
+
+	ev = xzalloc(sizeof(*ev));
+	ev->ifp = ifp;
+	ev->state = state;
+	TAILQ_INIT(&ev->data_list);
+
+	TAILQ_INSERT_TAIL(&client6_config.event_list, ev, link);
+
+	ev->timer = dhcp6_timer_add(client6_timo, ev);
+
+	return ev;
+}
+
+void dhcp6_remove_event(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *sp, *sp_next;
+
+	log1("removing an event on %s, state=%s",
+	    ev->ifp->ifname, dhcp6_event_statestr(ev));
+
+	if (ev->timer)
+		dhcp6_timer_remove(&ev->timer);
+
+	dhcp6_remove_evdata(ev);
+	dhcp6_vbuf_free(&ev->serverid);
+	TAILQ_REMOVE(&client6_config.event_list, ev, link);
+
+	sp = ev->servers;
+	while (sp) {
+		sp_next = sp->next;
+
+		log1("removing server (ID: %s)", duidstr(&sp->optinfo.serverID));
+		dhcp6_clear_options(&sp->optinfo);
+		free(sp->authparam);
+		free(sp);
+		sp = sp_next;
+	}
+
+	free(ev->authparam);
+
+	free(ev);
+}
+
+void dhcp6_remove_evdata(struct dhcp6_event *ev)
+{
+	struct dhcp6_eventdata *evd;
+
+	while ((evd = TAILQ_FIRST(&ev->data_list)) != NULL) {
+		TAILQ_REMOVE(&ev->data_list, evd, link);
+		destruct_iadata(evd);
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct authparam *new_authparam(int proto, int alg, int rdm)
+{
+	struct authparam *authparam;
+
+	authparam = xzalloc(sizeof(*authparam));
+
+	authparam->authproto = proto;
+	authparam->authalgorithm = alg;
+	authparam->authrdm = rdm;
+	authparam->key = NULL;
+	authparam->flags |= AUTHPARAM_FLAGS_NOPREVRD;
+	authparam->prevrd = 0;
+
+	return authparam;
+}
+
+static int copyout_auth(struct dhcp6_optinfo *optinfo,
+		struct dhcp6opt **pp, struct dhcp6opt *bp, struct dhcp6opt *ep,
+		int *totallenp)
+{
+	struct dhcp6opt_auth *auth;
+	int authlen;
+
+	authlen = sizeof(struct dhcp6opt_auth);
+	if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+		switch (optinfo->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			/* Realm + key ID + HMAC-MD5 */
+			authlen += optinfo->delayedauth_realmlen +
+			    sizeof(optinfo->delayedauth_keyid) + 16;
+			break;
+#ifdef notyet
+		case DHCP6_AUTHPROTO_RECONFIG:
+			/* type + key-or-HAMC */
+			authlen += 17;
+			break;
+#endif
+		default:
+			bb_error_msg("unsupported authentication protocol: %d",
+				    optinfo->authproto);
+			goto fail;
+		}
+	}
+
+	if (ep - (*pp) < authlen)
+		return -1;
+
+	/* copy_option will take care of type and len later */
+	auth = (struct dhcp6opt_auth *)(*pp);
+	auth->dh6_proto = (uint8_t)optinfo->authproto;
+	auth->dh6_alg = (uint8_t)optinfo->authalgorithm;
+	auth->dh6_rdm = (uint8_t)optinfo->authrdm;
+	memcpy(auth->dh6_rdinfo, &optinfo->authrd, sizeof(auth->dh6_rdinfo));
+
+	if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+		char *authinfo;
+
+		switch (optinfo->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			authinfo = (char *)(auth + 1);
+
+			/* copy realm */
+			memcpy(authinfo, optinfo->delayedauth_realmval,
+			    optinfo->delayedauth_realmlen);
+			authinfo += optinfo->delayedauth_realmlen;
+
+			/* copy key ID (unaligned!) */
+			move_to_unaligned32(authinfo, htonl(optinfo->delayedauth_keyid));
+
+			/*
+			 * Set the offset so that the caller can
+			 * calculate the HMAC.
+			 */
+			optinfo->delayedauth_offset = ((char *)(*pp) - (char *)bp)
+										+ authlen - 16;
+
+			log1("key ID %x, offset %d", optinfo->delayedauth_keyid,
+			    optinfo->delayedauth_offset);
+			break;
+#ifdef notyet
+		case DHCP6_AUTHPROTO_RECONFIG:
+#endif
+		default:
+			bb_error_msg("unsupported authentication protocol: %d",
+				    optinfo->authproto);
+			free(auth);
+			goto fail;
+		}
+	}
+
+	if (copy_option(DH6OPT_AUTH, authlen - 4, NULL, pp, ep, totallenp) != 0) {
+		goto fail;
+	}
+	return 0;
+
+ fail:
+	return -1;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static int sa6_plen2mask(struct sockaddr_in6 *sa6, int plen)
+{
+	uint8_t *cp;
+
+	if (plen < 0 || plen > 128)
+		return -1;
+
+	memset(sa6, 0, sizeof(*sa6));
+	sa6->sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sa6->sin6_len = sizeof(*sa6);
+#endif
+
+	for (cp = (uint8_t *)&sa6->sin6_addr; plen > 7; plen -= 8)
+		*cp++ = 0xff;
+	*cp = 0xff << (8 - plen);
+
+	return 0;
+}
+
+int prefix6_mask(struct in6_addr *in6, int plen)
+{
+	struct sockaddr_in6 mask6;
+	int i;
+
+	if (sa6_plen2mask(&mask6, plen))
+		return -1;
+
+	for (i = 0; i < 16; i++)
+		in6->s6_addr[i] &= mask6.sin6_addr.s6_addr[i];
+
+	return 0;
+}
+
+int get_duid(const char *idfile, struct dhcp6_vbuf *duid, int duid_type)
+{
+	int fd;
+	uint16_t len = 0, hwtype;
+
+	fd = open(idfile, O_RDONLY);
+	if (fd < 0 && errno != ENOENT)
+		bb_info_msg("can't open DUID file: %s", idfile);
+
+	if (fd > 0) {
+		/* decode length */
+		if (safe_read(fd, &len, sizeof(len)) != sizeof(len)) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+		duid->dv_len = len;
+		duid->dv_buf = xmalloc(len);
+
+		if (safe_read(fd, duid->dv_buf, len) != len) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+
+		log1("extracted an existing DUID from %s: %s",
+		    idfile, duidstr(duid));
+	} else {
+		int hwlen;
+		struct iovec iov[2];
+		union dhcp6opt_duid_type *dp;
+		char tmpbuf[64];	/* HWID should be no more than 64 bytes */
+
+		hwlen = gethwid(tmpbuf, &hwtype);
+		if (hwlen < 0) {
+			bb_error_msg("can't get hardware address");
+			goto fail;
+		}
+		duid->dv_buf = xmalloc(hwlen + sizeof(union dhcp6opt_duid_type));
+
+		dp = (union dhcp6opt_duid_type *)duid->dv_buf;
+
+		/* we only support the types 1,3 DUID */
+		switch (duid_type) {
+			case 1: {
+				uint64_t t64;
+
+				len = sizeof(struct dhcp6opt_duid_type1);
+				dp->d1.hwtype = htons(hwtype);
+				/* time is Jan 1, 2000 (UTC), modulo 2^32 */
+				t64 = (uint64_t)(time(NULL) - 946684800);
+				dp->d1.time = htonl((uint32_t )t64);
+				break;
+				}
+			case 3:
+				len = sizeof(struct dhcp6opt_duid_type3);
+				dp->d3.hwtype = htons(hwtype);
+				break;
+		}
+		dp->type = htons(duid_type);
+		memcpy((char *)dp + len, tmpbuf, hwlen);
+		len += hwlen;
+		duid->dv_len = len;
+
+		log1("generated a new DUID: %s", duidstr(duid));
+
+		/* save the (new) ID to the file for next time */
+		fd = open(idfile, O_WRONLY);
+		if (fd < 0) {
+			/* Not fatal */
+			return 0;
+		}
+		iov[0].iov_base = &len;
+		iov[0].iov_len  = sizeof(len);
+		iov[1].iov_base = duid->dv_buf;
+		iov[1].iov_len  = duid->dv_len;
+		if (writev(fd, iov, 2) < 0) {
+			bb_error_msg("can't write DUID file");
+			goto fail;
+		}
+	}
+	if (fd > 0)
+		close(fd);
+	return 0;
+
+  fail:
+	if (fd > 0)
+		close(fd);
+	dhcp6_vbuf_free(duid);
+	return -1;
+}
+
+void dhcp6_init_options(struct dhcp6_optinfo *optinfo)
+{
+	memset(optinfo, 0, sizeof(*optinfo));
+
+	optinfo->pref = DH6OPT_PREF_UNDEF;
+	optinfo->elapsed_time = DH6OPT_ELAPSED_TIME_UNDEF;
+	optinfo->refreshtime = DH6OPT_REFRESHTIME_UNDEF;
+
+	TAILQ_INIT(&optinfo->ia_list);
+	TAILQ_INIT(&optinfo->reqopt_list);
+	TAILQ_INIT(&optinfo->stcode_list);
+	TAILQ_INIT(&optinfo->ad_list);
+
+	optinfo->authproto = DHCP6_AUTHPROTO_UNDEF;
+	optinfo->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	optinfo->authrdm = DHCP6_AUTHRDM_UNDEF;
+}
+
+void dhcp6_clear_options(struct dhcp6_optinfo *optinfo)
+{
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dhcp6_vbuf_free(&optinfo->authinfo.aiu_delayed.realm);
+		break;
+	}
+
+	dhcp6_vbuf_free(&optinfo->clientID);
+	dhcp6_vbuf_free(&optinfo->serverID);
+
+	dhcp6_clear_list(&optinfo->ia_list);
+	dhcp6_clear_list(&optinfo->reqopt_list);
+	dhcp6_clear_list(&optinfo->stcode_list);
+	dhcp6_clear_list(&optinfo->ad_list);
+
+	dhcp6_vbuf_free(&optinfo->relay_msg);
+	dhcp6_vbuf_free(&optinfo->ifidopt);
+
+	dhcp6_init_options(optinfo);
+}
+
+void dhcp6_copy_options(struct dhcp6_optinfo *dst, struct dhcp6_optinfo *src)
+{
+	dhcp6_vbuf_copy(&dst->clientID, &src->clientID);
+	dhcp6_vbuf_copy(&dst->serverID, &src->serverID);
+
+	dhcp6_copy_list(&dst->ia_list, &src->ia_list);
+	dhcp6_copy_list(&dst->reqopt_list, &src->reqopt_list);
+	dhcp6_copy_list(&dst->stcode_list, &src->stcode_list);
+	dhcp6_copy_list(&dst->ad_list, &src->ad_list);
+
+	dst->rapidcommit = src->rapidcommit;
+	dst->elapsed_time = src->elapsed_time;
+	dst->refreshtime = src->refreshtime;
+	dst->pref = src->pref;
+
+	if (src->relaymsg_msg != NULL) {
+		dhcp6_vbuf_copy(&dst->relay_msg, &src->relay_msg);
+	}
+
+	if (src->ifidopt_id != NULL) {
+		dhcp6_vbuf_copy(&dst->ifidopt, &src->ifidopt);
+	}
+
+	dst->authflags = src->authflags;
+	dst->authproto = src->authproto;
+	dst->authalgorithm = src->authalgorithm;
+	dst->authrdm = src->authrdm;
+	dst->authrd = src->authrd;
+
+	switch (src->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dst->delayedauth_keyid = src->delayedauth_keyid;
+		dst->delayedauth_offset = src->delayedauth_offset;
+		dhcp6_vbuf_copy(&dst->authinfo.aiu_delayed.realm,
+				&src->authinfo.aiu_delayed.realm);
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		dst->reconfigauth_type = src->reconfigauth_type;
+		dst->reconfigauth_offset = src->reconfigauth_offset;
+		memcpy(dst->reconfigauth_val, src->reconfigauth_val,
+		    sizeof(dst->reconfigauth_val));
+		break;
+#endif
+	}
+}
+
+static int copy_option(uint16_t type, uint16_t len, void *val,
+		struct dhcp6opt **optp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6opt *opt = *optp, opth;
+
+	if ((char *)ep - (char *)opt < len + sizeof(struct dhcp6opt)) {
+		log1("option buffer short for %s", dhcp6optstr(type));
+		return -1;
+	}
+
+	opth.dh6opt_type = htons(type);
+	opth.dh6opt_len = htons(len);
+	memcpy(opt, &opth, sizeof(opth));
+	if (len != 0 && val)
+		memcpy(opt + 1, val, len);
+
+	(*optp) = (struct dhcp6opt *)((char *)(opt + 1) + len);
+	(*totallenp) += sizeof(struct dhcp6opt) + len;
+
+	log2("set %s (len %d)", dhcp6optstr(type), len);
+
+	return 0;
+}
+
+int dhcp6_get_options(struct dhcp6opt *p, struct dhcp6opt *ep,
+			struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *np;
+	int opt, optlen, tlen;
+	char *bp, *cp, *val;
+	union {
+		struct dhcp6opt h;
+		struct dhcp6opt_ia optia;
+	} u ALIGN4;
+	union {
+		uint16_t val16;
+		uint32_t val32;
+		struct dhcp6_ia ia;
+		struct dhcp6_vbuf duid0;
+		struct in6_addr valaddr;
+	} u1 ALIGN4;
+	struct dhcp6_list sublist;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	int authinfolen;
+#endif
+
+	TAILQ_INIT(&sublist);
+
+	bp = (char *)p;
+	for (; p + 1 <= ep; p = np) {
+		/*
+		 * get the option header.  XXX: since there is no guarantee
+		 * about the header alignment, we need to make a local copy.
+		 */
+		memcpy(&u.h, p, sizeof(struct dhcp6opt));
+		optlen = ntohs(u.h.dh6opt_len);
+		opt = ntohs(u.h.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP6 option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* option length field overrun */
+		if (opt > DH6OPT__MAX)
+			goto unexpected;
+		tlen = dhcp6_option_typelens[opt].minlen;
+		if (np > ep || optlen < tlen)
+			goto malformed;
+
+		switch (opt) {
+
+		case DH6OPT_CLIENTID:
+			u1.duid0.dv_len = optlen;
+			u1.duid0.dv_buf = cp;
+			log2("  DUID: %s", duidstr(&u1.duid0));
+			dhcp6_vbuf_copy(&optinfo->clientID, &u1.duid0);
+			break;
+
+		case DH6OPT_SERVERID:
+			u1.duid0.dv_len = optlen;
+			u1.duid0.dv_buf = cp;
+			log2("  DUID: %s", duidstr(&u1.duid0));
+			dhcp6_vbuf_copy(&optinfo->serverID, &u1.duid0);
+			break;
+
+		case DH6OPT_STATUS_CODE:
+			move_from_unaligned16(u1.val16, cp);
+			u1.val16 = ntohs(u1.val16);
+			log2("  status code: %s", dhcp6stcodestr(u1.val16));
+
+			/* need to check duplication? */
+			if (dhcp6_add_listval(&optinfo->stcode_list, opt,
+			    DHCP6_LISTVAL_NUM16, &u1, NULL) == NULL) {
+				goto fail;
+			}
+			break;
+
+		case DH6OPT_ORO:
+			if ((optlen & 0x1) != 0) /* must be multiple by sizeof(uint16_t) */
+				goto malformed;
+
+			for (val = cp; val < (char *)np; val += sizeof(uint16_t)) {
+
+				move_from_unaligned16(u1.val16, val);
+				u1.val16 = ntohs(u1.val16);
+				log2("  requested option: %s", dhcp6optstr(u1.val16));
+
+				if (dhcp6_find_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM16, &u1, 0)) {
+					bb_info_msg("duplicated %s", dhcp6optstr(u1.val16));
+					continue;
+				}
+
+				if (dhcp6_add_listval(&optinfo->reqopt_list, opt,
+				    DHCP6_LISTVAL_NUM16, &u1, NULL) == NULL) {
+					goto fail;
+				}
+			}
+			break;
+
+		case DH6OPT_PREFERENCE:
+			log2("  preference: %d", (int)*(uint8_t *)cp);
+			if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+				bb_info_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->pref = (int)*(uint8_t *)cp;
+			break;
+
+		case DH6OPT_ELAPSED_TIME:
+			move_from_unaligned16(u1.val16, cp);
+			u1.val16 = ntohs(u1.val16);
+
+			log2("  elapsed time: %u", (uint32_t)u1.val16);
+			if (optinfo->elapsed_time != DH6OPT_ELAPSED_TIME_UNDEF) {
+				bb_info_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->elapsed_time = u1.val16;
+			break;
+
+		case DH6OPT_RELAY_MSG:
+			optinfo->relaymsg_msg = xmalloc(optlen);
+			optinfo->relaymsg_len = optlen;
+			memcpy(optinfo->relaymsg_msg, cp, optlen);
+			break;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case DH6OPT_AUTH:
+			/*
+			 * Any DHCP message that includes more than one
+			 * authentication option MUST be discarded.
+			 * [RFC3315 Section 21.4.2]
+			 */
+			if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+				bb_info_msg("duplicated %s", dhcp6optstr(opt));
+				goto fail;
+			}
+
+			optinfo->authproto = *(uint8_t *)cp++;
+			optinfo->authalgorithm = *(uint8_t *)cp++;
+			optinfo->authrdm = *(uint8_t *)cp++;
+			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
+			cp += sizeof(optinfo->authrd);
+
+			log2("  %s", sprint_auth(optinfo));
+
+			authinfolen = optlen - tlen;
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				if (authinfolen == 0) {
+					optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+					break;
+				}
+				/* XXX: should we reject an empty realm? */
+				if (authinfolen < sizeof(optinfo->delayedauth_keyid) + 16) {
+					goto malformed;
+				}
+
+				optinfo->delayedauth_realmlen = authinfolen -
+				    (sizeof(optinfo->delayedauth_keyid) + 16);
+				optinfo->delayedauth_realmval =
+				    malloc_or_warn(optinfo->delayedauth_realmlen);
+				if (optinfo->delayedauth_realmval == NULL)
+					goto fail;
+				memcpy(optinfo->delayedauth_realmval, cp,
+				    optinfo->delayedauth_realmlen);
+				cp += optinfo->delayedauth_realmlen;
+
+				memcpy(&optinfo->delayedauth_keyid, cp,
+				    sizeof(optinfo->delayedauth_keyid));
+				optinfo->delayedauth_keyid = ntohl(optinfo->delayedauth_keyid);
+				cp += sizeof(optinfo->delayedauth_keyid);
+
+				optinfo->delayedauth_offset = cp - bp;
+				cp += 16;
+
+				log2("  auth key ID: %x, offset=%d, realmlen=%d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset,
+				    optinfo->delayedauth_realmlen);
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				break;
+#endif
+			default:
+				bb_info_msg("unsupported authentication protocol: %d", *cp);
+				goto fail;
+			}
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+		case DH6OPT_RAPID_COMMIT:
+			if (optlen != 0)
+				goto malformed;
+			optinfo->rapidcommit = 1;
+			break;
+
+		case DH6OPT_INTERFACE_ID:
+			optinfo->ifidopt_id = xmalloc(optlen);
+			optinfo->ifidopt_len = optlen;
+			memcpy(optinfo->ifidopt_id, cp, optlen);
+			break;
+
+		case DH6OPT_SIP_SERVER_D:
+		case DH6OPT_DNSNAME:
+		case DH6OPT_NIS_DOMAIN:
+		case DH6OPT_NISP_DOMAIN:
+		case DH6OPT_BCMCS_SERVER_D:
+#if ENABLE_FEATURE_UDHCP_RFC3397
+			if (dhcp6_get_domain(optlen, cp, opt, &optinfo->ad_list) == -1)
+				goto fail;
+#endif
+			break;
+
+		case DH6OPT_SIP_SERVER_A:
+		case DH6OPT_DNS:
+		case DH6OPT_NIS_SERVERS:
+		case DH6OPT_NISP_SERVERS:
+		case DH6OPT_BCMCS_SERVER_A:
+		case DH6OPT_SNTP_SERVERS:
+		case DH6OPT_NTP_SERVER:
+			if ((optlen % sizeof(struct in6_addr)) != 0)
+				goto malformed;
+			for (val = cp; val < (char *)np; val += sizeof(struct in6_addr)) {
+				char a[INET6_ADDRSTRLEN];
+
+				memcpy(&u1.valaddr, val, sizeof(struct in6_addr));
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+				sprint_nip6(a, (const uint8_t *)&u1.valaddr);
+				log2("  address: %s", a);
+#endif
+
+				if (dhcp6_find_listval(&optinfo->ad_list, opt, &u1.valaddr,
+					 MATCHLIST_DH6OPTYPE)) {
+					sprint_nip6(a, (const uint8_t *)&u1.valaddr);
+					bb_info_msg("duplicated %s address (%s)",
+								dhcp6optstr(opt), a);
+					continue;
+				}
+
+				if (dhcp6_add_listval(&optinfo->ad_list, opt, DHCP6_LISTVAL_ADDR6,
+					 &u1, NULL) == NULL) {
+					goto fail;
+				}
+			}
+			break;
+
+		case DH6OPT_IA_PD:
+		case DH6OPT_IA_NA:
+			memcpy(((char *)&u) + sizeof(struct dhcp6opt), cp, tlen);
+			u1.ia.iaid = ntohl(u.optia.dh6_iaid);
+			u1.ia.t1 = ntohl(u.optia.dh6_t1);
+			u1.ia.t2 = ntohl(u.optia.dh6_t2);
+
+			log2("  %s: ID=%u, T1=%u, T2=%u", dhcp6optstr(opt),
+				u1.ia.iaid, u1.ia.t1, u1.ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->ia_list,
+			    opt, &u1, MATCHLIST_DH6OPTYPE)) {
+				bb_info_msg("duplicated %s %u",	dhcp6optstr(opt), u1.ia.iaid);
+				break; /* ignore this IA */
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen),
+				 (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->ia_list, opt,
+			    DHCP6_LISTVAL_IA, &u1, &sublist) == NULL) {
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+
+		case DH6OPT_REFRESHTIME:
+			move_from_unaligned32(u1.val32, cp);
+			u1.val32 = ntohl(u1.val32);
+			log2("   information refresh time: %u", u1.val32);
+			if (u1.val32 < DHCP6_IRT_MINIMUM) {
+				/*
+				 * A client MUST use the refresh time
+				 * IRT_MINIMUM if it receives the option with a
+				 * value less than IRT_MINIMUM.
+				 * [draft-ietf-dhc-lifetime-02.txt,
+				 *  Section 3.2]
+				 */
+				bb_info_msg("refresh time is too small (%d), adjusted",	u1.val32);
+				u1.val32 = DHCP6_IRT_MINIMUM;
+			}
+			if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+				bb_info_msg("duplicated %s", dhcp6optstr(opt));
+			} else
+				optinfo->refreshtime = (int64_t)u1.val32;
+			break;
+
+		default:
+ unexpected:
+			/* no option specific behavior */
+			bb_info_msg("unexpected DHCP6 option %s, len %d",
+				dhcp6optstr(opt), optlen);
+			break;
+		}
+	}
+
+	return 0;
+
+ malformed:
+	bb_error_msg("malformed DHCP6 option: type %d, len %d", opt, optlen);
+ fail:
+	dhcp6_clear_list(&sublist);
+	dhcp6_clear_options(optinfo);
+	return -1;
+}
+
+static int copyin_option(int type, struct dhcp6opt *p, struct dhcp6opt *ep,
+			 struct dhcp6_list *list)
+{
+	int opt, optlen, tlen;
+	char *cp;
+	struct dhcp6opt *np;
+	union {
+		struct dhcp6opt h;
+		struct dhcp6opt_stcode stcode;
+		struct dhcp6opt_ia_pd_prefix prefix;
+		struct dhcp6opt_ia_addr addr;
+	} u ALIGN4;
+	union {
+		uint16_t dh6_stcode;
+		struct dhcp6_prefix ia_prefix;
+		struct dhcp6_statefuladdr ia_addr;
+	} u1 ALIGN4;
+	struct dhcp6_list sublist;
+	dhcp6_listval_type_t lvtype;
+	char a[INET6_ADDRSTRLEN];
+
+	TAILQ_INIT(&sublist);
+
+	for (; p + 1 <= ep; p = np) {
+		memcpy(&u.h, p, sizeof(struct dhcp6opt));
+		optlen = ntohs(u.h.dh6opt_len);
+		opt = ntohs(u.h.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP6 option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* check option context & length */
+		switch (opt) {
+		case DH6OPT_IA_PD_PREFIX:
+			if (type != DH6OPT_IA_PD) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			break;
+		case DH6OPT_IAADDR:
+			if (type != DH6OPT_IA_NA) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			break;
+		case DH6OPT_STATUS_CODE:
+			break;
+		default:
+			bb_info_msg("unexpected DHCP6 option %s, len %d",
+			    dhcp6optstr(opt), optlen);
+			goto nextoption;
+		} /* switch1(opt) */
+		lvtype = dhcp6_option_typelens[opt].lvtype;
+		tlen = dhcp6_option_typelens[opt].minlen;
+		if (np > ep || optlen < tlen) {
+				bb_error_msg("malformed DHCP6 option: type %d, len %d",
+					opt, optlen);
+				goto fail;
+		}
+		/* copy option main body (fixup unaligned access) */
+		memcpy(((char *)&u) + sizeof(struct dhcp6opt), cp, tlen);
+
+		switch (opt) {
+		case DH6OPT_IA_PD_PREFIX:
+			/* convert option values */
+			u1.ia_prefix.plen = u.prefix.dh6_prefix_len;
+			u1.ia_prefix.pltime = ntohl(u.prefix.dh6_preferred_time);
+			u1.ia_prefix.vltime = ntohl(u.prefix.dh6_valid_time);
+			memcpy(&u1.ia_prefix.addr, &u.prefix.dh6_prefix_addr, sizeof(u1.ia_prefix.addr));
+			if (u1.ia_prefix.plen < 4 || u1.ia_prefix.plen > 128) {
+				bb_info_msg("invalid prefix length: %d", u1.ia_prefix.plen);
+				goto fail;
+			}
+			/* clear padding bits in the prefix address */
+			prefix6_mask(&u1.ia_prefix.addr, u1.ia_prefix.plen);
+
+			sprint_nip6(a, (const uint8_t *)&u1.ia_prefix.addr);
+			log2("  IA_PD prefix: %s/%d pltime=%u vltime=%u", a,
+				u1.ia_prefix.plen, u1.ia_prefix.pltime, u1.ia_prefix.vltime);
+
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_info_msg("duplicated IA_PD %s/%d", a, u1.ia_prefix.plen );
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen), np,
+				 &sublist)) {
+				goto fail;
+			}
+			break;
+
+		case DH6OPT_IAADDR:
+			/* convert option values */
+			u1.ia_addr.pltime = ntohl(u.addr.dh6_preferred_time);
+			u1.ia_addr.vltime = ntohl(u.addr.dh6_valid_time);
+			memcpy(&u1.ia_addr.addr, &u.addr.dh6_addr, sizeof(u1.ia_addr.addr));
+
+			sprint_nip6(a, (const uint8_t *)&u1.ia_addr.addr);
+			log2("  IA_NA address: %s pltime=%u vltime=%u", a,
+				u1.ia_addr.pltime, u1.ia_addr.vltime);
+
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_info_msg("duplicated IA_NA %s", a);
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			if (copyin_option(opt, (struct dhcp6opt *)(cp + tlen), np,
+				 &sublist)) {
+				goto fail;
+			}
+			break;
+
+		case DH6OPT_STATUS_CODE:
+			/* convert option values */
+			u1.dh6_stcode = ntohs(u.stcode.dh6_stcode);
+
+			log2("  status code: %s", dhcp6stcodestr(u1.dh6_stcode));
+
+			/* duplication check */
+			if (dhcp6_find_listval(list, lvtype, &u1, 0)) {
+				bb_info_msg("duplicated status code (%d)", u1.dh6_stcode);
+				goto nextoption;
+			}
+			break;
+		} /* switch2(opt) */
+
+		/* copy-in option */
+		if (dhcp6_add_listval(list, opt, lvtype, &u1,
+			 (opt == DH6OPT_STATUS_CODE) ? NULL : &sublist) == NULL)
+			goto fail;
+		dhcp6_clear_list(&sublist);
+
+ nextoption:
+		;
+	} /* for(p) */
+
+	return 0;
+
+ fail:
+	dhcp6_clear_list(&sublist);
+	return -1;
+}
+
+/*
+ * Construct a DHCPv6 option along with sub-options in the wire format.
+ * If the packet buffer is NULL, just calculate the length of the option
+ * (and sub-options) so that the caller can allocate a buffer to store the
+ * option(s).
+ * This function basically assumes that the caller prepares enough buffer to
+ * store all the options.  However, it also takes the buffer end and checks
+ * the possibility of overrun for safety.
+ */
+static int copyout_option(void *p, void *ep, struct dhcp6_listval *optval)
+{
+	union {
+		struct dhcp6opt opt;
+		struct dhcp6opt_stcode stcodeopt;
+		struct dhcp6opt_ia ia;
+		struct dhcp6opt_ia_pd_prefix pd_prefix;
+		struct dhcp6opt_ia_addr ia_addr;
+	} u ALIGN4;
+	void *subp;
+	struct dhcp6_listval *subov;
+	int opt_len, headlen, sublen, opttype;
+
+	/* check invariant for safety */
+	if (ep <= p)
+		return -1;
+
+	/* first, detect the length of the option head */
+	switch (optval->lvtype) {
+	case DHCP6_LISTVAL_IA:
+		headlen = sizeof(u.ia);
+		opttype = optval->dh6optype;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		headlen = sizeof(u.ia_addr);
+		opttype = DH6OPT_IAADDR;
+		break;
+	case DHCP6_LISTVAL_NUM16:
+		headlen = sizeof(u.stcodeopt);
+		opttype = DH6OPT_STATUS_CODE;
+		break;
+	default:
+		/*
+		 * we encounter an unknown option.  this should be an internal
+		 * error.
+		 */
+		bb_error_msg("unknown listval type %d", optval->lvtype);
+		return -2;
+	}
+
+	/* then, calculate the length of and fill in the sub-options */
+	sublen = 0;
+	subp = p + headlen;
+	TAILQ_FOREACH(subov, &optval->sublist, link) {
+		int s = copyout_option(subp, ep, subov);
+
+		if (s < 0)
+			return s;
+		subp += s;
+		sublen += s;
+	}
+
+	/* finally, deal with the head part again */
+	opt_len = headlen + sublen;
+
+	log2("set %s [lvtype %d] (len %d)", dhcp6optstr(opttype),
+		optval->lvtype, opt_len);
+	if (ep - p < headlen) /* check it just in case */
+		return -1;
+
+	/* fill in the common part */
+	memset(&u, 0, sizeof(u));
+	u.opt.dh6opt_type = htons(opttype);
+	u.opt.dh6opt_len  = htons(opt_len - sizeof(struct dhcp6opt));
+
+	/* fill in type specific fields */
+	switch (optval->lvtype) {
+
+	case DHCP6_LISTVAL_IA:
+		u.ia.dh6_iaid = htonl(optval->val_ia.iaid);
+		u.ia.dh6_t1 = htonl(optval->val_ia.t1);
+		u.ia.dh6_t2 = htonl(optval->val_ia.t2);
+		break;
+
+	case DHCP6_LISTVAL_PREFIX6:
+		u.pd_prefix.dh6_preferred_time = htonl(optval->val_prefix6.pltime);
+		u.pd_prefix.dh6_valid_time = htonl(optval->val_prefix6.vltime);
+		u.pd_prefix.dh6_prefix_len = optval->val_prefix6.plen;
+		/* XXX: prefix_addr is badly aligned, so we need memcpy */
+		memcpy(&u.pd_prefix.dh6_prefix_addr,
+		    &optval->val_prefix6.addr, sizeof(struct in6_addr));
+		break;
+
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		u.ia_addr.dh6_preferred_time = htonl(optval->val_statefuladdr6.pltime);
+		u.ia_addr.dh6_valid_time = htonl(optval->val_statefuladdr6.vltime);
+		u.ia_addr.dh6_addr = optval->val_statefuladdr6.addr;
+		break;
+
+	case DHCP6_LISTVAL_NUM16:
+		u.stcodeopt.dh6_stcode = htons(optval->val_num16);
+		break;
+
+	default:
+		/*
+		 * XXX: this case should be rejected at the beginning of this
+		 * function.
+		 */
+		return -2;
+	}
+	/* copyout the data */
+	memcpy(p, &u, headlen);
+
+	return opt_len;
+}
+
+static int dhcp6_set_iaoptions(int type, struct dhcp6_list *head,
+		struct dhcp6opt **pp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, head, link) {
+		int opt_len1;
+
+		if (lv->dh6optype != type)
+			continue;
+
+		opt_len1 = copyout_option(*pp, ep, lv);
+		if (opt_len1 < 0) {
+			bb_error_msg("can't construct an %s option", dhcp6optstr(type));
+			return opt_len1;
+		}
+		(*pp) = (struct dhcp6opt *)((char *)(*pp) + opt_len1);
+		(*totallenp) += opt_len1;
+	}
+	return 0;
+}
+
+static int copyout_reqoptions(int type, struct dhcp6_list *head,
+		struct dhcp6opt **pp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6_listval *lv;
+	uint16_t *valp;
+	int opt_len = 0;
+
+	TAILQ_FOREACH(lv, head, link) {
+		opt_len += sizeof(uint16_t);
+	}
+	if (opt_len == 0)
+		return 0;
+
+	valp = (uint16_t *)((char *)(*pp)+ sizeof(struct dhcp6opt));
+	if (ep - (struct dhcp6opt *)valp < opt_len)
+		return -1;
+
+	TAILQ_FOREACH(lv, head, link) {
+		/*
+		 * Information request option can only be specified
+		 * in information-request messages.
+		 * [draft-ietf-dhc-lifetime-02.txt, Section 3.2]
+		 */
+		if (lv->val_num == DH6OPT_REFRESHTIME && type != DH6_INFORM_REQ) {
+			log1("refresh time option is not requested for %s",
+				 dhcp6msgstr(type));
+		}
+
+		move_to_unaligned16(valp++, htons((uint16_t)lv->val_num));
+	}
+	if (copy_option(DH6OPT_ORO, opt_len, NULL, pp, ep, totallenp) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+int dhcp6_set_options(int type, struct dhcp6opt *optbp, struct dhcp6opt *optep,
+		struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *p = optbp;
+	struct dhcp6_listval *lv;
+	int len = 0;
+
+	if (optinfo->clientID.dv_len) {
+		if (copy_option(DH6OPT_CLIENTID, optinfo->clientID.dv_len,
+		    optinfo->clientID.dv_buf, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->serverID.dv_len) {
+		if (copy_option(DH6OPT_SERVERID, optinfo->serverID.dv_len,
+		    optinfo->serverID.dv_buf, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (dhcp6_set_iaoptions(DH6OPT_IA_PD, &optinfo->ia_list, &p, optep, &len) < 0)
+		goto fail;
+
+	if (optinfo->rapidcommit) {
+		if (copy_option(DH6OPT_RAPID_COMMIT, 0, NULL, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+		uint8_t p8 = (uint8_t)optinfo->pref;
+
+		if (copy_option(DH6OPT_PREFERENCE, sizeof(p8), &p8, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->elapsed_time != DH6OPT_ELAPSED_TIME_UNDEF) {
+		uint16_t p16 = htons((uint16_t)optinfo->elapsed_time);
+
+		if (copy_option(DH6OPT_ELAPSED_TIME, sizeof(p16), &p16, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	TAILQ_FOREACH(lv, &optinfo->stcode_list, link) {
+		uint16_t code = htons(lv->val_num16);
+
+		if (copy_option(DH6OPT_STATUS_CODE, sizeof(code), &code, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->reqopt_list)) {
+		if (copyout_reqoptions(type, &optinfo->reqopt_list, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+	if (dhcp6_set_iaoptions(DH6OPT_IA_NA, &optinfo->ia_list, &p, optep, &len) < 0)
+		goto fail;
+
+	if (optinfo->relaymsg_len) {
+		if (copy_option(DH6OPT_RELAY_MSG, optinfo->relaymsg_len,
+		    optinfo->relaymsg_msg, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->ifidopt_id) {
+		if (copy_option(DH6OPT_INTERFACE_ID, optinfo->ifidopt_len,
+		    optinfo->ifidopt_id, &p, optep, &len) != 0)
+			goto fail;
+	}
+
+	if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		uint32_t p32 = htonl((uint32_t)optinfo->refreshtime);
+
+		if (copy_option(DH6OPT_REFRESHTIME, sizeof(p32), &p32, &p,
+		    optep, &len) != 0)
+			goto fail;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+		if (copyout_auth(optinfo, &p, optbp, optep, &len) != 0)
+			goto fail;
+	}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+	return len;
+
+  fail:
+	return -1;
+}
+
+void dhcp6_set_timeoparam(struct dhcp6_event *ev)
+{
+	ev->retrans = 0;
+	ev->max_retrans_cnt = 0;
+	ev->max_retrans_dur = 0;
+	ev->max_retrans_time = 0;
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		ev->init_retrans = SOL_TIMEOUT;
+		ev->max_retrans_time = SOL_MAX_RT;
+		break;
+	case DHCP6S_INFOREQ:
+		ev->init_retrans = INF_TIMEOUT;
+		ev->max_retrans_time = INF_MAX_RT;
+		break;
+	case DHCP6S_REQUEST:
+		ev->init_retrans = REQ_TIMEOUT;
+		ev->max_retrans_time = REQ_MAX_RT;
+		ev->max_retrans_cnt = REQ_MAX_RC;
+		break;
+	case DHCP6S_RENEW:
+		ev->init_retrans = REN_TIMEOUT;
+		ev->max_retrans_time = REN_MAX_RT;
+		break;
+	case DHCP6S_REBIND:
+		ev->init_retrans = REB_TIMEOUT;
+		ev->max_retrans_time = REB_MAX_RT;
+		break;
+	case DHCP6S_RELEASE:
+		ev->init_retrans = REL_TIMEOUT;
+		ev->max_retrans_cnt = REL_MAX_RC;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected event state %d on %s",
+		    ev->state, ev->ifp->ifname);
+	}
+}
+
+void dhcp6_reset_timer(struct dhcp6_event *ev)
+{
+	double n, r;
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		/*
+		 * The first Solicit message from the client on the interface
+		 * MUST be delayed by a random amount of time between
+		 * 0 and SOL_MAX_DELAY.
+		 * [RFC3315 17.1.2]
+		 * XXX: a random delay is also necessary before the first
+		 * information-request message.  Fortunately, the parameters
+		 * and the algorithm for these two cases are the same.
+		 * [RFC3315 18.1.5]
+		 */
+		ev->retrans = (random() % (SOL_MAX_DELAY));
+		break;
+
+	default:
+		if (ev->state == DHCP6S_SOLICIT && ev->timeouts == 0) {
+			/*
+			 * The first RT MUST be selected to be strictly
+			 * greater than IRT by choosing RAND to be strictly
+			 * greater than 0.
+			 * [RFC3315 17.1.2]
+			 */
+			r = (double)((random() % 1000) + 1) / 10000;
+			n = ev->init_retrans + r * ev->init_retrans;
+		} else {
+			r = (double)((random() % 2000) - 1000) / 10000;
+
+			if (ev->timeouts == 0) {
+				n = ev->init_retrans + r * ev->init_retrans;
+			} else {
+				n = 2 * ev->retrans + r * ev->retrans;
+			}
+		}
+		if (ev->max_retrans_time && n > ev->max_retrans_time)
+			n = ev->max_retrans_time + r * ev->max_retrans_time;
+
+		ev->retrans = (long)n;
+		break;
+	}
+
+	dhcp6_timer_set(ev->retrans, ev->timer);
+
+	log1("reset a timer on %s, state=%s, timeo=%d, retrans=%ld",
+		ev->ifp->ifname, dhcp6_event_statestr(ev), ev->timeouts, ev->retrans);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+/*
+ * Provide an NTP-format timestamp as a replay detection counter
+ * as mentioned in RFC3315.
+ */
+#define JAN_1970        2208988800UL        /* 1970 - 1900 in seconds */
+int get_rdvalue(int rdm, void *rdvalue)
+{
+	struct timeval tv;
+	uint32_t pack[2];
+
+	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection method (%d)", rdm);
+		return -1;
+	}
+
+	gettimeofday(&tv, NULL);
+
+	pack[0] = htonl((uint32_t)tv.tv_sec + JAN_1970);
+	pack[1] = htonl((uint32_t)tv.tv_usec);
+
+	memcpy(rdvalue, pack, sizeof(uint64_t));
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+# if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *optinfo)
+{
+	char *ret;
+	const char *proto, *alg, *rdm;
+	char proto0[16], alg0[16], rdm0[16];
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		proto = "delayed";
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		proto = "reconfig";
+		break;
+#endif
+	default:
+		snprintf(proto0, sizeof(proto0), "unknown(%d)",
+		    optinfo->authproto & 0xff);
+		proto = proto0;
+		break;
+	}
+
+	switch (optinfo->authalgorithm) {
+	case DHCP6_AUTHALG_HMACMD5:
+		alg = "HMAC-MD5";
+		break;
+	default:
+		snprintf(alg0, sizeof(alg0), "unknown(%d)",
+		    optinfo->authalgorithm & 0xff);
+		alg = alg0;
+		break;
+	}
+
+	switch (optinfo->authrdm) {
+	case DHCP6_AUTHRDM_MONOCOUNTER:
+		rdm = "mono counter";
+		break;
+	default:
+		snprintf(rdm0, sizeof(rdm0), "unknown(%d)", optinfo->authrdm);
+		rdm = rdm0;
+	}
+
+	ret = xasprintf("proto: %s, alg: %s, RDM: %s, RD: %llx",
+	    proto, alg, rdm, SWAP_BE64(optinfo->authrd));
+
+	return ret;
+}
+# endif /* CONFIG_UDHCP_DEBUG */
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const char *dh6_opts_strings[DH6OPT__MAX+1] = {
+ [DH6OPT_CLIENTID]			= "client ID",
+ [DH6OPT_SERVERID]			= "server ID",
+ [DH6OPT_IA_NA]				= "identity association",
+ [DH6OPT_IA_TA]				= "IA for temporary",
+ [DH6OPT_IAADDR]			= "IA address",
+ [DH6OPT_ORO]				= "option request",
+ [DH6OPT_PREFERENCE]		= "preference",
+ [DH6OPT_ELAPSED_TIME]		= "elapsed time",
+ [DH6OPT_RELAY_MSG]			= "relay message",
+ [DH6OPT_AUTH]				= "authentication",
+ [DH6OPT_UNICAST]			= "server unicast",
+ [DH6OPT_STATUS_CODE]		= "status code",
+ [DH6OPT_RAPID_COMMIT]		= "rapid commit",
+ [DH6OPT_USER_CLASS]		= "user class",
+ [DH6OPT_VENDOR_CLASS]		= "vendor class",
+ [DH6OPT_VENDOR_OPTS]		= "vendor specific info",
+ [DH6OPT_INTERFACE_ID]		= "interface ID",
+ [DH6OPT_RECONF_MSG]		= "reconfigure message",
+ [DH6OPT_RECONF_ACCEPT]		= "reconfigure accept",
+ [DH6OPT_SIP_SERVER_D]		= "SIP domain name",
+ [DH6OPT_SIP_SERVER_A]		= "SIP server address",
+ [DH6OPT_DNS]				= "DNS",
+ [DH6OPT_DNSNAME]			= "domain search list",
+ [DH6OPT_IA_PD]				= "IA_PD",
+ [DH6OPT_IA_PD_PREFIX]		= "IA_PD prefix",
+ [DH6OPT_NIS_SERVERS]		= "NIS servers",
+ [DH6OPT_NISP_SERVERS]		= "NIS+ servers",
+ [DH6OPT_NIS_DOMAIN]		= "NIS domain name",
+ [DH6OPT_NISP_DOMAIN]		= "NIS+ domain name",
+ [DH6OPT_SNTP_SERVERS]		= "SNTP server",
+ [DH6OPT_REFRESHTIME]		= "information refresh time",
+ [DH6OPT_BCMCS_SERVER_D]	= "BCMCS domain name",
+ [DH6OPT_BCMCS_SERVER_A]	= "BCMCS server address",
+ [DH6OPT_REMOTE_ID]			= "remote ID",
+ [DH6OPT_SUBSCRIBER_ID]		= "subscriber ID",
+ [DH6OPT_ERO]				= "Relay agent echo request",
+ [DH6OPT_NTP_SERVER]		= "NTP server",
+};
+
+#define genstr        (&bb_common_bufsiz1[COMMON_BUFSIZE / 2])
+#define sizeof_genstr (COMMON_BUFSIZE / 2 - 1)
+const char *dhcp6optstr(int type)
+{
+	if (type > 65535)
+		return "INVALID option";
+	if (type > DH6OPT__MAX || dh6_opts_strings[type] == NULL)
+		return utoa_to_buf(type, genstr, sizeof_genstr);
+
+	return dh6_opts_strings[type];
+}
+
+static const char *dh6_msgs_strings[DH6__MSG__MAX+1] = {
+ [0]				= "???",
+ [DH6_SOLICIT]		= "solicit",
+ [DH6_ADVERTISE]	= "advertise",
+ [DH6_REQUEST]		= "request",
+ [DH6_CONFIRM]		= "confirm",
+ [DH6_RENEW]		= "renew",
+ [DH6_REBIND]		= "rebind",
+ [DH6_REPLY]		= "reply",
+ [DH6_RELEASE]		= "release",
+ [DH6_DECLINE]		= "decline",
+ [DH6_RECONFIGURE]	= "reconfigure",
+ [DH6_INFORM_REQ]	= "information request",
+ [DH6_RELAY_FORW]	= "relay-forward",
+ [DH6_RELAY_REPLY]	= "relay-reply",
+};
+
+const char *dhcp6msgstr(int type)
+{
+	if (type > 255)
+		return "INVALID msg";
+	if (type > DH6__MSG__MAX) {
+		return utoa_to_buf(type, genstr+16, sizeof_genstr-16);
+	}
+
+	return dh6_msgs_strings[type];
+}
+
+static const char *dh6_stcodes_strings[DH6OPT_STCODE__MAX+1] = {
+ [DH6OPT_STCODE_SUCCESS]		= "success",
+ [DH6OPT_STCODE_UNSPECFAIL]		= "unspec failure",
+ [DH6OPT_STCODE_NOADDRSAVAIL]	= "no addresses",
+ [DH6OPT_STCODE_NOBINDING]		= "no binding",
+ [DH6OPT_STCODE_NOTONLINK]		= "not on-link",
+ [DH6OPT_STCODE_USEMULTICAST]	= "use multicast",
+ [DH6OPT_STCODE_NOPREFIXAVAIL]	= "no prefixes",
+};
+
+const char *dhcp6stcodestr(uint16_t code)
+{
+	if (code > 255)
+		return "INVALID code";
+	if (code > DH6OPT_STCODE__MAX) {
+		return utoa_to_buf(code, genstr+32, sizeof_genstr-32);
+	}
+
+	return dh6_stcodes_strings[code];
+}
+
+void BUG_dhcp6c_globals_too_big(void);
+
+char *duidstr(struct dhcp6_vbuf *duid)
+{
+	int i, len = 0;
+#define	duid_buf	(genstr + 48)
+	if (sizeof("xx:") * 32 + sizeof("...") > sizeof_genstr - 48)
+		BUG_dhcp6c_globals_too_big();
+
+	for (i = 0; i < duid->dv_len && i < 32; i++) {
+		if (i > 0)
+			duid_buf[len++] = ':';
+		bin2hex(duid_buf + len, (const char * )&duid->dv_buf[i], 1);
+		len += 2;
+	}
+	if (i < duid->dv_len) {
+		strcpy(duid_buf + len, "...");
+		len += 3;
+	}
+	duid_buf[len] = '\0';
+
+	return duid_buf;
+#undef  duid_buf
+}
+#undef	genstr
+#undef	sizeof_genstr
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+const char *dhcp6_event_statestr(struct dhcp6_event *ev)
+{
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		return "INIT";
+	case DHCP6S_SOLICIT:
+		return "SOLICIT";
+	case DHCP6S_INFOREQ:
+		return "INFOREQ";
+	case DHCP6S_REQUEST:
+		return "REQUEST";
+	case DHCP6S_RENEW:
+		return "RENEW";
+	case DHCP6S_REBIND:
+		return "REBIND";
+	case DHCP6S_RELEASE:
+		return "RELEASE";
+	default:
+		return "???"; /* XXX */
+	}
+}
+#endif
diff -urNBp a/networking/udhcp/common6.h b/networking/udhcp/common6.h
--- a/networking/udhcp/common6.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/common6.h	2011-10-25 20:51:00.000000000 +0400
@@ -0,0 +1,154 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* XXX: bsdi4 does not have TAILQ_EMPTY */
+#ifndef TAILQ_EMPTY
+#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)
+#endif
+
+/* and linux *_FIRST and *_NEXT */
+#ifndef LIST_EMPTY
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+#endif
+#ifndef LIST_FIRST
+#define	LIST_FIRST(head)	((head)->lh_first)
+#endif
+#ifndef LIST_NEXT
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+#endif
+#ifndef TAILQ_FIRST
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+#endif
+#ifndef TAILQ_LAST
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#endif
+#ifndef TAILQ_PREV
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#endif
+#ifndef TAILQ_NEXT
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+#endif
+#ifndef TAILQ_FOREACH
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+#endif
+
+#define xstr(s)		_xstr(s)
+#define	_xstr(s)	#s
+
+
+/* common6.c */
+struct dhcp6_option_typelen_t {
+	uint8_t	lvtype;
+	uint8_t	minlen;
+};
+
+extern const struct dhcp6_option_typelen_t dhcp6_option_typelens[DH6OPT__MAX+1];
+
+/* daemon state code */
+enum {
+	DHCP6S_INIT		= 0,
+	DHCP6S_SOLICIT	= DH6_SOLICIT,
+	DHCP6S_REQUEST	= DH6_REQUEST,
+	DHCP6S_RENEW	= DH6_RENEW,
+	DHCP6S_REBIND	= DH6_REBIND,
+	DHCP6S_RELEASE	= DH6_RELEASE,
+	DHCP6S_INFOREQ	= DH6_INFORM_REQ,
+};
+
+/* search option for dhcp6_find_listval() */
+enum {
+	MATCHLIST_PREFIXLEN	= (1 << 0),			/* Match prefix length only */
+	MATCHLIST_DH6OPTYPE	= (1 << 1),			/* Match by option type rather than listvalue type */
+};
+
+int dhcp6_copy_list(struct dhcp6_list *dst, const struct dhcp6_list *src);
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src);
+void dhcp6_clear_list(struct dhcp6_list *);
+void dhcp6_clear_listval(struct dhcp6_listval *);
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+    int type, const void *val, int options);
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+    int dh6optype, dhcp6_listval_type_t type,
+    const void *val, struct dhcp6_list *sublist);
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *, int) RETURNS_MALLOC;
+void dhcp6_remove_event(struct dhcp6_event *);
+void dhcp6_remove_evdata(struct dhcp6_event *);
+struct authparam *new_authparam(int proto, int alg, int rdm) RETURNS_MALLOC;
+int prefix6_mask(struct in6_addr *in6, int plen);
+int get_duid(const char *, struct dhcp6_vbuf *, int);
+void dhcp6_init_options(struct dhcp6_optinfo *);
+void dhcp6_clear_options(struct dhcp6_optinfo *);
+void dhcp6_copy_options(struct dhcp6_optinfo *,
+			   struct dhcp6_optinfo *);
+int dhcp6_get_options(struct dhcp6opt *, struct dhcp6opt *,
+			struct dhcp6_optinfo *);
+int dhcp6_set_options(int, struct dhcp6opt *, struct dhcp6opt *,
+			struct dhcp6_optinfo *);
+void dhcp6_set_timeoparam(struct dhcp6_event *);
+void dhcp6_reset_timer(struct dhcp6_event *);
+
+const char *dhcp6optstr(int);
+const char *dhcp6msgstr(int);
+const char *dhcp6stcodestr(uint16_t);
+char *duidstr(struct dhcp6_vbuf *);
+const char *dhcp6_event_statestr(struct dhcp6_event *);
+int get_rdvalue(int, void *);
+
+void dhcp6_vbuf_copy(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+void dhcp6_vbuf_free(struct dhcp6_vbuf *);
+static int ALWAYS_INLINE dhcp6_vbuf_cmp(struct dhcp6_vbuf *v1, struct dhcp6_vbuf *v2)
+{
+	if (v1->dv_len != v2->dv_len)
+		return (v1->dv_len - v2->dv_len);
+
+	return memcmp(v1->dv_buf, v2->dv_buf, v1->dv_len);
+}
+
+/* if6.c */
+typedef enum { IFADDRCONF_ADD, IFADDRCONF_REMOVE } ifaddrconf_cmd_t;
+
+void if6init(struct dhcp6_if *, const char *ifname);
+int sock6_init(struct addrinfo *res);
+ssize_t recv_from6(int fd, void *buf, size_t len,
+				struct sockaddr_in6 *from, unsigned int *to_ifindex) FAST_FUNC;
+
+extern ssize_t gethwid(char *buf, uint16_t *hwtype);
+int ifaddrconf(ifaddrconf_cmd_t, const char *ifname, struct in6_addr *,
+			int plen, int pltime, int vltime);
+
+/* dhcp6c_script.c */
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, const char *ifname);
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, const char *clientaddr);
+int dhcp6_script(const char *scriptpath, char **envp);
diff -urNBp a/networking/udhcp/config6.c b/networking/udhcp/config6.c
--- a/networking/udhcp/config6.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/config6.c	2011-10-31 16:08:11.000000000 +0300
@@ -0,0 +1,1430 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "auth6.h"
+
+/* structures and definitions used in the config file parser */
+struct cf_list {
+	struct cf_list *next;
+	struct cf_list *tail;
+
+	int type;
+	int line;		/* the line number of the config file */
+
+	/* type dependent values: */
+	char *ptr;
+	struct cf_list *sublist;
+};
+#define MAKE_CFLIST(l, t, pp, pl) do { \
+	(l) = (struct cf_list *)xzalloc(sizeof(*(l))); \
+	l->line = lineno; \
+	l->type = (t); \
+	l->ptr  = (pp); \
+	l->sublist = (pl); \
+	l->tail = (l); \
+	} while (0)
+
+static void cleanup_cflist(struct cf_list *);
+
+
+/* DHCPv6 authentication information */
+struct authinfo {
+	struct authinfo *next;
+
+	char *name;		/* auth info name */
+
+	int protocol;	/* authentication protocol */
+	int algorithm;	/* authentication algorithm */
+	int rdm;		/* random attack detection method */
+
+	/* keys specific to this info? */
+};
+
+static int add_pd_pif(struct ia_conf *, struct cf_list *);
+static int add_options(int, struct dhcp6_if *, struct cf_list *);
+static int add_prefix6(struct dhcp6_list *, int type, int lvtype,
+						struct dhcp6_prefix *);
+static void clear_pd_pif(struct ia_conf *);
+static void clear_iaconf(struct ia_conflist *);
+static void clear_keys(struct keyinfo *);
+static void clear_authinfo(struct authinfo *);
+static int get_default_ifid(struct prefix_ifconf *);
+static char* FAST_FUNC qstrdup(char *);
+
+
+static int configure_interface(void)
+{
+	struct cf_list *cnl;
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	for (cnl = client6_config.config_list; cnl; cnl = cnl->next) {
+		struct cf_list *cfl;
+
+		if (cnl->type != DECL_IFACE)
+			continue;
+		log3("configure iface '%s'", cnl->ptr);
+
+		if (if_nametoindex(cnl->ptr) == 0) {
+			bb_perror_msg("%s:%d invalid interface(%s)",
+				client6_config.conffile, cnl->line,	cnl->ptr);
+			return -1;
+		}
+
+		if (strcmp(ifp->ifname, cnl->ptr) != 0) {
+			log1("Unknown interface(%s), ignoring", cnl->ptr);
+			continue;
+		}
+
+		ifp->server_pref = DH6OPT_PREF_UNDEF;
+
+		for (cfl = cnl->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case DECL_REQUEST:
+			case DECL_SEND:
+				if (add_options(cfl->type, ifp, cfl->sublist))
+					return -1;
+				break;
+			case DECL_INFO_ONLY:
+				ifp->send_flags |= DHCIFF_INFO_ONLY;
+				break;
+			case DECL_SCRIPT:
+				if (ifp->scriptpath) {
+					bb_info_msg("%s:%d duplicated script",
+					    client6_config.conffile, cfl->line);
+					return -1;
+				}
+				ifp->scriptpath = qstrdup(cfl->ptr);
+				if (ifp->scriptpath == NULL)
+					goto bad;
+				if (ifp->scriptpath[0] != '/') {
+					bb_info_msg("script must be an absolute path");
+					return -1;
+				}
+				break;
+			default:
+ bad:
+				bb_error_msg("%s:%d invalid configuration",
+							client6_config.conffile, cfl->line);
+				return -1;
+			}
+		} /* for(cnl->sublist) */
+	} /* for(cf_list) */
+
+	return 0;
+}
+
+static int configure_ia(void)
+{
+	struct cf_list *iap;
+	struct ia_conf *iac = NULL;
+
+	for (iap = client6_config.config_list; iap; iap = iap->next) {
+		struct cf_list *cfl;
+
+		if (iap->type != DHCPOPT_IA_PD && iap->type != DHCPOPT_IA_NA)
+			continue;
+		log3("configure %s '%s'", dhcp6optstr(iap->type), iap->ptr);
+
+		iac = xzalloc(sizeof(struct ia_conf));
+		/* common initialization */
+		iac->type = iap->type;
+		iac->iaid = (uint32_t)atoi(iap->ptr);
+		TAILQ_INIT(&iac->iadata);
+		TAILQ_INSERT_TAIL(&client6_config.ia_allconflist, iac, link);
+
+		/* IA-type specific initialization */
+		switch (iap->type) {
+		case DHCPOPT_IA_PD:
+			TAILQ_INIT(&iac->iapd_pif_list);
+			/* Fall through */
+		case DHCPOPT_IA_NA:
+			TAILQ_INIT(&iac->prefix_list);
+			break;
+		default:
+			/* not happen - for compiler only*/
+			break;
+		}
+
+		/* set up parameters for the IA */
+		for (cfl = iap->sublist; cfl; cfl = cfl->next) {
+
+			switch (iap->type) {
+			case DHCPOPT_IA_PD:
+				switch (cfl->type) {
+				case IACONF_PIF:
+					if (add_pd_pif(iac, cfl))
+						return -1;
+					break;
+				case IACONF_PREFIX:
+					if (add_prefix6(&iac->prefix_list, iap->type,
+						 DHCP6_LISTVAL_PREFIX6,
+						 (struct dhcp6_prefix *)cfl->ptr))
+						return -1;
+					break;
+				default:
+					goto bad;
+				}
+				break;
+			case DHCPOPT_IA_NA:
+				switch (cfl->type) {
+				case IACONF_ADDR:
+					if (add_prefix6(&iac->prefix_list, iap->type,
+						 DHCP6_LISTVAL_STATEFULADDR6,
+						 (struct dhcp6_prefix *)cfl->ptr))
+						return -1;
+					break;
+				default:
+					goto bad;
+				}
+				break;
+			default:
+				/* not happen - for compiler only*/
+ bad:
+				bb_error_msg("%s:%d invalid configuration",
+					    client6_config.conffile, cfl->line);
+				return -1;
+			}
+		} /* for(iap->sublist) */
+	} /* for(cf_list) */
+
+	return 0;
+}
+
+static int add_pd_pif(struct ia_conf *iac, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct prefix_ifconf *pif;
+
+	/* duplication check */
+	TAILQ_FOREACH(pif, &iac->iapd_pif_list, link) {
+		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
+			bb_info_msg("%s:%d duplicated prefix interface %s",
+			    client6_config.conffile, cfl0->line, cfl0->ptr);
+			return 0; /* ignore it */
+		}
+	}
+
+	pif = xzalloc(sizeof(*pif));
+
+	/* validate and copy ifname */
+	if (if_nametoindex(cfl0->ptr) == 0) {
+		bb_perror_msg("%s:%d invalid interface(%s)",
+		    client6_config.conffile, cfl0->line, cfl0->ptr);
+		goto bad;
+	}
+	pif->ifname = xstrdup(cfl0->ptr);
+
+	pif->ifid_len = IFID_LEN_DEFAULT;
+	pif->sla_len = SLA_LEN_DEFAULT;
+	if (get_default_ifid(pif)) {
+		bb_error_msg("can't get IF ID for %s", pif->ifname);
+		goto bad;
+	}
+
+	for (cfl = cfl0->sublist; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case IFPARAM_SLA_ID:
+			pif->sla_id = xatou32(cfl->ptr);
+			break;
+		case IFPARAM_SLA_LEN:
+			pif->sla_len = xatou(cfl->ptr);
+			if (pif->sla_len < 0 || pif->sla_len > 128) {
+				bb_error_msg("%s:%d invalid SLA length: %d",
+				    client6_config.conffile, cfl->line, pif->sla_len);
+				goto bad;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d invalid configuration",
+			    client6_config.conffile, cfl->line);
+			goto bad;
+		}
+	}
+
+	TAILQ_INSERT_TAIL(&iac->iapd_pif_list, pif, link);
+	return 0;
+
+ bad:
+	free(pif->ifname);
+	free(pif);
+	return -1;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int configure_keys(void)
+{
+	struct cf_list *key;
+	struct keyinfo *kinfo;
+	char *expire = NULL;
+
+	for (key = client6_config.config_list; key; key = key->next) {
+		struct cf_list *cfl;
+
+		if (key->type != DECL_KEYINFO)
+			continue;
+		log3("configure keys '%s'", key->ptr);
+
+		kinfo = xzalloc(sizeof(*kinfo));
+		kinfo->next = client6_config.key_list;
+		kinfo->name = xstrdup(key->ptr);
+		kinfo->keyid = -1;
+		client6_config.key_list = kinfo;
+
+		for (cfl = key->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case KEYPARAM_REALM:
+				if (kinfo->realm.dv_buf != NULL) {
+					bb_info_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "realm", key->ptr);
+					continue;
+				}
+				kinfo->realm.dv_buf = qstrdup(cfl->ptr);
+				if (kinfo->realm.dv_buf == NULL)
+					goto wrong;
+				kinfo->realm.dv_len = strlen(kinfo->realm.dv_buf);
+				break;
+			case KEYPARAM_KEYID:
+				if (kinfo->keyid != -1) {
+					bb_info_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "key ID", key->ptr);
+					continue;
+				}
+				kinfo->keyid = xatou32(cfl->ptr);
+				break;
+			case KEYPARAM_SECRET:
+				/* duplicate check */
+				if (kinfo->secret != NULL) {
+					bb_info_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "secret", key->ptr);
+					continue; /* ignored */
+				}
+
+				{
+					int len;
+					unsigned char *out_tail;
+					const char *in_tail;
+
+					/* convert base64 string to binary secret */
+					len = strlen(cfl->ptr);
+					len = (len >> 2) + (len >> 1) + 1; /* 3/4x + 1 */
+					kinfo->secret = xmalloc(len);
+					out_tail = kinfo->secret;
+					in_tail = decode_base64((char **)&out_tail, cfl->ptr);
+					if (*in_tail != '\0') {
+						free(kinfo->secret);
+						goto wrong;
+					}
+					kinfo->secretlen = out_tail - kinfo->secret;
+				}
+				break;
+			case KEYPARAM_EXPIRE:
+				if (expire != NULL) {
+					bb_info_msg("%s:%d duplicated %s for key %s (ignored)",
+						client6_config.conffile, cfl->line, "expire", key->ptr);
+					continue;
+				}
+				expire = qstrdup(cfl->ptr);
+				if (expire == NULL)
+					goto wrong;
+				break;
+			default:
+ wrong:
+				bb_error_msg("%s:%d invalid parameter for %s",
+				    client6_config.conffile, cfl->line, key->ptr);
+				goto bad;
+			}
+		} /* for(key->sublist) */
+
+		/* check for mandatory parameters or use default */
+		if (kinfo->realm.dv_buf == NULL) {
+			bb_error_msg("%s not specified for key %s",	"realm", key->ptr);
+			goto bad;
+		}
+		if (kinfo->keyid == -1) {
+			bb_error_msg("%s not specified for key %s",	"key ID", key->ptr);
+			goto bad;
+		}
+		if (kinfo->secret == NULL) {
+			bb_error_msg("%s not specified for key %s",	"secret", key->ptr);
+			goto bad;
+		}
+		if (expire != NULL) {
+			if (strcmp(expire, "forever") != 0) {
+				time_t now, expire_time;
+				struct tm lt;
+
+				time(&now);
+				parse_datestr(expire, &lt);
+				expire_time = mktime(&lt);
+				if (expire_time < now) {
+					bb_error_msg("past expiration time specified: %s",
+					    expire);
+					goto bad;
+				}
+
+				kinfo->expire = expire_time;
+			}
+		}
+	} /* for(cf_list) */
+
+	return 0;
+
+ bad:
+	free(expire);
+	return -1;
+}
+
+static int configure_authinfo(void)
+{
+	struct cf_list *auth;
+	struct authinfo *ainfo;
+
+	for (auth = client6_config.config_list; auth; auth = auth->next) {
+		struct cf_list *cfl;
+
+		if (auth->type != DECL_AUTHINFO)
+			continue;
+		log3("configure auth '%s'", auth->ptr);
+
+		ainfo = xzalloc(sizeof(*ainfo));
+		ainfo->next = client6_config.auth_list;
+		client6_config.auth_list = ainfo;
+		ainfo->protocol = DHCP6_AUTHPROTO_UNDEF;
+		ainfo->algorithm = DHCP6_AUTHALG_UNDEF;
+		ainfo->rdm = DHCP6_AUTHRDM_UNDEF;
+		ainfo->name = xstrdup(auth->ptr);
+
+		for (cfl = auth->sublist; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case AUTHPARAM_PROTO:
+				if (ainfo->protocol != DHCP6_AUTHPROTO_UNDEF) {
+					bb_info_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "protocol", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "delayed") == 0)
+					ainfo->protocol = DHCP6_AUTHPROTO_DELAYED;
+#if 0 /* ENABLE_DHCP6S */
+				else if (strcasecmp(cfl->ptr, "reconfig") == 0)
+					ainfo->protocol = DHCP6_AUTHPROTO_RECONFIG;
+#endif
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_ALG:
+				if (ainfo->algorithm != DHCP6_AUTHALG_UNDEF) {
+					bb_info_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "algorithm", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "hmac-md5") == 0 ||
+				    strcasecmp(cfl->ptr, "hmacmd5") == 0)
+					ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_RDM:
+				if (ainfo->rdm != DHCP6_AUTHRDM_UNDEF) {
+					bb_info_msg("%s:%d duplicated %s for auth %s (ignored)",
+					    client6_config.conffile, cfl->line,
+					    "RDM", auth->ptr);
+					continue; /* ignored */
+				}
+				if (strcasecmp(cfl->ptr, "monocounter") == 0)
+					ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+				else
+					goto wrong;
+				break;
+			case AUTHPARAM_KEY:
+				bb_info_msg("%s:%d auth info specific keys "
+				    "are not supported",
+				    client6_config.conffile, cfl->line);
+				break;
+			default:
+ wrong:
+				bb_error_msg("%s:%d invalid auth info parameter for %s",
+				    client6_config.conffile, cfl->line, auth->ptr);
+				goto bad;
+			}
+		} /* for(auth->sublist) */
+
+		/* check for mandatory parameters and consistency */
+		switch (ainfo->protocol) {
+		case DHCP6_AUTHPROTO_UNDEF:
+			bb_error_msg("auth protocol not specified for %s", auth->ptr);
+			goto bad;
+		case DHCP6_AUTHPROTO_DELAYED:
+			break;
+		case DHCP6_AUTHPROTO_RECONFIG:
+			goto bad;
+			break;
+		}
+		if (ainfo->algorithm == DHCP6_AUTHALG_UNDEF)
+			ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+		if (ainfo->rdm == DHCP6_AUTHRDM_UNDEF)
+			ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+	}
+
+	return 0;
+
+ bad:
+	/* there is currently nothing special to recover the error */
+	return -1;
+}
+
+static struct authinfo *find_authinfo(struct authinfo *head, char *name)
+{
+	struct authinfo *ainfo;
+
+	for (ainfo = head; ainfo; ainfo = ainfo->next) {
+		if (strcmp(ainfo->name, name) == 0)
+			return ainfo;
+	}
+
+	return NULL;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+/* Strip quotes from string */
+static char* FAST_FUNC qstrdup(char *qstr)
+{
+	size_t len;
+	char *dst;
+
+	len = strlen(qstr);
+	if (qstr[0] != '"' || len < 2 || qstr[len - 1] != '"')
+		return NULL;
+
+	dst = xmalloc(len);
+
+	memcpy(dst, qstr + 1, len - 1);
+	dst[len - 2] = '\0';
+
+	return dst;
+}
+
+/* we currently only construct EUI-64 based interface ID */
+static int get_default_ifid(struct prefix_ifconf *pif)
+{
+	uint8_t buf[16];
+
+	if (pif->ifid_len < 64) {
+		bb_error_msg("ID length too short");
+		return -1;
+	}
+
+	if (udhcp_read_interface(pif->ifname, NULL, NULL, buf, NULL))
+		return -2;
+
+	memset(pif->ifid, 0, sizeof(pif->ifid));
+	pif->ifid[8]  = buf[0] ^ 0x02; /* reverse the u/l bit*/
+	pif->ifid[9]  = buf[1];
+	pif->ifid[10] = buf[2];
+	pif->ifid[11] = 0xff;
+	pif->ifid[12] = 0xfe;
+	pif->ifid[13] = buf[3];
+	pif->ifid[14] = buf[4];
+	pif->ifid[15] = buf[5];
+
+	return 0;
+}
+
+void clear_ifconf(int destroy)
+{
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	ifp->send_flags = 0;
+	ifp->allow_flags = 0;
+
+	ifp->server_pref = DH6OPT_PREF_UNDEF;
+
+	ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+	ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+
+	dhcp6_clear_list(&ifp->reqopt_list);
+
+	clear_iaconf(&ifp->iaconf_list);
+
+	free(ifp->scriptpath);
+	ifp->scriptpath = NULL;
+
+	free(ifp->pool.name);
+	ifp->pool.name = NULL;
+
+	if (ENABLE_FEATURE_CLEAN_UP && destroy) {
+		free(ifp->ifname);
+	}
+}
+
+static void clear_pd_pif(struct ia_conf *iac)
+{
+	struct prefix_ifconf *pif, *pif_next;
+
+	for (pif = TAILQ_FIRST(&iac->iapd_pif_list); pif; pif = pif_next) {
+		pif_next = TAILQ_NEXT(pif, link);
+
+		free(pif->ifname);
+		free(pif);
+	}
+
+	dhcp6_clear_list(&iac->prefix_list);
+}
+
+static void clear_iaconf(struct ia_conflist *ialist)
+{
+	struct ia_conf *iac;
+
+	while ((iac = TAILQ_FIRST(ialist)) != NULL) {
+		TAILQ_REMOVE(ialist, iac, link);
+
+		switch (iac->type) {
+		case DHCPOPT_IA_PD:
+			if (!TAILQ_EMPTY(&iac->iadata)) {
+				bb_error_msg("iadata not empty");
+			}
+			clear_pd_pif(iac);
+			break;
+		case DHCPOPT_IA_NA:
+			break;
+		default:
+			break;
+		}
+		free(iac);
+	}
+}
+
+static void clear_keys(struct keyinfo *klist)
+{
+	struct keyinfo *key = klist, *key_next;
+
+	while (key) {
+		key_next = key->next;
+
+		free(key->name);
+		dhcp6_vbuf_free(&key->realm);
+		free(key->secret);
+		free(key);
+
+		key = key_next;
+	}
+}
+
+static void clear_authinfo(struct authinfo *alist)
+{
+	struct authinfo *auth = alist, *auth_next;
+
+	while (auth) {
+		auth_next = auth->next;
+		free(auth);
+
+		auth = auth_next;
+	}
+}
+
+static int add_options(int opcode, struct dhcp6_if *ifp, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct ia_conf *iac;
+	uint32_t iaid;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authinfo *ainfo;
+#endif
+
+	for (cfl = cfl0; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case DHCPOPT_RAPID_COMMIT:
+			switch (opcode) {
+			case DECL_SEND:
+				ifp->send_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#if 0 /* ENABLE_DHCP6S */
+			case DECL_ALLOW:
+				ifp->allow_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#endif
+			default:
+				goto inv_op;
+			}
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case DHCPOPT_AUTHINFO:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			ainfo = find_authinfo(client6_config.auth_list, cfl->ptr);
+			if (ainfo == NULL) {
+				bb_error_msg("%s:%d auth info (%s) is not defined",
+				    client6_config.conffile, cfl->line, cfl->ptr);
+				return -1;
+			}
+			if (ifp->authproto != DHCP6_AUTHPROTO_UNDEF) {
+				bb_error_msg("%s:%d duplicated auth info for %s",
+				    client6_config.conffile, cfl->line, ifp->ifname);
+				return -1;
+			}
+			ifp->authproto = ainfo->protocol;
+			ifp->authalgorithm = ainfo->algorithm;
+			ifp->authrdm = ainfo->rdm;
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+		case DHCPOPT_IA_PD:
+		case DHCPOPT_IA_NA:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			iaid = xatou32(cfl->ptr);
+			iac = find_iaconf(&ifp->iaconf_list, cfl->type, iaid);
+			if (iac != NULL) {
+				bb_error_msg("%s:%d duplicated %s (%u)",
+					client6_config.conffile, cfl->line,
+					dhcp6optstr(cfl->type), iaid);
+				return -1;
+			}
+			iac = find_iaconf(&client6_config.ia_allconflist, cfl->type, iaid);
+			if (iac == NULL) {
+				bb_error_msg("%s:%d %s (%u) is not defined",
+					client6_config.conffile, cfl->line,
+					dhcp6optstr(cfl->type), iaid);
+				return -1;
+			}
+
+			TAILQ_REMOVE(&client6_config.ia_allconflist, iac, link);
+			TAILQ_INSERT_TAIL(&ifp->iaconf_list, iac, link);
+
+			break;
+		case DHCPOPT_SIP:
+		case DHCPOPT_SIPNAME:
+		case DHCPOPT_DNS:
+		case DHCPOPT_DNSNAME:
+		case DHCPOPT_SNTP:
+		case DHCPOPT_NIS:
+		case DHCPOPT_NISNAME:
+		case DHCPOPT_NISP:
+		case DHCPOPT_NISPNAME:
+		case DHCPOPT_BCMCS:
+		case DHCPOPT_BCMCSNAME:
+		case DHCPOPT_REFRESHTIME:
+			if (opcode != DECL_REQUEST)
+				goto inv_op;
+			if (dhcp6_find_listval(&ifp->reqopt_list,
+					DHCP6_LISTVAL_NUM, &cfl->type, 0) != NULL) {
+				bb_info_msg("duplicated request option (%s)",
+				    dhcp6optstr(cfl->type));
+				goto next; /* ignore it */
+			}
+			if (dhcp6_add_listval(&ifp->reqopt_list, 0,
+					DHCP6_LISTVAL_NUM, &cfl->type, NULL) == NULL) {
+				bb_error_msg("can't add an option (%s)",
+					dhcp6optstr(cfl->type));
+				return -1;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d unsupported option (%s)",
+				client6_config.conffile, cfl->line,
+				dhcp6optstr(cfl->type));
+			return -1;
+		}
+
+ next:
+		;
+	}
+
+	return 0;
+
+ inv_op:
+	bb_error_msg("%s:%d invalid operation (%d) for option (%s)",
+		    client6_config.conffile, cfl->line,
+		    opcode, dhcp6optstr(cfl->type));
+	return -1;
+}
+
+static int add_prefix6(struct dhcp6_list *head, int type, int lvtype,
+		   struct dhcp6_prefix *prefix)
+{
+	struct in6_addr oldaddr;
+	const char *name = dhcp6optstr(type);
+	char p[INET6_ADDRSTRLEN];
+
+	oldaddr = prefix->addr;
+
+	/* additional validation of parameters */
+	if (prefix->plen < 4 || prefix->plen > 128) {
+		bb_error_msg("invalid prefix length: %d", prefix->plen);
+		return -1;
+	}
+	/* clear trailing bits */
+	prefix6_mask(&prefix->addr, prefix->plen);
+	sprint_nip6(p, (const uint8_t *)&prefix->addr);
+	if (!IN6_ARE_ADDR_EQUAL(&oldaddr, &prefix->addr)) {
+		char p0[INET6_ADDRSTRLEN];
+
+		sprint_nip6(p0, (const uint8_t *)&oldaddr);
+		bb_info_msg("prefix %s/%d for %s "
+		    "has a trailing garbage. It should be %s/%d",
+		    p0, prefix->plen, name, p, prefix->plen);
+		/* ignore the error */
+	}
+
+	/* avoid invalid prefix addresses */
+	if (IN6_IS_ADDR_MULTICAST(&prefix->addr) ||
+	    IN6_IS_ADDR_LINKLOCAL(&prefix->addr) ||
+	    IN6_IS_ADDR_SITELOCAL(&prefix->addr)) {
+		bb_error_msg("invalid prefix address: %s", p);
+		return -1;
+	}
+
+	/* prefix duplication check */
+	if (dhcp6_find_listval(head, lvtype, prefix, 0)) {
+		if (lvtype == DHCP6_LISTVAL_PREFIX6) {
+			bb_info_msg("duplicated prefix: %s/%d for %s",
+			    p, prefix->plen, name);
+		} else {
+			bb_info_msg("duplicated address: %s for %s", p, name);
+		}
+		return -1;
+	}
+
+	/* validation about relationship of pltime and vltime */
+	if (prefix->vltime != DHCP6_DURATION_INFINITE &&
+		 (prefix->pltime == DHCP6_DURATION_INFINITE ||
+		 prefix->pltime > prefix->vltime)) {
+		bb_info_msg("%s/%d has larger preferred lifetime than valid lifetime",
+				p, (lvtype == DHCP6_LISTVAL_PREFIX6) ? prefix->plen : 128);
+		return -1;
+	}
+
+	/* insert the new prefix to the chain */
+	if (dhcp6_add_listval(head, type, lvtype, prefix, NULL) == NULL) {
+		return -1;
+	}
+
+	return 0;
+}
+
+struct ia_conf *find_iaconf(struct ia_conflist *head, dh6cnfopts_t type,
+			uint32_t iaid)
+{
+	struct ia_conf *iac;
+
+	TAILQ_FOREACH(iac, head, link) {
+		if (iac->type == type && iac->iaid == iaid)
+			return iac;
+	}
+
+	return NULL;
+}
+
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *list,
+				struct dhcp6_prefix *prefix)
+{
+	struct dhcp6_listval *lv;
+
+	TAILQ_FOREACH(lv, list, link) {
+		if (lv->val_prefix6.plen == prefix->plen &&
+		    IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr, &prefix->addr)) {
+			return (&lv->val_prefix6);
+		}
+	}
+	return NULL;
+}
+
+struct keyinfo *find_key(struct dhcp6_vbuf *realm, uint32_t id)
+{
+	struct keyinfo *key;
+
+	for (key = client6_config.key_list; key; key = key->next) {
+		if (key->keyid == id && dhcp6_vbuf_cmp(&key->realm, realm) == 0) {
+			return key;
+		}
+	}
+
+	return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////
+
+
+/* supplement routines for configuration */
+static int add_cflevel0(dh6cnfopts_t type, const char *name, int lineno)
+{
+	struct cf_list *new;
+	struct cf_list *n = client6_config.config_list;
+
+	MAKE_CFLIST(new, type, xstrdup(name), NULL);
+
+	/* check for duplicated configuration */
+	while (n) {
+		if (n->type == new->type && strcmp(n->ptr, new->ptr) == 0) {
+			bb_info_msg("%s:%d duplicated %s name: %s (ignored)",
+				client6_config.conffile, lineno, dhcp6optstr(type), name);
+			cleanup_cflist(new);
+			return 0;
+		}
+		n = n->next;
+	}
+
+	/* insert at first pos of list */
+	new->next = client6_config.config_list;
+	if (client6_config.config_list)
+		new->tail = client6_config.config_list->tail;
+	client6_config.config_list = new;
+
+	return 0;
+}
+
+static int add_cfparam(struct cf_list *new)
+{
+	struct cf_list *headp = client6_config.config_list;
+
+	if (headp->sublist == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		headp->sublist = new;
+	} else {
+		/* add to the end of list */
+		headp->sublist->tail->next = new;
+		headp->sublist->tail = new->tail;
+	}
+	return 0;
+}
+
+static int add_cfsubparam(struct cf_list *new, struct cf_list *parent)
+{
+	if (parent->sublist == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		parent->sublist = new;
+	} else {
+		/* add to the end of list */
+		parent->sublist->tail->next = new;
+		parent->sublist->tail = new->tail;
+	}
+	return 0;
+}
+
+static void cleanup_cflist(struct cf_list *cfl)
+{
+	struct cf_list *cfl_next;
+
+	while (cfl) {
+		cfl_next = cfl->next;
+		free(cfl->ptr);
+		if (cfl->sublist)
+			cleanup_cflist(cfl->sublist);
+		free(cfl);
+
+		cfl = cfl_next;
+	}
+}
+
+struct dhcp_cf_options {
+	const char *optname;
+	const int optval;
+	const uint8_t paramt; /* 0-none, 1-string, 2-integer */
+};
+
+static const struct dhcp_cf_options dhcp_option_list[] = {
+    { "rapid-commit",             DHCPOPT_RAPID_COMMIT,  0 },
+    { "ia-pd",                    DHCPOPT_IA_PD,         2 },
+    { "ia-na",                    DHCPOPT_IA_NA,         2 },
+    { "authentication",           DHCPOPT_AUTHINFO,      1 },
+    { "domain-name-servers",      DHCPOPT_DNS,           0 },
+    { "ntp-servers",              DHCPOPT_SNTP,          0 },
+    { "sip-server-address",       DHCPOPT_SIP,           0 },
+    { "nis-server-address",       DHCPOPT_NIS,           0 },
+    { "nisp-server-address",      DHCPOPT_NISP,          0 },
+    { "bcmcs-server-address",     DHCPOPT_BCMCS,         0 },
+#if ENABLE_FEATURE_UDHCP_RFC3397
+    { "domain-name",              DHCPOPT_DNSNAME,       0 },
+    { "sip-server-domain-name",   DHCPOPT_SIPNAME,       0 },
+    { "nis-domain-name",          DHCPOPT_NISNAME,       0 },
+    { "nisp-domain-name",         DHCPOPT_NISPNAME,      0 },
+    { "bcmcs-server-domain-name", DHCPOPT_BCMCSNAME,     0 },
+#endif
+};
+
+static int FAST_FUNC create_iface(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_IFACE, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC create_assoc(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	const char *id;
+	dh6cnfopts_t iatype;
+
+	if (cnt < 2)
+		return -2;
+
+	if (cnt >=3 && strcmp(varr[2], "{"))
+		id = varr[2];
+	else
+		id = "0";
+
+	if (strcasecmp(varr[1], "pd") == 0)
+		iatype = DHCPOPT_IA_PD;
+	else if (strcasecmp(varr[1], "na") == 0)
+		iatype = DHCPOPT_IA_NA;
+	else
+		return -3;
+
+	if (add_cflevel0(iatype, id, lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_iface(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	int i, j;
+
+	switch (kw_ind) {
+	case 0: /* send */
+		MAKE_CFLIST(l, DECL_SEND, NULL, NULL);
+		add_cfparam(l);
+		break;
+	case 1: /* request */
+		MAKE_CFLIST(l, DECL_REQUEST, NULL, NULL);
+		add_cfparam(l);
+		break;
+	case 2: /* script */
+		if (cnt < 2)
+			return -2;
+		MAKE_CFLIST(l, DECL_SCRIPT, xstrdup(varr[1]), NULL);
+		add_cfparam(l);
+		return 0;
+	case 3: /* information-only */
+		MAKE_CFLIST(l, DECL_INFO_ONLY, NULL, NULL);
+		add_cfparam(l);
+		return 0;
+	}
+
+	/* add subparams */
+	for (i = 1; i < cnt; i++) {
+
+		for (j = 0; j < ARRAY_SIZE(dhcp_option_list); j++) {
+			if (strcasecmp(dhcp_option_list[j].optname, varr[i]) == 0) {
+
+			MAKE_CFLIST(l, dhcp_option_list[j].optval, xstrdup(varr[i+1]), NULL);
+			if (dhcp_option_list[j].paramt && (i < cnt - 1))
+				i++;
+			if (add_cfsubparam(l, client6_config.config_list->sublist->tail))
+				return -1;
+			break;
+
+			}
+		}
+
+		if (j >= ARRAY_SIZE(dhcp_option_list))
+		return -3;
+
+	}
+
+	return 0;
+}
+
+static int FAST_FUNC create_prefiff(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	struct cf_list *ifl;
+
+	if (cnt < 2)
+		return -2;
+
+	MAKE_CFLIST(ifl, IACONF_PIF, xstrdup(varr[1]), NULL);
+
+	if (add_cfparam(ifl))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_prefiff(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+	case 0: /* sla-id */
+		MAKE_CFLIST(l, IFPARAM_SLA_ID, xstrdup(varr[1]), NULL);
+		break;
+	case 1: /* sla-len */
+		MAKE_CFLIST(l, IFPARAM_SLA_LEN, xstrdup(varr[1]), NULL);
+		break;
+	default:
+		return -1;
+	}
+	if (add_cfsubparam(l, client6_config.config_list->sublist->tail))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_assoc(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	struct dhcp6_prefix *pconf;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* address */
+			MAKE_CFLIST(l, IACONF_ADDR, NULL, NULL);
+			break;
+		case 1: /* prefix */
+			MAKE_CFLIST(l, IACONF_PREFIX, NULL, NULL);
+			break;
+		default:
+			return -1;
+	}
+	pconf = xzalloc(sizeof(*pconf));
+	if (inet_pton(AF_INET6, varr[1], &pconf->addr) != 1) {
+		bb_error_msg("invalid IPv6 address: %s", varr[1]);
+				free(pconf);
+				return -1;
+	}
+	/* validate other parameters later */
+	pconf->plen = 128; /* XXX this field is ignored */
+	if (cnt < 3) {
+		pconf->pltime = DHCP6_DURATION_INFINITE;
+	} else {
+		pconf->pltime = xatoul(varr[2]);
+		if (cnt < 4)
+			pconf->vltime = DHCP6_DURATION_INFINITE;
+		else
+			pconf->vltime = xatoul(varr[3]);
+	}
+	l->ptr = (void *)pconf;
+
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int FAST_FUNC create_auth(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_AUTHINFO, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC create_keyinfo(int lineno, int kw_ind UNUSED_PARAM, char **varr, int cnt)
+{
+	if (cnt < 2)
+		return -2;
+
+	if (add_cflevel0(DECL_KEYINFO, varr[1], lineno))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_auth(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* protocol */
+			MAKE_CFLIST(l, AUTHPARAM_PROTO, xstrdup(varr[1]), NULL);
+			break;
+		case 1: /* algorithm */
+			MAKE_CFLIST(l, AUTHPARAM_ALG, xstrdup(varr[1]), NULL);
+			break;
+		case 2: /* rdm */
+			MAKE_CFLIST(l, AUTHPARAM_RDM, xstrdup(varr[1]), NULL);
+			break;
+		default:
+			return -1;
+	}
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+
+static int FAST_FUNC parse_keyinfo(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return -2;
+
+	switch (kw_ind) {
+		case 0: /* realm */
+			MAKE_CFLIST(l, KEYPARAM_REALM, xstrdup(varr[1]), NULL);
+			break;
+		case 1: /* keyid */
+			MAKE_CFLIST(l, KEYPARAM_KEYID, xstrdup(varr[1]), NULL);
+			break;
+		case 2: /* secret */
+			MAKE_CFLIST(l, KEYPARAM_SECRET, qstrdup(varr[1]), NULL);
+			break;
+		case 3: /* expire */
+			MAKE_CFLIST(l, KEYPARAM_EXPIRE, xstrdup(varr[1]), NULL);
+			break;
+		default:
+			return -1;
+	}
+	if (add_cfparam(l))
+		return -1;
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+struct config_keyword;
+
+struct config_keyword {
+	const char *keyword;
+	const struct config_keyword *next_level;
+
+	int (*handler)(int lineno, int kw_ind, char **varr, int cnt) FAST_FUNC;
+};
+
+static const struct config_keyword interface_kw[] = {
+ { "send",             NULL,          &parse_iface    },
+ { "request",          NULL,          &parse_iface    },
+ { "script",           NULL,          &parse_iface    },
+ { "information-only", NULL,          &parse_iface    },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword prefiff_kw[] = {
+ { "sla-id",           NULL,          &parse_prefiff  },
+ { "sla-len",          NULL,          &parse_prefiff  },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword assoc_kw[] = {
+ { "address",          NULL,          &parse_assoc    },
+ { "prefix",           NULL,          &parse_assoc    },
+ { "prefix-interface", prefiff_kw,    &create_prefiff },
+ { NULL,               NULL,          NULL },
+};
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static const struct config_keyword auth_kw[] = {
+ { "protocol",         NULL,          &parse_auth     },
+ { "algorithm",        NULL,          &parse_auth     },
+ { "rdm",              NULL,          &parse_auth     },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword keyinfo_kw[] = {
+ { "realm",            NULL,          &parse_keyinfo  },
+ { "keyid",            NULL,          &parse_keyinfo  },
+ { "secret",           NULL,          &parse_keyinfo  },
+ { "expire",           NULL,          &parse_keyinfo  },
+ { NULL,               NULL,          NULL },
+};
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const struct config_keyword level0_kw[] = {
+ { "interface",        interface_kw,  &create_iface   },
+ { "id-assoc",         assoc_kw,      &create_assoc   },
+#if ENABLE_FEATURE_DHCP6_AUTH
+ { "authentication",   auth_kw,       &create_auth    },
+ { "keyinfo",          keyinfo_kw,    &create_keyinfo },
+#endif
+ { NULL,               NULL,          NULL            },
+};
+
+TAILQ_HEAD(keyword6_list, keywords6);
+struct keywords6 {
+	TAILQ_ENTRY(keywords6) link;
+
+	const struct config_keyword *kw;
+};
+
+
+int FAST_FUNC read_config6(const char *file)
+{
+	parser_t *parser;
+	struct keyword6_list kwq_head;
+	struct keywords6 *kl;
+	unsigned i = 0, j, m, n;
+#define MAX_TOKENS	15
+	char *token[MAX_TOKENS];
+	const struct config_keyword *req_next_level = NULL;
+	int ret = 0;
+
+	/* cleanup config int. structures */
+	cleanup_cflist(client6_config.config_list);
+	client6_config.config_list = NULL;
+	TAILQ_INIT(&client6_config.ia_allconflist);
+	clear_keys(client6_config.key_list);
+	client6_config.key_list = NULL;
+	clear_authinfo(client6_config.auth_list);
+	client6_config.auth_list = NULL;
+	clear_ifconf(0);
+
+	/* Phase I - parse & fill-up config int. structures */
+	TAILQ_INIT(&kwq_head);
+	kl = xzalloc(sizeof(*kl));
+	kl->kw = level0_kw;
+	TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+	parser = config_open(file);
+	while ((n = config_read(parser, token, MAX_TOKENS, 1, "# \t,", PARSE_NORMAL))) {
+		const struct config_keyword *k;
+		int was_found;
+
+		kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		i = 0;
+ restart_scan:
+		if (kl == NULL)
+			goto scan_fail;
+		k = kl->kw;
+		j = 0;
+		was_found = 0;
+		/* Just skip alone ';' */
+		if (strcmp(token[i], ";") == 0) {
+			i++;
+		}
+		while (i < n && k[j].keyword != NULL) {
+			if (strcasecmp(token[i], k[j].keyword) == 0) {
+				if (k[j].handler != NULL) {
+					/* scan for ';' statement trailer */
+					char *lc;
+					for (m = i+1; m < n; m++) {
+						if (strcmp(token[m], "{") == 0 || strcmp(token[m], ";") == 0)
+							break;
+						lc = last_char_is(token[m], ';');
+						if (lc) {
+							*lc = '\0';
+							m++;
+							break;
+						}
+					}
+					log3("parse line(%d): token '%s' nargs=%d", parser->lineno, token[i], m-i);
+					if ((*k[j].handler)(parser->lineno, j, &token[i], m-i) < 0)
+						goto scan_fail;
+
+					i = m;
+				} else {
+					i++;
+				}
+				req_next_level = k[j].next_level;
+				was_found = 1;
+				break;
+			}
+			j++;
+		} /* while(keywords scan) */
+
+		if (i >= n)	// EOL
+			continue;
+
+		if (req_next_level != NULL) {
+			if (strcmp(token[i], "{") != 0) {
+				goto scan_fail;
+			}
+			kl = xzalloc(sizeof(*kl));
+			kl->kw = req_next_level;
+			TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+			req_next_level = NULL;
+			if (++i >= n)	// EOL
+				continue;
+			goto restart_scan;
+		}
+		if (strncmp(token[i], "}", 1) == 0) {
+			TAILQ_REMOVE(&kwq_head, kl, link);
+			free(kl);
+			kl = TAILQ_LAST(&kwq_head, keyword6_list);
+			if (++i >= n)	// EOL
+				continue;
+			goto restart_scan;
+		}
+		if (was_found)
+			goto restart_scan;
+
+ scan_fail:
+		bb_error_msg("%s: can't parse line %u near token '%s'", file, parser->lineno, token[i]);
+		break;
+	} /* while(config_read) */
+	config_close(parser);
+	while ((kl = TAILQ_FIRST(&kwq_head)) != NULL) {
+		TAILQ_REMOVE(&kwq_head, kl, link);
+		free(kl);
+	}
+
+	/* Phase II - validations & cross-checks */
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (configure_keys())
+		goto cf_fail;
+
+	if (configure_authinfo())
+		goto cf_fail;
+#endif
+	if (configure_ia())
+		goto cf_fail;
+
+	if (configure_interface())
+		goto cf_fail;
+
+	/* unused IA configurations */
+	if (!TAILQ_EMPTY(&client6_config.ia_allconflist)) {
+		bb_info_msg("some IA defined but not used!");
+	}
+
+ cf_ret:
+	clear_iaconf(&client6_config.ia_allconflist);
+	cleanup_cflist(client6_config.config_list);
+	client6_config.config_list = NULL;
+	return ret;
+
+ cf_fail:
+	ret = -1;
+	goto cf_ret;
+}
diff -urNBp a/networking/udhcp/config6.h b/networking/udhcp/config6.h
--- a/networking/udhcp/config6.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/config6.h	2011-10-31 16:08:11.000000000 +0300
@@ -0,0 +1,246 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+typedef enum {
+	DHCPOPT_IA_NA			= DH6OPT_IA_NA,
+	DHCPOPT_AUTHINFO		= DH6OPT_AUTH,
+	DHCPOPT_RAPID_COMMIT	= DH6OPT_RAPID_COMMIT,
+	DHCPOPT_SIPNAME			= DH6OPT_SIP_SERVER_D,
+	DHCPOPT_SIP				= DH6OPT_SIP_SERVER_A,
+	DHCPOPT_DNS				= DH6OPT_DNS,
+	DHCPOPT_DNSNAME			= DH6OPT_DNSNAME,
+	DHCPOPT_IA_PD			= DH6OPT_IA_PD,
+	DHCPOPT_NIS				= DH6OPT_NIS_SERVERS,
+	DHCPOPT_NISP			= DH6OPT_NISP_SERVERS,
+	DHCPOPT_NISNAME			= DH6OPT_NIS_DOMAIN,
+	DHCPOPT_NISPNAME		= DH6OPT_NISP_DOMAIN,
+	DHCPOPT_SNTP			= DH6OPT_SNTP_SERVERS,
+	DHCPOPT_REFRESHTIME		= DH6OPT_REFRESHTIME,
+	DHCPOPT_BCMCSNAME		= DH6OPT_BCMCS_SERVER_D,
+	DHCPOPT_BCMCS			= DH6OPT_BCMCS_SERVER_A,
+
+	DECL_IFACE = 100, DECL_AUTHINFO, DECL_KEYINFO,
+	DECL_SEND, DECL_REQUEST, DECL_SCRIPT, DECL_INFO_ONLY,
+/* server only start */
+	DECL_ALLOW, DECL_DUID, DECL_PREFIX, DECL_PREFERENCE,
+	DECL_DELAYEDKEY, DECL_ADDRESS, DECL_RANGE, DECL_ADDRESSPOOL,
+/* server only  end  */
+	IACONF_PIF, IACONF_PREFIX, IACONF_ADDR,
+	IFPARAM_SLA_ID, IFPARAM_SLA_LEN,
+	AUTHPARAM_PROTO, AUTHPARAM_ALG, AUTHPARAM_RDM, AUTHPARAM_KEY,
+	KEYPARAM_REALM, KEYPARAM_KEYID, KEYPARAM_SECRET, KEYPARAM_EXPIRE
+} dh6cnfopts_t;
+
+/* definitions of tail-queue types */
+TAILQ_HEAD(ia_conflist, ia_conf);
+TAILQ_HEAD(pifc_list, prefix_ifconf);
+
+struct dhcp6_poolspec {
+	char *name;
+	uint32_t pltime;
+	uint32_t vltime;
+};
+
+struct dhcp6_range {
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+struct pool_conf {
+	struct pool_conf *next;
+
+	char *name;
+
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+/* per-interface information */
+struct dhcp6_if {
+/*	struct dhcp6_if *next;*/
+
+	/* timer for the interface */
+	struct dhcp6_timer *timer;
+
+	/* static parameters of the interface */
+	char *ifname;
+	unsigned int ifid;
+	/* multiple global address configuration is not supported now */
+	struct in6_addr addr; 		/* global address (server only) */
+
+	/* configuration parameters */
+	uint32_t send_flags;
+	uint32_t allow_flags;
+#define DHCIFF_INFO_ONLY    0x1
+#define DHCIFF_RAPID_COMMIT 0x2
+
+	int server_pref;			/* server preference (server only) */
+	struct dhcp6_poolspec pool;	/* address pool (server only) */
+	char *scriptpath;			/* path to config script (client only) */
+
+	struct dhcp6_list reqopt_list;
+	struct ia_conflist iaconf_list;
+
+	/* authentication information */
+	int authproto;				/* protocol */
+	/* the followings are valid only if authproto is not UNDEF */
+	int authalgorithm;			/* algorithm */
+	int authrdm;				/* replay attack detection method */
+};
+
+/* run-time authentication parameters */
+struct authparam {
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	struct keyinfo *key;
+	int flags;
+#define AUTHPARAM_FLAGS_NOPREVRD	0x1
+
+	uint64_t prevrd;			/* previous RD value provided by the peer */
+};
+
+struct dhcp6_event {
+	TAILQ_ENTRY(dhcp6_event) link;
+
+	struct dhcp6_if *ifp;
+	struct dhcp6_timer *timer;
+
+	struct dhcp6_vbuf serverid; /* server DUID */
+
+	unsigned long long t_start; /* timestamp(ms) when the 1st msg is sent */
+
+	/* internal timer parameters */
+	unsigned long retrans;
+	unsigned long init_retrans;
+	long max_retrans_cnt;
+	long max_retrans_time;
+	long max_retrans_dur;
+	int timeouts;				/* number of timeouts */
+
+	uint32_t xid;				/* current transaction ID */
+	int state;
+
+	/* list of known servers */
+	struct dhcp6_serverinfo *current_server;
+	struct dhcp6_serverinfo *servers;
+
+	/* authentication parameters */
+	struct authparam *authparam;
+
+	TAILQ_HEAD(, dhcp6_eventdata) data_list;
+};
+
+struct dhcp6_eventdata {
+	TAILQ_ENTRY(dhcp6_eventdata) link;
+
+	struct dhcp6_event *event;
+	int type;
+	void *data;
+};
+
+struct dhcp6_serverinfo {
+	struct dhcp6_serverinfo *next;
+
+	/* option information provided in the advertisement */
+	struct dhcp6_optinfo optinfo;
+
+	int pref;					/* preference */
+	int active;					/* bool; if this server is active or not */
+
+	struct authparam *authparam; /* authentication parameters */
+
+	/* TODO: remember available information from the server */
+};
+
+struct prefix_ifconf {
+	TAILQ_ENTRY(prefix_ifconf) link;
+
+	char *ifname;		/* interface name such as ne0 */
+	int sla_len;		/* SLA ID length in bits */
+	uint32_t sla_id;	/* need more than 32bits? */
+	int ifid_len;		/* interface ID length in bits */
+	int ifid_type;		/* EUI-64 and manual (unused?) */
+	char ifid[16];		/* Interface ID, up to 128bits */
+};
+#define IFID_LEN_DEFAULT 64
+#define SLA_LEN_DEFAULT  16
+
+struct ia_conf {
+	TAILQ_ENTRY(ia_conf) link;
+
+	int type;
+	uint32_t iaid;
+
+	TAILQ_HEAD(, ia) iadata; /* struct ia is an opaque type */
+
+	/* type dependent values follow */
+	struct dhcp6_list prefix_list;
+	struct pifc_list iapd_pif_list;
+};
+
+struct cf_list;
+struct authinfo;
+
+struct client6_config_t {
+	const char *conffile;
+
+	struct dhcp6_if dhcp6c_if;
+
+	struct ia_conflist ia_allconflist;
+	struct keyinfo *key_list;
+	struct authinfo *auth_list;
+
+	/* config parser internal tree */
+	struct cf_list *config_list;
+
+	/* timer */
+	LIST_HEAD(, dhcp6_timer) timer_head;
+	unsigned long long tm_sentinel;
+	struct timeval tm_check;
+
+	/* event queue */
+	TAILQ_HEAD(, dhcp6_event) event_list;
+} FIX_ALIASING;
+
+#define client6_config (*(struct client6_config_t*)(&bb_common_bufsiz1))
+
+void clear_ifconf(int destroy);
+
+struct prefix_ifconf *find_prefixifconf(char *);
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *, struct dhcp6_prefix *);
+struct ia_conf *find_iaconf(struct ia_conflist *, dh6cnfopts_t, uint32_t);
+struct keyinfo *find_key(struct dhcp6_vbuf *, uint32_t);
+
+int read_config6(const char *file) FAST_FUNC;
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urNBp a/networking/udhcp/Config.src b/networking/udhcp/Config.src
--- a/networking/udhcp/Config.src	2011-10-31 03:00:00.000000000 +0300
+++ b/networking/udhcp/Config.src	2011-10-31 16:08:11.000000000 +0300
@@ -96,7 +96,7 @@ config UDHCP_DEBUG
 	int "Maximum verbosity level for udhcp applets (0..9)"
 	default 9
 	range 0 9
-	depends on UDHCPD || UDHCPC || DHCPRELAY
+	depends on UDHCPD || UDHCPC || DHCPRELAY || DHCP6C
 	help
 	  Verbosity can be increased with multiple -v options.
 	  This option controls how high it can be cranked up.
@@ -107,7 +107,7 @@ config UDHCP_DEBUG
 config FEATURE_UDHCP_RFC3397
 	bool "Support for RFC3397 domain search (experimental)"
 	default y
-	depends on UDHCPD || UDHCPC
+	depends on UDHCPD || UDHCPC || DHCP6C
 	help
 	  If selected, both client and server will support passing of domain
 	  search lists via option 119, specified in RFC 3397,
@@ -159,3 +159,19 @@ config UDHCPC_SLACK_FOR_BUGGY_SERVERS
 	    maximum size of entire IP packet, and sends packets which are
 	    28 bytes too large.
 	  Seednet (ISP) VDSL: sends packets 2 bytes too large.
+
+config DHCP6C
+	bool "DHCPv6 client daemon (dhcp6c)"
+	default n
+	depends on PLATFORM_LINUX && FEATURE_IPV6
+	help
+	  dhcp6c is a DHCPv6 client geared primarily toward embedded systems,
+	  while striving to be fully functional and RFC compliant.
+
+config FEATURE_DHCP6_AUTH
+	bool "Support DHCPv6 messages authentication"
+	default n
+	depends on DHCP6C
+	help
+	  If selected, client will support DHCPv6 messages authentication,
+	  currently HMAC-MD5 only.
diff -urNBp a/networking/udhcp/dhcp6c.c b/networking/udhcp/dhcp6c.c
--- a/networking/udhcp/dhcp6c.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/dhcp6c.c	2011-10-31 16:11:35.000000000 +0300
@@ -0,0 +1,1261 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * DHCPv6 client
+ *
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+
+#include <net/if.h>
+#include <syslog.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "timer.h"
+#include "dhcp6c.h"
+#include "auth6.h"
+
+#define DHCP6C_CONF     "/etc/dhcp6c.conf"
+#define DHCP6C_PIDFILE  "/var/run/dhcp6c.pid"
+#define DUID_FILE       "/var/state/dhcp6c_duid"
+
+struct globals {
+	len_and_sockaddr *sa6_allagent;
+
+	const char *pid_file;
+
+	int csock;	/* inbound/outbound udp port */
+
+	char rbuf[BUFSIZ], sbuf[BUFSIZ];
+
+	struct dhcp6_vbuf client_duid;
+	int duid_type;
+} FIX_ALIASING;
+
+void BUG_dhcp6c_globals_too_big(void);
+#define G (*ptr_to_globals)
+#define csock		(G.csock        )
+#define INIT_G() do { \
+	if (sizeof(struct client6_config_t) > COMMON_BUFSIZE / 2) \
+		BUG_dhcp6c_globals_too_big(); \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	G.pid_file = DHCP6C_PIDFILE; \
+	G.duid_type = 1; \
+} while (0)
+
+
+struct dhcp6_timer *client6_timo(void *arg);
+
+static void client6_init(void);
+static void client6_startall(int isrestart);
+static void client6_mainloop(void);
+static void free_resources(int force);
+static void check_exit(int force);
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *,
+						 struct dhcp6_vbuf *);
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *);
+static void client6_recv(void);
+static int client6_recvadvert(struct dhcp6_if *, struct dhcp6_event *,
+				   struct dhcp6_optinfo *);
+static int client6_recvreply(struct dhcp6_if *, struct dhcp6_event *,
+				  struct dhcp6_optinfo *);
+static struct dhcp6_event *find_event_withid(unsigned int ifid, uint32_t xid);
+static int construct_confdata(struct dhcp6_if *, struct dhcp6_event *);
+static int construct_reqdata(struct dhcp6_if *, struct dhcp6_optinfo *,
+    struct dhcp6_event *);
+static struct dhcp6_timer *client6_expire_refreshtime(void *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int process_auth(struct authparam *, struct dhcp6 *dh6, ssize_t,
+    struct dhcp6_optinfo *);
+static int set_auth(struct dhcp6_event *, struct dhcp6_optinfo *);
+#endif
+
+enum {
+        OPT_FOREGROUND = 1 << 0,
+        OPT_i = 1 << 1,
+        OPT_c = 1 << 2,
+        OPT_D = 1 << 3,
+        OPT_p = 1 << 4,
+        OPT_VERBOSE = 1 << 5,
+};
+
+//usage:#define dhcp6c_trivial_usage
+//usage:       "[-vfi] [-c FILE] [-D LL|LLT] [-p FILE] interface"
+//usage:#define dhcp6c_full_usage "\n"
+//usage:      "\n	-v         Print debugging messages(may be repeated)"
+//usage:      "\n	-f         Foreground mode"
+//usage:      "\n	-i         Info-req(information-only) mode"
+//usage:      "\n	-c FILE    Use FILE as the configuration file"
+//usage:      "\n	-D LL|LLT  Use LL or LLT to override default(LLT) DUID type generation"
+//usage:      "\n	-p FILE    Use FILE to dump the process ID of dhcp6c"
+
+int dhcp6c_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6c_main(int argc UNUSED_PARAM, char **argv)
+{
+	int opt;
+	const char *str_D;
+
+	INIT_G();
+	client6_config.conffile = DHCP6C_CONF;
+
+	srandom(getpid());
+
+	opt_complementary = "=1" IF_UDHCP_VERBOSE(":vv");
+	opt = getopt32(argv, "fic:D:p:v",
+			&client6_config.conffile, &str_D, &G.pid_file
+			IF_UDHCP_VERBOSE(, &dhcp_verbose)
+			);
+	if (opt & OPT_D) {
+		if (strcasecmp(str_D, "LL") == 0)
+			G.duid_type = 3;
+		else if (strcasecmp(str_D, "LLT") == 0)
+			G.duid_type = 1;
+	}
+
+	if (!(opt & OPT_FOREGROUND) && !(opt & OPT_i)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	bb_signals(0 + (1 << SIGHUP) + (1 << SIGTERM) + (1 << SIGQUIT),
+		  record_signo);
+
+	if6init(&client6_config.dhcp6c_if, argv[optind]);
+
+	if (!(opt & OPT_i) && (read_config6(client6_config.conffile)) != 0) {
+		bb_error_msg_and_die("can't parse config");
+	}
+
+	bb_info_msg("started");
+	client6_init();
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	client6_startall(0);
+	client6_mainloop();
+	return 0;
+}
+
+
+/*------------------------------------------------------------*/
+
+void client6_init(void)
+{
+	struct addrinfo hints, *res;
+	int error;
+
+	/* get our DUID */
+	if (get_duid(DUID_FILE, &G.client_duid, G.duid_type)) {
+		bb_error_msg_and_die("can't get a DUID");
+	}
+
+	G.sa6_allagent = xhost_and_af2sockaddr(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, AF_INET6);
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(NULL, xstr(DH6PORT_DOWNSTREAM), &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	csock = sock6_init(res);
+
+	setsockopt_bindtodevice(csock, client6_config.dhcp6c_if.ifname);
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_MULTICAST_LOOP)");
+	}
+
+	dhcp6_timer_init();
+	TAILQ_INIT(&client6_config.event_list);
+}
+
+int client6_start(struct dhcp6_if *ifp)
+{
+	struct dhcp6_event *ev;
+
+	/* make sure that the interface does not have a timer */
+	if (ifp->timer)
+		dhcp6_timer_remove(&ifp->timer);
+
+	/* create an event for the initial delay */
+	ev = dhcp6_create_event(ifp, DHCP6S_INIT);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ev->authparam = new_authparam(ifp->authproto,
+	    ifp->authalgorithm, ifp->authrdm);
+#endif
+
+	dhcp6_reset_timer(ev);
+
+	return 0;
+}
+
+static void client6_startall(int isrestart)
+{
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+
+	if (isrestart) {
+		/* reload the configuration file */
+		if (read_config6(client6_config.conffile))
+			bb_error_msg_and_die("can't parse config");
+
+		ifp->ifid = if_nametoindex(ifp->ifname);
+		if (ifp->ifid == 0)
+			bb_error_msg_and_die("invalid interface(%s)", ifp->ifname);
+	}
+
+	if (client6_start(ifp)) {
+		exit(1); /* initialization failure.  we give up. */
+	}
+}
+
+static void free_resources(int force)
+{
+	struct dhcp6_event *ev, *ev_next;
+
+	/* release all IAs as well as send RELEASE message(s) */
+	release_all_ia(&client6_config.dhcp6c_if);
+
+	/*
+	 * Cancel all outstanding events for each interface except
+	 * ones being released.
+	 */
+	for (ev = TAILQ_FIRST(&client6_config.event_list); ev; ev = ev_next) {
+		ev_next = TAILQ_NEXT(ev, link);
+
+		if (!force && ev->state == DHCP6S_RELEASE)
+			continue; /* keep it for now */
+
+		dhcp6_remove_event(ev);
+	}
+}
+
+static void check_exit(int force)
+{
+	if (!force) {
+		if (!bb_got_signal)
+			return;
+
+		/*
+		 * Check if we have an outstanding event.  If we do, we cannot
+		 * exit for now.
+		 */
+		if (!TAILQ_EMPTY(&client6_config.event_list))
+			return;
+	}
+
+	/* We have no existing event.  Do exit. */
+	bb_info_msg("exiting");
+	free_resources(1);
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		free(G.sa6_allagent);
+		dhcp6_vbuf_free(&G.client_duid);
+		clear_ifconf(1);
+	}
+	remove_pidfile(G.pid_file);
+
+	exit(0);
+}
+
+static void client6_mainloop(void)
+{
+	struct timeval *w;
+	int ret, maxsock;
+	fd_set r;
+
+	while (1) {
+		if (bb_got_signal) {
+			switch (bb_got_signal) {
+			case SIGQUIT:
+			case SIGTERM:
+				check_exit(1);
+				break;
+			case SIGHUP:
+				bb_info_msg("restarting");
+				bb_got_signal = 0;
+				free_resources(0);
+				client6_startall(1);
+				break;
+			}
+		}
+
+		w = dhcp6_timer_check();
+
+		FD_ZERO(&r);
+		FD_SET(csock, &r);
+		maxsock = csock;
+
+		ret = select(maxsock + 1, &r, NULL, NULL, w);
+
+		switch (ret) {
+		case -1:
+			if (errno != EINTR) {
+				bb_perror_msg_and_die("select");
+			}
+			continue;
+		case 0:	/* timeout */
+			break;	/* dhcp6_timer_check() will treat the case */
+		default:
+			break;
+		}
+		if (FD_ISSET(csock, &r))
+			client6_recv();
+	}
+}
+
+static struct dhcp6_timer *client6_expire_refreshtime(void *arg)
+{
+	struct dhcp6_if *ifp = (struct dhcp6_if *)arg;
+
+	log1("information refresh time on %s expired", ifp->ifname);
+
+	dhcp6_timer_remove(&ifp->timer);
+	client6_start(ifp);
+
+	return NULL;
+}
+
+struct dhcp6_timer *client6_timo(void *arg)
+{
+	struct dhcp6_event *ev = (struct dhcp6_event *)arg;
+	struct dhcp6_if *ifp;
+	int state = ev->state;
+
+	ifp = ev->ifp;
+	ev->timeouts++;
+
+	/*
+	 * Unless MRC is zero, the message exchange fails once the client has
+	 * transmitted the message MRC times.
+	 * [RFC3315 14.]
+	 */
+	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
+		bb_info_msg("no responses were received");
+		dhcp6_remove_event(ev);
+
+		if (state == DHCP6S_RELEASE)
+			check_exit(0);
+
+		return NULL;
+	}
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		ev->timeouts = 0; /* indicate to generate a new XID. */
+		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || (option_mask32 & OPT_i)) {
+			ev->state = DHCP6S_INFOREQ;
+		} else {
+			ev->state = DHCP6S_SOLICIT;
+			if (construct_confdata(ifp, ev)) {
+				bb_error_msg_and_die("can't send solicit"); /* XXX */
+			}
+		}
+		dhcp6_set_timeoparam(ev); /* XXX */
+		/* fall through */
+	case DHCP6S_REQUEST:
+	case DHCP6S_RELEASE:
+	case DHCP6S_INFOREQ:
+		client6_send(ev);
+		break;
+	case DHCP6S_RENEW:
+	case DHCP6S_REBIND:
+		if (!TAILQ_EMPTY(&ev->data_list)) {
+			client6_send(ev);
+		} else {
+			bb_info_msg("all information to be updated was canceled");
+			dhcp6_remove_event(ev);
+			return NULL;
+		}
+		break;
+	case DHCP6S_SOLICIT:
+		if (ev->servers) {
+			/*
+			 * Send a Request to the best server.
+			 * Note that when we set Rapid-commit in Solicit,
+			 * but a direct Reply has been delayed (very much),
+			 * the transition to DHCP6S_REQUEST (and the change of
+			 * transaction ID) will invalidate the reply even if it
+			 * ever arrives.
+			 */
+			ev->current_server = select_server(ev);
+			if (ev->current_server == NULL) {
+				/* this should not happen! */
+				bb_error_msg_and_die("can't find a server");
+			}
+			dhcp6_vbuf_copy(&ev->serverid, &ev->current_server->optinfo.serverID);
+			ev->timeouts = 0;
+			ev->state = DHCP6S_REQUEST;
+			dhcp6_set_timeoparam(ev);
+
+			free(ev->authparam);
+			ev->authparam = ev->current_server->authparam;
+			ev->current_server->authparam = NULL;
+
+			if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+				bb_info_msg("can't construct request");
+				break;
+			}
+		}
+		client6_send(ev);
+		break;
+	}
+
+	dhcp6_reset_timer(ev);
+
+	return ev->timer;
+}
+
+static int construct_confdata(struct dhcp6_if *ifp, struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case DH6OPT_IA_PD:
+		case DH6OPT_IA_NA:
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA,
+			    &iaparam, &iac->prefix_list) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("impossible IA type %d", iac->type);
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return 0;
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return -1;
+}
+
+static int construct_reqdata(struct dhcp6_if *ifp, struct dhcp6_optinfo *optinfo,
+		  struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	/* discard previous event data */
+	dhcp6_remove_evdata(ev);
+
+	if (optinfo == NULL)
+		return 0;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		struct dhcp6_listval *lv;
+
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case DH6OPT_IA_PD:
+		case DH6OPT_IA_NA:
+			lv = dhcp6_find_listval(&optinfo->ia_list,
+			    iac->type, &iaparam, MATCHLIST_DH6OPTYPE);
+			if (lv == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA,
+			    &iaparam, &lv->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("impossible IA type %d", iac->type);
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return 0;
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return -1;
+}
+
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	/*
+	 * pick the best server according to RFC3315 Section 17.1.3.
+	 * XXX: we currently just choose the one that is active and has the
+	 * highest preference.
+	 */
+	while (s) {
+		if (s->active) {
+			log1("picked a server (ID: %s)", duidstr(&s->optinfo.serverID));
+			return s;
+		}
+		s = s->next;
+	}
+
+	return NULL;
+}
+
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *ev,
+					 struct dhcp6_vbuf *duid)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	while (s) {
+		if (dhcp6_vbuf_cmp(&s->optinfo.serverID, duid) == 0)
+			return s;
+
+		s = s->next;
+	}
+
+	return NULL;
+}
+
+void client6_send(struct dhcp6_event *ev)
+{
+	struct dhcp6_if *ifp = ev->ifp;
+	struct dhcp6 *dh6 = (struct dhcp6 *)G.sbuf;
+	struct sockaddr_in6 dst;
+	struct dhcp6_optinfo optinfo;
+	ssize_t optlen, len;
+	struct dhcp6_eventdata *evd;
+
+	len = sizeof(*dh6);
+	memset(dh6, 0, len);
+	dh6->dh6_msgtype = ev->state;
+
+	if (ev->timeouts == 0) {
+		/*
+		 * A client SHOULD generate a random number that cannot easily
+		 * be guessed or predicted to use as the transaction ID for
+		 * each new message it sends.
+		 *
+		 * A client MUST leave the transaction-ID unchanged in
+		 * retransmissions of a message. [RFC3315 15.1]
+		 */
+		ev->xid = random() & DH6_XIDMASK;
+		log1("a new XID (%x) is generated",
+		    ev->xid);
+	}
+	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
+	dh6->dh6_xid |= htonl(ev->xid);
+
+	/*
+	 * construct options
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* server ID */
+	switch (ev->state) {
+	case DHCP6S_REQUEST:
+	case DHCP6S_RENEW:
+	case DHCP6S_RELEASE:
+		dhcp6_vbuf_copy(&optinfo.serverID, &ev->serverid);
+		break;
+	}
+
+	/* client ID */
+	dhcp6_vbuf_copy(&optinfo.clientID, &G.client_duid);
+
+	/* rapid commit (in Solicit only) */
+	if (ev->state == DHCP6S_SOLICIT && (ifp->send_flags & DHCIFF_RAPID_COMMIT)) {
+		optinfo.rapidcommit = 1;
+	}
+
+	/* elapsed time */
+	if (ev->timeouts == 0) {
+		ev->t_start = monotonic_ms();
+		optinfo.elapsed_time = 0;
+	} else {
+		long long t_diff;
+
+		t_diff = (monotonic_ms() - ev->t_start) / 10LL;
+		/*
+		 * The client uses the value 0xffff to represent any elapsed
+		 * time values greater than the largest time value that can be
+		 * represented in the Elapsed Time option (hundredths of a second).
+		 * [RFC3315 22.9.]
+		 */
+		if (t_diff > MAX_ELAPSED_TIME) {
+			/*
+			 * Perhaps we are nervous too much, but without this
+			 * additional check, we would see an overflow in 248
+			 * days (of no responses).
+			 */
+			t_diff = MAX_ELAPSED_TIME;
+		}
+		optinfo.elapsed_time = (int32_t )t_diff;
+	}
+
+	/* option request options */
+	if (ev->state != DHCP6S_RELEASE &&
+	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
+		bb_error_msg("can't copy requested options");
+		goto end;
+	}
+
+	/* configuration information specified as event data */
+	evd = TAILQ_FIRST(&ev->data_list);
+	while (evd) {
+		if (dhcp6_copy_list(&optinfo.ia_list, (struct dhcp6_list *)evd->data)) {
+			bb_info_msg("can't add IA");
+			goto end;
+		}
+		evd = TAILQ_NEXT(evd, link);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication information */
+	if (set_auth(ev, &optinfo)) {
+		goto end;
+	}
+#endif
+
+	/* set options in the message */
+	optlen = dhcp6_set_options(dh6->dh6_msgtype,
+	    (struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)(G.sbuf + sizeof(G.sbuf)), &optinfo);
+	if (optlen < 0) {
+		bb_error_msg("can't construct options");
+		goto end;
+	}
+	len += optlen;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* calculate MAC if necessary, and put it to the message */
+	if (ev->authparam != NULL) {
+		switch (ev->authparam->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			if (ev->authparam->key == NULL)
+				break;
+
+			if (dhcp6_calc_mac((char *)dh6, len,
+					optinfo.authproto, optinfo.authalgorithm,
+					optinfo.delayedauth_offset + sizeof(*dh6),
+					ev->authparam->key)) {
+				bb_error_msg("can't calculate MAC");
+				goto end;
+			}
+			break;
+		default:
+			break;	/* do nothing */
+		}
+	}
+#endif
+
+	/*
+	 * Unless otherwise specified in this document or in a document that
+	 * describes how IPv6 is carried over a specific type of link (for link
+	 * types that do not support multicast), a client sends DHCP messages
+	 * to the All_DHCP_Relay_Agents_and_Servers.
+	 * [RFC3315 Section 13.]
+	 */
+	dst = G.sa6_allagent->u.sin6;
+	dst.sin6_scope_id = ifp->ifid;
+
+	if (sendto(csock, G.sbuf, len, 0, (struct sockaddr *)&dst,
+			sizeof(dst)) == -1) {
+		bb_perror_msg("sendto");
+		goto end;
+	}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	{
+		char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&dst);
+		log1("send %s to %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+	}
+#endif
+
+ end:
+	dhcp6_clear_options(&optinfo);
+}
+
+static void client6_recv(void)
+{
+	struct sockaddr_in6 from;
+	unsigned int to_ifid;
+	struct dhcp6_if *ifp = &client6_config.dhcp6c_if;
+	struct dhcp6_optinfo optinfo;
+	ssize_t len;
+	struct dhcp6 *dh6 = (struct dhcp6 *)G.rbuf;
+	struct dhcp6_event *ev;
+	char *a;
+
+	len = recv_from6(csock, G.rbuf, sizeof(G.rbuf), &from, &to_ifid);
+	if (len < 0)
+		return;
+
+	if (ifp->ifid != to_ifid) {
+		char ifname[IFNAMSIZ];
+
+		bb_info_msg("unexpected interface (%s)", if_indextoname(to_ifid, ifname));
+		return;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+	log1("receive %s from %s on %s", dhcp6msgstr(dh6->dh6_msgtype),
+		a, ifp->ifname);
+
+	if (dh6->dh6_msgtype != DH6_ADVERTISE && dh6->dh6_msgtype != DH6_REPLY) {
+		bb_info_msg("received an unexpected message (%s) from %s",
+			dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+		return;
+	}
+
+	/* get options */
+	dhcp6_init_options(&optinfo);
+	if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)((char *)dh6 + len), &optinfo) < 0) {
+		bb_info_msg("can't parse options");
+		goto fail;
+	}
+
+	/* find the corresponding event based on the received xid */
+	ev = find_event_withid(ifp->ifid, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
+	if (ev == NULL) {
+		bb_error_msg("XID mismatch");
+		goto fail;
+	}
+
+	/* packet validation based on Section 15.3 of RFC3315. */
+	if (optinfo.serverID.dv_len == 0) {
+		bb_error_msg("no server ID option");
+		goto fail;
+	}
+
+	if (optinfo.clientID.dv_len == 0) {
+		bb_error_msg("no client ID option");
+		goto fail;
+	}
+	/*
+	 * DUID in the Client ID option (which must be contained for our
+	 * client implementation) must match ours.
+	 */
+	if (dhcp6_vbuf_cmp(&optinfo.clientID, &G.client_duid)) {
+		bb_error_msg("client DUID mismatch");
+		goto fail;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* validate authentication */
+	if (process_auth(ev->authparam, dh6, len, &optinfo)) {
+		bb_error_msg("auth fail");
+		goto fail;
+	}
+#endif
+
+	switch (dh6->dh6_msgtype) {
+	case DH6_ADVERTISE:
+		client6_recvadvert(ifp, ev, &optinfo);
+		break;
+	case DH6_REPLY:
+		client6_recvreply(ifp, ev, &optinfo);
+		break;
+	}
+
+fail:
+	dhcp6_clear_options(&optinfo);
+	free(a);
+	return;
+}
+
+static int client6_recvadvert(struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_serverinfo *newserver, **sp;
+	struct dhcp6_eventdata *evd;
+
+	/*
+	 * The requesting router MUST ignore any Advertise message that
+	 * includes a Status Code option containing the value NoPrefixAvail
+	 * [RFC3633 Section 11.1].
+	 * Likewise, the client MUST ignore any Advertise message that includes
+	 * a Status Code option containing the value NoAddrsAvail.
+	 * [RFC3315 Section 17.1.3].
+	 * We only apply this when we are going to request an address or
+	 * a prefix.
+	 */
+	TAILQ_FOREACH(evd, &ev->data_list, link) {
+		uint16_t stcode;
+		const char *stcodestr;
+
+		switch (evd->type) {
+		case DH6OPT_IA_PD:
+			stcode = DH6OPT_STCODE_NOPREFIXAVAIL;
+			stcodestr = "NoPrefixAvail";
+			break;
+		case DH6OPT_IA_NA:
+			stcode = DH6OPT_STCODE_NOADDRSAVAIL;
+			stcodestr = "NoAddrsAvail";
+			break;
+		default:
+			continue;
+		}
+		if (dhcp6_find_listval(&optinfo->stcode_list,
+		    DHCP6_LISTVAL_NUM16, &stcode, 0)) {
+			bb_error_msg("advertise contains %s status", stcodestr);
+			return -1;
+		}
+	}
+
+	if (ev->state != DHCP6S_SOLICIT ||
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) || (option_mask32 & OPT_i)) {
+		/*
+		 * We expected a reply message, but do actually receive an
+		 * Advertise message.  The server should be configured not to
+		 * allow the Rapid Commit option.
+		 * We process the message as if we expected the Advertise.
+		 * [RFC3315 Section 17.1.4]
+		 */
+		bb_info_msg("unexpected advertise");
+		/* proceed anyway */
+	}
+
+	/* ignore the server if it is known */
+	if (find_server(ev, &optinfo->serverID)) {
+		bb_info_msg("duplicated server (ID: %s)", duidstr(&optinfo->serverID));
+		return -1;
+	}
+
+	/* keep the server */
+	newserver = xzalloc(sizeof(*newserver));
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* remember authentication parameters */
+	newserver->authparam = ev->authparam;
+
+	/* allocate new authentication parameter for the soliciting event */
+	ev->authparam = new_authparam(ev->authparam->authproto,
+		ev->authparam->authalgorithm, ev->authparam->authrdm);
+#endif
+
+	/* copy options */
+	dhcp6_init_options(&newserver->optinfo);
+	dhcp6_copy_options(&newserver->optinfo, optinfo);
+	if (optinfo->pref != DH6OPT_PREF_UNDEF)
+		newserver->pref = optinfo->pref;
+	newserver->active = 1;
+	for (sp = &ev->servers; *sp; sp = &(*sp)->next) {
+		if ((*sp)->pref != DH6OPT_PREF_MAX && (*sp)->pref < newserver->pref) {
+			break;
+		}
+	}
+	newserver->next = *sp;
+	*sp = newserver;
+
+	if (newserver->pref == DH6OPT_PREF_MAX) {
+		/*
+		 * If the client receives an Advertise message that includes a
+		 * Preference option with a preference value of 255, the client
+		 * immediately begins a client-initiated message exchange.
+		 * [RFC3315 Section 17.1.2]
+		 */
+		ev->current_server = newserver;
+		dhcp6_vbuf_copy(&ev->serverid, &ev->current_server->optinfo.serverID);
+		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+			bb_info_msg("can't construct request");
+			return -1; /* XXX */
+		}
+
+		ev->timeouts = 0;
+		ev->state = DHCP6S_REQUEST;
+
+		free(ev->authparam);
+		ev->authparam = newserver->authparam;
+		newserver->authparam = NULL;
+
+		client6_send(ev);
+
+		dhcp6_set_timeoparam(ev);
+		dhcp6_reset_timer(ev);
+	} else if (ev->servers->next == NULL) {
+		unsigned long long elapsed, timo;
+
+		/*
+		 * If this is the first advertise, adjust the timer so that
+		 * the client can collect other servers until IRT elapses.
+		 */
+		elapsed = ev->retrans - dhcp6_timer_rest(ev->timer);
+		if (elapsed <= ev->init_retrans)
+			timo = ev->init_retrans - elapsed;
+		else
+			timo = 0;
+
+		log1("reset timer for %s to %d.%03d",
+		    ifp->ifname, (int )(timo/1000ULL), (int )(timo%1000ULL));
+
+		dhcp6_timer_set(timo, ev->timer);
+	}
+
+	return 0;
+}
+
+static int client6_recvreply(struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_listval *lv;
+	int state;
+
+	state = ev->state;
+	if (state != DHCP6S_INFOREQ &&
+	    state != DHCP6S_REQUEST &&
+	    state != DHCP6S_RENEW &&
+	    state != DHCP6S_REBIND &&
+	    state != DHCP6S_RELEASE &&
+	    (state != DHCP6S_SOLICIT || !(ifp->send_flags & DHCIFF_RAPID_COMMIT))
+	   ) {
+		bb_info_msg("unexpected reply");
+		return -1;
+	}
+
+	/*
+	 * If the client included a Rapid Commit option in the Solicit message,
+	 * the client discards any Reply messages it receives that do not
+	 * include a Rapid Commit option.
+	 * (should we keep the server otherwise?)
+	 * [RFC3315 Section 17.1.4]
+	 */
+	if (state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) && !optinfo->rapidcommit) {
+		bb_info_msg("no rapid commit");
+		return -1;
+	}
+
+	/*
+	 * The client MAY choose to report any status code or message from the
+	 * status code option in the Reply message.
+	 * [RFC3315 Section 18.1.8]
+	 */
+	TAILQ_FOREACH(lv, &optinfo->stcode_list, link) {
+		bb_info_msg("status code: %s", dhcp6stcodestr(lv->val_num16));
+	}
+
+	/*
+	 * Set refresh timer for configuration information specified in
+	 * information-request.  If the timer value is specified by the server
+	 * in an information refresh time option, use it; use the protocol
+	 * default otherwise.
+	 */
+	if (state == DHCP6S_INFOREQ) {
+		unsigned long long refreshtime = DHCP6_IRT_DEFAULT;
+
+		if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF)
+			refreshtime = optinfo->refreshtime;
+
+		ifp->timer = dhcp6_timer_add(client6_expire_refreshtime, ifp);
+
+		if (refreshtime > 0x7fffffffULL) {
+			/*
+			 * XXX: tv_sec can overflow for an
+			 * unsigned 32bit value.
+			 */
+			bb_info_msg("refresh time is too large: %llu", refreshtime);
+			refreshtime = 0x7fffffffULL;
+		}
+		refreshtime *= 1000ULL;
+		dhcp6_timer_set(refreshtime, ifp->timer);
+
+	} else if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		/*
+		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
+		 * is only used for information-request and reply exchanges.
+		 */
+		bb_info_msg("unexpected information refresh time option (ignored)");
+	}
+
+	/* update stateful configuration information */
+	if (state != DHCP6S_RELEASE) {
+		update_ia(&optinfo->ia_list, ifp, &optinfo->serverID, ev->authparam);
+	}
+
+	/*
+	 * Call the configuration script, if specified, to handle various
+	 * configuration parameters.
+	 */
+	if (ifp->scriptpath != NULL) {
+		log1("executes %s", ifp->scriptpath);
+		dhcp6_script(ifp->scriptpath, fill_envp_client6(optinfo, ifp->ifname));
+	}
+
+	dhcp6_remove_event(ev);
+
+	if (state == DHCP6S_RELEASE) {
+		/*
+		 * When the client receives a valid Reply message in response
+		 * to a Release message, the client considers the Release event
+		 * completed, regardless of the Status Code option(s) returned
+		 * by the server.
+		 * [RFC3315 Section 18.1.8]
+		 */
+		check_exit(0);
+	}
+
+	log1("got an expected reply, sleeping");
+
+	if (option_mask32 & OPT_i) {
+		check_exit(1);
+	}
+	return 0;
+}
+
+static struct dhcp6_event *find_event_withid(unsigned int ifid, uint32_t xid)
+{
+	struct dhcp6_event *ev;
+
+	TAILQ_FOREACH(ev, &client6_config.event_list, link) {
+		if (ev->xid == xid && ev->ifp->ifid == ifid)
+			return ev;
+	}
+
+	return NULL;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int
+process_auth(struct authparam *authparam, struct dhcp6 *dh6, ssize_t len,
+	     struct dhcp6_optinfo *optinfo)
+{
+	struct keyinfo *key = NULL;
+	int authenticated = 0;
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF:
+		/* server did not provide authentication option */
+		break;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			bb_info_msg("server did not include authentication information");
+			break;
+		}
+
+		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
+			bb_info_msg("unknown authentication algorithm: %d",
+				 optinfo->authalgorithm);
+			break;
+		}
+
+		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+			bb_info_msg("unsupported replay detection method (%d)",
+				optinfo->authrdm);
+			break;
+		}
+
+		/*
+		 * Replay protection.  If we do not know the previous RD value,
+		 * we accept the message anyway (XXX).
+		 */
+		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
+			bb_info_msg("previous RD value is unknown (accept it)");
+		} else {
+			if (dhcp6_auth_replaycheck(optinfo->authrdm,
+			    authparam->prevrd, optinfo->authrd)) {
+				bb_info_msg("possible replay attack detected");
+				break;
+			}
+		}
+
+		/* identify the secret key */
+		key = authparam->key;
+		if (key != NULL) {
+			/*
+			 * If we already know a key, its identification should
+			 * match that contained in the received option.
+			 * (from Section 21.4.5.1 of RFC3315)
+			 */
+			if (optinfo->delayedauth_keyid != key->keyid ||
+				dhcp6_vbuf_cmp(&optinfo->authinfo.aiu_delayed.realm,
+							   &key->realm) != 0) {
+				bb_error_msg("authentication key mismatch");
+				break;
+			}
+		} else {
+			key = find_key(&optinfo->authinfo.aiu_delayed.realm,
+			    optinfo->delayedauth_keyid);
+			if (key == NULL) {
+				bb_error_msg("can't find server key (ID: %x)",
+				    optinfo->delayedauth_keyid);
+				break;
+			} else {
+				log1("found key for authentication: %s", key->name);
+			}
+			authparam->key = key;
+		}
+
+		/* check for the key lifetime */
+		if (dhcp6_validate_key(key)) {
+			bb_error_msg("auth key %s has expired", key->name);
+			break;
+		}
+
+		/* validate MAC */
+		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
+		    optinfo->authalgorithm,
+		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
+			log1("message authentication validated");
+			authenticated = 1;
+		} else {
+			bb_error_msg("invalid message authentication");
+		}
+
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+			 optinfo->authproto);
+		break;
+	}
+
+	if (authenticated == 0) {
+		if (authparam->authproto != DHCP6_AUTHPROTO_UNDEF) {
+			bb_error_msg("message not authenticated "
+			    "while authentication required");
+
+			/*
+			 * Right now, we simply discard unauthenticated
+			 * messages.
+			 */
+			return -1;
+		}
+	} else {
+		/* if authenticated, update the "previous" RD value */
+		authparam->prevrd = optinfo->authrd;
+		authparam->flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+	}
+
+	return 0;
+}
+
+static int set_auth(struct dhcp6_event *ev, struct dhcp6_optinfo *optinfo)
+{
+	struct authparam *authparam = ev->authparam;
+
+	if (authparam == NULL)
+		return 0;
+
+	optinfo->authproto = authparam->authproto;
+	optinfo->authalgorithm = authparam->authalgorithm;
+	optinfo->authrdm = authparam->authrdm;
+
+	switch (authparam->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF: /* we simply do not need authentication */
+		return 0;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if (ev->state == DHCP6S_INFOREQ) {
+			/*
+			 * In the current implementation, delayed
+			 * authentication for Information-request and Reply
+			 * exchanges doesn't work.  Specification is also
+			 * unclear on this usage.
+			 */
+			bb_info_msg("delayed authentication "
+			    "cannot be used for Information-request yet");
+			return -1;
+		}
+
+		if (ev->state == DHCP6S_SOLICIT) {
+			optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+			return 0; /* no auth information is needed */
+		}
+
+		if (authparam->key == NULL) {
+			bb_error_msg("no authentication key");
+			return -1;
+		}
+
+		if (dhcp6_validate_key(authparam->key)) {
+			bb_error_msg("auth key %s is invalid", authparam->key->name);
+			return -1;
+		}
+
+		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd)) {
+			return -1;
+		}
+
+		optinfo->delayedauth_keyid = authparam->key->keyid;
+		dhcp6_vbuf_copy(&optinfo->authinfo.aiu_delayed.realm,
+			&authparam->key->realm);
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+		    authparam->authproto);
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH*/
diff -urNBp a/networking/udhcp/dhcp6c.h b/networking/udhcp/dhcp6c.h
--- a/networking/udhcp/dhcp6c.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/dhcp6c.h	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,44 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+#define MAX_ELAPSED_TIME 0xffff
+
+/* dhcp6c.c */
+int client6_start(struct dhcp6_if *);
+void client6_send(struct dhcp6_event *);
+
+/* dhcp6c_ia.c */
+void update_ia(struct dhcp6_list *iahead, struct dhcp6_if *ifp,
+		struct dhcp6_vbuf *serverid, struct authparam *);
+void release_all_ia(struct dhcp6_if *);
+
+POP_SAVED_FUNCTION_VISIBILITY
diff -urNBp a/networking/udhcp/dhcp6c_ia.c b/networking/udhcp/dhcp6c_ia.c
--- a/networking/udhcp/dhcp6c_ia.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/dhcp6c_ia.c	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,893 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <netinet/in.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "timer.h"
+#include "dhcp6c.h"
+
+typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND} iastate_t;
+
+TAILQ_HEAD(iaprefix_list, iaprefix);
+
+struct iaprefix {
+	TAILQ_ENTRY(iaprefix) link;
+
+	struct dhcp6_prefix pa;
+	time_t updatetime;
+	struct dhcp6_timer *timer;
+	struct iactl *ctl;
+
+	union {
+		TAILQ_HEAD(, dhcp6_ifprefix) ifprefix_list; /* interface prefixes */
+		struct dhcp6_if *dhcpif;
+	} u;
+};
+
+struct ia {
+	TAILQ_ENTRY(ia) link;
+
+	/* back pointer to configuration */
+	struct ia_conf *conf;
+
+	/* common parameters of IA */
+	uint32_t t1;				/* duration for renewal */
+	uint32_t t2;				/* duration for rebind  */
+
+	/* internal parameters for renewal/rebinding */
+	iastate_t state;
+	struct dhcp6_timer *timer;
+
+	/* DHCP related parameters */
+	struct dhcp6_if *ifp;		/* DHCP interface */
+	struct dhcp6_vbuf serverid; /* the server ID that provided this IA */
+
+	/* control information shared with each particular config routine */
+	struct iactl *ctl;
+
+	/* authentication parameters for transaction with servers on this IA */
+	struct authparam *authparam;
+};
+
+struct iactl {
+	struct ia *iactl_ia;		/* back pointer to IA */
+
+	int type;
+
+	struct pifc_list *pifc_head;
+	struct iaprefix_list iaprefix_head;
+};
+
+struct dhcp6_ifprefix {
+	TAILQ_ENTRY(dhcp6_ifprefix) plink;
+
+	/* interface configuration */
+	struct prefix_ifconf *ifconf;
+
+	/* interface prefix parameters */
+	struct in6_addr paddr;
+	int plen;
+
+	/* address assigned on the interface based on the prefix */
+	struct in6_addr ifaddr;
+};
+
+
+void destruct_iadata(struct dhcp6_eventdata *evd);
+
+static int prepare_iaevent(struct ia *, int);
+static int reestablish_ia(struct ia *);
+static void remove_ia(struct ia *);
+static struct ia *get_ia(struct dhcp6_if *, struct ia_conf *,
+    struct dhcp6_listval *, struct dhcp6_vbuf *);
+static struct dhcp6_timer *ia_timo(void *);
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t);
+#endif
+
+static int update_prefix6(struct ia *, struct dhcp6_listval *,
+        struct pifc_list *, struct dhcp6_if *, struct iactl **);
+static struct iaprefix *find_iaprefix(struct iaprefix_list *,
+    struct dhcp6_prefix *, int);
+static int remove_iaprefix(struct iaprefix *, int);
+
+static int iapref_renew(struct iactl *, struct dhcp6_ia *,
+        struct dhcp6_eventdata *);
+static ALWAYS_INLINE int pref_isvalid(struct iactl *);
+static uint32_t pref_duration(struct iactl *);
+static void pref_cleanup(struct iactl *);
+static struct dhcp6_timer *iapref_timo(void *);
+static int add_ifprefix(struct iaprefix *,
+    struct dhcp6_prefix *, struct prefix_ifconf *);
+
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static struct authparam *copy_authparam(struct authparam *authparam) RETURNS_MALLOC;
+
+static struct authparam *copy_authparam(struct authparam *authparam)
+{
+	struct authparam *dst = malloc_or_warn(sizeof(*dst));
+
+	if (dst == NULL)
+		return NULL;
+
+	memcpy(dst, authparam, sizeof(*dst));
+
+	return dst;
+}
+
+static int update_authparam(struct ia *ia, struct authparam *authparam)
+{
+	if (authparam == NULL)
+		return 0;
+
+	if (ia->authparam == NULL) {
+		ia->authparam = copy_authparam(authparam);
+		if (ia->authparam == NULL) {
+			return -1;
+		}
+		return 0;
+	}
+
+	/* update the previous RD value and flags */
+	ia->authparam->prevrd = authparam->prevrd;
+	ia->authparam->flags = authparam->flags;
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+void update_ia(struct dhcp6_list *iahead, struct dhcp6_if *ifp,
+	  struct dhcp6_vbuf *serverid,
+	  struct authparam *authparam IF_NOT_FEATURE_DHCP6_AUTH(UNUSED_PARAM))
+{
+	struct ia *ia;
+	struct ia_conf *iac;
+	struct dhcp6_listval *iav, *siav;
+
+	TAILQ_FOREACH(iav, iahead, link) {
+		/* if we're not interested in this IA, ignore it. */
+		iac = find_iaconf(&ifp->iaconf_list, iav->dh6optype, iav->val_ia.iaid);
+		if (iac == NULL)
+			continue;
+
+		/* validate parameters */
+		/*
+		 * If a client receives an IA_NA with T1 greater than T2, and
+		 * both T1 and T2 are greater than 0, the client discards the
+		 * IA_NA option and processes the remainder of the message as
+		 * though the server had not included the invalid IA_NA option.
+		 * [RFC3315 22.4]
+		 * We apply the same rule to IA_PD as well.
+		 */
+		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
+			bb_info_msg("invalid IA: T1(%u) > T2(%u)",
+			    iav->val_ia.t1, iav->val_ia.t2);
+			continue;
+		}
+
+		/* locate the local IA or make a new one */
+		ia = get_ia(ifp, iac, iav, serverid);
+		if (ia == NULL)
+			continue;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		/* update authentication parameters */
+		if (update_authparam(ia, authparam)) {
+			bb_info_msg("can't update authentication param for %s, ID: %u",
+				dhcp6optstr(iac->type), iac->iaid);
+			remove_ia(ia);
+			continue;
+		}
+#endif
+
+		/* update IA configuration information */
+		TAILQ_FOREACH(siav, &iav->sublist, link) {
+			char p[INET6_ADDRSTRLEN];
+
+			switch (siav->lvtype) {
+			case DHCP6_LISTVAL_PREFIX6:
+				/* add or update the prefix */
+				if (update_prefix6(ia, siav, &iac->iapd_pif_list, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_prefix6.addr);
+					bb_error_msg("can't update a prefix %s/%d",
+					    p, siav->val_prefix6.plen);
+				}
+				break;
+			case DHCP6_LISTVAL_STATEFULADDR6:
+				if (update_prefix6(ia, siav, NULL, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_statefuladdr6.addr);
+					bb_error_msg("can't update an address %s", p);
+				}
+				break;
+			case DHCP6_LISTVAL_NUM16:
+				bb_info_msg("status code for %s-%u: %s",
+				    dhcp6optstr(iav->dh6optype), iav->val_ia.iaid,
+				    dhcp6stcodestr(siav->val_num16));
+				if ((ia->state == IAS_RENEW || ia->state == IAS_REBIND) &&
+				    siav->val_num16 == DH6OPT_STCODE_NOBINDING) {
+					/*
+					 * For each IA in the original Renew or
+					 * Rebind message, the client
+					 * sends a Request message if the IA
+					 * contained a Status Code option
+					 * with the NoBinding status.
+					 * [RFC3315 18.1.8]
+					 * XXX: what about the PD case?
+					 */
+					bb_info_msg("receive NoBinding against "
+					    "renew/rebind for %s-%u",
+					    dhcp6optstr(ia->conf->type), ia->conf->iaid);
+					reestablish_ia(ia);
+					goto nextia;
+				}
+				break;
+			default:
+				bb_error_msg("impossible subopt");
+				goto nextia;
+			}
+		}
+
+		/* see if this IA is still valid.  if not, remove it. */
+		if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+			log1("%s-%u invalidated",
+				dhcp6optstr(ia->conf->type), ia->conf->iaid);
+			remove_ia(ia);
+			continue;
+		}
+
+		/* if T1 or T2 is 0, determine appropriate values locally. */
+		if (ia->t1 == 0 || ia->t2 == 0) {
+			uint32_t duration;
+
+			if (ia->ctl)
+				duration = pref_duration(ia->ctl);
+			else
+				duration = 1800; /* 30min. XXX: no rationale */
+
+			if (ia->t1 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t1 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t1 = duration / 2;
+			}
+			if (ia->t2 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t2 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t2 = duration * 4 / 5;
+			}
+
+			/* make sure T1 <= T2 */
+			if (ia->t1 > ia->t2)
+				ia->t1 = ia->t2 * 5 / 8;
+
+			bb_info_msg("T1(%u) and/or T2(%u) is locally determined",
+						ia->t1, ia->t2);
+		}
+
+		/*
+		 * Be proactive for too-small timeout values.  Note that
+		 * the adjusted values may make some information expire
+		 * without renewal.
+		 */
+		if (ia->t2 < DHCP6_DURATION_MIN) {
+			bb_info_msg("T1 (%u) or T2 (%u) is too small", ia->t1, ia->t2);
+			ia->t2 = DHCP6_DURATION_MIN;
+			ia->t1 = ia->t2 * 5 / 8;
+			bb_info_msg(" adjusted to %u and %u", ia->t1, ia->t2);
+		}
+
+		/* set up a timer for this IA. */
+		if (ia->t1 == DHCP6_DURATION_INFINITE) {
+			if (ia->timer) {
+				dhcp6_timer_remove(&ia->timer);
+			}
+		} else {
+			if (ia->timer == NULL) {
+				ia->timer = dhcp6_timer_add(ia_timo, ia);
+			}
+			dhcp6_timer_set(ia->t1 * 1000ULL, ia->timer);
+		}
+
+		ia->state = IAS_ACTIVE;
+
+	  nextia:
+		;
+	}
+}
+
+static int prepare_iaevent(struct ia *ia, int dhcpstate)
+{
+	struct dhcp6_event *ev;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_eventdata *evd;
+
+	ev = dhcp6_create_event(ia->ifp, dhcpstate);
+
+	if (dhcpstate == DHCP6S_RELEASE ||
+	    dhcpstate == DHCP6S_REQUEST ||
+	    dhcpstate == DHCP6S_RENEW
+	   ) {
+		dhcp6_vbuf_copy(&ev->serverid, &ia->serverid);
+	}
+
+	evd = xzalloc(sizeof(*evd));
+	evd->event = ev;
+	memset(&iaparam, 0, sizeof(iaparam));
+	iaparam.iaid = ia->conf->iaid;
+	/* XXX: should we set T1/T2 to 0 on release?  spec is silent on this. */
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+
+	if (ia->ctl && iapref_renew(ia->ctl, &iaparam, evd)) {
+		bb_error_msg("can't prepare IA data");
+			goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (ia->authparam != NULL) {
+		ev->authparam = copy_authparam(ia->authparam);
+		if (ev->authparam == NULL) {
+			goto fail;
+		}
+	}
+#endif
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	client6_send(ev);
+	return 0;
+
+fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+	return -1;
+}
+
+static int reestablish_ia(struct ia *ia)
+{
+
+	log1("re-establishing %s-%u",
+			dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
+		bb_error_msg_and_die("invalid IA state (%d)", ia->state);
+	}
+
+	/* we don't need a timer for the IA (see comments in ia_timo()) */
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	return prepare_iaevent(ia, DHCP6S_REQUEST);
+}
+
+void release_all_ia(struct dhcp6_if *ifp)
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+
+	TAILQ_FOREACH(iac, &ifp->iaconf_list, link) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			log1("release an %s-%u",
+				dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+			prepare_iaevent(ia, DHCP6S_RELEASE);
+
+			/*
+			 * The client MUST stop using all of the addresses
+			 * being released as soon as the client begins the
+			 * Release message exchange process.
+			 * [RFC3315 Section 18.1.6]
+			 */
+			remove_ia(ia);
+		}
+	}
+}
+
+static void remove_ia(struct ia *ia)
+{
+	struct ia_conf *iac = ia->conf;
+	struct dhcp6_if *ifp = ia->ifp;
+
+	log1("remove an %s-%u", dhcp6optstr(ia->conf->type), ia->conf->iaid);
+
+	TAILQ_REMOVE(&iac->iadata, ia, link);
+
+	dhcp6_vbuf_free(&ia->serverid);
+
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	if (ia->ctl)
+		pref_cleanup(ia->ctl);
+
+	free(ia->authparam);
+	free(ia);
+
+	client6_start(ifp);
+}
+
+static struct dhcp6_timer *ia_timo(void *arg)
+{
+	struct ia *ia = (struct ia *)arg;
+	int dhcpstate;
+
+	log1("timeout for %s-%u, state=%s",
+	    dhcp6optstr(ia->conf->type), ia->conf->iaid, iastatestr(ia->state));
+
+	switch (ia->state) {
+	case IAS_ACTIVE:
+		ia->state = IAS_RENEW;
+		dhcpstate = DHCP6S_RENEW;
+		dhcp6_timer_set((ia->t1 < ia->t2) ? (ia->t2 - ia->t1) * 1000ULL : 0,
+						ia->timer);
+		break;
+	case IAS_RENEW:
+		ia->state = IAS_REBIND;
+		dhcpstate = DHCP6S_REBIND;
+
+		/*
+		 * We need keep DUID for sending Release in this state.
+		 * But we don't need a timer for the IA.  We'll just wait for a
+		 * reply for the REBIND until all associated configuration
+		 * parameters for this IA expire.
+		 */
+		dhcp6_timer_remove(&ia->timer);
+		break;
+	default:
+		bb_error_msg("invalid IA state (%d)", ia->state);
+		return NULL;	/* XXX */
+	}
+
+	if (prepare_iaevent(ia, dhcpstate) == 0)
+		return ia->timer;
+	else
+		return NULL;
+}
+
+static struct ia *get_ia(struct dhcp6_if *ifp,
+	struct ia_conf *iac, struct dhcp6_listval *iaparam,
+	struct dhcp6_vbuf *serverid)
+{
+	struct ia *ia;
+	int create;
+
+	TAILQ_FOREACH(ia, &iac->iadata, link) {
+		if (ia->conf->type == iaparam->dh6optype &&
+		    ia->conf->iaid == iaparam->val_ia.iaid)
+			break;
+	}
+
+	if (ia == NULL) {
+		ia = xzalloc(sizeof(*ia));
+		ia->state = IAS_ACTIVE;
+
+		TAILQ_INSERT_TAIL(&iac->iadata, ia, link);
+		ia->conf = iac;
+
+		create = 1;
+	} else {
+		dhcp6_vbuf_free(&ia->serverid);
+
+		create = 0;
+	}
+
+	ia->t1 = iaparam->val_ia.t1;
+	ia->t2 = iaparam->val_ia.t2;
+	ia->ifp = ifp;
+	dhcp6_vbuf_copy(&ia->serverid, serverid);
+
+	log1("%s an %s-%u", create ? "make" : "update",
+	    dhcp6optstr(iaparam->dh6optype), ia->conf->iaid);
+
+	return ia;
+}
+
+
+void destruct_iadata(struct dhcp6_eventdata *evd)
+{
+	struct dhcp6_list *ial;
+
+	if (evd->type != DH6OPT_IA_PD && evd->type != DH6OPT_IA_NA) {
+		bb_error_msg_and_die("impossible IA type %d", evd->type);
+	}
+
+	ial = (struct dhcp6_list *)evd->data;
+	dhcp6_clear_list(ial);
+	free(ial);
+
+	free(evd);
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t state)
+{
+	switch (state) {
+	case IAS_ACTIVE:
+		return "ACTIVE";
+	case IAS_RENEW:
+		return "RENEW";
+	case IAS_REBIND:
+		return "REBIND";
+	default:
+		return "???";	/* should be a bug */
+	}
+}
+#endif
+
+
+static int update_prefix6(struct ia *ia, struct dhcp6_listval *lv,
+		struct pifc_list *pifc,	struct dhcp6_if * dhcpifp,
+		struct iactl **ctlp)
+{
+	struct iactl *iac = (struct iactl *)(*ctlp);
+	struct iaprefix *sp;
+	struct dhcp6_prefix pinfo;
+	struct prefix_ifconf *pif;
+	int spcreate = 0;
+	char p[INET6_ADDRSTRLEN];
+
+	switch (lv->lvtype) {
+		case DHCP6_LISTVAL_PREFIX6:
+			memcpy(&pinfo, &lv->uv.uv_prefix6, sizeof(pinfo));
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			memcpy(&pinfo, &lv->uv.uv_statefuladdr6, sizeof(struct dhcp6_statefuladdr));
+			pinfo.plen = 128;
+			break;
+		default:
+			break;
+	}
+
+	/*
+	 * A client discards any addresses for which the preferred
+         * lifetime is greater than the valid lifetime.
+	 * [RFC3315 22.6]
+	 */
+	sprint_nip6(p, (const uint8_t *)&pinfo.addr);
+	if (pinfo.vltime != DHCP6_DURATION_INFINITE &&
+	    (pinfo.pltime == DHCP6_DURATION_INFINITE ||
+	    pinfo.pltime > pinfo.vltime)) {
+		bb_info_msg("%s/%d has larger preferred lifetime than valid lifetime",
+				p, pinfo.plen);
+		return -1;
+	}
+
+	if (iac == NULL) {
+		iac = xzalloc(sizeof(*iac));
+
+		iac->iactl_ia = ia;
+		iac->type = (lv->lvtype == DHCP6_LISTVAL_PREFIX6) ?
+					DH6OPT_IA_PD : DH6OPT_IA_NA;
+
+		iac->pifc_head = pifc;
+		TAILQ_INIT(&iac->iaprefix_head);
+		*ctlp = (struct iactl *)iac;
+	}
+
+	/* search for the given prefix, and make a new one if it fails */
+	sp = find_iaprefix(&iac->iaprefix_head, &pinfo,
+					(lv->lvtype==DHCP6_LISTVAL_PREFIX6));
+	if (sp == NULL) {
+		sp = xzalloc(sizeof(*sp));
+		sp->pa.addr = pinfo.addr;
+		sp->pa.plen = pinfo.plen;
+		sp->ctl = iac;
+
+		if (lv->lvtype == DHCP6_LISTVAL_PREFIX6)
+			TAILQ_INIT(&sp->u.ifprefix_list);
+
+		TAILQ_INSERT_TAIL(&iac->iaprefix_head, sp, link);
+
+		spcreate = 1;
+	}
+
+	/* update the timestamp of update */
+	sp->updatetime = time(NULL);
+
+	/* update the prefix according to pinfo */
+	sp->pa.pltime = pinfo.pltime;
+	sp->pa.vltime = pinfo.vltime;
+	if (lv->lvtype == DHCP6_LISTVAL_STATEFULADDR6)
+		sp->u.dhcpif = dhcpifp;
+
+	log2("%s a address %s/%d pltime=%u, vltime=%u",
+	    spcreate ? "create" : "update",
+	    p, pinfo.plen, pinfo.pltime, pinfo.vltime);
+
+	/* update prefix interfaces if necessary */
+	if (sp->pa.vltime != 0) {
+		if (lv->lvtype == DHCP6_LISTVAL_PREFIX6 && spcreate) {
+			TAILQ_FOREACH(pif, iac->pifc_head, link) {
+			/*
+			 * The requesting router MUST NOT assign any delegated
+			 * prefixes or subnets from the delegated prefix(es) to
+			 * the link through which it received the DHCP message
+			 * from the delegating router.
+			 * [RFC3633 Section 12.1]
+			 */
+				if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
+					bb_info_msg("skip %s as a prefix interface",
+					    dhcpifp->ifname);
+					continue;
+				}
+
+				add_ifprefix(sp, &pinfo, pif);
+			}
+		}
+		else if (lv->lvtype == DHCP6_LISTVAL_STATEFULADDR6) {
+			if (ifaddrconf(IFADDRCONF_ADD, sp->u.dhcpif->ifname, &sp->pa.addr,
+				 128, sp->pa.pltime, sp->pa.vltime) < 0)
+				return -1;
+		}
+	}
+
+	/*
+	 * If the new vltime is 0, this prefix immediately expires.
+	 * Otherwise, set up or update the associated timer.
+	 */
+	switch (sp->pa.vltime) {
+	case 0:
+		remove_iaprefix(sp, (lv->lvtype == DHCP6_LISTVAL_PREFIX6) ?
+				     DH6OPT_IA_PD : DH6OPT_IA_NA);
+		break;
+	case DHCP6_DURATION_INFINITE:
+		if (sp->timer)
+			dhcp6_timer_remove(&sp->timer);
+		break;
+	default:
+		if (sp->timer == NULL) {
+			sp->timer = dhcp6_timer_add(iapref_timo, sp);
+		}
+		/* update the timer */
+		dhcp6_timer_set(sp->pa.vltime * 1000ULL, sp->timer);
+		break;
+	}
+
+	return 0;
+}
+
+static struct iaprefix *find_iaprefix(struct iaprefix_list *head, struct dhcp6_prefix *addr,
+		int match_plen)
+{
+	struct iaprefix *sp;
+
+	TAILQ_FOREACH(sp, head, link) {
+		if (!IN6_ARE_ADDR_EQUAL(&sp->pa.addr, &addr->addr))
+			continue;
+		if (match_plen == 0 || sp->pa.plen == addr->plen)
+			return sp;
+	}
+
+	return NULL;
+}
+
+static int remove_iaprefix(struct iaprefix *sp, int type)
+{
+	int ret = 0;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log2("remove an address %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	if (type == DH6OPT_IA_PD) {
+		struct dhcp6_ifprefix *ip;
+
+		/* remove all interface prefixes */
+		while ((ip = TAILQ_FIRST(&sp->u.ifprefix_list)) != NULL) {
+			TAILQ_REMOVE(&sp->u.ifprefix_list, ip, plink);
+			ifaddrconf(IFADDRCONF_REMOVE, ip->ifconf->ifname,
+						&ip->ifaddr, ip->plen,
+						DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE);
+			free(ip);
+		}
+	} else {
+		ret = ifaddrconf(IFADDRCONF_REMOVE, sp->u.dhcpif->ifname, &sp->pa.addr,
+						128, sp->pa.pltime, sp->pa.vltime);
+	}
+
+	TAILQ_REMOVE(&sp->ctl->iaprefix_head, sp, link);
+	free(sp);
+	return ret;
+}
+
+static ALWAYS_INLINE int pref_isvalid(struct iactl *iac)
+{
+	if (TAILQ_EMPTY(&iac->iaprefix_head))
+		return 0;	/* this IA is invalid */
+	return 1;
+}
+
+static uint32_t pref_duration(struct iactl *iac)
+{
+	struct iaprefix *sp;
+	uint32_t base = DHCP6_DURATION_INFINITE, pltime, passed;
+	time_t now;
+
+	/* Determine the smallest period until pltime expires. */
+	now = time(NULL);
+	TAILQ_FOREACH(sp, &iac->iaprefix_head, link) {
+		passed = now > sp->updatetime ? (uint32_t)(now - sp->updatetime) : 0;
+		pltime = sp->pa.pltime > passed ? sp->pa.pltime - passed : 0;
+
+		if (base == DHCP6_DURATION_INFINITE || pltime < base)
+			base = pltime;
+	}
+
+	return base;
+}
+
+static void pref_cleanup(struct iactl *iac)
+{
+	struct iaprefix *sp;
+
+	while ((sp = TAILQ_FIRST(&iac->iaprefix_head)) != NULL) {
+		TAILQ_REMOVE(&iac->iaprefix_head, sp, link);
+		remove_iaprefix(sp, iac->type);
+	}
+
+	free(iac);
+}
+
+static int iapref_renew(struct iactl *iac, struct dhcp6_ia *iaparam,
+		struct dhcp6_eventdata *evd)
+{
+	struct iaprefix *sp;
+	struct dhcp6_list *ial = NULL, pl;
+
+	TAILQ_INIT(&pl);
+	TAILQ_FOREACH(sp, &iac->iaprefix_head, link) {
+		if (dhcp6_add_listval(&pl, iac->type,
+		    (iac->type == DH6OPT_IA_PD) ? DHCP6_LISTVAL_PREFIX6 : DHCP6_LISTVAL_STATEFULADDR6,
+		    &sp->pa, NULL) == NULL)
+			goto fail;
+	}
+
+	ial = xmalloc(sizeof(*ial));
+	TAILQ_INIT(ial);
+	if (dhcp6_add_listval(ial, iac->type, DHCP6_LISTVAL_IA, iaparam, &pl) == NULL)
+		goto fail;
+	dhcp6_clear_list(&pl);
+
+	evd->type = iac->type;
+	evd->data = ial;
+
+	return 0;
+
+  fail:
+	dhcp6_clear_list(&pl);
+	free(ial);
+	return -1;
+}
+
+static struct dhcp6_timer *iapref_timo(void *arg)
+{
+	struct iaprefix *sp = (struct iaprefix *)arg;
+	struct ia *ia = sp->ctl->iactl_ia;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log1("address timeout for %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	remove_iaprefix(sp, sp->ctl->type);
+
+	/* see if this IA is still valid.  if not, remove it. */
+	if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+		log1("%s-%u is invalidated",
+		    dhcp6optstr(ia->conf->type), ia->conf->iaid);
+		remove_ia(ia);
+	}
+
+	return NULL;
+}
+
+static int add_ifprefix(struct iaprefix *iaprefix,
+		struct dhcp6_prefix *prefix, struct prefix_ifconf *pconf)
+{
+	struct dhcp6_ifprefix *ifpfx = NULL;
+	uint32_t sla_id;
+	char *sp;
+	int b, i;
+
+	ifpfx = xzalloc(sizeof(*ifpfx));
+
+	ifpfx->ifconf = pconf;
+
+	ifpfx->paddr = prefix->addr;
+	ifpfx->plen = prefix->plen + pconf->sla_len;
+	/*
+	 * XXX: our current implementation assumes ifid len is a multiple of 8
+	 */
+	if ((pconf->ifid_len % 8) != 0) {
+		bb_error_msg("length of interface ID must be multiple of 8");
+		goto bad;
+	}
+	if (ifpfx->plen + pconf->ifid_len < 0 ||
+	    ifpfx->plen + pconf->ifid_len > 128) {
+		bb_info_msg("invalid prefix length: %d + %d + %d",
+			prefix->plen, pconf->sla_len, pconf->ifid_len);
+		goto bad;
+	}
+
+	/* copy prefix and SLA ID */
+	b = prefix->plen;
+	for (i = 0, b = prefix->plen; b > 0; b -= 8, i++) {
+		ifpfx->paddr.s6_addr[i] = prefix->addr.s6_addr[i];
+	}
+	sla_id = htonl(pconf->sla_id);
+	sp = ((char *)&sla_id + 3);
+	i = (128 - pconf->ifid_len) / 8;
+	for (b = pconf->sla_len; b > 7; b -= 8, sp--) {
+		ifpfx->paddr.s6_addr[--i] = *sp;
+	}
+	if (b) {
+		ifpfx->paddr.s6_addr[--i] |= *sp;
+	}
+
+	/* configure the corresponding address */
+	ifpfx->ifaddr = ifpfx->paddr;
+	for (i = 15; i >= pconf->ifid_len / 8; i--) {
+		ifpfx->ifaddr.s6_addr[i] = pconf->ifid[i];
+	}
+	if (ifaddrconf(IFADDRCONF_ADD, ifpfx->ifconf->ifname, &ifpfx->ifaddr,
+		 ifpfx->plen, DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE))
+		goto bad;
+
+	/* TODO: send a control message for other processes */
+
+	TAILQ_INSERT_TAIL(&iaprefix->u.ifprefix_list, ifpfx, plink);
+
+	return 0;
+
+  bad:
+	free(ifpfx);
+	return -1;
+}
diff -urNBp a/networking/udhcp/dhcp6c_script.c b/networking/udhcp/dhcp6c_script.c
--- a/networking/udhcp/dhcp6c_script.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/dhcp6c_script.c	2011-10-31 16:08:11.000000000 +0300
@@ -0,0 +1,155 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+typedef struct {
+	const char *name;
+	int type;
+} envp_list_t;
+
+static const envp_list_t client6_envp_list[] = {
+    { "new_sip_servers",		DH6OPT_SIP_SERVER_A   },
+    { "new_sip_name",			DH6OPT_SIP_SERVER_D   },
+    { "new_domain_name_servers",DH6OPT_DNS            },
+    { "new_domain_name",		DH6OPT_DNSNAME        },
+    { "new_sntp_servers",		DH6OPT_SNTP_SERVERS   },
+    { "new_ntp_servers",		DH6OPT_NTP_SERVER     },
+    { "new_nis_servers",		DH6OPT_NIS_SERVERS    },
+    { "new_nis_name", 			DH6OPT_NIS_DOMAIN     },
+    { "new_nisp_servers",		DH6OPT_NISP_SERVERS   },
+    { "new_nisp_name",			DH6OPT_NISP_DOMAIN    },
+};
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, const char *ifname)
+{
+	int i, sz, envc, elen;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+	int elens[ARRAY_SIZE(client6_envp_list)];
+
+	envc = 3;    /* we at least include the interface, reason and the terminator */
+
+	/* count the number of variables & total env. length */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    sz = 0;
+	    v = TAILQ_FIRST(&optinfo->ad_list);
+	    while (v) {
+			if (v->dh6optype == client6_envp_list[i].type) {
+			    switch (v->lvtype) {
+				case DHCP6_LISTVAL_VBUF:
+				    sz += v->val_vbuf.dv_len + 1;
+				    break;
+				case DHCP6_LISTVAL_ADDR6:
+				    sz += INET6_ADDRSTRLEN + 1 + 1;
+				    break;
+				default:
+				    break;
+			    }
+			}
+			v = TAILQ_NEXT(v, link);
+	    }
+	    elens[i] = sz;
+	    envc += (sz ? 1 : 0);
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* reason */
+	*curr = xstrdup("REASON=NBI");
+	putenv(*curr++);
+	/* interface name */
+	*curr = xasprintf("interface=%s", ifname);
+	putenv(*curr++);
+
+	/* "var=addr1 addr2 ... addrN" + null char for termination */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    if (elens[i] > 0) {
+			char a[INET6_ADDRSTRLEN];
+
+			elen = strlen(client6_envp_list[i].name) + 1 + elens[i];
+			*curr = xzalloc(elen);
+			sprintf(*curr, "%s=", client6_envp_list[i].name);
+
+			TAILQ_FOREACH(v, &optinfo->ad_list, link) {
+				if (v->dh6optype != client6_envp_list[i].type)
+					continue;
+				/* since we count total length above, it is safely to use strcat() */
+				switch (v->lvtype) {
+				    case DHCP6_LISTVAL_VBUF:
+					    strcat(*curr, v->val_vbuf.dv_buf);
+					    break;
+				    case DHCP6_LISTVAL_ADDR6:
+					    sprint_nip6(a, (const uint8_t *)&v->val_addr6);
+					    strcat(*curr, a);
+					    break;
+				    default:
+					    break;
+				}
+			    strcat(*curr, " ");
+			}
+			putenv(*curr++);
+	    }
+	}
+
+	return envp;
+}
+
+int dhcp6_script(const char *scriptpath, char **envp)
+{
+	char *argv[2];
+
+	/* if a script is not specified, do nothing */
+	if (!scriptpath[0])
+		return -2;
+
+	/* launch the script */
+	argv[0] = (char *)scriptpath;
+	argv[1] = NULL;
+	spawn_and_wait(argv);
+
+	/* free env */
+	if (envp != NULL) {
+		char **curr;
+
+		for (curr = envp; *curr; curr++) {
+			bb_unsetenv_and_free(*curr);
+		}
+		free(envp);
+	}
+	return 0;
+}
diff -urNBp a/networking/udhcp/dhcp6.h b/networking/udhcp/dhcp6.h
--- a/networking/udhcp/dhcp6.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/dhcp6.h	2011-10-31 16:08:11.000000000 +0300
@@ -0,0 +1,410 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6_H_DEFINED
+#define __DHCP6_H_DEFINED
+
+#include <sys/queue.h>
+
+/* Error Values */
+#define DH6ERR_FAILURE		16
+#define DH6ERR_AUTHFAIL		17
+#define DH6ERR_POORLYFORMED	18
+#define DH6ERR_UNAVAIL		19
+#define DH6ERR_OPTUNAVAIL	20
+
+/* Message type */
+#define DH6_SOLICIT		1
+#define DH6_ADVERTISE	2
+#define DH6_REQUEST		3
+#define DH6_CONFIRM		4
+#define DH6_RENEW		5
+#define DH6_REBIND		6
+#define DH6_REPLY		7
+#define DH6_RELEASE		8
+#define DH6_DECLINE		9
+#define DH6_RECONFIGURE	10
+#define DH6_INFORM_REQ	11
+#define DH6_RELAY_FORW	12
+#define DH6_RELAY_REPLY	13
+#define DH6__MSG__MAX	DH6_RELAY_REPLY
+
+/* Predefined addresses */
+#define DH6ADDR_ALLAGENT	"ff02::1:2"
+#define DH6ADDR_ALLSERVER	"ff05::1:3"
+#define DH6PORT_DOWNSTREAM	546
+#define DH6PORT_UPSTREAM	547
+
+/* Protocol constants */
+
+/* timer parameters (msec, unless explicitly commented) */
+#define SOL_MAX_DELAY	1000
+#define SOL_TIMEOUT		1000
+#define SOL_MAX_RT		120000
+#define INF_TIMEOUT		1000
+#define INF_MAX_RT		120000
+#define REQ_TIMEOUT		1000
+#define REQ_MAX_RT		30000
+#define REQ_MAX_RC		10	/* Max Request retry attempts */
+#define REN_TIMEOUT		10000	/* 10secs */
+#define REN_MAX_RT		600000	/* 600secs */
+#define REB_TIMEOUT		10000	/* 10secs */
+#define REB_MAX_RT		600000	/* 600secs */
+#define REL_TIMEOUT		1000	/* 1 sec */
+#define REL_MAX_RC		5
+
+#define DHCP6_DURATION_INFINITE 0xffffffff
+#define DHCP6_DURATION_MIN      30
+
+#define DHCP6_RELAY_MULTICAST_HOPS  32
+#define DHCP6_RELAY_HOP_COUNT_LIMIT 32
+
+#define DHCP6_IRT_DEFAULT 86400	/* 1 day */
+#define DHCP6_IRT_MINIMUM 600
+
+struct dhcp6_vbuf {		/* generic variable length buffer */
+	int dv_len;
+	caddr_t dv_buf;
+};
+
+/* option information */
+struct dhcp6_ia {		/* identity association */
+	uint32_t iaid;
+	uint32_t t1;
+	uint32_t t2;
+};
+
+struct dhcp6_prefix {		/* IA_PD */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+	int plen;
+};
+
+struct dhcp6_statefuladdr {	/* IA_NA */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+};
+
+/* Internal data structure */
+typedef enum {
+	DHCP6_LISTVAL_NUM = 1, DHCP6_LISTVAL_NUM16, DHCP6_LISTVAL_NUM8,
+	DHCP6_LISTVAL_IA,
+	DHCP6_LISTVAL_ADDR6,
+	DHCP6_LISTVAL_PREFIX6,
+	DHCP6_LISTVAL_STATEFULADDR6,
+	DHCP6_LISTVAL_VBUF
+} dhcp6_listval_type_t;
+
+TAILQ_HEAD(dhcp6_list, dhcp6_listval);
+struct dhcp6_listval {
+	TAILQ_ENTRY(dhcp6_listval) link;
+
+	int dh6optype;					/* DHCPv6 option number (See DH6OPT_ ) */
+	dhcp6_listval_type_t lvtype;
+
+	union {
+		int32_t  uv_num;
+		uint16_t uv_num16;
+		uint8_t  uv_num8;
+		struct in6_addr uv_addr6;
+		struct dhcp6_prefix uv_prefix6;
+		struct dhcp6_statefuladdr uv_statefuladdr6;
+		struct dhcp6_ia uv_ia;
+		struct dhcp6_vbuf uv_vbuf;
+	} uv;
+
+	struct dhcp6_list sublist;
+};
+#define val_num           uv.uv_num
+#define val_num16         uv.uv_num16
+#define val_num8          uv.uv_num8
+#define val_addr6         uv.uv_addr6
+#define val_ia            uv.uv_ia
+#define val_prefix6       uv.uv_prefix6
+#define val_statefuladdr6 uv.uv_statefuladdr6
+#define val_vbuf          uv.uv_vbuf
+
+struct dhcp6_optinfo {
+	struct dhcp6_vbuf clientID;		/* DUID */
+	struct dhcp6_vbuf serverID;		/* DUID */
+
+	int rapidcommit;				/* bool */
+	int pref;						/* server preference */
+	int32_t elapsed_time;			/* elapsed time (from client to server only) */
+	int64_t refreshtime;			/* info refresh time for stateless options */
+
+	struct dhcp6_list ia_list;		/* list of IA_PD/IA_NA */
+	struct dhcp6_list reqopt_list;	/* options in option request */
+	struct dhcp6_list stcode_list;	/* status code */
+	struct dhcp6_list ad_list;		/* SIP/DNS/NTP/NIS/NIS+/BCMS servers/domain list */
+
+	struct dhcp6_vbuf relay_msg;	/* relay message */
+#define relaymsg_len relay_msg.dv_len
+#define relaymsg_msg relay_msg.dv_buf
+
+	struct dhcp6_vbuf ifidopt;		/* Interface-id */
+#define ifidopt_len ifidopt.dv_len
+#define ifidopt_id  ifidopt.dv_buf
+
+	uint16_t authflags;
+#define DHCP6OPT_AUTHFLAG_NOINFO	0x1
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	/* the followings are effective only when NOINFO is unset */
+	uint64_t authrd;
+	union {
+		struct {
+			uint32_t keyid;
+			struct dhcp6_vbuf realm;
+			int offset;			/* offset to the HMAC field */
+		} aiu_delayed;
+		struct {
+			int type;
+			int offset;			/* offset to the HMAC field */
+			char val[16];		/* key value */
+		} aiu_reconfig;
+	} authinfo;
+#define delayedauth_keyid    authinfo.aiu_delayed.keyid
+#define delayedauth_realm    authinfo.aiu_delayed.realm
+#define delayedauth_realmlen authinfo.aiu_delayed.realm.dv_len
+#define delayedauth_realmval authinfo.aiu_delayed.realm.dv_buf
+#define delayedauth_offset   authinfo.aiu_delayed.offset
+#define reconfigauth_type    authinfo.aiu_reconfig.type
+#define reconfigauth_offset  authinfo.aiu_reconfig.offset
+#define reconfigauth_val     authinfo.aiu_reconfig.val
+};
+
+/* DHCP6 base packet format */
+struct dhcp6 {
+	union {
+		uint8_t m;
+		uint32_t x;
+	} dh6_msgtypexid;
+	/* options follow */
+} __attribute__ ((__packed__));
+#define dh6_msgtype	dh6_msgtypexid.m
+#define dh6_xid		dh6_msgtypexid.x
+#define DH6_XIDMASK	0x00ffffff
+
+/* DHCPv6 relay messages */
+struct dhcp6_relay {
+	uint8_t dh6relay_msgtype;
+	uint8_t dh6relay_hcnt;
+	struct in6_addr dh6relay_linkaddr; /* XXX: badly aligned */
+	struct in6_addr dh6relay_peeraddr; /* ditto */
+	/* options follow */
+} __attribute__ ((__packed__));
+
+/* options */
+#define DH6OPT_CLIENTID				1			/* RFC3315 */
+#define DH6OPT_SERVERID				2			/* RFC3315 */
+#define DH6OPT_IA_NA				3			/* RFC3315 */
+#define DH6OPT_IA_TA				4			/* RFC3315 */
+#define DH6OPT_IAADDR				5			/* RFC3315 */
+#define DH6OPT_ORO					6			/* RFC3315 */
+#define DH6OPT_PREFERENCE			7			/* RFC3315 */
+#  define DH6OPT_PREF_UNDEF             -1
+#  define DH6OPT_PREF_MAX               255
+#define DH6OPT_ELAPSED_TIME			8			/* RFC3315 */
+#  define DH6OPT_ELAPSED_TIME_UNDEF     -1
+#define DH6OPT_RELAY_MSG			9			/* RFC3315 */
+/* #define DH6OPT_10				10: deprecated */
+#define DH6OPT_AUTH					11			/* RFC3315 */
+#  define DH6OPT_AUTH_PROTO_DELAYED     2
+#  define DH6OPT_AUTH_RRECONFIGURE      3
+#  define DH6OPT_AUTH_ALG_HMACMD5       1
+#define DH6OPT_UNICAST				12			/* RFC3315 */
+#define DH6OPT_STATUS_CODE			13			/* RFC3315 */
+#  define DH6OPT_STCODE_SUCCESS         0
+#  define DH6OPT_STCODE_UNSPECFAIL      1
+#  define DH6OPT_STCODE_NOADDRSAVAIL    2
+#  define DH6OPT_STCODE_NOBINDING       3
+#  define DH6OPT_STCODE_NOTONLINK       4
+#  define DH6OPT_STCODE_USEMULTICAST    5
+#  define DH6OPT_STCODE_NOPREFIXAVAIL   6
+#  define DH6OPT_STCODE__MAX            DH6OPT_STCODE_NOPREFIXAVAIL
+
+#define DH6OPT_RAPID_COMMIT			14			/* RFC3315 */
+#define DH6OPT_USER_CLASS			15			/* RFC3315 */
+#define DH6OPT_VENDOR_CLASS			16			/* RFC3315 */
+#define DH6OPT_VENDOR_OPTS			17			/* RFC3315 */
+#define DH6OPT_INTERFACE_ID			18			/* RFC3315 */
+#define DH6OPT_RECONF_MSG			19			/* RFC3315 */
+#define DH6OPT_RECONF_ACCEPT		20			/* RFC3315 */
+
+#define DH6OPT_SIP_SERVER_D			21			/* RFC3319 */
+#define DH6OPT_SIP_SERVER_A			22			/* RFC3319 */
+#define DH6OPT_DNS					23			/* RFC3646 */
+#define DH6OPT_DNSNAME				24			/* RFC3646 */
+#define DH6OPT_IA_PD				25			/* RFC3633 */
+#define DH6OPT_IA_PD_PREFIX			26			/* RFC3633 */
+#define DH6OPT_NIS_SERVERS			27			/* RFC3898 */
+#define DH6OPT_NISP_SERVERS			28			/* RFC3898 */
+#define DH6OPT_NIS_DOMAIN			29			/* RFC3898 */
+#define DH6OPT_NISP_DOMAIN			30			/* RFC3898 */
+#define DH6OPT_SNTP_SERVERS			31			/* RFC4075 */
+#define DH6OPT_REFRESHTIME			32			/* RFC4242 */
+#  define DH6OPT_REFRESHTIME_UNDEF      -1
+#define DH6OPT_BCMCS_SERVER_D		33			/* RFC4280 */
+#define DH6OPT_BCMCS_SERVER_A		34			/* RFC4280 */
+/* #define DH6OPT_35				35: unassigned */
+#define DH6OPT_GEOCONF_CIVIC		36			/* RFC4776 */
+#define DH6OPT_REMOTE_ID			37			/* RFC4649 */
+#define DH6OPT_SUBSCRIBER_ID		38			/* RFC4580 */
+#define DH6OPT_CLIENT_FQDN			39			/* RFC4704 */
+#define DH6OPT_PANA_AGENT			40			/* RFC5192 */
+#define DH6OPT_NEW_POSIX_TIMEZONE	41			/* RFC4833 */
+#define DH6OPT_NEW_TZDB_TIMEZONE	42			/* RFC4833 */
+#define DH6OPT_ERO					43			/* RFC4994 */
+#define DH6OPT_LQ_QUERY				44			/* RFC5007 */
+#define DH6OPT_CLIENT_DATA			45			/* RFC5007 */
+#define DH6OPT_CLT_TIME				46			/* RFC5007 */
+#define DH6OPT_LQ_RELAY_DATA		47			/* RFC5007 */
+#define DH6OPT_LQ_CLIENT_LINK		48			/* RFC5007 */
+#define DH6OPT_MIP6_HNINF			49			/* RFC-ietf-mip6-hiopt-17 */
+#define DH6OPT_MIP6_RELAY			50			/* RFC-ietf-mip6-hiopt-17 */
+#define DH6OPT_V6_LOST				51			/* RFC5223 */
+#define DH6OPT_CAPWAP_AC_V6			52			/* RFC5417 */
+#define DH6OPT_RELAY_ID				53			/* RFC5460 */
+#define DH6OPT_IPv6_Address_MoS		54			/* RFC5678 */
+#define DH6OPT_IPv6_FQDN_MoS		55			/* RFC5678 */
+#define DH6OPT_NTP_SERVER			56			/* RFC5908 */
+#define DH6OPT_V6_ACCESS_DOMAIN		57			/* RFC5986 */
+#define DH6OPT_SIP_UA_CS_LIST		58			/* RFC6011 */
+#define DH6OPT_BOOTFILE_URL			59			/* RFC5970 */
+#define DH6OPT_BOOTFILE_PARAM		60			/* RFC5970 */
+#define DH6OPT_CLIENT_ARCH_TYPE		61			/* RFC5970 */
+#define DH6OPT_NII					62			/* RFC5970 */
+#define DH6OPT__MAX					DH6OPT_NII
+
+/* The followings are KAME specific. */
+
+/* DUID type 1 (DUID-LLT) */
+struct dhcp6opt_duid_type1 {
+	uint16_t type;
+	uint16_t hwtype;
+	uint32_t time;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 2 (DUID-EN) */
+struct dhcp6opt_duid_type2 {
+	uint16_t type;
+	uint32_t enterprise_number;
+	/* identifier follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 3 (DUID-LL) */
+struct dhcp6opt_duid_type3 {
+	uint16_t type;
+	uint16_t hwtype;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+union dhcp6opt_duid_type {
+	uint16_t type;
+	struct dhcp6opt_duid_type1	d1;
+	struct dhcp6opt_duid_type2	d2;
+	struct dhcp6opt_duid_type3	d3;
+};
+
+struct dhcp6opt {
+	uint16_t dh6opt_type;
+	uint16_t dh6opt_len;
+	/* type-dependent data follows */
+} __attribute__ ((__packed__));
+
+#define __DH6OPT_COMMON(opt_prefix) \
+    struct dhcp6opt opt_prefix##opt
+
+/* Status Code */
+struct dhcp6opt_stcode {
+	__DH6OPT_COMMON (stcode_);
+	uint16_t dh6_stcode;
+} __attribute__ ((__packed__));
+
+/*
+ * General format of Identity Association.
+ * This format applies to Prefix Delegation (IA_PD) and Non-temporary Addresses
+ * (IA_NA)
+ */
+struct dhcp6opt_ia {
+	__DH6OPT_COMMON (ia_);
+	uint32_t dh6_iaid;
+	uint32_t dh6_t1;
+	uint32_t dh6_t2;
+	/* sub options follow */
+} __attribute__ ((__packed__));
+
+/* IA Addr */
+struct dhcp6opt_ia_addr {
+	__DH6OPT_COMMON (ia_addr_);
+	struct in6_addr dh6_addr;
+	uint32_t dh6_preferred_time;
+	uint32_t dh6_valid_time;
+} __attribute__ ((__packed__));
+
+/* IA_PD Prefix */
+struct dhcp6opt_ia_pd_prefix {
+	__DH6OPT_COMMON (iapd_prefix_);
+	uint32_t dh6_preferred_time;
+	uint32_t dh6_valid_time;
+	uint8_t dh6_prefix_len;
+	struct in6_addr dh6_prefix_addr;
+} __attribute__ ((__packed__));
+
+/* Authentication */
+struct dhcp6opt_auth {
+	__DH6OPT_COMMON (auth_);
+	uint8_t dh6_proto;
+	uint8_t dh6_alg;
+	uint8_t dh6_rdm;
+	uint8_t dh6_rdinfo[8];
+	/* authentication information follows */
+} __attribute__ ((__packed__));
+
+enum {
+	DHCP6_AUTHPROTO_UNDEF    = -1,
+	DHCP6_AUTHPROTO_DELAYED  = 2,
+	DHCP6_AUTHPROTO_RECONFIG = 3
+};
+enum {
+	DHCP6_AUTHALG_UNDEF   = -1,
+	DHCP6_AUTHALG_HMACMD5 = 1
+};
+enum {
+	DHCP6_AUTHRDM_UNDEF       = -1,
+	DHCP6_AUTHRDM_MONOCOUNTER = 0
+};
+
+#endif /* __DHCP6_H_DEFINED */
diff -urNBp a/networking/udhcp/if6.c b/networking/udhcp/if6.c
--- a/networking/udhcp/if6.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/if6.c	2011-10-21 19:15:07.000000000 +0400
@@ -0,0 +1,277 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+#ifndef SO_REUSEPORT
+#define SO_REUSEPORT SO_REUSEADDR
+#endif
+
+#ifdef __linux__
+/* from /usr/include/linux/ipv6.h */
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	uint32_t ifr6_prefixlen;
+	unsigned int ifr6_ifindex;
+};
+#endif /* __linux__ */
+
+
+void if6init(struct dhcp6_if *ifp, const char *ifname)
+{
+	ifp->ifid = if_nametoindex(ifname);
+	if (ifp->ifid == 0) {
+		bb_perror_msg_and_die("invalid interface(%s)", ifp->ifname);
+	}
+
+	ifp->ifname = xstrdup(ifname);
+
+	TAILQ_INIT(&ifp->reqopt_list);
+	TAILQ_INIT(&ifp->iaconf_list);
+
+	ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+	ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+}
+
+int sock6_init(struct addrinfo *res)
+{
+	int sock;
+
+	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+	if (sock < 0) {
+		bb_perror_msg_and_die("socket");
+	}
+	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(SO_REUSEPORT)");
+	}
+	socket_want_pktinfo(sock);
+#ifdef IPV6_V6ONLY
+	if (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_V6ONLY)");
+	}
+#endif
+
+	/*
+	 * According RFC3315 2.2, only the incoming port should be bound to UDP
+	 * port 546.  However, to have an interoperability with some servers,
+	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
+	 */
+	xbind(sock, res->ai_addr, res->ai_addrlen);
+	freeaddrinfo(res);
+
+	return sock;
+}
+
+/* TODO! we can't use udp_io.c:recv_from_to() since it not return ipi6_ifindex */
+ssize_t FAST_FUNC recv_from6(int fd, void *buf, size_t len,
+				struct sockaddr_in6 *from, unsigned int *to_ifindex)
+{
+	struct msghdr mhdr;
+	struct cmsghdr *cm;
+	struct iovec iov[1];
+	char cmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+	ssize_t recv_length;
+
+	memset(&mhdr, 0, sizeof(mhdr));
+	iov[0].iov_base = buf;
+	iov[0].iov_len  = len;
+	mhdr.msg_name       = from;
+	mhdr.msg_namelen    = sizeof(*from);
+	mhdr.msg_control    = cmsgbuf;
+	mhdr.msg_controllen = sizeof(cmsgbuf);
+	mhdr.msg_iov        = iov;
+	mhdr.msg_iovlen     = 1;
+
+	recv_length = recvmsg(fd, &mhdr, 0);
+	if (recv_length < 0) {
+		bb_perror_msg("recvmsg");
+		return -EIO;
+	}
+
+	if (((struct sockaddr *)from)->sa_family != AF_INET6) {
+		bb_info_msg("non-IPv6 packet is received (AF %d)",
+				((struct sockaddr *)from)->sa_family);
+		return -EPROTOTYPE;
+	}
+
+	/* detect receiving interface */
+	*to_ifindex = 0;
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(&mhdr, cm)) {
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    (cm->cmsg_type == IPV6_PKTINFO 
+#if defined(IPV6_2292PKTINFO) && defined(IPV6_RECVPKTINFO)
+			 || cm->cmsg_type == IPV6_2292PKTINFO
+#endif
+		    ) && cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))
+		) {
+			const int IPI6_IFINDEX_OFF = offsetof(struct in6_pktinfo, ipi6_ifindex);
+			move_from_unaligned_int(*to_ifindex, (char*)(CMSG_DATA(cm)) + IPI6_IFINDEX_OFF);
+			break;
+		}
+	}
+
+	if (recv_length < sizeof(struct dhcp6)) {
+		bb_info_msg("short packet (%d bytes)", (int )recv_length);
+		return -ENODATA;
+	}
+
+	return recv_length;
+}
+
+/* Get hardware id(MAC) of first ethernet interface for DUID */
+ssize_t gethwid(char *buf, uint16_t *hwtype)
+{
+	int n, numreqs = 30;
+	struct ifconf ifc;
+	struct ifreq *ifr;
+	int skfd;
+	ssize_t l = 0;
+
+	ifc.ifc_buf = NULL;
+	skfd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (skfd < 0)
+		return -1;
+
+	/* query all available interfaces */
+	for (;;) {
+		ifc.ifc_len = sizeof(struct ifreq) * numreqs;
+		ifc.ifc_buf = xrealloc(ifc.ifc_buf, ifc.ifc_len);
+
+		if (ioctl_or_warn(skfd, SIOCGIFCONF, &ifc) < 0) {
+			goto out;
+		}
+		if (ifc.ifc_len == (int)(sizeof(struct ifreq) * numreqs)) {
+			/* assume it overflowed and try again */
+			numreqs += 10;
+			continue;
+		}
+		break;
+	}
+
+	/* search for acceptable hwaddr */
+	ifr = ifc.ifc_req;
+	for (n = 0; n < ifc.ifc_len; n += sizeof(struct ifreq), ifr++) {
+		if (ioctl(skfd, SIOCGIFHWADDR, ifr) != 0)
+			continue;
+		switch (ifr->ifr_hwaddr.sa_family) {
+			case ARPHRD_ETHER:
+			case ARPHRD_EETHER:
+			case ARPHRD_IEEE802:
+				memcpy(buf, ifr->ifr_hwaddr.sa_data, 8);
+				*hwtype = ifr->ifr_hwaddr.sa_family;
+				l = ETH_ALEN;
+				break;
+			default:
+				continue;
+		}
+		break;
+	}
+	if (l > 0)
+		log1("found an interface %s hwtype %d for DUID", ifr->ifr_name, *hwtype);
+
+ out:
+	close(skfd);
+	free(ifc.ifc_buf);
+	return l;
+}
+
+int ifaddrconf(ifaddrconf_cmd_t cmd, const char *ifname, struct in6_addr *addr,
+	   int plen, int pltime UNUSED_PARAM, int vltime UNUSED_PARAM)
+{
+/*
+ * TODO: Should be rewritten to Netlink calls in order to support
+ *       preferred/valid lifetimes
+ */
+	struct in6_ifreq req;
+	struct ifreq ifr;
+	const char *cmdstr[] = {
+		[IFADDRCONF_ADD] "add",
+		[IFADDRCONF_REMOVE] "remove"
+	};
+	unsigned long ioctl_cmd;
+	struct sockaddr_in6 sin6;
+	int sk;
+	char *a;
+
+	switch (cmd) {
+	case IFADDRCONF_ADD:
+		ioctl_cmd = SIOCSIFADDR;
+		break;
+	case IFADDRCONF_REMOVE:
+		ioctl_cmd = SIOCDIFADDR;
+		break;
+	default:
+		return -1;
+	}
+
+	sk = xsocket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+	memset(&req, 0, sizeof(req));
+    memset(&sin6, 0, sizeof(sin6));
+    sin6.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+    sin6.sin6_len = sizeof(struct sockaddr_in6);
+#endif
+    sin6.sin6_addr = *addr;
+
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
+	xioctl(sk, SIOGIFINDEX, &ifr);
+	memcpy(&req.ifr6_addr, addr, sizeof(struct in6_addr));
+	req.ifr6_prefixlen = plen;
+	req.ifr6_ifindex = ifr.ifr_ifindex;
+
+	if (ioctl(sk, ioctl_cmd, &req)) {
+		if (errno == EEXIST) /* Ignore address duplicate */
+			goto out;
+		bb_perror_msg("can't %s address on %s", cmdstr[cmd], ifname);
+		close(sk);
+		return -1;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sin6);
+	bb_info_msg("%s address %s/%d on %s", cmdstr[cmd], a, plen, ifname);
+	free(a);
+
+ out:
+	close(sk);
+	return 0;
+}
diff -urNBp a/networking/udhcp/Kbuild.src b/networking/udhcp/Kbuild.src
--- a/networking/udhcp/Kbuild.src	2011-09-06 06:35:17.000000000 +0400
+++ b/networking/udhcp/Kbuild.src	2011-10-31 16:08:11.000000000 +0300
@@ -17,5 +17,11 @@ lib-$(CONFIG_UDHCPD)     += dhcpd.o arpp
 lib-$(CONFIG_DUMPLEASES) += dumpleases.o
 lib-$(CONFIG_DHCPRELAY)  += dhcprelay.o
 
+lib-$(CONFIG_DHCP6C)     += common6.o common.o
+
+lib-$(CONFIG_DHCP6C)     += dhcp6c.o config6.o dhcp6c_script.o dhcp6c_ia.o if6.o timer.o
+
+lib-$(CONFIG_FEATURE_DHCP6_AUTH)    += auth6.o
+
 lib-$(CONFIG_FEATURE_UDHCPC_ARPING) += arpping.o
 lib-$(CONFIG_FEATURE_UDHCP_RFC3397) += domain_codec.o
diff -urNBp a/networking/udhcp/timer.c b/networking/udhcp/timer.c
--- a/networking/udhcp/timer.c	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/timer.c	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,127 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "timer.h"
+
+void dhcp6_timer_init(void)
+{
+	LIST_INIT(&client6_config.timer_head);
+	client6_config.tm_sentinel = ULLONG_MAX;
+}
+
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*timeout)(void *),
+				    void *timeodata)
+{
+	struct dhcp6_timer *newtimer;
+
+	if (timeout == NULL) {
+		log1("timeout function unspecified");
+		return NULL;
+	}
+
+	newtimer = xzalloc(sizeof(*newtimer));
+	newtimer->expire = timeout;
+	newtimer->expire_data = timeodata;
+	newtimer->t = ULLONG_MAX;
+
+	LIST_INSERT_HEAD(&client6_config.timer_head, newtimer, link);
+
+	return newtimer;
+}
+
+void dhcp6_timer_remove(struct dhcp6_timer **timer)
+{
+	LIST_REMOVE(*timer, link);
+	free(*timer);
+	*timer = NULL;
+}
+
+void dhcp6_timer_set(unsigned long long t, struct dhcp6_timer *timer)
+{
+	timer->t = monotonic_ms() + t;
+
+	/* update the next expiration time */
+	if (timer->t < client6_config.tm_sentinel)
+		client6_config.tm_sentinel = timer->t;
+}
+
+/*
+ * Check expiration for each timer. If a timer is expired,
+ * call the expire function for the timer and update the timer.
+ * Return the next interval for select() call.
+ */
+struct timeval *dhcp6_timer_check(void)
+{
+	unsigned long long now = monotonic_ms();
+	struct dhcp6_timer *tm, *tm_next;
+
+	client6_config.tm_sentinel = ULLONG_MAX;
+	for (tm = LIST_FIRST(&client6_config.timer_head); tm; tm = tm_next) {
+		tm_next = LIST_NEXT(tm, link);
+
+		if ((long long)(now - tm->t) >= 0) {
+			if ((*tm->expire)(tm->expire_data) == NULL)
+				continue; /* timer has been freed */
+		}
+
+		if (tm->t < client6_config.tm_sentinel)
+			client6_config.tm_sentinel = tm->t;
+	}
+
+	if (ULLONG_MAX == client6_config.tm_sentinel) {
+		/* no need to timeout */
+		return NULL;
+	} else if (client6_config.tm_sentinel < now) {
+		/* this may occur when the interval is too small */
+		client6_config.tm_check.tv_sec = client6_config.tm_check.tv_usec = 0;
+	} else {
+		client6_config.tm_check.tv_sec =
+			(client6_config.tm_sentinel - now) / 1000ULL;
+		client6_config.tm_check.tv_usec =
+			((client6_config.tm_sentinel - now) % 1000ULL) * 1000ULL;
+	}
+	return (&client6_config.tm_check);
+}
+
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *timer)
+{
+	unsigned long long now = monotonic_ms();
+
+	if (timer->t - now <= 0) {
+		log2("a timer must be expired, but not yet");
+		return 0;
+	} else {
+		return (timer->t - now);
+	}
+}
diff -urNBp a/networking/udhcp/timer.h b/networking/udhcp/timer.h
--- a/networking/udhcp/timer.h	1970-01-01 03:00:00.000000000 +0300
+++ b/networking/udhcp/timer.h	2011-10-21 18:39:13.000000000 +0400
@@ -0,0 +1,54 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6_TIMER_H
+#define __DHCP6_TIMER_H 1
+
+PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
+
+struct dhcp6_timer {
+	LIST_ENTRY(dhcp6_timer) link;
+
+	unsigned long long t;
+
+	struct dhcp6_timer *(*expire)(void *);
+	void *expire_data;
+};
+
+void dhcp6_timer_init(void);
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*)(void *), void *);
+void dhcp6_timer_set(unsigned long long , struct dhcp6_timer *);
+void dhcp6_timer_remove(struct dhcp6_timer **);
+struct timeval *dhcp6_timer_check(void);
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *);
+
+POP_SAVED_FUNCTION_VISIBILITY
+
+#endif /* __DHCP6_TIMER_H */
