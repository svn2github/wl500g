From 7ce209b9d4f6053b7e6d07dec66e382bc3614c35
From: Denys Vlasenko
Date: Sun, 15 Jan 2012 21:58:06 +0000
Subject: shell_builtin_read: set cc[VMIN] to 1; lineedit: don't clear c_cc[VINTR]

First change fixes "read -n NUM". Apparently poll() won't report
data availability if cc[VMIN] > 1 until there are at least cc[VMIN] bytes.

function                                             old     new   delta
read_line_input                                     3885    3877      -8
shell_builtin_read                                  1097    1087     -10
------------------------------------------------------------------------------
(add/remove: 0/0 grow/shrink: 0/2 up/down: 0/-18)             Total: -18 bytes

Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
---
diff --git a/libbb/lineedit.c b/libbb/lineedit.c
--- a/libbb/lineedit.c
+++ b/libbb/lineedit.c
@@ -2206,14 +2206,17 @@ int FAST_FUNC read_line_input(line_input_t *st, const char *prompt, char *comman
 #define command command_must_not_be_used
 
 	new_settings = initial_settings;
-	new_settings.c_lflag &= ~ICANON;        /* unbuffered input */
-	/* Turn off echoing and CTRL-C, so we can trap it */
-	new_settings.c_lflag &= ~(ECHO | ECHONL | ISIG);
-	/* Hmm, in linux c_cc[] is not parsed if ICANON is off */
+	/* ~ICANON: unbuffered input (most c_cc[] are disabled, VMIN/VTIME are enabled) */
+	/* ~ECHO, ~ECHONL: turn off echoing, including newline echoing */
+	/* ~ISIG: turn off INTR (ctrl-C), QUIT, SUSP */
+	new_settings.c_lflag &= ~(ICANON | ECHO | ECHONL | ISIG);
+	/* reads would block only if < 1 char is available */
 	new_settings.c_cc[VMIN] = 1;
+	/* no timeout (reads block forever) */
 	new_settings.c_cc[VTIME] = 0;
-	/* Turn off CTRL-C, so we can trap it */
-	new_settings.c_cc[VINTR] = _POSIX_VDISABLE;
+	/* Should be not needed if ISIG is off: */
+	/* Turn off CTRL-C */
+	/* new_settings.c_cc[VINTR] = _POSIX_VDISABLE; */
 	tcsetattr_stdin_TCSANOW(&new_settings);
 
 #if ENABLE_USERNAME_OR_HOMEDIR
diff --git a/shell/shell_common.c b/shell/shell_common.c
--- a/shell/shell_common.c
+++ b/shell/shell_common.c
@@ -138,7 +138,13 @@ shell_builtin_read(void FAST_FUNC (*setvar)(const char *name, const char *val),
 		old_tty = tty;
 		if (nchars) {
 			tty.c_lflag &= ~ICANON;
-			tty.c_cc[VMIN] = nchars < 256 ? nchars : 255;
+			// Setting it to more than 1 breaks poll():
+			// it blocks even if there's data. !??
+			//tty.c_cc[VMIN] = nchars < 256 ? nchars : 255;
+			/* reads would block only if < 1 char is available */
+			tty.c_cc[VMIN] = 1;
+			/* no timeout (reads block forever) */
+			tty.c_cc[VTIME] = 0;
 		}
 		if (read_flags & BUILTIN_READ_SILENT) {
 			tty.c_lflag &= ~(ECHO | ECHOK | ECHONL);
--
cgit v0.9.0.1-2-gef13
