diff -urNBp -x'.*' -x'*.o' busybox/include/applets.h busybox.new/include/applets.h
--- busybox/include/applets.h	2009-07-22 19:28:09.000000000 +0400
+++ busybox.new/include/applets.h	2009-11-16 12:50:21.000000000 +0300
@@ -392,6 +392,7 @@ IF_TOP(APPLET(top, _BB_DIR_USR_BIN, _BB_
 IF_TOUCH(APPLET_NOFORK(touch, touch, _BB_DIR_BIN, _BB_SUID_DROP, touch))
 IF_TR(APPLET(tr, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_TRACEROUTE(APPLET(traceroute, _BB_DIR_USR_BIN, _BB_SUID_MAYBE))
+IF_TRACEROUTE6(APPLET(traceroute6, _BB_DIR_USR_BIN, _BB_SUID_MAYBE))
 IF_TRUE(APPLET_NOFORK(true, true, _BB_DIR_BIN, _BB_SUID_DROP, true))
 IF_TTY(APPLET(tty, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_TTYSIZE(APPLET(ttysize, _BB_DIR_USR_BIN, _BB_SUID_DROP))
diff -urNBp -x'.*' -x'*.o' busybox/include/usage.h busybox.new/include/usage.h
--- busybox/include/usage.h	2009-07-22 19:26:30.000000000 +0400
+++ busybox.new/include/usage.h	2009-11-16 13:03:41.000000000 +0300
@@ -4626,6 +4626,26 @@
      "\n			(default 3 sec)" \
      "\n	-g		Loose source route gateway (8 max)" \
 
+#define traceroute6_trivial_usage \
+       "[-dnrv] [-m max_ttl] [-p port#] [-q nqueries]\n" \
+       "	[-s src_addr] [-t tos] [-w wait] [-i iface]\n" \
+       "	HOST [data size]"
+#define traceroute6_full_usage "\n\n" \
+       "Trace the route to HOST\n" \
+     "\nOptions:" \
+     "\n	-d	Set SO_DEBUG options to socket" \
+     "\n	-n	Print hop addresses numerically rather than symbolically" \
+     "\n	-r	Bypass the normal routing tables and send directly to a host" \
+     "\n	-v	Verbose" \
+     "\n	-m max_ttl	Max time-to-live (max number of hops)" \
+     "\n	-p port#	Base UDP port number used in probes" \
+     "\n			(default is 33434)" \
+     "\n	-q nqueries	Number of probes per 'ttl' (default 3)" \
+     "\n	-s src_addr	IP address to use as the source address" \
+     "\n	-t tos		Type-of-service in probe packets (default 0)" \
+     "\n	-w wait		Time in seconds to wait for a response" \
+     "\n			(default 3 sec)" \
+
 #define true_trivial_usage \
        ""
 #define true_full_usage "\n\n" \
diff -urNBp -x'.*' -x'*.o' busybox/networking/Config.in busybox.new/networking/Config.in
--- busybox/networking/Config.in	2009-10-08 04:59:09.000000000 +0400
+++ busybox.new/networking/Config.in	2009-11-16 13:00:07.000000000 +0300
@@ -846,6 +846,13 @@ config TRACEROUTE
 	help
 	  Utility to trace the route of IP packets.
 
+config TRACEROUTE6
+	bool "traceroute6"
+	default n
+	depends on FEATURE_IPV6 && TRACEROUTE
+	help
+	  Utility to trace the route of IPv6 packets.
+
 config FEATURE_TRACEROUTE_VERBOSE
 	bool "Enable verbose output"
 	default n
diff -urNBp -x'.*' -x'*.o' busybox/networking/traceroute.c busybox.new/networking/traceroute.c
--- busybox/networking/traceroute.c	2009-09-26 17:14:57.000000000 +0400
+++ busybox.new/networking/traceroute.c	2009-11-16 22:27:56.000000000 +0300
@@ -23,6 +23,21 @@
  */
 
 /*
+ *      Modified for NRL 4.4BSD IPv6 release.
+ *      07/31/96 bgp
+ *
+ *	Modified for Linux IPv6 by Pedro Roque <roque@di.fc.ul.pt>
+ *	31/07/1996
+ *
+ *	As ICMP error messages for IPv6 now include more than 8 bytes
+ *	UDP datagrams are now sent via an UDP socket instead of magic
+ *	RAW socket tricks.
+ *
+ *	Converted to busybox applet by Leonid Lisovskiy <lly@sf.net>
+ *	2009-11-16
+ */
+
+/*
  * traceroute host  - trace the route ip packets follow going to "host".
  *
  * Attempt to trace the route an ip packet would follow to some
@@ -211,6 +226,13 @@
 #include <netinet/udp.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
+#if ENABLE_FEATURE_IPV6
+#include <netinet/ip6.h>
+#include <netinet/icmp6.h>
+#ifndef SOL_IPV6
+#define SOL_IPV6 IPPROTO_IPV6
+#endif
+#endif
 
 #include "libbb.h"
 #include "inet_common.h"
@@ -258,15 +280,29 @@ struct outdata_t {
 	struct timeval tv_UNUSED PACKED; /* time packet left */
 };
 
+#if ENABLE_TRACEROUTE6
+struct outdata6_t
+{
+	u_int32_t ident6;
+	u_int32_t seq6;
+	struct timeval tv;
+};
+#endif
+
 struct globals {
 	struct ip *outip;
 	struct outdata_t *outdata;
 	len_and_sockaddr *dest_lsa;
 	int packlen;                    /* total length of packet */
 	int pmtu;                       /* Path MTU Discovery (RFC1191) */
-	uint16_t ident;
+	uint32_t ident;
 	uint16_t port; // 32768 + 666;  /* start udp dest port # for probe packets */
 	int waittime; // 5;             /* time to wait for response (in seconds) */
+	int tos; //0
+	int max_ttl; // 30
+	int nprobes; // 3
+	int first_ttl; // 1
+	unsigned pausemsecs; // 0
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 	int optlen;                     /* length of ip options */
 #else
@@ -279,6 +315,10 @@ struct globals {
 	/* loose source route gateway list (including room for final destination) */
 	uint32_t gwlist[NGATEWAYS + 1];
 #endif
+
+#if ENABLE_TRACEROUTE6
+	struct sockaddr_in6 firsthop;
+#endif
 };
 
 #define G (*ptr_to_globals)
@@ -290,15 +330,28 @@ struct globals {
 #define ident     (G.ident    )
 #define port      (G.port     )
 #define waittime  (G.waittime )
+#define tos        (G.tos        )
+#define max_ttl    (G.max_ttl    )
+#define nprobes    (G.nprobes    )
+#define first_ttl  (G.first_ttl  )
+#define pausemsecs (G.pausemsecs )
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 # define optlen   (G.optlen   )
 #endif
 #define recv_pkt  (G.recv_pkt )
 #define gwlist    (G.gwlist   )
+#if ENABLE_TRACEROUTE6
+# define firsthop  (G.firsthop   )
+#endif
 #define INIT_G() do { \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 	port = 32768 + 666; \
 	waittime = 5; \
+	tos = 0; \
+	max_ttl = 30; \
+	nprobes = 3; \
+	first_ttl = 1; \
+	pausemsecs = 0; \
 } while (0)
 
 #define outicmp ((struct icmp *)(outip + 1))
@@ -444,6 +497,62 @@ pr_type(unsigned char t)
 
 	return ttab[t];
 }
+
+#if ENABLE_TRACEROUTE6
+static inline const char *
+pr6_type(unsigned char t)
+{
+	switch (t) {
+	/* Unknown */
+	case 0:
+		return "Error";
+	case 1:
+		/* ICMP6_DST_UNREACH: */
+		return "Destination Unreachable";
+	case 2:
+		/* ICMP6_PACKET_TOO_BIG: */
+		return "Packet Too Big";
+	case 3:
+		/* ICMP6_TIME_EXCEEDED */
+		return "Time Exceeded in Transit";
+	case 4:
+		/* ICMP6_PARAM_PROB */
+		return "Parameter Problem";
+	case 128:
+		/* ICMP6_ECHO_REQUEST */
+		return "Echo Request";
+	case 129:
+		/* ICMP6_ECHO_REPLY */
+		return "Echo Reply";
+	case 130:
+		/* ICMP6_MEMBERSHIP_QUERY */
+		return "Membership Query";
+	case 131:
+		/* ICMP6_MEMBERSHIP_REPORT */
+		return "Membership Report";
+	case 132:
+		/* ICMP6_MEMBERSHIP_REDUCTION */
+		return "Membership Reduction";
+	case 133:
+		/* ND_ROUTER_SOLICIT */
+		return "Router Solicitation";
+	case 134:
+		/* ND_ROUTER_ADVERT */
+		return "Router Advertisement";
+	case 135:
+		/* ND_NEIGHBOR_SOLICIT */
+		return "Neighbor Solicitation";
+	case 136:
+		/* ND_NEIGHBOR_ADVERT */
+		return "Neighbor Advertisement";
+	case 137:
+		/* ND_REDIRECT */
+		return "Redirect";
+	}
+
+	return "OUT-OF-RANGE";
+}
+#endif
 #endif
 
 #if !ENABLE_FEATURE_TRACEROUTE_VERBOSE
@@ -546,7 +655,17 @@ print_inetname(const struct sockaddr_in
 {
 	const char *ina;
 
+#if ENABLE_TRACEROUTE6
+	char pa[MAXHOSTNAMELEN];
+
+	if (from->sin_family == AF_INET6)
+		ina = inet_ntop(from->sin_family,
+			 &((const struct sockaddr_in6 *)from)->sin6_addr,
+			 pa, sizeof(pa));
+	else
+#endif
 	ina = inet_ntoa(from->sin_addr);
+
 	if (option_mask32 & OPT_ADDR_NUM)
 		printf("  %s", ina);
 	else {
@@ -551,7 +670,9 @@ print_inetname(const struct sockaddr_in
 		printf("  %s", ina);
 	else {
 		char *n = NULL;
-		if (from->sin_addr.s_addr != INADDR_ANY)
+
+		if (from->sin_family != AF_INET
+		    || from->sin_addr.s_addr != INADDR_ANY)
 			n = xmalloc_sockaddr2host_noport((struct sockaddr*)from);
 		printf("  %s (%s)", (n ? n : ina), ina);
 		free(n);
@@ -580,24 +701,191 @@ print_delta_ms(unsigned t1p, unsigned t2
 	printf("  %u.%03u ms", tt / 1000, tt % 1000);
 }
 
-/*
-Usage: [-dFIlnrvx] [-g gateway] [-i iface] [-f first_ttl]
-[-m max_ttl] [ -p port] [-q nqueries] [-s src_addr] [-t tos]
-[-w waittime] [-z pausemsecs] host [packetlen]"
-*/
+#if ENABLE_TRACEROUTE6
+static int wait_for_reply6(int sock,
+	       struct sockaddr_in6 *from,
+	       struct in6_addr *to,
+	       int reset_timer)
+{
+	fd_set fds;
+	static struct timeval wait_rep;
+	int cc = 0;
+	char cbuf[512];
 
-int traceroute_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int traceroute_main(int argc, char **argv)
+	FD_ZERO(&fds);
+	FD_SET(sock, &fds);
+	if (reset_timer) {
+		/*
+		 * traceroute could hang if someone else has a ping
+		 * running and our ICMP reply gets dropped but we don't
+		 * realize it because we keep waking up to handle those
+		 * other ICMP packets that keep coming in.  To fix this,
+		 * "reset_timer" will only be true if the last packet that
+		 * came in was for us or if this is the first time we're
+		 * waiting for a reply since sending out a probe.  Note
+		 * that this takes advantage of the select() feature on
+		 * Linux where the remaining timeout is written to the
+		 * struct timeval area.
+		 */
+		wait_rep.tv_sec = waittime;
+		wait_rep.tv_usec = 0;
+	}
+
+	if (select(sock+1, &fds, (fd_set *)0, (fd_set *)0, &wait_rep) > 0) {
+		struct iovec iov;
+		struct msghdr msg;
+		iov.iov_base = recv_pkt;
+		iov.iov_len = sizeof(recv_pkt);
+		msg.msg_name = (void *)from;
+		msg.msg_namelen = sizeof(*from);
+		msg.msg_iov = &iov;
+		msg.msg_iovlen = 1;
+		msg.msg_flags = 0;
+		msg.msg_control = cbuf;
+		msg.msg_controllen = sizeof(cbuf);
+
+		cc = recvmsg(rcvsock, &msg, 0);
+		if (cc >= 0) {
+			struct cmsghdr *cmsg;
+			struct in6_pktinfo *ipi;
+
+			for (cmsg = CMSG_FIRSTHDR(&msg);
+			     cmsg;
+			     cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+				if (cmsg->cmsg_level != SOL_IPV6)
+					continue;
+				switch (cmsg->cmsg_type) {
+				case IPV6_PKTINFO:
+#if defined IPV6_2292PKTINFO && defined IPV6_RECVPKTINFO
+				case IPV6_2292PKTINFO:
+#endif
+					ipi = (struct in6_pktinfo *)CMSG_DATA(cmsg);
+					memcpy(to, ipi, sizeof(*to));
+				}
+			}
+		}
+	}
+
+	return(cc);
+}
+
+
+static void send_probe6(int seq, int ttl)
+{
+	struct outdata6_t *pkt = (struct outdata6_t *) outip;
+	struct timezone tz;
+	int res;
+
+	pkt->ident6  = htonl(ident);
+	pkt->seq6 = htonl(seq);
+	gettimeofday(&pkt->tv, &tz);
+
+	res = setsockopt(sndsock, SOL_IPV6, IPV6_UNICAST_HOPS, &ttl, sizeof(ttl));
+	if (res < 0)
+		bb_perror_msg_and_die("setsockopt UNICAST_HOPS %d", ttl);
+
+	res = xsendto(sndsock, outip, packlen,
+			   (struct sockaddr *)&dest_lsa->u.sa, dest_lsa->len);
+
+	if (res != packlen)  {
+		bb_info_msg("wrote %d chars, ret=%d\n", packlen, res);
+	}
+}
+
+
+static void print_delta6_ms(struct timeval *t1p, struct timeval *t2p)
+{
+	register double dt;
+
+	dt = (double)(t2p->tv_sec - t1p->tv_sec) * 1000.0 +
+	     (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
+
+	printf("  %g ms", dt);
+}
+
+
+static int packet6_ok(u_char *buf, int cc, struct sockaddr_in6 *from,
+	      struct in6_addr *to, int seq,
+	      struct timeval *tv)
+{
+	const struct icmp6_hdr *icp;
+	unsigned char type, code;
+
+	icp = (struct icmp6_hdr *) buf;
+
+	type = icp->icmp6_type;
+	code = icp->icmp6_code;
+
+	if ((type == ICMP6_TIME_EXCEEDED && code == ICMP6_TIME_EXCEED_TRANSIT) ||
+	    type == ICMP6_DST_UNREACH)
+	{
+		struct ip6_hdr *hip;
+		struct udphdr *up;
+		int nexthdr;
+
+		hip = (struct ip6_hdr *)(icp + 1);
+		up  = (struct udphdr *) (hip + 1);
+		nexthdr = hip->ip6_nxt;
+
+		if (nexthdr == IPPROTO_FRAGMENT) {
+			nexthdr = *(unsigned char*)up;
+			up++;
+		}
+		if (nexthdr == IPPROTO_UDP)
+		{
+			struct outdata6_t *pkt;
+
+			pkt = (struct outdata6_t *) (up + 1);
+
+			if (ntohl(pkt->ident6) == ident &&
+			    ntohl(pkt->seq6) == seq)
+			{
+				*tv = pkt->tv;
+				return (type == ICMP6_TIME_EXCEEDED ? -1 : code+1);
+			}
+		}
+
+	}
+
+#if ENABLE_FEATURE_TRACEROUTE_VERBOSE
+	if (verbose) {
+		unsigned char *p;
+		char pa1[MAXHOSTNAMELEN];
+		char pa2[MAXHOSTNAMELEN];
+		int i;
+
+		p = (unsigned char *) (icp + 1);
+
+		printf("\n%d bytes from %s to "
+		       "%s: icmp type %d (%s) code %d\n",
+			cc,
+			inet_ntop(AF_INET6, &from->sin6_addr, pa1, sizeof(pa1)),
+			inet_ntop(AF_INET6, to, pa2, sizeof(pa2)),
+			type, pr6_type(type), icp->icmp6_code);
+
+		cc -= sizeof(struct icmp6_hdr);
+		for (i = 0; i < cc ; i++) {
+			if (i % 16 == 0)
+				printf("%04x:", i);
+			if (i % 4 == 0)
+				printf(" ");
+			printf("%02x", 0xff & (unsigned)p[i]);
+			if (i % 16 == 15 && i + 1 < cc)
+				printf("\n");
+		}
+		printf("\n");
+	}
+#endif
+
+	return(0);
+}
+#endif /* ENABLE_TRACEROUTE6 */
+
+int traceroute(int argc, char **argv, sa_family_t af);
+int traceroute(int argc, char **argv, sa_family_t af)
 {
-	int minpacket;
-	int ttl, i;
-	int seq = 0;
-	int tos = 0;
-	int max_ttl = 30;
-	int nprobes = 3;
-	int first_ttl = 1;
-	unsigned pausemsecs = 0;
 	unsigned op;
+	int minpacket;
 	char *source;
 	char *device;
 	char *tos_str;
@@ -674,9 +962,15 @@ int traceroute_main(int argc, char **arg
 	}
 #endif
 
-	minpacket = sizeof(*outip) + SIZEOF_ICMP_HDR + sizeof(*outdata) + optlen;
-	if (!(op & OPT_USE_ICMP))
-		minpacket += sizeof(*outudp) - SIZEOF_ICMP_HDR;
+	if (af == AF_INET) {
+		minpacket = sizeof(*outip) + SIZEOF_ICMP_HDR + sizeof(*outdata) + optlen;
+		if (!(op & OPT_USE_ICMP))
+			minpacket += sizeof(*outudp) - SIZEOF_ICMP_HDR;
+	}
+#if ENABLE_TRACEROUTE6
+	else
+		minpacket = sizeof(struct outdata6_t);
+#endif
 	packlen = minpacket;
 
 	/* Process destination and optional packet size */
@@ -687,7 +981,10 @@ int traceroute_main(int argc, char **arg
 		packlen = xatoul_range(argv[1], minpacket, 32 * 1024);
 		/* Fall through */
 	case 1:
-		dest_lsa = xhost2sockaddr(argv[0], port);
+		dest_lsa = xhost_and_af2sockaddr(argv[0], port, af);
+#if ENABLE_TRACEROUTE6
+		firsthop = dest_lsa->u.sin6;
+#endif
 		break;
 	default:
 		bb_show_usage();
@@ -696,7 +993,24 @@ int traceroute_main(int argc, char **arg
 	/* Ensure the socket fds won't be 0, 1 or 2 */
 	bb_sanitize_stdio();
 
+#if ENABLE_TRACEROUTE6
+	if (af == AF_INET6) {
+
+		xmove_fd(xsocket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6), rcvsock);
+
+#ifdef IPV6_RECVPKTINFO
+		setsockopt(rcvsock, SOL_IPV6, IPV6_RECVPKTINFO,
+				&const_int_1, sizeof(const_int_1));
+		setsockopt(rcvsock, SOL_IPV6, IPV6_2292PKTINFO,
+				&const_int_1, sizeof(const_int_1));
+#else
+		setsockopt(rcvsock, SOL_IPV6, IPV6_PKTINFO,
+				&const_int_1, sizeof(const_int_1));
+#endif
+	} else
+#endif /* ENABLE_TRACEROUTE6 */
 	xmove_fd(xsocket(AF_INET, SOCK_RAW, IPPROTO_ICMP), rcvsock);
+
 #if TRACEROUTE_SO_DEBUG
 	if (op & OPT_DEBUG)
 		setsockopt(rcvsock, SOL_SOCKET, SO_DEBUG,
@@ -706,10 +1020,23 @@ int traceroute_main(int argc, char **arg
 		setsockopt(rcvsock, SOL_SOCKET, SO_DONTROUTE,
 				&const_int_1, sizeof(const_int_1));
 
+#if ENABLE_TRACEROUTE6
+	if (af == AF_INET6)
+	{
+		int on = 2;
+
+		if (setsockopt(rcvsock, SOL_RAW, IPV6_CHECKSUM,
+			   &on, sizeof(on)) < 0)
+			bb_perror_msg_and_die("setsockopt RAW_CHECKSUM");
+
+		xmove_fd(xsocket(af, SOCK_DGRAM, 0), sndsock);
+	} else
+#endif
+	{
 	if (op & OPT_USE_ICMP)
-		xmove_fd(xsocket(AF_INET, SOCK_RAW, IPPROTO_ICMP), sndsock);
+		xmove_fd(xsocket(af, SOCK_RAW, IPPROTO_ICMP), sndsock);
 	else
-		xmove_fd(xsocket(AF_INET, SOCK_DGRAM, 0), sndsock);
+		xmove_fd(xsocket(af, SOCK_DGRAM, 0), sndsock);
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 #if defined(IP_OPTIONS)
 	if (lsrr > 0) {
@@ -736,6 +1063,8 @@ int traceroute_main(int argc, char **arg
 	}
 #endif /* IP_OPTIONS */
 #endif /* CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE */
+	}
+
 #ifdef SO_SNDBUF
 	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, &packlen, sizeof(packlen)) < 0) {
 		bb_perror_msg_and_die("SO_SNDBUF");
@@ -762,14 +1091,19 @@ int traceroute_main(int argc, char **arg
 
 	outip = xzalloc(packlen);
 
+        ident = getpid();
+
+	if (af == AF_INET)
+	{
 	if (op & OPT_USE_ICMP) {
-		ident = getpid() | 0x8000;
+		ident |= 0x8000;
 		outicmp->icmp_type = ICMP_ECHO;
 		outicmp->icmp_id = htons(ident);
 		outdata = (struct outdata_t *)((char *)outicmp + SIZEOF_ICMP_HDR);
 	} else {
 		outdata = (struct outdata_t *)(outudp + 1);
 	}
+	}
 
 	if (op & OPT_DEVICE) /* hmm, do we need error check? */
 		setsockopt_bindtodevice(sndsock, device);
@@ -785,6 +1119,38 @@ int traceroute_main(int argc, char **arg
 		xbind(sndsock, &source_lsa->u.sa, source_lsa->len);
 		free(source_lsa);
 	}
+#if ENABLE_TRACEROUTE6
+	else if (af == AF_INET6) {
+		struct sockaddr_in6 saddr;
+		socklen_t alen;
+		int probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
+
+		if (probe_fd < 0) {
+			bb_perror_msg_and_die("probe socket");
+		}
+		if (op & OPT_DEVICE) {
+			if (setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device)+1) == -1)
+				bb_perror_msg("WARNING: interface is ignored");
+		}
+		firsthop.sin6_port = htons(1025);
+		if (connect(probe_fd, (struct sockaddr*)&firsthop, sizeof(firsthop)) == -1) {
+			bb_perror_msg_and_die("connect");
+		}
+		alen = sizeof(saddr);
+		if (getsockname(probe_fd, (struct sockaddr*)&saddr, &alen) == -1) {
+			bb_perror_msg_and_die("getsockname");
+		}
+		saddr.sin6_port = 0;
+		close(probe_fd);
+
+		if (bind(sndsock, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
+			bb_perror_msg_and_die("bind send socket");
+		}
+		if (bind(rcvsock, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
+			bb_perror_msg_and_die("bind icmp6 socket");
+		}
+	}
+#endif /* ENABLE_TRACEROUTE6 */
 
 	/* Revert to non-privileged user after opening sockets */
 	xsetgid(getgid());
@@ -796,6 +1162,23 @@ int traceroute_main(int argc, char **arg
 		printf(" from %s", source);
 	printf(", %d hops max, %d byte packets\n", max_ttl, packlen);
 
+	return 0;
+}
+
+/*
+Usage: [-dFIlnrvx] [-g gateway] [-i iface] [-f first_ttl]
+[-m max_ttl] [ -p port] [-q nqueries] [-s src_addr] [-t tos]
+[-w waittime] [-z pausemsecs] host [packetlen]"
+*/
+
+int traceroute_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int traceroute_main(int argc, char **argv)
+{
+	int ttl, i;
+	int seq = 0;
+
+	traceroute(argc, argv, AF_INET);
+
 	for (ttl = first_ttl; ttl <= max_ttl; ++ttl) {
 //TODO: make it protocol agnostic (get rid of sockaddr_in)
 		struct sockaddr_in from;
@@ -836,7 +1219,7 @@ int traceroute_main(int argc, char **arg
 				}
 				print_delta_ms(t1, t2);
 				ip = (struct ip *)recv_pkt;
-				if (op & OPT_TTL_FLAG)
+				if (option_mask32 & OPT_TTL_FLAG)
 					printf(" (%d)", ip->ip_ttl);
 				if (i == -2) {
 					if (ip->ip_ttl <= 1)
@@ -924,3 +1307,79 @@ int traceroute_main(int argc, char **arg
 	}
 	return 0;
 }
+
+#if ENABLE_TRACEROUTE6
+int traceroute6_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int traceroute6_main(int argc, char **argv)
+{
+	int i, probe, ttl;
+	int seq = 0;
+
+	traceroute(argc, argv, AF_INET6);
+
+	for (ttl = first_ttl; ttl <= max_ttl; ++ttl) {
+		struct in6_addr lastaddr = {{{0,}}};
+		int got_there = 0;
+		int unreachable = 0;
+
+		printf("%2d ", ttl);
+		for (probe = 0; probe < nprobes; ++probe) {
+			int cc, reset_timer;
+			struct timeval t1, t2;
+			struct timezone tz;
+			struct sockaddr_in6 from;
+			struct in6_addr to;
+
+			gettimeofday(&t1, &tz);
+			send_probe6(++seq, ttl);
+			reset_timer = 1;
+			fflush(stdout);
+
+			while ((cc = wait_for_reply6(rcvsock, &from, &to, reset_timer)) != 0) {
+				gettimeofday(&t2, &tz);
+				if ((i = packet6_ok(recv_pkt, cc, &from, &to, seq, &t1))) {
+					reset_timer = 1;
+					if (memcmp(&from.sin6_addr, &lastaddr, sizeof(from.sin6_addr))) {
+						print_inetname((const struct sockaddr_in *)&from);
+						memcpy(&lastaddr,
+						       &from.sin6_addr,
+						       sizeof(lastaddr));
+					}
+					print_delta6_ms(&t1, &t2);
+					switch (i - 1) {
+					case ICMP6_DST_UNREACH_NOPORT:
+						++got_there;
+						break;
+
+					case ICMP6_DST_UNREACH_NOROUTE:
+						++unreachable;
+						printf(" !N");
+						break;
+					case ICMP6_DST_UNREACH_ADDR:
+						++unreachable;
+						printf(" !H");
+						break;
+
+					case ICMP6_DST_UNREACH_ADMIN:
+						++unreachable;
+						printf(" !S");
+						break;
+					}
+					break;
+				} else
+					reset_timer = 0;
+			}
+			if (cc <= 0)
+				printf(" *");
+		}
+		putchar('\n');
+		if (got_there ||
+		    (unreachable > 0 && unreachable >= nprobes-1)
+		) {
+			break;
+		}
+	}
+
+	return 0;
+}
+#endif
