Volume label support to allow use it with swapon

diff -BurpN busybox-1.15.3/include/usage.h busybox/include/usage.h
--- busybox-1.15.3/include/usage.h	2009-07-22 15:26:30.000000000 +0000
+++ busybox/include/usage.h	2009-12-13 18:49:23.000000000 +0000
@@ -2820,9 +2820,11 @@
        "$ mknod -m 644 /tmp/pipe p\n"
 
 #define mkswap_trivial_usage \
-       "DEVICE"
+       "[-L label] DEVICE"
 #define mkswap_full_usage "\n\n" \
-       "Prepare block device to be used as swap partition"
+       "Prepare block device to be used as swap partition" \
+     "\nOptions:" \
+     "\n	-L lbl	Volume label"
 #if 0
        "[-c] [-v0|-v1] DEVICE [BLOCKS]"
      "\nOptions:"
diff -BurpN busybox-1.15.3/util-linux/mkswap.c busybox/util-linux/mkswap.c
--- busybox-1.15.3/util-linux/mkswap.c	2009-12-12 21:13:29.000000000 +0000
+++ busybox/util-linux/mkswap.c	2009-12-13 18:33:23.000000000 +0000
@@ -164,19 +164,26 @@ struct BUG_bufsiz1_is_too_small {
 /* Stored without terminating NUL */
 static const char SWAPSPACE2[sizeof("SWAPSPACE2")-1] ALIGN1 = "SWAPSPACE2";
 
+#define OPTION_STR "L:"
+enum {
+	OPT_L = (1 << 0),
+};
+
 int mkswap_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mkswap_main(int argc, char **argv)
+int mkswap_main(int argc UNUSED_PARAM, char **argv)
 {
 	int fd, pagesize;
 	off_t len;
+	char *opt_label = NULL;
+	unsigned opt;
 
-	// No options supported.
-
-	if (argc != 2) bb_show_usage();
+	opt = getopt32(argv, OPTION_STR, &opt_label);
+	argv += optind;
+	if (!argv[0]) bb_show_usage();
 
 	// Figure out how big the device is and announce our intentions.
 
-	fd = xopen(argv[1], O_RDWR);
+	fd = xopen(argv[0], O_RDWR);
 	/* fdlength was reported to be unreliable - use seek */
 	len = xlseek(fd, 0, SEEK_END);
 #if ENABLE_SELINUX
@@ -185,12 +192,14 @@ int mkswap_main(int argc, char **argv)
 	pagesize = getpagesize();
 	printf("Setting up swapspace version 1, size = %"OFF_FMT"u bytes\n",
 			len - pagesize);
-	mkswap_selinux_setcontext(fd, argv[1]);
+	mkswap_selinux_setcontext(fd, argv[0]);
 
 	// Make a header. hdr is zero-filled so far...
 	hdr[0] = 1;
 	hdr[1] = (len / pagesize) - 1;
 	mkswap_generate_uuid((void*) &hdr[3]);
+	if (opt & OPT_L)
+		strncpy((void*) &hdr[7], opt_label, 16);
 
 	// Write the header.  Sync to disk because some kernel versions check
 	// signature on disk (not in cache) during swapon.
