--- src/shared.1927/bcmsrom.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmsrom.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,54 +12,140 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <stdarg.h>
 #include <bcmutils.h>
-#include <bcmsrom.h>
+#include <sbchipc.h>
 #include <bcmdevs.h>
 #include <bcmendian.h>
 #include <sbpcmcia.h>
 #include <pcicfg.h>
+#include <sbconfig.h>
 #include <sbutils.h>
+#include <bcmsrom.h>
 
+#include <bcmnvram.h>
+#include <bcmotp.h>
+
+#if defined(CONFIG_BCMUSBDEV)
+#include <sbsdio.h>
+#include <sbhnddma.h>
+#include <sbsdpcmdev.h>
+#endif 
+
+#ifdef WLTEST
+#include <sbsprom.h>
+#endif /* WLTEST */
 #include <proto/ethernet.h>	/* for sprom content groking */
 
-#define	VARS_MAX	4096	/* should be reduced */
+/* debug/trace */
+#if defined(WLTEST)
+#define	BS_ERROR(args)	printf args
+#else
+#define	BS_ERROR(args)
+#endif	
 
 #define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
 #define WRITE_WORD_DELAY	20	/* 20 ms between each word write */
 
-static int initvars_srom_pci(void *osh, void *curmap, char **vars, int *count);
-static int initvars_cis_pcmcia(void *sbh, void *curmap, void *osh, char **vars, int *count);
-static int srom_parsecis(void *osh, uint8 *cis, char **vars, int *count);
-static int sprom_cmd_pcmcia(void *osh, uint8 cmd);
-static int sprom_read_pcmcia(void *osh, uint16 addr, uint16 *data);
-static int sprom_write_pcmcia(void *osh, uint16 addr, uint16 data);
-static int sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc);
+typedef struct varbuf {
+	char *buf;		/* pointer to current position */
+	unsigned int size;	/* current (residual) size in bytes */
+} varbuf_t;
+
+static int initvars_srom_sb(sb_t *sbh, osl_t *osh, void *curmap, char **vars, uint *count);
+static void _initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off, varbuf_t *b);
+static int initvars_srom_pci(sb_t *sbh, void *curmap, char **vars, uint *count);
+static int initvars_cis_pcmcia(sb_t *sbh, osl_t *osh, char **vars, uint *count);
+#if !defined(CONFIG_BCMUSBDEV) && !defined(CONFIG_BCMSDIODEV)
+static int initvars_flash_sb(sb_t *sbh, char **vars, uint *count);
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+static int sprom_cmd_pcmcia(osl_t *osh, uint8 cmd);
+static int sprom_read_pcmcia(osl_t *osh, uint16 addr, uint16 *data);
+static int sprom_write_pcmcia(osl_t *osh, uint16 addr, uint16 data);
+static int sprom_read_pci(osl_t *osh, uint16 *sprom, uint wordoff, uint16 *buf, uint nwords,
+                          bool check_crc);
+
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars, uint *count);
+static int initvars_flash(sb_t *sbh, osl_t *osh, char **vp, uint len);
+
+#ifdef BCMUSBDEV
+static int get_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                              uint boff, uint16 *srom, uint bsz);
+static int set_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                              uint boff, uint16 *srom, uint bsz);
+static uint srom_size(sb_t *sbh, osl_t *osh);
+#endif /* def BCMUSBDEV */
+
+/* Initialization of varbuf structure */
+static void
+varbuf_init(varbuf_t *b, char *buf, uint size)
+{
+	b->size = size;
+	b->buf = buf;
+}
+
+/* append a null terminated var=value string */
+static int
+varbuf_append(varbuf_t *b, const char *fmt, ...)
+{
+	va_list ap;
+	int r;
+
+	if (b->size < 2)
+	  return 0;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+	va_end(ap);
+
+	/* C99 snprintf behavior returns r >= size on overflow,
+	 * others return -1 on overflow.
+	 * All return -1 on format error.
+	 * We need to leave room for 2 null terminations, one for the current var
+	 * string, and one for final null of the var table. So check that the
+	 * strlen written, r, leaves room for 2 chars.
+	 */
+	if ((r == -1) || (r > (int)(b->size - 2))) {
+		b->size = 0;
+		return 0;
+	}
+
+	/* skip over this string's null termination */
+	r++;
+	b->size -= r;
+	b->buf += r;
+
+	return r;
+}
 
 /*
  * Initialize local vars from the right source for this platform.
  * Return 0 on success, nonzero on error.
  */
 int
-srom_var_init(void *sbh, uint bustype, void *curmap, void *osh, char **vars, int *count)
+BCMINITFN(srom_var_init)(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+	char **vars, uint *count)
 {
 	ASSERT(bustype == BUSTYPE(bustype));
-	if (vars == NULL)
+	if (vars == NULL || count == NULL)
 		return (0);
 
-	switch (BUSTYPE(bustype)) {
-	case SB_BUS:
-		/* These two could be asserts ... */
 		*vars = NULL;
 		*count = 0;
-		return(0);
+
+	switch (BUSTYPE(bustype)) {
+	case SB_BUS:
+	case JTAG_BUS:
+		return initvars_srom_sb(sbh, osh, curmap, vars, count);
 
 	case PCI_BUS:
 		ASSERT(curmap);	/* can not be NULL */
-		return(initvars_srom_pci(osh, curmap, vars, count));
+		return initvars_srom_pci(sbh, curmap, vars, count);
 
 	case PCMCIA_BUS:
-		return(initvars_cis_pcmcia(sbh, curmap, osh, vars, count));
+		return initvars_cis_pcmcia(sbh, osh, vars, count);
 
 
 	default:
@@ -70,7 +156,8 @@
 
 /* support only 16-bit word read from srom */
 int
-srom_read(uint bustype, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_read(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+          uint byteoff, uint nbytes, uint16 *buf)
 {
 	void *srom;
 	uint i, off, nw;
@@ -88,13 +175,39 @@
 		if (!curmap)
 			return 1;
 		srom = (uchar*)curmap + PCI_BAR0_SPROM_OFFSET;
-		if (sprom_read_pci(srom, off, buf, nw, FALSE))
+		if (sprom_read_pci(osh, srom, off, buf, nw, FALSE))
 			return 1;
 	} else if (BUSTYPE(bustype) == PCMCIA_BUS) {
 		for (i = 0; i < nw; i++) {
-			if (sprom_read_pcmcia(osh, (uint16)(off + i), (uint16*)(buf + i)))
+			if (sprom_read_pcmcia(osh, (uint16)(off + i), (uint16 *)(buf + i)))
 				return 1;
 		}
+	} else if (BUSTYPE(bustype) == SB_BUS) {
+#ifdef BCMUSBDEV
+		if (SPROMBUS == PCMCIA_BUS) {
+			uint origidx;
+			void *regs;
+			int rc;
+			bool wasup;
+
+			origidx = sb_coreidx(sbh);
+			regs = sb_setcore(sbh, SB_PCMCIA, 0);
+			ASSERT(regs != NULL);
+
+			if (!(wasup = sb_iscoreup(sbh)))
+				sb_core_reset(sbh, 0, 0);
+
+			rc = get_sb_pcmcia_srom(sbh, osh, regs, byteoff, buf, nbytes);
+
+			if (!wasup)
+				sb_core_disable(sbh, 0);
+
+			sb_setcoreidx(sbh, origidx);
+			return rc;
+		}
+#endif /* def BCMUSBDEV */
+
+		return 1;
 	} else {
 		return 1;
 	}
@@ -104,45 +217,69 @@
 
 /* support only 16-bit word write into srom */
 int
-srom_write(uint bustype, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_write(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+           uint byteoff, uint nbytes, uint16 *buf)
 {
 	uint16 *srom;
-	uint i, off, nw, crc_range;
-	uint16 image[SPROM_SIZE], *p;
+	uint i, nw, crc_range;
+	uint16 image[SPROM_SIZE];
 	uint8 crc;
 	volatile uint32 val32;
 
 	ASSERT(bustype == BUSTYPE(bustype));
 
 	/* check input - 16-bit access only */
-	if (byteoff & 1 || nbytes & 1 || (byteoff + nbytes) > (SPROM_SIZE * 2))
+	if ((byteoff & 1) || (nbytes & 1))
 		return 1;
 
-	crc_range = (((BUSTYPE(bustype) == PCMCIA_BUS) || (BUSTYPE(bustype) == SDIO_BUS)) ? SPROM_SIZE : SPROM_CRC_RANGE) * 2;
+	if (byteoff == 0x55aa) {
+		/* Erase request */
+		crc_range = 0;
+		memset((void *)image, 0xff, nbytes);
+		nw = nbytes / 2;
+	} else if ((byteoff == 0) &&
+	           ((nbytes == SPROM_SIZE * 2) ||
+	            (nbytes == (SPROM_CRC_RANGE * 2)) ||
+	            (nbytes == (SROM4_WORDS * 2)))) {
+		/* Are we writing the whole thing at once? */
+		crc_range = nbytes;
+		bcopy((void *)buf, (void *)image, nbytes);
+		nw = nbytes / 2;
+	} else {
+		if ((byteoff + nbytes) > (SPROM_SIZE * 2))
+			return 1;
 
-	/* if changes made inside crc cover range */
-	if (byteoff < crc_range) {
-		nw = (((byteoff + nbytes) > crc_range) ? byteoff + nbytes : crc_range) / 2;
-		/* read data including entire first 64 words from srom */
-		if (srom_read(bustype, curmap, osh, 0, nw * 2, image))
+		if (BUSTYPE(bustype) == PCMCIA_BUS) {
+			crc_range = SPROM_SIZE * 2;
+		}
+		else {
+			crc_range = SPROM_CRC_RANGE * 2;	/* Tentative */
+		}
+
+		nw = crc_range / 2;
+		/* read first 64 words from srom */
+		if (srom_read(sbh, bustype, curmap, osh, 0, crc_range, image))
+			return 1;
+		if (image[SROM4_SIGN] == SROM4_SIGNATURE) {
+			nw = SROM4_WORDS;
+			crc_range = nw * 2;
+			if (srom_read(sbh, bustype, curmap, osh, 0, crc_range, image))
 			return 1;
+		}
 		/* make changes */
-		bcopy((void*)buf, (void*)&image[byteoff / 2], nbytes);
+		bcopy((void *)buf, (void *)&image[byteoff / 2], nbytes);
+	}
+
+	if (crc_range) {
 		/* calculate crc */
 		htol16_buf(image, crc_range);
 		crc = ~hndcrc8((uint8 *)image, crc_range - 1, CRC8_INIT_VALUE);
 		ltoh16_buf(image, crc_range);
-		image[(crc_range / 2) - 1] = (crc << 8) | (image[(crc_range / 2) - 1] & 0xff);
-		p = image;
-		off = 0;
-	} else {
-		p = buf;
-		off = byteoff / 2;
-		nw = nbytes / 2;
+		image[nw - 1] = (crc << 8) | (image[nw - 1] & 0xff);
 	}
 
 	if (BUSTYPE(bustype) == PCI_BUS) {
-		srom = (uint16*)((uchar*)curmap + PCI_BAR0_SPROM_OFFSET);
+		srom = (uint16 *)((uchar*)curmap + PCI_BAR0_SPROM_OFFSET);
 		/* enable writes to the SPROM */
 		val32 = OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32));
 		val32 |= SPROM_WRITEEN;
@@ -150,11 +287,12 @@
 		bcm_mdelay(WRITE_ENABLE_DELAY);
 		/* write srom */
 		for (i = 0; i < nw; i++) {
-			W_REG(&srom[off + i], p[i]);
+			W_REG(osh, &srom[i], image[i]);
 			bcm_mdelay(WRITE_WORD_DELAY);
 		}
 		/* disable writes to the SPROM */
-		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32 & ~SPROM_WRITEEN);
+		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32 &
+		                     ~SPROM_WRITEEN);
 	} else if (BUSTYPE(bustype) == PCMCIA_BUS) {
 		/* enable writes to the SPROM */
 		if (sprom_cmd_pcmcia(osh, SROM_WEN))
@@ -162,12 +300,37 @@
 		bcm_mdelay(WRITE_ENABLE_DELAY);
 		/* write srom */
 		for (i = 0; i < nw; i++) {
-			sprom_write_pcmcia(osh, (uint16)(off + i), p[i]);
+			sprom_write_pcmcia(osh, (uint16)(i), image[i]);
 			bcm_mdelay(WRITE_WORD_DELAY);
 		}
 		/* disable writes to the SPROM */
 		if (sprom_cmd_pcmcia(osh, SROM_WDS))
 			return 1;
+	} else if (BUSTYPE(bustype) == SB_BUS) {
+#ifdef BCMUSBDEV
+		if (SPROMBUS == PCMCIA_BUS) {
+			uint origidx;
+			void *regs;
+			int rc;
+			bool wasup;
+
+			origidx = sb_coreidx(sbh);
+			regs = sb_setcore(sbh, SB_PCMCIA, 0);
+			ASSERT(regs != NULL);
+
+			if (!(wasup = sb_iscoreup(sbh)))
+				sb_core_reset(sbh, 0, 0);
+
+			rc = set_sb_pcmcia_srom(sbh, osh, regs, byteoff, buf, nbytes);
+
+			if (!wasup)
+				sb_core_disable(sbh, 0);
+
+			sb_setcoreidx(sbh, origidx);
+			return rc;
+		}
+#endif /* def BCMUSBDEV */
+		return 1;
 	} else {
 		return 1;
 	}
@@ -176,25 +339,231 @@
 	return 0;
 }
 
+#ifdef BCMUSBDEV
+#define SB_PCMCIA_READ(osh, regs, fcr) \
+		R_REG(osh, (volatile uint8 *)(regs) + 0x600 + (fcr) - 0x700 / 2)
+#define SB_PCMCIA_WRITE(osh, regs, fcr, v) \
+		W_REG(osh, (volatile uint8 *)(regs) + 0x600 + (fcr) - 0x700 / 2, v)
+
+/* set PCMCIA srom command register */
+static int
+srom_cmd_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint8 cmd)
+{
+	uint8 status = 0;
+	uint wait_cnt = 0;
+
+	/* write srom command register */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_CS, cmd);
+
+	/* wait status */
+	while (++wait_cnt < 1000000) {
+		status = SB_PCMCIA_READ(osh, pcmregs, SROM_CS);
+		if (status & SROM_DONE)
+			return 0;
+		OSL_DELAY(1);
+	}
+
+	BS_ERROR(("sr_cmd: Give up after %d tries, stat = 0x%x\n", wait_cnt, status));
+	return 1;
+}
+
+/* read a word from the PCMCIA srom over SB */
+static int
+srom_read_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint16 addr, uint16 *data)
+{
+	uint8 addr_l, addr_h,  data_l, data_h;
+
+	addr_l = (uint8)((addr * 2) & 0xff);
+	addr_h = (uint8)(((addr * 2) >> 8) & 0xff);
+
+	/* set address */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRH, addr_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRL, addr_l);
+
+	/* do read */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_READ))
+		return 1;
 
+	/* read data */
+	data_h = SB_PCMCIA_READ(osh, pcmregs, SROM_DATAH);
+	data_l = SB_PCMCIA_READ(osh, pcmregs, SROM_DATAL);
+	*data = ((uint16)data_h << 8) | data_l;
+
+	return 0;
+}
+
+/* write a word to the PCMCIA srom over SB */
 static int
-srom_parsecis(void *osh, uint8 *cis, char **vars, int *count)
+srom_write_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint16 addr, uint16 data)
+{
+	uint8 addr_l, addr_h, data_l, data_h;
+	int rc;
+
+	addr_l = (uint8)((addr * 2) & 0xff);
+	addr_h = (uint8)(((addr * 2) >> 8) & 0xff);
+
+	/* set address */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRH, addr_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRL, addr_l);
+
+	data_l = (uint8)(data & 0xff);
+	data_h = (uint8)((data >> 8) & 0xff);
+
+	/* write data */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_DATAH, data_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_DATAL, data_l);
+
+	/* do write */
+	rc = srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WRITE);
+	OSL_DELAY(20000);
+	return rc;
+}
+
+/*
+ * Read the srom for the pcmcia-srom over sb case.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+get_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                   uint boff, uint16 *srom, uint bsz)
+{
+	uint i, nw, woff, wsz;
+	int err = 0;
+
+	/* read must be at word boundary */
+	ASSERT((boff & 1) == 0 && (bsz & 1) == 0);
+
+	/* read sprom size and validate the parms */
+	if ((nw = srom_size(sbh, osh)) == 0) {
+		BS_ERROR(("get_sb_pcmcia_srom: sprom size unknown\n"));
+		err = -1;
+		goto out;
+	}
+	if (boff + bsz > 2 * nw) {
+		BS_ERROR(("get_sb_pcmcia_srom: sprom size exceeded\n"));
+		err = -2;
+		goto out;
+	}
+
+	/* read in sprom contents */
+	for (woff = boff / 2, wsz = bsz / 2, i = 0;
+	     woff < nw && i < wsz; woff ++, i ++) {
+		if (srom_read_sb_pcmcia(osh, pcmregs, (uint16)woff, &srom[i])) {
+			BS_ERROR(("get_sb_pcmcia_srom: sprom read failed\n"));
+			err = -3;
+			goto out;
+		}
+	}
+
+out:
+	return err;
+}
+
+/*
+ * Write the srom for the pcmcia-srom over sb case.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+set_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                   uint boff, uint16 *srom, uint bsz)
+{
+	uint i, nw, woff, wsz;
+	uint16 word;
+	uint8 crc;
+	int err = 0;
+
+	/* write must be at word boundary */
+	ASSERT((boff & 1) == 0 && (bsz & 1) == 0);
+
+	/* read sprom size and validate the parms */
+	if ((nw = srom_size(sbh, osh)) == 0) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom size unknown\n"));
+		err = -1;
+		goto out;
+	}
+	if (boff + bsz > 2 * nw) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom size exceeded\n"));
+		err = -2;
+		goto out;
+	}
+
+	/* enable write */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WEN)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom wen failed\n"));
+		err = -3;
+		goto out;
+	}
+
+	/* write buffer to sprom */
+	for (woff = boff / 2, wsz = bsz / 2, i = 0;
+	     woff < nw && i < wsz; woff ++, i ++) {
+		if (srom_write_sb_pcmcia(osh, pcmregs, (uint16)woff, srom[i])) {
+			BS_ERROR(("set_sb_pcmcia_srom: sprom write failed\n"));
+			err = -4;
+			goto out;
+		}
+	}
+
+	/* fix crc */
+	crc = CRC8_INIT_VALUE;
+	for (woff = 0; woff < nw; woff ++) {
+		if (srom_read_sb_pcmcia(osh, pcmregs, (uint16)woff, &word)) {
+			BS_ERROR(("set_sb_pcmcia_srom: sprom fix crc read failed\n"));
+			err = -5;
+			goto out;
+		}
+		word = htol16(word);
+		crc = hndcrc8((uint8 *)&word, woff != nw - 1 ? 2 : 1, crc);
+	}
+	word = (~crc << 8) + (ltoh16(word) & 0xff);
+	if (srom_write_sb_pcmcia(osh, pcmregs, (uint16)(woff - 1), word)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom fix crc write failed\n"));
+		err = -6;
+		goto out;
+	}
+
+	/* disable write */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WDS)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom wds failed\n"));
+		err = -7;
+		goto out;
+	}
+
+out:
+	return err;
+}
+#endif /* def BCMUSBDEV */
+
+int
+srom_parsecis(osl_t *osh, uint8 *pcis[], uint ciscnt, char **vars, uint *count)
 {
 	char eabuf[32];
-	char *vp, *base;
-	uint8 tup, tlen, sromrev = 1;
+	char *base;
+	varbuf_t b;
+	uint8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
 	uint varsize;
 	bool ag_init = FALSE;
-	uint16 w;
+	uint32 w32;
+	uint funcid;
+	uint cisnum;
+	int32 boardnum = -1;
 
 	ASSERT(vars);
 	ASSERT(count);
 
-	base = vp = MALLOC(osh, VARS_MAX);
-	ASSERT(vp);
-
+	base = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	ASSERT(base);
+	if (!base)
+		return -2;
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+
+	eabuf[0] = '\0';
+	for (cisnum = 0; cisnum < ciscnt; cisnum++) {
+		cis = *pcis++;
 	i = 0;
+		funcid = 0;
 	do {
 		tup = cis[i++];
 		tlen = cis[i++];
@@ -202,142 +571,335 @@
 			break;
 
 		switch (tup) {
+			case CISTPL_VERS_1:
+				/* assume the strings are good if the version field checks out */
+				if (((cis[i + 1] << 8) + cis[i]) >= 0x0008) {
+					varbuf_append(&b, "manf=%s", &cis[i + 2]);
+					varbuf_append(&b, "productname=%s",
+					              &cis[i + 3 + strlen((char *)&cis[i + 2])]);
+					break;
+				}
+
 		case CISTPL_MANFID:
-			vp += sprintf(vp, "manfid=%d", (cis[i + 1] << 8) + cis[i]);
-			vp++;
-			vp += sprintf(vp, "prodid=%d", (cis[i + 3] << 8) + cis[i + 2]);
-			vp++;
+				varbuf_append(&b, "manfid=0x%x", (cis[i + 1] << 8) + cis[i]);
+				varbuf_append(&b, "prodid=0x%x", (cis[i + 3] << 8) + cis[i + 2]);
+				break;
+
+			case CISTPL_FUNCID:
+				funcid = cis[i];
 			break;
 
 		case CISTPL_FUNCE:
-			if (cis[i] == LAN_NID) {
+				switch (funcid) {
+				default:
+					/* set macaddr if HNBU_MACADDR not seen yet */
+					if (eabuf[0] == '\0' && cis[i] == LAN_NID) {
 				ASSERT(cis[i + 1] == ETHER_ADDR_LEN);
-				bcm_ether_ntoa((uchar*)&cis[i + 2], eabuf);
-				vp += sprintf(vp, "il0macaddr=%s", eabuf);
-				vp++;
+						bcm_ether_ntoa((struct ether_addr *)&cis[i + 2],
+						               eabuf);
+					}
+					/* set boardnum if HNBU_BOARDNUM not seen yet */
+					if (boardnum == -1)
+						boardnum = (cis[i + 6] << 8) + cis[i + 7];
+					break;
 			}
 			break;
 
 		case CISTPL_CFTABLE:
-			vp += sprintf(vp, "regwindowsz=%d", (cis[i + 7] << 8) | cis[i + 6]);
-			vp++;
+				varbuf_append(&b, "regwindowsz=%d", (cis[i + 7] << 8) | cis[i + 6]);
 			break;
 
 		case CISTPL_BRCM_HNBU:
 			switch (cis[i]) {
+				case HNBU_SROMREV:
+					sromrev = cis[i + 1];
+					varbuf_append(&b, "sromrev=%d", sromrev);
+					break;
+
 			case HNBU_CHIPID:
-				vp += sprintf(vp, "vendid=%d", (cis[i + 2] << 8) + cis[i + 1]);
-				vp++;
-				vp += sprintf(vp, "devid=%d", (cis[i + 4] << 8) + cis[i + 3]);
-				vp++;
-				if (tlen == 7) {
-					vp += sprintf(vp, "chiprev=%d", (cis[i + 6] << 8) + cis[i + 5]);
-					vp++;
+					varbuf_append(&b, "vendid=0x%x", (cis[i + 2] << 8) +
+					              cis[i + 1]);
+					varbuf_append(&b, "devid=0x%x", (cis[i + 4] << 8) +
+					              cis[i + 3]);
+					if (tlen >= 7) {
+						varbuf_append(&b, "chiprev=%d",
+						              (cis[i + 6] << 8) + cis[i + 5]);
+					}
+					if (tlen >= 9) {
+						varbuf_append(&b, "subvendid=0x%x",
+						              (cis[i + 8] << 8) + cis[i + 7]);
+					}
+					if (tlen >= 11) {
+						varbuf_append(&b, "subdevid=0x%x",
+						              (cis[i + 10] << 8) + cis[i + 9]);
+						/* subdevid doubles for boardtype */
+						varbuf_append(&b, "boardtype=0x%x",
+						              (cis[i + 10] << 8) + cis[i + 9]);
 				}
 				break;
 
 			case HNBU_BOARDREV:
-				vp += sprintf(vp, "boardrev=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "boardrev=0x%x", cis[i + 1]);
 				break;
 
 			case HNBU_AA:
-				vp += sprintf(vp, "aa0=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "aa2g=%d", cis[i + 1]);
 				break;
 
 			case HNBU_AG:
-				vp += sprintf(vp, "ag0=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "ag0=%d", cis[i + 1]);
 				ag_init = TRUE;
 				break;
 
+				case HNBU_ANT5G:
+					varbuf_append(&b, "aa5g=%d", cis[i + 1]);
+					varbuf_append(&b, "ag1=%d", cis[i + 2]);
+					break;
+
 			case HNBU_CC:
-				vp += sprintf(vp, "cc=%d", cis[i + 1]);
-				vp++;
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, "cc=%d", cis[i + 1]);
 				break;
 
 			case HNBU_PAPARMS:
-				vp += sprintf(vp, "pa0maxpwr=%d", cis[i + tlen - 1]);
-				vp++;
-				if (tlen == 9) {
-					/* New version */
+					if (tlen == 2) {
+						ASSERT(sromrev == 1);
+						varbuf_append(&b, "pa0maxpwr=%d", cis[i + 1]);
+					} else if (tlen >= 9) {
+						if (tlen == 10) {
+							ASSERT(sromrev >= 2);
+							varbuf_append(&b, "opo=%d", cis[i + 9]);
+						} else
+							ASSERT(tlen == 9);
+
 					for (j = 0; j < 3; j++) {
-						vp += sprintf(vp, "pa0b%d=%d", j,
-							      (cis[i + (j * 2) + 2] << 8) + cis[i + (j * 2) + 1]);
-						vp++;
-					}
-					vp += sprintf(vp, "pa0itssit=%d", cis[i + 7]);
-					vp++;
+							varbuf_append(&b, "pa0b%d=%d", j,
+							              (cis[i + (j * 2) + 2] << 8) +
+							              cis[i + (j * 2) + 1]);
 				}
+						varbuf_append(&b, "pa0itssit=%d", cis[i + 7]);
+						varbuf_append(&b, "pa0maxpwr=%d", cis[i + 8]);
+					} else
+						ASSERT(tlen >= 9);
+					break;
+
+				case HNBU_PAPARMS5G:
+					ASSERT((sromrev == 2) || (sromrev == 3));
+					for (j = 0; j < 3; j++) {
+						varbuf_append(&b, "pa1b%d=%d", j,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					for (j = 3; j < 6; j++) {
+						varbuf_append(&b, "pa1lob%d=%d", j - 3,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					for (j = 6; j < 9; j++) {
+						varbuf_append(&b, "pa1hib%d=%d", j - 6,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					varbuf_append(&b, "pa1itssit=%d", cis[i + 19]);
+					varbuf_append(&b, "pa1maxpwr=%d", cis[i + 20]);
+					varbuf_append(&b, "pa1lomaxpwr=%d", cis[i + 21]);
+					varbuf_append(&b, "pa1himaxpwr=%d", cis[i + 22]);
 				break;
 
 			case HNBU_OEM:
-				vp += sprintf(vp, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
-					cis[i + 1], cis[i + 2], cis[i + 3], cis[i + 4],
-					cis[i + 5], cis[i + 6], cis[i + 7], cis[i + 8]);
-				vp++;
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
+					              cis[i + 1], cis[i + 2],
+					              cis[i + 3], cis[i + 4],
+					              cis[i + 5], cis[i + 6],
+					              cis[i + 7], cis[i + 8]);
 				break;
+
 			case HNBU_BOARDFLAGS:
-				w = (cis[i + 2] << 8) + cis[i + 1];
-				if (w == 0xffff) w = 0;
-				vp += sprintf(vp, "boardflags=%d", w);
-				vp++;
+					w32 = (cis[i + 2] << 8) + cis[i + 1];
+					if (tlen == 5)
+						w32 |= (cis[i + 4] << 24) + (cis[i + 3] << 16);
+					varbuf_append(&b, "boardflags=0x%x", w32);
 				break;
-			case HNBU_LED:
+
+				case HNBU_LEDS:
 				if (cis[i + 1] != 0xff) {
-					vp += sprintf(vp, "wl0gpio0=%d", cis[i + 1]);
-					vp++;
+						varbuf_append(&b, "ledbh0=%d", cis[i + 1]);
 				}
 				if (cis[i + 2] != 0xff) {
-					vp += sprintf(vp, "wl0gpio1=%d", cis[i + 2]);
-					vp++;
+						varbuf_append(&b, "ledbh1=%d", cis[i + 2]);
 				}
 				if (cis[i + 3] != 0xff) {
-					vp += sprintf(vp, "wl0gpio2=%d", cis[i + 3]);
-					vp++;
+						varbuf_append(&b, "ledbh2=%d", cis[i + 3]);
 				}
 				if (cis[i + 4] != 0xff) {
-					vp += sprintf(vp, "wl0gpio3=%d", cis[i + 4]);
-					vp++;
+						varbuf_append(&b, "ledbh3=%d", cis[i + 4]);
 				}
 				break;
-			}
+
+				case HNBU_CCODE:
+					ASSERT(sromrev > 1);
+					if ((cis[i + 1] == 0) || (cis[i + 2] == 0))
+						varbuf_append(&b, "ccode=");
+					else
+						varbuf_append(&b, "ccode=%c%c",
+						              cis[i + 1], cis[i + 2]);
+					varbuf_append(&b, "cctl=0x%x", cis[i + 3]);
+					break;
+
+				case HNBU_CCKPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, "cckpo=0x%x",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_OFDMPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, "ofdmpo=0x%x",
+					              (cis[i + 4] << 24) |
+					              (cis[i + 3] << 16) |
+					              (cis[i + 2] << 8) |
+					              cis[i + 1]);
+					break;
+
+				case HNBU_RDLID:
+					varbuf_append(&b, "rdlid=0x%x",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_RDLRNDIS:
+					varbuf_append(&b, "rdlrndis=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RDLRWU:
+					varbuf_append(&b, "rdlrwu=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RDLSN:
+					varbuf_append(&b, "rdlsn=%d",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_XTALFREQ:
+					varbuf_append(&b, "xtalfreq=%d",
+					              (cis[i + 4] << 24) |
+					              (cis[i + 3] << 16) |
+					              (cis[i + 2] << 8) |
+					              cis[i + 1]);
+					break;
+
+				case HNBU_RSSISMBXA2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rssismf2g=%d", cis[i + 1] & 0xf);
+					varbuf_append(&b, "rssismc2g=%d", (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, "rssisav2g=%d", cis[i + 2] & 0x7);
+					varbuf_append(&b, "bxa2g=%d", (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_RSSISMBXA5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rssismf5g=%d", cis[i + 1] & 0xf);
+					varbuf_append(&b, "rssismc5g=%d", (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, "rssisav5g=%d", cis[i + 2] & 0x7);
+					varbuf_append(&b, "bxa5g=%d", (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_TRI2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "tri2g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_TRI5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "tri5gl=%d", cis[i + 1]);
+					varbuf_append(&b, "tri5g=%d", cis[i + 2]);
+					varbuf_append(&b, "tri5gh=%d", cis[i + 3]);
+					break;
+
+				case HNBU_RXPO2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rxpo2g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RXPO5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rxpo5g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_BOARDNUM:
+					boardnum = (cis[i + 2] << 8) + cis[i + 1];
+					break;
+
+				case HNBU_MACADDR:
+					bcm_ether_ntoa((struct ether_addr *)&cis[i + 1],
+					               eabuf);
 			break;
 
+				case HNBU_BOARDTYPE:
+					varbuf_append(&b, "boardtype=0x%x",
+					              (cis[i + 2] << 8) + cis[i + 1]);
+					break;
+
+#if defined(CONFIG_BCMCCISSR3)
+				case HNBU_SROM3SWRGN: {
+					uint16 srom[35];
+					uint8 srev = cis[i + 1 + 70];
+					ASSERT(srev == 3);
+					/* make tuple value 16-bit aligned and parse it */
+					bcopy(&cis[i + 1], srom, sizeof(srom));
+					_initvars_srom_pci(srev, srom, SROM3_SWRGN_OFF, &b);
+					/* create extra variables */
+					varbuf_append(&b, "vendid=0x%x",
+					              (cis[i + 1 + 73] << 8) + cis[i + 1 + 72]);
+					varbuf_append(&b, "devid=0x%x",
+					              (cis[i + 1 + 75] << 8) + cis[i + 1 + 74]);
+					varbuf_append(&b, "xtalfreq=%d",
+					              (cis[i + 1 + 77] << 8) + cis[i + 1 + 76]);
+					/* 2.4G antenna gain is included in SROM */
+					ag_init = TRUE;
+					/* Ethernet MAC address is included in SROM */
+					eabuf[0] = 0;
+					boardnum = -1;
+					break;
+				}
+#endif	
+				}
+				break;
 		}
 		i += tlen;
-	} while (tup != 0xff);
+		} while (tup != CISTPL_END);
+	}
+
+	if (boardnum != -1) {
+		varbuf_append(&b, "boardnum=%d", boardnum);
+	}
 
-	/* Set the srom version */
-	vp += sprintf(vp, "sromrev=%d", sromrev);
-	vp++;
-
-	/* For now just set boardflags2 to zero */
-	vp += sprintf(vp, "boardflags2=0");
-	vp++;
+	if (eabuf[0]) {
+		varbuf_append(&b, "macaddr=%s", eabuf);
+	}
 
 	/* if there is no antenna gain field, set default */
 	if (ag_init == FALSE) {
-		vp += sprintf(vp, "ag0=%d", 0xff);
-		vp++;
+		varbuf_append(&b, "ag0=%d", 0xff);
 	}
 
 	/* final nullbyte terminator */
-	*vp++ = '\0';
-	varsize = (uint)(vp - base);
-
-	ASSERT((vp - base) < VARS_MAX);
+	ASSERT(b.size >= 1);
+	*b.buf++ = '\0';
+	varsize = (uint)(b.buf - base);
+	ASSERT(varsize < MAXSZ_NVRAM_VARS);
+	if (varsize < MAXSZ_NVRAM_VARS) {
+		char* new_buf;
+		new_buf = (char*)MALLOC(osh, varsize);
+		ASSERT(new_buf);
+		if (new_buf) {
+			bcopy(base, new_buf, varsize);
+			MFREE(osh, base, MAXSZ_NVRAM_VARS);
+			base = new_buf;
+		}
+	}
 
-	if (varsize == VARS_MAX) {
 		*vars = base;
-	} else {
-		vp = MALLOC(osh, varsize);
-		ASSERT(vp);
-		bcopy(base, vp, varsize);
-		MFREE(osh, base, VARS_MAX);
-		*vars = vp;
-	}
 	*count = varsize;
 
 	return (0);
@@ -346,7 +908,7 @@
 
 /* set PCMCIA sprom command register */
 static int
-sprom_cmd_pcmcia(void *osh, uint8 cmd)
+sprom_cmd_pcmcia(osl_t *osh, uint8 cmd)
 {
 	uint8 status = 0;
 	uint wait_cnt = 1000;
@@ -366,7 +928,7 @@
 
 /* read a word from the PCMCIA srom */
 static int
-sprom_read_pcmcia(void *osh, uint16 addr, uint16 *data)
+sprom_read_pcmcia(osl_t *osh, uint16 addr, uint16 *data)
 {
 	uint8 addr_l, addr_h, data_l, data_h;
 
@@ -392,7 +954,7 @@
 
 /* write a word to the PCMCIA srom */
 static int
-sprom_write_pcmcia(void *osh, uint16 addr, uint16 data)
+sprom_write_pcmcia(osl_t *osh, uint16 addr, uint16 data)
 {
 	uint8 addr_l, addr_h, data_l, data_h;
 
@@ -418,265 +980,800 @@
  * Return 0 on success, nonzero on error.
  */
 static int
-sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc)
+sprom_read_pci(osl_t *osh, uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc)
 {
-	uint8 chk8;
+	int err = 0;
 	uint i;
 
 	/* read the sprom */
-	for (i = 0; i < nwords; i++)
-		buf[i] = R_REG(&sprom[wordoff + i]);
+	for (i = 0; i < nwords; i++) {
+#ifdef BCMQT
+		buf[i] = R_REG(osh, &sprom[wordoff + i]);
+#endif
+		buf[i] = R_REG(osh, &sprom[wordoff + i]);
+	}
 
 	if (check_crc) {
+		if (buf[0] == 0xffff) {
+			/* The hardware thinks that an srom that starts with 0xffff
+			 * is blank, regardless of the rest of the content, so declare
+			 * it bad.
+			 */
+			BS_ERROR(("%s: buf[0] = 0x%x, returning bad-crc\n", __FUNCTION__, buf[0]));
+			return 1;
+		}
+
 		/* fixup the endianness so crc8 will pass */
 		htol16_buf(buf, nwords * 2);
-		if ((chk8 = hndcrc8((uchar*)buf, nwords * 2, CRC8_INIT_VALUE)) != CRC8_GOOD_VALUE)
-			return (1);
+		if (hndcrc8((uint8 *)buf, nwords * 2, CRC8_INIT_VALUE) != CRC8_GOOD_VALUE)
+			err = 1;
 		/* now correct the endianness of the byte array */
 		ltoh16_buf(buf, nwords * 2);
 	}
 
-	return (0);
+	return err;
 }
 
 /*
- * Initialize nonvolatile variable table from sprom.
+* Create variable table from memory.
+* Return 0 on success, nonzero on error.
+*/
+static int
+BCMINITFN(initvars_table)(osl_t *osh, char *start, char *end, char **vars, uint *count)
+{
+	int c = (int)(end - start);
+
+	/* do it only when there is more than just the null string */
+	if (c > 1) {
+		char *vp = MALLOC(osh, c);
+		ASSERT(vp);
+		if (!vp)
+			return BCME_NOMEM;
+		bcopy(start, vp, c);
+		*vars = vp;
+		*count = c;
+	}
+	else {
+		*vars = NULL;
+		*count = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Find variables with <devpath> from flash. 'base' points to the beginning
+ * of the table upon enter and to the end of the table upon exit when success.
  * Return 0 on success, nonzero on error.
  */
-
 static int
-initvars_srom_pci(void *osh, void *curmap, char **vars, int *count)
+initvars_flash(sb_t *sbh, osl_t *osh, char **base, uint len)
 {
-	uint16 w, b[64];
-	uint8 sromrev;
-	struct ether_addr ea;
-	char eabuf[32];		     
-	uint32 bfl;
-	int c, woff, i;
-	char *vp, *base;
+	char *vp = *base;
+	char *flash;
+	int err;
+	char *s;
+	uint l, dl, copy_len;
+	char devpath[SB_DEVPATH_BUFSZ];
+
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE)))
+		return BCME_NOMEM;
+	if ((err = nvram_getall(flash, NVRAM_SPACE)))
+		goto exit;
+
+	sb_devpath(sbh, devpath, sizeof(devpath));
+
+	/* grab vars with the <devpath> prefix in name */
+	dl = strlen(devpath);
+	for (s = flash; s && *s; s += l + 1) {
+		l = strlen(s);
+
+		/* skip non-matching variable */
+		if (strncmp(s, devpath, dl))
+			continue;
+
+		/* is there enough room to copy? */
+		copy_len = l - dl + 1;
+		if (len < copy_len) {
+			err = BCME_BUFTOOSHORT;
+			goto exit;
+		}
+
+		/* no prefix, just the name=value */
+		strncpy(vp, &s[dl], copy_len);
+		vp += copy_len;
+		len -= copy_len;
+	}
+
+	/* add null string as terminator */
+	if (len < 1) {
+		err = BCME_BUFTOOSHORT;
+		goto exit;
+	}
+	*vp++ = '\0';
 
-	if (sprom_read_pci((void*)((int8*)curmap + PCI_BAR0_SPROM_OFFSET), 0, b, sizeof(b)/sizeof(b[0]), TRUE))
-		return (-1);
+	*base = vp;
 
-	/* top word of sprom contains version and crc8 */
-	sromrev = b[63] & 0xff;
-	/* bcm4401 sroms misprogrammed */
-	if (sromrev == 0x10)
-		sromrev = 1;
-	if ((sromrev != 1) && (sromrev != 2))
-		return (-2);
+exit:	MFREE(osh, flash, NVRAM_SPACE);
+	return err;
+}
+
+#if !defined(CONFIG_BCMUSBDEV) && !defined(CONFIG_BCMSDIODEV)
+/*
+ * Initialize nonvolatile variable table from flash.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+initvars_flash_sb(sb_t *sbh, char **vars, uint *count)
+{
+	osl_t *osh = sb_osh(sbh);
+	char *vp, *base;
+	int err;
 
 	ASSERT(vars);
 	ASSERT(count);
 
-	base = vp = MALLOC(osh, VARS_MAX);
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
 	ASSERT(vp);
+	if (!vp)
+		return BCME_NOMEM;
 
-	vp += sprintf(vp, "sromrev=%d", sromrev);
-	vp++;
+	if ((err = initvars_flash(sbh, osh, &vp, MAXSZ_NVRAM_VARS)) == 0)
+		err = initvars_table(osh, base, vp, vars, count);
 
-	if (sromrev >= 2) {
-		/* New section takes over the 4th hardware function space */
+	MFREE(osh, base, MAXSZ_NVRAM_VARS);
 
-		/* Word 29 is max power 11a high/low */
-		w = b[29];
-		vp += sprintf(vp, "pa1himaxpwr=%d", w & 0xff);
-		vp++;
-		vp += sprintf(vp, "pa1lomaxpwr=%d", (w >> 8) & 0xff);
-		vp++;
-
-		/* Words 30-32 set the 11alow pa settings,
-		 * 33-35 are the 11ahigh ones.
-		 */
-		for (i = 0; i < 3; i++) {
-			vp += sprintf(vp, "pa1lob%d=%d", i, b[30 + i]);
-			vp++;
-			vp += sprintf(vp, "pa1hib%d=%d", i, b[33 + i]);
-			vp++;
-		}
-		w = b[59];
-		if (w == 0)
-			vp += sprintf(vp, "ccode=");
-		else
-			vp += sprintf(vp, "ccode=%c%c", (w >> 8), (w & 0xff));
-		vp++;
+	return err;
+}
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+
+#ifdef WLTEST
+char mfgsromvars[256];
+char *defaultsromvars = "il0macaddr=00:11:22:33:44:51\0"
+		"et0macaddr=00:11:22:33:44:52\0"
+		"et1macaddr=00:11:22:33:44:53\0"
+		"boardtype=0xffff\0"
+		"boardrev=0x10\0"
+		"boardflags=8\0"
+		"sromrev=2\0"
+		"aa2g=3\0"
+		"\0";
+#define	MFGSROM_DEFVARSLEN	149 /* default srom len */
+#endif /* WL_TEST */
+
+/*
+ * Initialize nonvolatile variable table from sprom.
+ * Return 0 on success, nonzero on error.
+ */
+
+typedef struct {
+	const char *name;
+	uint32	revmask;
+	uint32	flags;
+	uint16	off;
+	uint16	mask;
+} sromvar_t;
+
+#define SRFL_MORE	1		/* value continues as described by the next entry */
+#define	SRFL_NOFFS	2		/* value bits can't be all one's */
+#define	SRFL_PRHEX	4		/* value is in hexdecimal format */
+#define	SRFL_PRSIGN	8		/* value is in signed decimal format */
+#define	SRFL_CCODE	0x10		/* value is in country code format */
+#define	SRFL_ETHADDR	0x20		/* value is an Ethernet address */
+#define SRFL_LEDDC	0x40		/* value is an LED duty cycle */
+
+/* Assumptions:
+ * - Ethernet address spins across 3 consective words
+ *
+ * Table rules:
+ * - Add multiple entries next to each other if a value spins across multiple words
+ *   (even multiple fields in the same word) with each entry except the last having
+ *   it's SRFL_MORE bit set.
+ * - Ethernet address entry does not follow above rule and must not have SRFL_MORE
+ *   bit set. Its SRFL_ETHADDR bit implies it takes multiple words.
+ * - The last entry's name field must be NULL to indicate the end of the table. Other
+ *   entries must have non-NULL name.
+ */
+
+static const sromvar_t pci_sromvars[] = {
+	{"boardrev",	0x0000000e,	SRFL_PRHEX,	SROM_AABREV, SROM_BR_MASK},
+	{"boardrev",	0x000000f0,	SRFL_PRHEX,	SROM4_BREV, 0xffff},
+	{"boardrev",	0xffffff00,	SRFL_PRHEX,	SROM8_BREV, 0xffff},
+	{"boardflags",	0x00000002,	SRFL_PRHEX,	SROM_BFL, 0xffff},
+	{"boardflags",	0x00000004,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL, 0xffff},
+	{"",		0,		0,			SROM_BFL2, 0xffff},
+	{"boardflags",	0x00000008,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL, 0xffff},
+	{"",		0,		0,			SROM3_BFL2, 0xffff},
+	{"boardflags",	0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL0, 0xffff},
+	{"",		0,		0,			SROM4_BFL1, 0xffff},
+	{"boardflags",	0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL0, 0xffff},
+	{"",		0,		0,			SROM5_BFL1, 0xffff},
+	{"boardflags",	0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL0, 0xffff},
+	{"",		0,		0,			SROM8_BFL1, 0xffff},
+	{"boardflags2", 0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL2, 0xffff},
+	{"",		0,		0,			SROM4_BFL3, 0xffff},
+	{"boardflags2", 0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL2, 0xffff},
+	{"",		0,		0,			SROM5_BFL3, 0xffff},
+	{"boardflags2", 0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL2, 0xffff},
+	{"",		0,		0,			SROM8_BFL3, 0xffff},
+	{"boardtype",	0xfffffffc,	SRFL_PRHEX,	SROM_SSID, 0xffff},
+	{"boardnum",	0x00000006,	0,		SROM_MACLO_IL0, 0xffff},
+	{"boardnum",	0x00000008,	0,		SROM3_MACLO, 0xffff},
+	{"boardnum",	0x00000010,	0,		SROM4_MACLO, 0xffff},
+	{"boardnum",	0x000000e0,	0,		SROM5_MACLO, 0xffff},
+	{"boardnum",	0xffffff00,	0,		SROM8_MACLO, 0xffff},
+	{"cc",		0x00000002,	0,		SROM_AABREV, SROM_CC_MASK},
+	{"regrev",	0x00000008,	0,		SROM_OPO, 0xff00},
+	{"regrev",	0x00000010,	0,		SROM4_REGREV, 0xff},
+	{"regrev",	0x000000e0,	0,		SROM5_REGREV, 0xff},
+	{"regrev",	0xffffff00,	0,		SROM8_REGREV, 0xff},
+	{"ledbh0",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10, 0xff},
+	{"ledbh1",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10, 0xff00},
+	{"ledbh2",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32, 0xff},
+	{"ledbh3",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32, 0xff00},
+	{"ledbh0",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10, 0xff},
+	{"ledbh1",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10, 0xff00},
+	{"ledbh2",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32, 0xff},
+	{"ledbh3",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32, 0xff00},
+	{"ledbh0",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10, 0xff},
+	{"ledbh1",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10, 0xff00},
+	{"ledbh2",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32, 0xff},
+	{"ledbh3",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32, 0xff00},
+	{"ledbh0",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH10, 0xff},
+	{"ledbh1",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH10, 0xff00},
+	{"ledbh2",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH32, 0xff},
+	{"ledbh3",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH32, 0xff00},
+	{"pa0b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB0, 0xffff},
+	{"pa0b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB1, 0xffff},
+	{"pa0b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB2, 0xffff},
+	{"pa0itssit",	0x0000000e,	0,		SROM_ITT, 0xff},
+	{"pa0maxpwr",	0x0000000e,	0,		SROM_WL10MAXP, 0xff},
+	{"pa0b0",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB0, 0xffff},
+	{"pa0b1",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB1, 0xffff},
+	{"pa0b2",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB2, 0xffff},
+	{"pa0itssit",	0xffffff00,	0,		SROM8_W0_ITTMAXP, 0xff00},
+	{"pa0maxpwr",	0xffffff00,	0,		SROM8_W0_ITTMAXP, 0xff},
+	{"opo",		0x0000000c,	0,		SROM_OPO, 0xff},
+	{"opo",		0xffffff00,	0,		SROM8_2G_OFDMPO, 0xff},
+	{"aa2g",	0x0000000e,	0,		SROM_AABREV, SROM_AA0_MASK},
+	{"aa2g",	0x000000f0,	0,		SROM4_AA, 0xff},
+	{"aa2g",	0xffffff00,	0,		SROM8_AA, 0xff},
+	{"aa5g",	0x0000000e,	0,		SROM_AABREV, SROM_AA1_MASK},
+	{"aa5g",	0x000000f0,	0,		SROM4_AA, 0xff00},
+	{"aa5g",	0xffffff00,	0,		SROM8_AA, 0xff00},
+	{"ag0",		0x0000000e,	0,		SROM_AG10, 0xff},
+	{"ag1",		0x0000000e,	0,		SROM_AG10, 0xff00},
+	{"ag0",		0x000000f0,	0,		SROM4_AG10, 0xff},
+	{"ag1",		0x000000f0,	0,		SROM4_AG10, 0xff00},
+	{"ag2",		0x000000f0,	0,		SROM4_AG32, 0xff},
+	{"ag3",		0x000000f0,	0,		SROM4_AG32, 0xff00},
+	{"ag0",		0xffffff00,	0,		SROM8_AG10, 0xff},
+	{"ag1",		0xffffff00,	0,		SROM8_AG10, 0xff00},
+	{"ag2",		0xffffff00,	0,		SROM8_AG32, 0xff},
+	{"ag3",		0xffffff00,	0,		SROM8_AG32, 0xff00},
+	{"pa1b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB0, 0xffff},
+	{"pa1b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB1, 0xffff},
+	{"pa1b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB2, 0xffff},
+	{"pa1lob0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB0, 0xffff},
+	{"pa1lob1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB1, 0xffff},
+	{"pa1lob2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB2, 0xffff},
+	{"pa1hib0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB0, 0xffff},
+	{"pa1hib1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB1, 0xffff},
+	{"pa1hib2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB2, 0xffff},
+	{"pa1itssit",	0x0000000e,	0,		SROM_ITT, 0xff00},
+	{"pa1maxpwr",	0x0000000e,	0,		SROM_WL10MAXP, 0xff00},
+	{"pa1lomaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP, 0xff00},
+	{"pa1himaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP, 0xff},
+	{"pa1b0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0, 0xffff},
+	{"pa1b1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1, 0xffff},
+	{"pa1b2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2, 0xffff},
+	{"pa1lob0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0_LC, 0xffff},
+	{"pa1lob1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1_LC, 0xffff},
+	{"pa1lob2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2_LC, 0xffff},
+	{"pa1hib0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0_HC, 0xffff},
+	{"pa1hib1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1_HC, 0xffff},
+	{"pa1hib2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2_HC, 0xffff},
+	{"pa1itssit",	0xffffff00,	0,		SROM8_W1_ITTMAXP, 0xff00},
+	{"pa1maxpwr",	0xffffff00,	0,		SROM8_W1_ITTMAXP, 0xff},
+	{"pa1lomaxpwr",	0xffffff00,	0,		SROM8_W1_MAXP_LCHC, 0xff00},
+	{"pa1himaxpwr",	0xffffff00,	0,		SROM8_W1_MAXP_LCHC, 0xff},
+	{"bxa2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x1800},
+	{"rssisav2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x0700},
+	{"rssismc2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x00f0},
+	{"rssismf2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x000f},
+	{"bxa2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x1800},
+	{"rssisav2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x0700},
+	{"rssismc2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x00f0},
+	{"rssismf2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x000f},
+	{"bxa5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x1800},
+	{"rssisav5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x0700},
+	{"rssismc5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x00f0},
+	{"rssismf5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x000f},
+	{"bxa5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x1800},
+	{"rssisav5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x0700},
+	{"rssismc5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x00f0},
+	{"rssismf5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x000f},
+	{"tri2g",	0x00000008,	0,		SROM_TRI52G, 0xff},
+	{"tri5g",	0x00000008,	0,		SROM_TRI52G, 0xff00},
+	{"tri5gl",	0x00000008,	0,		SROM_TRI5GHL, 0xff},
+	{"tri5gh",	0x00000008,	0,		SROM_TRI5GHL, 0xff00},
+	{"tri2g",	0xffffff00,	0,		SROM8_TRI52G, 0xff},
+	{"tri5g",	0xffffff00,	0,		SROM8_TRI52G, 0xff00},
+	{"tri5gl",	0xffffff00,	0,		SROM8_TRI5GHL, 0xff},
+	{"tri5gh",	0xffffff00,	0,		SROM8_TRI5GHL, 0xff00},
+	{"rxpo2g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G, 0xff},
+	{"rxpo5g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G, 0xff00},
+	{"rxpo2g",	0xffffff00,	SRFL_PRSIGN,	SROM8_RXPO52G, 0xff},
+	{"rxpo5g",	0xffffff00,	SRFL_PRSIGN,	SROM8_RXPO52G, 0xff00},
+	{"txchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_SWITCH_MASK},
+	{"txchain",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_SWITCH_MASK},
+	{"txpid2ga0",	0x000000f0,	0,		SROM4_TXPID2G, 0xff},
+	{"txpid2ga1",	0x000000f0,	0,		SROM4_TXPID2G, 0xff00},
+	{"txpid2ga2",	0x000000f0,	0,		SROM4_TXPID2G + 1, 0xff},
+	{"txpid2ga3",	0x000000f0,	0,		SROM4_TXPID2G + 1, 0xff00},
+	{"txpid5ga0",	0x000000f0,	0,		SROM4_TXPID5G, 0xff},
+	{"txpid5ga1",	0x000000f0,	0,		SROM4_TXPID5G, 0xff00},
+	{"txpid5ga2",	0x000000f0,	0,		SROM4_TXPID5G + 1, 0xff},
+	{"txpid5ga3",	0x000000f0,	0,		SROM4_TXPID5G + 1, 0xff00},
+	{"txpid5gla0",	0x000000f0,	0,		SROM4_TXPID5GL, 0xff},
+	{"txpid5gla1",	0x000000f0,	0,		SROM4_TXPID5GL, 0xff00},
+	{"txpid5gla2",	0x000000f0,	0,		SROM4_TXPID5GL + 1, 0xff},
+	{"txpid5gla3",	0x000000f0,	0,		SROM4_TXPID5GL + 1, 0xff00},
+	{"txpid5gha0",	0x000000f0,	0,		SROM4_TXPID5GH, 0xff},
+	{"txpid5gha1",	0x000000f0,	0,		SROM4_TXPID5GH, 0xff00},
+	{"txpid5gha2",	0x000000f0,	0,		SROM4_TXPID5GH + 1, 0xff},
+	{"txpid5gha3",	0x000000f0,	0,		SROM4_TXPID5GH + 1, 0xff00},
+	{"cck2gpo",	0x000000f0,	0,		SROM4_2G_CCKPO, 0xffff},
+	{"cck2gpo",	0xffffff00,	0,		SROM8_2G_CCKPO, 0xffff},
+	{"ofdm2gpo",	0x000000f0,	SRFL_MORE,	SROM4_2G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo",	0x000000f0,	SRFL_MORE,	SROM4_5G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo",	0x000000f0,	SRFL_MORE,	SROM4_5GL_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo",	0x000000f0,	SRFL_MORE,	SROM4_5GH_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5GH_OFDMPO + 1, 0xffff},
+	{"ofdm2gpo",	0xffffff00,	SRFL_MORE,	SROM8_2G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo",	0xffffff00,	SRFL_MORE,	SROM8_5G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo",	0xffffff00,	SRFL_MORE,	SROM8_5GL_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo",	0xffffff00,	SRFL_MORE,	SROM8_5GH_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5GH_OFDMPO + 1, 0xffff},
+	{"mcs2gpo0",	0x000000f0,	0,		SROM4_2G_MCSPO, 0xffff},
+	{"mcs2gpo1",	0x000000f0,	0,		SROM4_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2",	0x000000f0,	0,		SROM4_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3",	0x000000f0,	0,		SROM4_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4",	0x000000f0,	0,		SROM4_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5",	0x000000f0,	0,		SROM4_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6",	0x000000f0,	0,		SROM4_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7",	0x000000f0,	0,		SROM4_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0",	0x000000f0,	0,		SROM4_5G_MCSPO, 0xffff},
+	{"mcs5gpo1",	0x000000f0,	0,		SROM4_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2",	0x000000f0,	0,		SROM4_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3",	0x000000f0,	0,		SROM4_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4",	0x000000f0,	0,		SROM4_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5",	0x000000f0,	0,		SROM4_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6",	0x000000f0,	0,		SROM4_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7",	0x000000f0,	0,		SROM4_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0",	0x000000f0,	0,		SROM4_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1",	0x000000f0,	0,		SROM4_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2",	0x000000f0,	0,		SROM4_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3",	0x000000f0,	0,		SROM4_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4",	0x000000f0,	0,		SROM4_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5",	0x000000f0,	0,		SROM4_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6",	0x000000f0,	0,		SROM4_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7",	0x000000f0,	0,		SROM4_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0",	0x000000f0,	0,		SROM4_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1",	0x000000f0,	0,		SROM4_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2",	0x000000f0,	0,		SROM4_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3",	0x000000f0,	0,		SROM4_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4",	0x000000f0,	0,		SROM4_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5",	0x000000f0,	0,		SROM4_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6",	0x000000f0,	0,		SROM4_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7",	0x000000f0,	0,		SROM4_5GH_MCSPO + 7, 0xffff},
+	{"mcs2gpo0",	0xffffff00,	0,		SROM8_2G_MCSPO, 0xffff},
+	{"mcs2gpo1",	0xffffff00,	0,		SROM8_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2",	0xffffff00,	0,		SROM8_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3",	0xffffff00,	0,		SROM8_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4",	0xffffff00,	0,		SROM8_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5",	0xffffff00,	0,		SROM8_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6",	0xffffff00,	0,		SROM8_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7",	0xffffff00,	0,		SROM8_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0",	0xffffff00,	0,		SROM8_5G_MCSPO, 0xffff},
+	{"mcs5gpo1",	0xffffff00,	0,		SROM8_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2",	0xffffff00,	0,		SROM8_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3",	0xffffff00,	0,		SROM8_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4",	0xffffff00,	0,		SROM8_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5",	0xffffff00,	0,		SROM8_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6",	0xffffff00,	0,		SROM8_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7",	0xffffff00,	0,		SROM8_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0",	0xffffff00,	0,		SROM8_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1",	0xffffff00,	0,		SROM8_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2",	0xffffff00,	0,		SROM8_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3",	0xffffff00,	0,		SROM8_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4",	0xffffff00,	0,		SROM8_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5",	0xffffff00,	0,		SROM8_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6",	0xffffff00,	0,		SROM8_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7",	0xffffff00,	0,		SROM8_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0",	0xffffff00,	0,		SROM8_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1",	0xffffff00,	0,		SROM8_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2",	0xffffff00,	0,		SROM8_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3",	0xffffff00,	0,		SROM8_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4",	0xffffff00,	0,		SROM8_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5",	0xffffff00,	0,		SROM8_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6",	0xffffff00,	0,		SROM8_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7",	0xffffff00,	0,		SROM8_5GH_MCSPO + 7, 0xffff},
+	{"cddpo",	0x000000f0,	0,		SROM4_CDDPO, 0xffff},
+	{"stbcpo",	0x000000f0,	0,		SROM4_STBCPO, 0xffff},
+	{"bw40po",	0x000000f0,	0,		SROM4_BW40PO, 0xffff},
+	{"bwduppo",	0x000000f0,	0,		SROM4_BWDUPPO, 0xffff},
+	{"cddpo",	0xffffff00,	0,		SROM8_CDDPO, 0xffff},
+	{"stbcpo",	0xffffff00,	0,		SROM8_STBCPO, 0xffff},
+	{"bw40po",	0xffffff00,	0,		SROM8_BW40PO, 0xffff},
+	{"bwduppo",	0xffffff00,	0,		SROM8_BWDUPPO, 0xffff},
+	{"ccode",	0x0000000f,	SRFL_CCODE,	SROM_CCODE, 0xffff},
+	{"ccode",	0x00000010,	SRFL_CCODE,	SROM4_CCODE, 0xffff},
+	{"ccode",	0x000000e0,	SRFL_CCODE,	SROM5_CCODE, 0xffff},
+	{"ccode",	0xffffff00,	SRFL_CCODE,	SROM8_CCODE, 0xffff},
+	{"macaddr",	0xffffff00,	SRFL_ETHADDR,	SROM8_MACHI, 0xffff},
+	{"macaddr",	0x000000e0,	SRFL_ETHADDR,	SROM5_MACHI, 0xffff},
+	{"macaddr",	0x00000010,	SRFL_ETHADDR,	SROM4_MACHI, 0xffff},
+	{"macaddr",	0x00000008,	SRFL_ETHADDR,	SROM3_MACHI, 0xffff},
+	{"il0macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_IL0, 0xffff},
+	{"et1macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_ET1, 0xffff},
+	{"leddc",	0xffffff00,	SRFL_NOFFS|SRFL_LEDDC,	SROM8_LEDDC, 0xffff},
+	{"leddc",	0x000000e0,	SRFL_NOFFS|SRFL_LEDDC,	SROM5_LEDDC, 0xffff},
+	{"leddc",	0x00000010,	SRFL_NOFFS|SRFL_LEDDC,	SROM4_LEDDC, 0xffff},
+	{"leddc",	0x00000008,	SRFL_NOFFS|SRFL_LEDDC,	SROM3_LEDDC, 0xffff},
+	{NULL,		0,		0,		0, 0}
+};
+
+static const sromvar_t perpath_pci_sromvars[] = {
+	{"maxp2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP, 0xff},
+	{"itt2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP, 0xff00},
+	{"itt5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA, 0xffff},
+	{"pa2gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 1, 0xffff},
+	{"pa2gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 2, 0xffff},
+	{"pa2gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 3, 0xffff},
+	{"maxp5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP, 0xff},
+	{"maxp5gha",	0x000000f0,	0,		SROM4_5GLH_MAXP, 0xff},
+	{"maxp5gla",	0x000000f0,	0,		SROM4_5GLH_MAXP, 0xff00},
+	{"pa5gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA, 0xffff},
+	{"pa5gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 1, 0xffff},
+	{"pa5gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 2, 0xffff},
+	{"pa5gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 3, 0xffff},
+	{"pa5glw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA, 0xffff},
+	{"pa5glw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 1, 0xffff},
+	{"pa5glw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 2, 0xffff},
+	{"pa5glw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 3, 0xffff},
+	{"pa5ghw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA, 0xffff},
+	{"pa5ghw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 2, 0xffff},
+	{"pa5ghw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 3, 0xffff},
+	{"maxp2ga",	0xffffff00,	0,		SROM8_2G_ITT_MAXP, 0xff},
+	{"itt2ga",	0xffffff00,	0,		SROM8_2G_ITT_MAXP, 0xff00},
+	{"itt5ga",	0xffffff00,	0,		SROM8_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA, 0xffff},
+	{"pa2gw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA + 1, 0xffff},
+	{"pa2gw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA + 2, 0xffff},
+	{"maxp5ga",	0xffffff00,	0,		SROM8_5G_ITT_MAXP, 0xff},
+	{"maxp5gha",	0xffffff00,	0,		SROM8_5GLH_MAXP, 0xff},
+	{"maxp5gla",	0xffffff00,	0,		SROM8_5GLH_MAXP, 0xff00},
+	{"pa5gw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA, 0xffff},
+	{"pa5gw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA + 1, 0xffff},
+	{"pa5gw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA + 2, 0xffff},
+	{"pa5glw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA, 0xffff},
+	{"pa5glw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA + 1, 0xffff},
+	{"pa5glw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA + 2, 0xffff},
+	{"pa5ghw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA, 0xffff},
+	{"pa5ghw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA + 2, 0xffff},
+	{NULL,		0,		0,		0, 0}
+};
+
+/* Parse SROM and create name=value pairs. 'srom' points to
+ * the SROM word array. 'off' specifies the offset of the
+ * first word 'srom' points to, which should be either 0 or
+ * SROM3_SWRG_OFF (full SROM or software region).
+ */
 
+static uint
+mask_shift(uint16 mask)
+{
+	uint i;
+	for (i = 0; i < (sizeof(mask) << 3); i ++) {
+		if (mask & (1 << i))
+			return i;
 	}
+	ASSERT(mask);
+	return 0;
+}
 
-	/* parameter section of sprom starts at byte offset 72 */
-	woff = 72/2;
+static uint
+mask_width(uint16 mask)
+{
+	int i;
+	for (i = (sizeof(mask) << 3) - 1; i >= 0; i --) {
+		if (mask & (1 << i))
+			return (uint)(i - mask_shift(mask) + 1);
+	}
+	ASSERT(mask);
+	return 0;
+}
 
-	/* first 6 bytes are il0macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "il0macaddr=%s", eabuf);
-	vp++;
-
-	/* next 6 bytes are et0macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "et0macaddr=%s", eabuf);
-	vp++;
-
-	/* next 6 bytes are et1macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "et1macaddr=%s", eabuf);
-	vp++;
+#ifdef BCMDBG_ASSERT
+static bool
+mask_valid(uint16 mask)
+{
+	uint shift = mask_shift(mask);
+	uint width = mask_width(mask);
+	return mask == ((~0 << shift) & ~(~0 << (shift + width)));
+}
+#endif
 
-	/*
-	 * Enet phy settings one or two singles or a dual
-	 * Bits 4-0 : MII address for enet0 (0x1f for not there)
-	 * Bits 9-5 : MII address for enet1 (0x1f for not there)
-	 * Bit 14   : Mdio for enet0
-	 * Bit 15   : Mdio for enet1
-	 */
-	w = b[woff];
-	vp += sprintf(vp, "et0phyaddr=%d", (w & 0x1f));
-	vp++;
-	vp += sprintf(vp, "et1phyaddr=%d", ((w >> 5) & 0x1f));
-	vp++;
-	vp += sprintf(vp, "et0mdcport=%d", ((w >> 14) & 0x1));
-	vp++;
-	vp += sprintf(vp, "et1mdcport=%d", ((w >> 15) & 0x1));
-	vp++;
-
-	/* Word 46 has board rev, antennas 0/1 & Country code/control */
-	w = b[46];
-	vp += sprintf(vp, "boardrev=%d", w & 0xff);
-	vp++;
+static void
+_initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off, varbuf_t *b)
+{
+	uint16 w;
+	uint32 val;
+	const sromvar_t *srv;
+	uint width;
+	uint flags;
+	uint32 sr = (1 << sromrev);
+
+	varbuf_append(b, "sromrev=%d", sromrev);
+
+	for (srv = pci_sromvars; srv->name != NULL; srv ++) {
+		const char *name;
+
+		if ((srv->revmask & sr) == 0)
+			continue;
+
+		if (srv->off < off)
+			continue;
+
+		flags = srv->flags;
+		name = srv->name;
+
+		if (flags & SRFL_ETHADDR) {
+			char eabuf[ETHER_ADDR_STR_LEN];
+			struct ether_addr ea;
+
+			ea.octet[0] = (srom[srv->off - off] >> 8) & 0xff;
+			ea.octet[1] = srom[srv->off - off] & 0xff;
+			ea.octet[2] = (srom[srv->off + 1 - off] >> 8) & 0xff;
+			ea.octet[3] = srom[srv->off + 1 - off] & 0xff;
+			ea.octet[4] = (srom[srv->off + 2 - off] >> 8) & 0xff;
+			ea.octet[5] = srom[srv->off + 2 - off] & 0xff;
+			bcm_ether_ntoa(&ea, eabuf);
+
+			varbuf_append(b, "%s=%s", name, eabuf);
+		}
+		else {
+			ASSERT(mask_valid(srv->mask));
+			ASSERT(mask_width(srv->mask));
+
+			w = srom[srv->off - off];
+			val = (w & srv->mask) >> mask_shift(srv->mask);
+			width = mask_width(srv->mask);
+
+			while (srv->flags & SRFL_MORE) {
+				srv ++;
+				ASSERT(srv->name);
 
-	if (sromrev > 1)
-		vp += sprintf(vp, "cctl=%d", (w >> 8) & 0xf);
+				if (srv->off == 0 || srv->off < off)
+					continue;
+
+				ASSERT(mask_valid(srv->mask));
+				ASSERT(mask_width(srv->mask));
+
+				w = srom[srv->off - off];
+				val += ((w & srv->mask) >> mask_shift(srv->mask)) << width;
+				width += mask_width(srv->mask);
+			}
+
+			if ((flags & SRFL_NOFFS) && ((int)val == (1 << width) - 1))
+				continue;
+
+			if (flags & SRFL_CCODE) {
+				if (val == 0)
+					varbuf_append(b, "ccode=");
 	else
-		vp += sprintf(vp, "cc=%d", (w >> 8) & 0xf);
-	vp++;
+					varbuf_append(b, "ccode=%c%c", (val >> 8), (val & 0xff));
+			}
+			/* LED Powersave duty cycle has to be scaled:
+			 *(oncount >> 24) (offcount >> 8)
+			 */
+			else if (flags & SRFL_LEDDC) {
+				uint32 w32 = (((val >> 8) & 0xff) << 24) | /* oncount */
+					     (((val & 0xff)) << 8); /* offcount */
+				varbuf_append(b, "leddc=%d", w32);
+			}
+			else if (flags & SRFL_PRHEX)
+				varbuf_append(b, "%s=0x%x", name, val);
+			else if ((flags & SRFL_PRSIGN) && (val & (1 << (width - 1))))
+				varbuf_append(b, "%s=%d", name, (int)(val | (~0 << width)));
+			else
+				varbuf_append(b, "%s=%u", name, val);
+		}
+	}
 
-	vp += sprintf(vp, "aa0=%d", (w >> 12) & 0x3);
-	vp++;
+	if (sromrev >= 4) {
+		/* Do per-path variables */
+		uint p, pb, psz;
+
+		if (sromrev >= 8) {
+			pb = SROM8_PATH0;
+			psz = SROM8_PATH1 - SROM8_PATH0;
+		} else {
+			pb = SROM4_PATH0;
+			psz = SROM4_PATH1 - SROM4_PATH0;
+		}
 
-	vp += sprintf(vp, "aa1=%d", (w >> 14) & 0x3);
-	vp++;
+		for (p = 0; p < MAX_PATH; p++) {
+			for (srv = perpath_pci_sromvars; srv->name != NULL; srv ++) {
+				if ((srv->revmask & sr) == 0)
+					continue;
 
-	/* Words 47-49 set the (wl) pa settings */
-	woff = 47;
-
-	for (i = 0; i < 3; i++) {
-		vp += sprintf(vp, "pa0b%d=%d", i, b[woff+i]);
-		vp++;
-		vp += sprintf(vp, "pa1b%d=%d", i, b[woff+i+6]);
-		vp++;
+				if (pb + srv->off < off)
+					continue;
+
+				w = srom[pb + srv->off - off];
+				ASSERT(mask_valid(srv->mask));
+				val = (w & srv->mask) >> mask_shift(srv->mask);
+				width = mask_width(srv->mask);
+
+				/* Cheating: no per-path var is more than 1 word */
+
+				if ((srv->flags & SRFL_NOFFS) && ((int)val == (1 << width) - 1))
+					continue;
+
+				if (srv->flags & SRFL_PRHEX)
+					varbuf_append(b, "%s%d=0x%x", srv->name, p, val);
+				else
+					varbuf_append(b, "%s%d=%d", srv->name, p, val);
+			}
+			pb += psz;
 	}
+	}
+}
+
+static int
+initvars_srom_pci(sb_t *sbh, void *curmap, char **vars, uint *count)
+{
+	uint16 *srom;
+	uint8 sromrev = 0;
+	uint32 sr;
+	varbuf_t b;
+	char *vp, *base = NULL;
+	osl_t *osh = sb_osh(sbh);
+	bool flash = FALSE;
+	char *value;
+	int err;
 
 	/*
-	 * Words 50-51 set the customer-configured wl led behavior.
-	 * 8 bits/gpio pin.  High bit:  activehi=0, activelo=1;
-	 * LED behavior values defined in wlioctl.h .
-	 */
-	w = b[50];
-	if ((w != 0) && (w != 0xffff)) {
-		/* gpio0 */
-		vp += sprintf(vp, "wl0gpio0=%d", (w & 0xff));
-		vp++;
-
-		/* gpio1 */
-		vp += sprintf(vp, "wl0gpio1=%d", (w >> 8) & 0xff);
-		vp++;
-	}
-	w = b[51];
-	if ((w != 0) && (w != 0xffff)) {
-		/* gpio2 */
-		vp += sprintf(vp, "wl0gpio2=%d", w & 0xff);
-		vp++;
-
-		/* gpio3 */
-		vp += sprintf(vp, "wl0gpio3=%d", (w >> 8) & 0xff);
-		vp++;
-	}
-	
-	/* Word 52 is max power 0/1 */
-	w = b[52];
-	vp += sprintf(vp, "pa0maxpwr=%d", w & 0xff);
-	vp++;
-	vp += sprintf(vp, "pa1maxpwr=%d", (w >> 8) & 0xff);
-	vp++;
-
-	/* Word 56 is idle tssi target 0/1 */
-	w = b[56];
-	vp += sprintf(vp, "pa0itssit=%d", w & 0xff);
-	vp++;
-	vp += sprintf(vp, "pa1itssit=%d", (w >> 8) & 0xff);
-	vp++;
-
-	/* Word 57 is boardflags, if not programmed make it zero */
-	bfl = (uint32)b[57];
-	if (bfl == 0xffff) bfl = 0;
-	if (sromrev > 1) {
-		/* Word 28 is boardflags2 */
-		bfl |= (uint32)b[28] << 16;
-	}
-	vp += sprintf(vp, "boardflags=%d", bfl);
-	vp++;
-
-	/* Word 58 is antenna gain 0/1 */
-	w = b[58];
-	vp += sprintf(vp, "ag0=%d", w & 0xff);
-	vp++;
-
-	vp += sprintf(vp, "ag1=%d", (w >> 8) & 0xff);
-	vp++;
-
-	if (sromrev == 1) {
-		/* set the oem string */
-		vp += sprintf(vp, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
-			      ((b[59] >> 8) & 0xff), (b[59] & 0xff),
-			      ((b[60] >> 8) & 0xff), (b[60] & 0xff),
-			      ((b[61] >> 8) & 0xff), (b[61] & 0xff),
-			      ((b[62] >> 8) & 0xff), (b[62] & 0xff));
-		vp++;
+	 * Apply CRC over SROM content regardless SROM is present or not,
+	 * and use variable <devpath>sromrev's existance in flash to decide
+	 * if we should return an error when CRC fails or read SROM variables
+	 * from flash.
+	 */
+	srom = MALLOC(osh, SROM_MAX);
+	ASSERT(srom);
+	if (!srom)
+		return -2;
+
+	err = sprom_read_pci(osh, (void *)((int8 *)curmap + PCI_BAR0_SPROM_OFFSET), 0, srom,
+	                     SROM_WORDS, TRUE);
+
+	if ((srom[SROM4_SIGN] == SROM4_SIGNATURE) ||
+	    ((sbh->buscoretype == SB_PCIE) && (sbh->buscorerev >= 6))) {
+		/* sromrev >= 4, read more */
+		err = sprom_read_pci(osh, (void *)((int8 *)curmap + PCI_BAR0_SPROM_OFFSET), 0,
+		                     srom, SROM4_WORDS, TRUE);
+		sromrev = srom[SROM4_CRCREV] & 0xff;
+	} else if (err == 0) {
+		/* srom is good and is rev < 4 */
+		/* top word of sprom contains version and crc8 */
+		sromrev = srom[SROM_CRCREV] & 0xff;
+		/* bcm4401 sroms misprogrammed */
+		if (sromrev == 0x10)
+			sromrev = 1;
+	}
+
+	if (err) {
+#ifdef WLTEST
+		uint32 val;
+
+		BS_ERROR(("SROM Crc Error, so see if we could use a default\n"));
+		val = OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32));
+		if (val & SPROM_OTPIN_USE) {
+			BS_ERROR(("srom crc failed with OTP, use default vars....\n"));
+			vp = base = mfgsromvars;
+			if (sb_chip(sbh) == BCM4311_CHIP_ID) {
+				const char *devid = "devid=0x4311";
+				const size_t devid_strlen = strlen(devid);
+				BS_ERROR(("setting the devid to be 4311\n"));
+				bcopy(devid, vp, devid_strlen + 1);
+				vp += devid_strlen + 1;
+			}
+			bcopy(defaultsromvars, vp, MFGSROM_DEFVARSLEN);
+			vp += MFGSROM_DEFVARSLEN;
+			goto varsdone;
 	} else {
-		/* Word 60 OFDM tx power offset from CCK level */
-		/* OFDM Power Offset - opo */
-		vp += sprintf(vp, "opo=%d", b[60] & 0xff);
-		vp++;
+#endif /* WLTEST */
+			BS_ERROR(("srom crc failed with SPROM....\n"));
+			if (!(value = sb_getdevpathvar(sbh, "sromrev"))) {
+				err = -1;
+				goto errout;
+			}
+			sromrev = (uint8)bcm_strtoul(value, NULL, 0);
+			flash = TRUE;
+#ifdef WLTEST
+		}
+#endif /* WLTEST */
 	}
 
-	/* final nullbyte terminator */
-	*vp++ = '\0';
+	/* Bitmask for the sromrev */
+	sr = 1 << sromrev;
 
-	c = (int)(vp - base);
-	ASSERT((vp - base) <= VARS_MAX);
+	/* srom version check
+	 * Current valid versions: 1, 2, 3, 4, 5, 8
+	 */
+	if ((sr & 0x13e) == 0) {
+		err = -2;
+		goto errout;
+	}
 
-	if (c == VARS_MAX) {
-		*vars = base;
-	} else {
-		vp = MALLOC(osh, c);
+	ASSERT(vars);
+	ASSERT(count);
+
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
 		ASSERT(vp);
-		bcopy(base, vp, c);
-		MFREE(osh, base, VARS_MAX);
-		*vars = vp;
+	if (!vp) {
+		err = -2;
+		goto errout;
 	}
-	*count = c;
 
-	return (0);
+	/* read variables from flash */
+	if (flash) {
+		if ((err = initvars_flash(sbh, osh, &vp, MAXSZ_NVRAM_VARS)))
+			goto errout;
+		goto varsdone;
+	}
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+
+	/* parse SROM into name=value pairs. */
+	_initvars_srom_pci(sromrev, srom, 0, &b);
+
+	/* final nullbyte terminator */
+	ASSERT(b.size >= 1);
+	vp = b.buf;
+	*vp++ = '\0';
+
+	ASSERT((vp - base) <= MAXSZ_NVRAM_VARS);
+
+varsdone:
+	err = initvars_table(osh, base, vp, vars, count);
+
+errout:
+#ifdef WLTEST
+	if (base && (base != mfgsromvars))
+#else
+	if (base)
+#endif
+		MFREE(osh, base, MAXSZ_NVRAM_VARS);
+
+	MFREE(osh, srom, SROM_MAX);
+	return err;
 }
 
 /*
@@ -684,7 +1781,7 @@
  * Return 0 on success, nonzero on error.
  */
 static int
-initvars_cis_pcmcia(void *sbh, void *curmap, void *osh, char **vars, int *count)
+initvars_cis_pcmcia(sb_t *sbh, osl_t *osh, char **vars, uint *count)
 {
 	uint8 *cis = NULL;
 	int rc;
@@ -696,19 +1793,187 @@
 		return (-2);
 
 	if (sb_pcmciarev(sbh) == 1) {
-		if (srom_read(PCMCIA_BUS, (void *)NULL, osh, 0, data_sz, (uint16 *)cis)) {
+		if (srom_read(sbh, PCMCIA_BUS, (void *)NULL, osh, 0, data_sz, (uint16 *)cis)) {
 			MFREE(osh, cis, data_sz);
 			return (-1);
 		}
 		/* fix up endianess for 16-bit data vs 8-bit parsing */
-		ltoh16_buf((uint16 *)cis, data_sz);
+		htol16_buf((uint16 *)cis, data_sz);
 	} else
 		OSL_PCMCIA_READ_ATTR(osh, 0, cis, data_sz);
 
-	rc = srom_parsecis(osh, cis, vars, count);
+	rc = srom_parsecis(osh, &cis, 1, vars, count);
 
 	MFREE(osh, cis, data_sz);
 
 	return (rc);
 }
 
+
+static int
+BCMINITFN(initvars_srom_sb)(sb_t *sbh, osl_t *osh, void *curmap, char **vars, uint *varsz)
+{
+#if defined(CONFIG_BCMSDIODEV)
+	/* CIS is read and supplied by the host */
+	return BCME_OK;
+#elif defined(CONFIG_BCMUSBDEV)
+	static bool srvars = FALSE;	/* Use OTP/SPROM as global variables */
+
+	int sel = 0;	/* where to read the srom. 0 - nowhere, 1 - otp, 2 - sprom */
+	uint sz = 0;	/* srom size in bytes */
+	void *oh = NULL;
+	int rc = BCME_OK;
+
+	/* Bail out if we've dealt with OTP/SPROM before! */
+	if (srvars)
+		return 0;
+
+#if defined(CONFIG_BCM4328)
+	if (sbh->chip == BCM4328_CHIP_ID) {
+		/* Access the SPROM if it is present */
+		if ((sz = srom_size(sbh, osh)) != 0) {
+			sz <<= 1;
+			sel = 2;
+		}
+	}
+#endif
+#if defined(CONFIG_BCM4325)
+	if (sbh->chip == BCM4325_CHIP_ID) {
+		uint32 cst = sbh->chipst & CST4325_SPROM_OTP_SEL_MASK;
+
+		/* Access OTP if it is present, powered on, and programmed */
+		if ((oh = otp_init(sbh)) != NULL && (otp_status(oh) & OTPS_GUP_SW)) {
+			sz = otp_size(oh);
+			sel = 1;
+		}
+		/* Access the SPROM if it is present and allow to be accessed */
+		else if ((cst == CST4325_OTP_PWRDN || cst == CST4325_SPROM_SEL) &&
+		         (sz = srom_size(sbh, osh)) != 0) {
+			sz <<= 1;
+			sel = 2;
+		}
+	}
+#endif	/* BCM4325 */
+
+	/* Read CIS in OTP/SPROM */
+	if (sel != 0) {
+		uint16 *srom;
+		uint8 *body = NULL;
+
+		ASSERT(sz);
+
+		/* Allocate memory */
+		if ((srom = (uint16 *)MALLOC(osh, sz)) == NULL)
+			return BCME_NOMEM;
+
+		/* Read CIS */
+		switch (sel) {
+		case 1:
+			rc = otp_read_region(oh, OTP_SW_RGN, srom, sz);
+			body = (uint8 *)srom;
+			break;
+		case 2:
+			rc = srom_read(sbh, SB_BUS, curmap, osh, 0, sz, srom);
+			/* sprom has 8 byte h/w header */
+			body = (uint8 *)srom + SBSDIO_SPROM_CIS_OFFSET;
+			break;
+		default:
+			/* impossible to come here */
+			ASSERT(0);
+			break;
+		}
+
+		/* Parse CIS */
+		if (rc == BCME_OK) {
+			uint i, tpls = 0xffffffff;
+			/* # sdiod fns + common + extra */
+			uint8 *cis[SBSDIO_NUM_FUNCTION + 2];
+			uint ciss = 0;
+
+			/* each word is in host endian */
+			htol16_buf((uint8 *)srom, sz);
+
+			ASSERT(body);
+
+			/* count cis tuple chains */
+			for (i = 0; i < sz && ciss < ARRAYSIZE(cis) && tpls != 0; i ++) {
+				cis[ciss++] = &body[i];
+				for (tpls = 0; i < sz - 1; tpls ++) {
+					if (body[i++] == CISTPL_END)
+						break;
+					i += body[i] + 1;
+				}
+			}
+
+			/* call parser routine only when there are tuple chains */
+			if (ciss > 1)
+				rc = srom_parsecis(osh, cis, ciss, vars, varsz);
+		}
+
+		/* Clean up */
+		MFREE(osh, srom, sz);
+
+		/* Make SROM variables global */
+		if (rc == BCME_OK) {
+			rc = nvram_append((void *)sbh, *vars, *varsz);
+			srvars = TRUE;
+
+			/* Tell the caller there is no individual SROM variables */
+			*vars = NULL;
+			*varsz = 0;
+		}
+	}
+
+	return rc;
+#else	/* !BCMUSBDEV && !BCMSDIODEV */
+	/* Search flash nvram section for srom variables */
+	return initvars_flash_sb(sbh, vars, varsz);
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+}
+
+#ifdef BCMUSBDEV
+/* Return sprom size in 16-bit words */
+static uint
+srom_size(sb_t *sbh, osl_t *osh)
+{
+	uint size = 0;
+	if (SPROMBUS == PCMCIA_BUS) {
+		uint32 origidx;
+		sdpcmd_regs_t *pcmregs;
+		bool wasup;
+
+		origidx = sb_coreidx(sbh);
+		pcmregs = sb_setcore(sbh, SB_PCMCIA, 0);
+		ASSERT(pcmregs);
+
+		if (!(wasup = sb_iscoreup(sbh)))
+			sb_core_reset(sbh, 0, 0);
+
+		/* not worry about earlier core revs */
+		if (sb_corerev(sbh) < 8)
+			goto done;
+
+		/* SPROM is accessible only in PCMCIA mode unless there is SDIO clock */
+		if (!(R_REG(osh, &pcmregs->corestatus) & CS_PCMCIAMODE))
+			goto done;
+
+		switch (SB_PCMCIA_READ(osh, pcmregs, SROM_INFO) & SRI_SZ_MASK) {
+		case 1:
+			size = 256;	/* SROM_INFO == 1 means 4kbit */
+			break;
+		case 2:
+			size = 1024;	/* SROM_INFO == 2 means 16kbit */
+			break;
+		default:
+			break;
+		}
+
+	done:
+		if (!wasup)
+			sb_core_disable(sbh, 0);
+
+		sb_setcoreidx(sbh, origidx);
+	}
+	return size;
+}
+#endif /* def BCMUSBDEV */
--- src/shared.1927/bcmstdlib.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmstdlib.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,16 +10,85 @@
  * $Id$
  */
 
+/*
+ * bcmstdlib.c file should be used only to construct an OSL or alone without any OSL
+ * It should not be used with any orbitarary OSL's as there could be a conflict
+ * with some of the routines defined here.
+*/
+
 #include <typedefs.h>
-#include <stdarg.h>
+#if defined(NDIS) || defined(_MINOSL_) || defined(__vxworks) || \
+	defined(PCBIOS) || defined(LINUXSIM) || defined(EFI)
+/* debatable */
 #include <osl.h>
+#elif !defined(__IOPOS__)
+#include <stdio.h>
+#endif 
+
+/*
+ * Define BCMSTDLIB_WIN32_APP if this is a Win32 Application compile
+ */
+#if defined(_WIN32) && !defined(NDIS) && !defined(EFI)
+#define BCMSTDLIB_WIN32_APP 1
+#endif /* _WIN32 && !NDIS */
+
+/*
+ * Define BCMSTDLIB_SNPRINTF_ONLY if we only want snprintf & vsnprintf implementations
+ */
+#if (defined(_WIN32) && !defined(EFI)) || defined(__vxworks) || defined(_CFE_)
+#define BCMSTDLIB_SNPRINTF_ONLY 1
+#endif 
+
+#include <stdarg.h>
+#include <bcmstdlib.h>
+#ifndef BCMSTDLIB_WIN32_APP
 #include <bcmutils.h>
+#endif
+
+#ifdef BCMSTDLIB_WIN32_APP
+
+/* for a WIN32 application, use _vsnprintf as basis of vsnprintf/snprintf to 
+ * support full set of format specifications.
+ */
+
+int
+vsnprintf(char *buf, size_t bufsize, const char *fmt, va_list ap)
+{
+	int r;
+
+	r = _vsnprintf(buf, bufsize, fmt, ap);
+
+	/* Microsoft _vsnprintf() will not null terminate on overflow,
+	 * so null terminate at buffer end on error
+	 */
+	if (r < 0 && bufsize > 0)
+		buf[bufsize - 1] = '\0';
+
+	return r;
+}
+
+int
+snprintf(char *buf, size_t bufsize, const char *fmt, ...)
+{
+	va_list	ap;
+	int	r;
+
+	va_start(ap, fmt);
+	r = vsnprintf(buf, bufsize, fmt, ap);
+	va_end(ap);
+
+	return r;
+}
+
+#else /* BCMSTDLIB_WIN32_APP */
+
+#ifndef	BCMROMOFFLOAD
 
 static const char digits[17] = "0123456789ABCDEF";
 static const char ldigits[17] = "0123456789abcdef";
 
 static int
-__atox(char *buf, unsigned int num, unsigned int radix, int width,
+__atox(char *buf, char * end, unsigned int num, unsigned int radix, int width,
        const char *digits)
 {
 	char buffer[16];
@@ -49,20 +115,19 @@
 
 	while (op != buffer) {
 		op--;
-		*buf++ = *op;
+		if (buf <= end)
+			*buf = *op;
+		buf++;
 	}
 
 	return retval;
 }
 
-#define isdigit(x) (((x) >= '0') && ((x) <= '9'))
-
-extern int vsprintf(char *buf, const char *fmt, va_list ap);
-
 int
-vsprintf(char *buf, const char *fmt, va_list ap)
+BCMROMFN(vsnprintf)(char *buf, size_t size, const char *fmt, va_list ap)
 {
 	char *optr;
+	char *end;
 	const char *iptr;
 	unsigned char *tmpptr;
 	unsigned int x;
@@ -75,11 +140,20 @@
 	int hashash = 0;
 
 	optr = buf;
+	end = buf + size - 1;
 	iptr = fmt;
 
+	if (end < buf - 1) {
+		end = ((void *) -1);
+		size = end - buf + 1;
+	}
+
 	while (*iptr) {
 		if (*iptr != '%') {
-			*optr++ = *iptr++;
+			if (optr <= end)
+				*optr = *iptr;
+			++optr;
+			++iptr;
 			continue;
 		}
 
@@ -101,19 +175,19 @@
 			leadingzero = 0;
 
 		width = 0;
-		while (*iptr && isdigit(*iptr)) {
+		while (*iptr && bcm_isdigit(*iptr)) {
 			width += (*iptr - '0');
 			iptr++;
-			if (isdigit(*iptr))
+			if (bcm_isdigit(*iptr))
 				width *= 10;
 		}
 		if (*iptr == '.') {
 			iptr++;
 			width2 = 0;
-			while (*iptr && isdigit(*iptr)) {
+			while (*iptr && bcm_isdigit(*iptr)) {
 				width2 += (*iptr - '0');
 				iptr++;
-				if (isdigit(*iptr)) width2 *= 10;
+				if (bcm_isdigit(*iptr)) width2 *= 10;
 			}
 		}
 
@@ -128,121 +202,147 @@
 			tmpptr = (unsigned char *) va_arg(ap, unsigned char *);
 			if (!tmpptr) tmpptr = (unsigned char *) "(null)";
 			if ((width == 0) & (width2 == 0)) {
-				while (*tmpptr) *optr++ = *tmpptr++;
+				while (*tmpptr) {
+					if (optr <= end)
+						*optr = *tmpptr;
+					++optr;
+					++tmpptr;
+				}
 				break;
 			}
 			while (width && *tmpptr) {
-				*optr++ = *tmpptr++;
+				if (optr <= end)
+					*optr = *tmpptr;
+				++optr;
+				++tmpptr;
 				width--;
 			}
 			while (width) {
-				*optr++ = ' ';
+				if (optr <= end)
+					*optr = ' ';
+				++optr;
 				width--;
 			}
 			break;
 		case 'd':
+		case 'i':
 			i = va_arg(ap, int);
-			if (i < 0) { *optr++='-'; i = -i;}
-			optr += __atox(optr, i, 10, width, digits);
+			if (i < 0) {
+				if (optr <= end)
+					*optr = '-';
+				++optr;
+				i = -i;
+			}
+			optr += __atox(optr, end, i, 10, width, digits);
 			break;
 		case 'u':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 10, width, digits);
+			optr += __atox(optr, end, x, 10, width, digits);
 			break;
 		case 'X':
 		case 'x':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 16, width,
+			optr += __atox(optr, end, x, 16, width,
 				       (*iptr == 'X') ? digits : ldigits);
 			break;
 		case 'p':
 		case 'P':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 16, 8,
+			optr += __atox(optr, end, x, 16, 8,
 				       (*iptr == 'P') ? digits : ldigits);
 			break;
 		case 'c':
 			x = va_arg(ap, int);
-			*optr++ = x & 0xff;
+			if (optr <= end)
+				*optr = x & 0xff;
+			optr++;
 			break;
 
 		default:
-			*optr++ = *iptr;
+			if (optr <= end)
+				*optr = *iptr;
+			optr++;
 			break;
 		}
 		iptr++;
 	}
 
+	if (optr <= end) {
 	*optr = '\0';
-
-	return (optr - buf);
+		return (int)(optr - buf);
+	} else {
+		*end = '\0';
+		return (int)(end - buf);
+	}
 }
 
+
 int
-sprintf(char *buf, const char *fmt, ...)
+BCMROMFN(snprintf)(char *buf, size_t bufsize, const char *fmt, ...)
 {
 	va_list ap;
-	int count;
+	int			r;
 
 	va_start(ap, fmt);
-	count = vsprintf(buf, fmt, ap);
+	r = vsnprintf(buf, bufsize, fmt, ap);
 	va_end(ap);
 
-	return count;
+	return r;
 }
+#endif	/* !BCMROMOFFLOAD */
+
+#endif /* BCMSTDLIB_WIN32_APP */
+
+#ifndef BCMSTDLIB_SNPRINTF_ONLY
+
+#ifndef	BCMROMOFFLOAD
 
 int
-printf(const char *fmt, ...)
+BCMROMFN(vsprintf)(char *buf, const char *fmt, va_list ap)
+{
+	return (vsnprintf(buf, INT_MAX, fmt, ap));
+}
+
+
+int
+BCMROMFN(sprintf)(char *buf, const char *fmt, ...)
 {
 	va_list ap;
-	int count, i;
-	char buffer[512];
+	int count;
 
 	va_start(ap, fmt);
-	count = vsprintf(buffer, fmt, ap);
+	count = vsprintf(buf, fmt, ap);
 	va_end(ap);
 
-	for (i = 0; i < count; i++) {
-		putc(buffer[i]);
-	}
-
 	return count;
 }
 
-void *
-memset(void *dest, int c, uint n)
-{
-	unsigned char *d;
-
-	d = (unsigned char *)dest;
-
-	while (n) {
-		*d++ = (unsigned char) c;
-		n--;
-	}
-
-	return d;
-}
 
 void *
-memcpy(void *dest, const void *src, uint n)
+BCMROMFN(memmove)(void *dest, const void *src, size_t n)
 {
 	unsigned char *d;
 	const unsigned char *s;
 
-	d = (unsigned char *)dest;
-	s = (const unsigned char *)src;
+	/* only use memmove if dest is after source, otherwise use memcopy */
+	if (src < dest)
+		return memcpy(dest, src, n);
+
+	/* do what memcpy does, but starting at the end and work backwords */
+	d = (unsigned char *)dest + (n-1);
+	s = (const unsigned char *)src + (n-1);
 
 	while (n) {
-		*d++ = *s++;
+		*d-- = *s--;
 		n--;
 	}
 
 	return dest;
 }
 
+#ifndef EFI
 int
-memcmp(const void *s1, const void *s2, uint n)
+BCMROMFN(memcmp)(const void *s1, const void *s2, size_t n)
 {
 	const unsigned char *ss1;
 	const unsigned char *ss2;
@@ -263,37 +363,41 @@
 	return 0;
 }
 
+/* Skip over functions that are being used from DriverLibrary to save space */
 char *
-strcpy(char *dest, const char *src)
+BCMROMFN(strcpy)(char *dest, const char *src)
 {
 	char *ptr = dest;
 
-	while (*src)
-		*ptr++ = *src++;
-	*ptr = '\0';
+	while ((*ptr++ = *src++) != '\0')
+		;
 
 	return dest;
 }
 
 char *
-strncpy(char *dest, const char *src, uint n)
+BCMROMFN(strncpy)(char *dest, const char *src, size_t n)
 {
-	char *ptr = dest;
+	char *endp;
+	char *p;
 
-	while (*src && (n > 0)) {
-		*ptr++ = *src++;
-		n--;
-	}
-	if (n > 0)
-		*ptr = '\0';
+	p = dest;
+	endp = p + n;
+
+	while (p != endp && (*p++ = *src++) != '\0')
+		;
+
+	/* zero fill remainder */
+	while (p != endp)
+		*p++ = '\0';
 
 	return dest;
 }
 
-uint
-strlen(const char *s)
+size_t
+BCMROMFN(strlen)(const char *s)
 {
-	uint n = 0;
+	size_t n = 0;
 
 	while (*s) {
 		s++;
@@ -304,7 +408,7 @@
 }
 
 int
-strcmp(const char *s1, const char *s2)
+BCMROMFN(strcmp)(const char *s1, const char *s2)
 {
 	while (*s2 && *s1) {
 		if (*s1 < *s2)
@@ -321,9 +425,10 @@
 		return -1;
 	return 0;
 }
+#endif /* EFI */
 
 int
-strncmp(const char *s1, const char *s2, uint n)
+BCMROMFN(strncmp)(const char *s1, const char *s2, size_t n)
 {
 	while (*s2 && *s1 && n) {
 		if (*s1 < *s2)
@@ -345,7 +450,7 @@
 }
 
 char *
-strchr(const char *str,int c)
+BCMROMFN(strchr)(const char *str, int c)
 {
 	char *x = (char *)str; 
 
@@ -357,7 +462,7 @@
 }
 
 char * 
-strrchr(const char *str,int c)
+BCMROMFN(strrchr)(const char *str, int c)
 {
     char *save = NULL;
 
@@ -369,14 +474,265 @@
     return (save);
 }
 
+/* Skip over functions that are being used from DriverLibrary to save space */
+#ifndef EFI
 char *
-strcat(char *d, const char *s)
+BCMROMFN(strcat)(char *d, const char *s)
 {
-	char *x, *ss = (char *)s;
+	strcpy(&d[strlen(d)], s);
+	return (d);
+}
+#endif /* EFI */
 
-	x = &d[strlen(d)];
-	while ((*x++ = *ss++))
-		;
+char *
+BCMROMFN(index)(const char *s, int c)
+{
+	/* Terminating NUL is considered part of string */
 
-	return (d);
+	for (; *s != c; s++)
+		if (!*s)
+			return NULL;
+
+	return (char *)s;
+}
+
+/* Skip over functions that are being used from DriverLibrary to save space */
+#ifndef EFI
+char *
+BCMROMFN(strstr)(const char *s, const char *substr)
+{
+	int substr_len = strlen(substr);
+
+	for (; *s; s++)
+		if (strncmp(s, substr, substr_len) == 0)
+			return (char *)s;
+
+	return NULL;
+}
+#endif /* EFI */
+
+size_t
+BCMROMFN(strspn)(const char *s, const char *accept)
+{
+	uint count = 0;
+
+	while (s[count] && index(accept, s[count]))
+		count++;
+
+	return count;
+}
+
+size_t
+BCMROMFN(strcspn)(const char *s, const char *reject)
+{
+	uint count = 0;
+
+	while (s[count] && !index(reject, s[count]))
+		count++;
+
+	return count;
+}
+
+void *
+BCMROMFN(memchr)(const void *s, int c, size_t n)
+{
+	if (n != 0) {
+		const unsigned char *ptr = s;
+
+		do {
+			if (*ptr == (unsigned char)c)
+				return (void *)ptr;
+			ptr++;
+			n--;
+		} while (n != 0);
+	}
+	return NULL;
+}
+
+unsigned long
+BCMROMFN(strtoul)(const char *cp, char **endp, int base)
+{
+	ulong result, value;
+	bool minus;
+
+	minus = FALSE;
+
+	while (bcm_isspace(*cp))
+		cp++;
+
+	if (cp[0] == '+')
+		cp++;
+	else if (cp[0] == '-') {
+		minus = TRUE;
+		cp++;
+	}
+
+	if (base == 0) {
+		if (cp[0] == '0') {
+			if ((cp[1] == 'x') || (cp[1] == 'X')) {
+				base = 16;
+				cp = &cp[2];
+			} else {
+				base = 8;
+				cp = &cp[1];
+			}
+		} else
+			base = 10;
+	} else if (base == 16 && (cp[0] == '0') && ((cp[1] == 'x') || (cp[1] == 'X'))) {
+		cp = &cp[2];
+	}
+
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value = bcm_isdigit(*cp) ? *cp - '0' : bcm_toupper(*cp) - 'A' + 10) <
+	       (ulong) base) {
+		result = result * base + value;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong)(result * -1);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+#endif	/* !BCMROMOFFLOAD */
+
+#ifndef EFI
+/* memset is not in ROM offload because it is used directly by the compiler in
+ * structure assignments/character array initialization with "".
+ */
+void *
+memset(void *dest, int c, size_t n)
+{
+	uint32 w, *dw;
+	unsigned char *d;
+
+
+	dw = (uint32 *)dest;
+
+	/* 8 min because we have to create w */
+	if ((n >= 8) && (((uint)dest & 3) == 0)) {
+		if (c == 0)
+			w = 0;
+		else {
+			unsigned char ch;
+
+			ch = (unsigned char)(c & 0xff);
+			w = (ch << 8) | ch;
+			w |= w << 16;
+		}
+		while (n >= 4) {
+			*dw++ = w;
+			n -= 4;
+		}
+	}
+	d = (unsigned char *)dw;
+
+	while (n) {
+		*d++ = (unsigned char)c;
+		n--;
+	}
+
+	return d;
+}
+
+/* memcpy is not in ROM offload because it is used directly by the compiler in
+ * structure assignments.
+ */
+void *
+memcpy(void *dest, const void *src, size_t n)
+{
+	uint32 *dw;
+	const uint32 *sw;
+	unsigned char *d;
+	const unsigned char *s;
+
+	sw = (const uint32 *)src;
+	dw = (uint32 *)dest;
+	if ((n >= 4) && (((uint)src & 3) == 0) && (((uint)dest & 3) == 0)) {
+		while (n >= 4) {
+			*dw++ = *sw++;
+			n -= 4;
+		}
+	}
+	d = (unsigned char *)dw;
+	s = (const unsigned char *)sw;
+	while (n) {
+		*d++ = *s++;
+		n--;
+	}
+
+	return dest;
+}
+#endif /* EFI */
+
+/* Include printf if it has already not been defined as NULL */
+#ifndef printf
+int
+printf(const char *fmt, ...)
+{
+	va_list ap;
+	int count, i;
+	char buffer[PRINTF_BUFLEN + 1];
+
+	va_start(ap, fmt);
+	count = vsnprintf(buffer, sizeof(buffer), fmt, ap);
+	va_end(ap);
+
+	for (i = 0; i < count; i++) {
+		putc(buffer[i]);
+
+#ifdef EFI
+		if (buffer[i] == '\n')
+			putc('\r');
+#endif
+	}
+
+	return count;
+}
+#endif /* printf */
+
+int
+fputs(const char *s, FILE *stream /* UNUSED */)
+{
+	char c;
+	while ((c = *s++))
+		putchar(c);
+	return 0;
+}
+
+int
+puts(const char *s)
+{
+	fputs(s, stdout);
+	putchar('\n');
+	return 0;
+}
+
+int
+fputc(int c, FILE *stream /* UNUSED */)
+{
+	putc(c);
+	return (int)(unsigned char)c;
+}
+
+
+unsigned long
+rand(void)
+{
+	static unsigned long seed = 1;
+	long x, hi, lo, t;
+
+	x = seed;
+	hi = x / 127773;
+	lo = x % 127773;
+	t = 16807 * lo - 2836 * hi;
+	if (t <= 0) t += 0x7fffffff;
+	seed = t;
+	return t;
 }
+#endif /* BCMSTDLIB_SNPRINTF_ONLY */
--- src/shared.1927/bcmutils.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmutils.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,21 +12,42 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
+#include <stdarg.h>
+#include <bcmutils.h>
 #ifdef BCMDRIVER
 #include <osl.h>
+#include <sbutils.h>
 #include <bcmnvram.h>
 #else
 #include <stdio.h>
 #include <string.h>
+#endif /* BCMDRIVER */
+#if defined(_WIN32) || defined(NDIS) || defined(__vxworks) || \
+	defined(_CFE_) || defined(EFI)
+/* debatable */
+#include <bcmstdlib.h>
 #endif
-#include <bcmutils.h>
 #include <bcmendian.h>
 #include <bcmdevs.h>
+#include <proto/ethernet.h>
+#include <proto/vlan.h>
+#include <proto/bcmip.h>
+#include <proto/bcmtcp.h>
+#include <proto/802.1d.h>
+
+#ifdef BCMPERFSTATS
+#include <bcmperf.h>
+#endif
 
 #ifdef BCMDRIVER
+/* nvram vars cache */
+static char *nvram_vars = NULL;
+static int vars_len = -1;
+
 /* copy a pkt buffer chain into a buffer */
 uint
-pktcopy(void *drv, void *p, uint offset, int len, uchar *buf)
+pktcopy(osl_t *osh, void *p, uint offset, int len, uchar *buf)
 {
 	uint n, ret = 0;
 
@@ -34,19 +55,19 @@
 		len = 4096;	/* "infinite" */
 
 	/* skip 'offset' bytes */
-	for (; p && offset; p = PKTNEXT(drv, p)) {
-		if (offset < (uint)PKTLEN(drv, p))
+	for (; p && offset; p = PKTNEXT(osh, p)) {
+		if (offset < (uint)PKTLEN(osh, p))
 			break;
-		offset -= PKTLEN(drv, p);
+		offset -= PKTLEN(osh, p);
 	}
 
 	if (!p)
 		return 0;
 
 	/* copy the data */
-	for (; p && len; p = PKTNEXT(drv, p)) {
-		n = MIN((uint)PKTLEN(drv, p) - offset, (uint)len);
-		bcopy(PKTDATA(drv, p) + offset, buf, n);
+	for (; p && len; p = PKTNEXT(osh, p)) {
+		n = MIN((uint)PKTLEN(osh, p) - offset, (uint)len);
+		bcopy(PKTDATA(osh, p) + offset, buf, n);
 		buf += n;
 		len -= n;
 		ret += n;
@@ -58,215 +79,439 @@
 
 /* return total length of buffer chain */
 uint
-pkttotlen(void *drv, void *p)
+pkttotlen(osl_t *osh, void *p)
 {
 	uint total;
 
 	total = 0;
-	for (; p; p = PKTNEXT(drv, p))
-		total += PKTLEN(drv, p);
+	for (; p; p = PKTNEXT(osh, p))
+		total += PKTLEN(osh, p);
 	return (total);
 }
 
-void
-pktq_init(struct pktq *q, uint maxlen, const bool prio_map[])
+/* return the last buffer of chained pkt */
+void *
+pktlast(osl_t *osh, void *p)
 {
-	q->head = q->tail = NULL;
-	q->maxlen = maxlen;
-	q->len = 0;
-	if (prio_map) {
-		q->priority = TRUE;
-		bcopy(prio_map, q->prio_map, sizeof(q->prio_map));
-	}
-	else
-		q->priority = FALSE;
+	for (; PKTNEXT(osh, p); p = PKTNEXT(osh, p))
+		;
+
+	return (p);
 }
 
-/* should always check pktq_full before calling pktenq */
-void
-pktenq(struct pktq *q, void *p, bool lifo)
+
+/*
+ * osl multiple-precedence packet queue
+ * hi_prec is always >= the number of the highest non-empty precedence
+ */
+void *
+pktq_penq(struct pktq *pq, int prec, void *p)
 {
-	void *next, *prev;
+	struct pktq_prec *q;
 
-	/* allow 10 pkts slack */
-	ASSERT(q->len < (q->maxlen + 10));
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);         /* queueing chains not allowed */
 
-	/* Queueing chains not allowed */
-	ASSERT(PKTLINK(p) == NULL);
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
 
-	/* Queue is empty */
-	if (q->tail == NULL) {
-		ASSERT(q->head == NULL);
-		q->head = q->tail = p;
-	}
+	q = &pq->q[prec];
 
-	/* Insert at head or tail */
-	else if (q->priority == FALSE) {
-		/* Insert at head (LIFO) */
-		if (lifo) {
-			PKTSETLINK(p, q->head);
-			q->head = p;
-		}
-		/* Insert at tail (FIFO) */
-		else {
-			ASSERT(PKTLINK(q->tail) == NULL);
+	if (q->head)
 			PKTSETLINK(q->tail, p);
-			PKTSETLINK(p, NULL);
+	else
+		q->head = p;
+
 			q->tail = p;
-		}
-	}
+	q->len++;
 
-	/* Insert by priority */
-	else {
-		/* legal priorities 0-7 */
-		ASSERT(PKTPRIO(p) <= MAXPRIO);
-
-		ASSERT(q->head);
-		ASSERT(q->tail);
-		/* Shortcut to insertion at tail */
-		if (_pktq_pri(q, PKTPRIO(p)) < _pktq_pri(q, PKTPRIO(q->tail)) ||
-		    (!lifo && _pktq_pri(q, PKTPRIO(p)) <= _pktq_pri(q, PKTPRIO(q->tail)))) {
-			prev = q->tail;
-			next = NULL;
-		}
-		/* Insert at head or in the middle */
-		else {
-			prev = NULL;
-			next = q->head;
-		}
-		/* Walk the queue */
-		for (; next; prev = next, next = PKTLINK(next)) {
-			/* Priority queue invariant */
-			ASSERT(!prev || _pktq_pri(q, PKTPRIO(prev)) >= _pktq_pri(q, PKTPRIO(next)));
-			/* Insert at head of string of packets of same priority (LIFO) */
-			if (lifo) {
-				if (_pktq_pri(q, PKTPRIO(p)) >= _pktq_pri(q, PKTPRIO(next)))
-					break;
-			}
-			/* Insert at tail of string of packets of same priority (FIFO) */
-			else {
-				if (_pktq_pri(q, PKTPRIO(p)) > _pktq_pri(q, PKTPRIO(next)))
-					break;
-			}
-		}
-		/* Insert at tail */
-		if (next == NULL) {
-			ASSERT(PKTLINK(q->tail) == NULL);
-			PKTSETLINK(q->tail, p);
-			PKTSETLINK(p, NULL);
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8)prec;
+
+	return p;
+}
+
+void *
+pktq_penq_head(struct pktq *pq, int prec, void *p)
+{
+	struct pktq_prec *q;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);         /* queueing chains not allowed */
+
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
+
+	q = &pq->q[prec];
+
+	if (q->head == NULL)
 			q->tail = p;
-		}
-		/* Insert in the middle */
-		else if (prev) {
-			PKTSETLINK(prev, p);
-			PKTSETLINK(p, next);
-		}
-		/* Insert at head */
-		else {
+
 			PKTSETLINK(p, q->head);
 			q->head = p;
-		}
-	}
+	q->len++;
 
-	/* List invariants after insertion */
-	ASSERT(q->head);
-	ASSERT(PKTLINK(q->tail) == NULL);
+	pq->len++;
 
-	q->len++;
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8)prec;
+
+	return p;
+}
+
+void *
+pktq_pdeq(struct pktq *pq, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
 }
 
-/* dequeue packet at head */
-void*
-pktdeq(struct pktq *q)
+void *
+pktq_pdeq_tail(struct pktq *pq, int prec)
 {
+	struct pktq_prec *q;
+	void *p, *prev;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
+		PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
+	q->tail = prev;
+	q->len--;
+
+	pq->len--;
+
+	return p;
+}
+
+void
+pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir)
+{
+	struct pktq_prec *q;
 	void *p;
 
-	if ((p = q->head)) {
-		ASSERT(q->tail);
+	q = &pq->q[prec];
+	p = q->head;
+	while (p) {
 		q->head = PKTLINK(p);
 		PKTSETLINK(p, NULL);
+		PKTFREE(osh, p, dir);
 		q->len--;
-		if (q->head == NULL)
-			q->tail = NULL;
+		pq->len--;
+		p = q->head;
 	}
-	else {
-		ASSERT(q->tail == NULL);
+	ASSERT(q->len == 0);
+	q->tail = NULL;
+}
+
+bool
+pktq_pdel(struct pktq *pq, void *pktbuf, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	if (!pktbuf)
+		return FALSE;
+
+	q = &pq->q[prec];
+
+	if (q->head == pktbuf) {
+		if ((q->head = PKTLINK(pktbuf)) == NULL)
+			q->tail = NULL;
+	} else {
+		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p))
+			;
+		if (p == NULL)
+			return FALSE;
+
+		PKTSETLINK(p, PKTLINK(pktbuf));
+		if (q->tail == pktbuf)
+			q->tail = p;
 	}
 
-	return (p);
+	q->len--;
+	pq->len--;
+	PKTSETLINK(pktbuf, NULL);
+	return TRUE;
+}
+
+void
+pktq_init(struct pktq *pq, int num_prec, int max_len)
+{
+	int prec;
+
+	ASSERT(num_prec > 0 && num_prec <= PKTQ_MAX_PREC);
+
+	/* pq is variable size; only zero out what's requested */
+	bzero(pq, OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+
+	pq->num_prec = (uint16)num_prec;
+
+	pq->max = (uint16)max_len;
+
+	for (prec = 0; prec < num_prec; prec++)
+		pq->q[prec].max = pq->max;
 }
 
-/* dequeue packet at tail */
-void*
-pktdeqtail(struct pktq *q)
+int
+pktq_setmax(struct pktq *pq, int max_len)
 {
+	int prec;
+
+	if (!max_len)
+		return pq->max;
+
+	pq->max = (uint16)max_len;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pq->q[prec].max = pq->max;
+
+	return pq->max;
+}
+
+void *
+pktq_deq(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
 	void *p;
-	void *next, *prev;
+	int prec;
 
-	if (q->head == q->tail) {  /* last packet on queue or queue empty */
-		p = q->head;
-		q->head = q->tail = NULL;
-		q->len = 0;
-		return(p);
-	}
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
 
-	/* start walk at head */
-	prev = NULL;
-	next = q->head;
-
-	/* Walk the queue to find prev of q->tail */
-	for (; next; prev = next, next = PKTLINK(next)) {
-		if (next == q->tail)
+	q->len--;
+
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *
+pktq_deq_tail(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p, *prev;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
 			break;
-	}
 
-	ASSERT(prev);
+	q = &pq->q[prec];
 
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
 	PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
 	q->tail = prev;
 	q->len--;
-	p = next;
 
-	return (p);
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *
+pktq_peek(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].head);
+}
+
+void *
+pktq_peek_tail(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
+			break;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].tail);
 }
 
-unsigned char bcm_ctype[] = {
+void
+pktq_flush(osl_t *osh, struct pktq *pq, bool dir)
+{
+	int prec;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pktq_pflush(osh, pq, prec, dir);
+	ASSERT(pq->len == 0);
+}
+
+/* Return sum of lengths of a specific set of precedences */
+int
+pktq_mlen(struct pktq *pq, uint prec_bmp)
+{
+	int prec, len;
+
+	len = 0;
+
+	for (prec = 0; prec <= pq->hi_prec; prec++)
+		if (prec_bmp & (1 << prec))
+			len += pq->q[prec].len;
+
+	return len;
+}
+
+/* Priority dequeue from a specific set of precedences */
+void *
+pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	while ((prec_bmp & (1 << prec)) == 0 || pq->q[prec].head == NULL)
+		if (prec-- == 0)
+			return NULL;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+#endif /* BCMDRIVER */
+
+#ifndef	BCMROMOFFLOAD
+
+const unsigned char bcm_ctype[] = {
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 0-7 */
-	_BCM_C,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C,_BCM_C,		/* 8-15 */
+	_BCM_C, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C,
+	_BCM_C,	/* 8-15 */
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 16-23 */
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 24-31 */
 	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 32-39 */
 	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 40-47 */
 	_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,			/* 48-55 */
 	_BCM_D,_BCM_D,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 56-63 */
-	_BCM_P,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U,	/* 64-71 */
+	_BCM_P, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X,
+	_BCM_U|_BCM_X, _BCM_U, /* 64-71 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 72-79 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 80-87 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 88-95 */
-	_BCM_P,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L,	/* 96-103 */
+	_BCM_P, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X,
+	_BCM_L|_BCM_X, _BCM_L, /* 96-103 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 104-111 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 112-119 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_C,			/* 120-127 */
-	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
-	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
-	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,   /* 160-175 */
-	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,       /* 176-191 */
-	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,       /* 192-207 */
-	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_L,       /* 208-223 */
-	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,       /* 224-239 */
-	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L        /* 240-255 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 128-143 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 144-159 */
+	_BCM_S|_BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 160-175 */
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 176-191 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 192-207 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_U, _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_L,	/* 208-223 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 224-239 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_L, _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L /* 240-255 */
 };
 
-uchar
-bcm_toupper(uchar c)
-{
-	if (bcm_islower(c))
-		c -= 'a'-'A';
-	return (c);
-}
-
 ulong
-bcm_strtoul(char *cp, char **endp, uint base)
+BCMROMFN(bcm_strtoul)(char *cp, char **endp, uint base)
 {
 	ulong result, value;
 	bool minus;
@@ -298,196 +543,721 @@
 		cp = &cp[2];
 	}
 		   
-	result = 0;
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong)(result * -1);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+
+int
+BCMROMFN(bcm_atoi)(char *s)
+{
+	return (int)bcm_strtoul(s, NULL, 10);
+}
+
+/* return pointer to location of substring 'needle' in 'haystack' */
+char*
+BCMROMFN(bcmstrstr)(char *haystack, char *needle)
+{
+	int len, nlen;
+	int i;
+
+	if ((haystack == NULL) || (needle == NULL))
+		return (haystack);
+
+	nlen = strlen(needle);
+	len = strlen(haystack) - nlen + 1;
+
+	for (i = 0; i < len; i++)
+		if (memcmp(needle, &haystack[i], nlen) == 0)
+			return (&haystack[i]);
+	return (NULL);
+}
+
+char*
+BCMROMFN(bcmstrcat)(char *dest, const char *src)
+{
+	strcpy(&dest[strlen(dest)], src);
+	return (dest);
+}
+
+char*
+BCMROMFN(bcmstrncat)(char *dest, const char *src, uint size)
+{
+	char *endp;
+	char *p;
+
+	p = dest + strlen(dest);
+	endp = p + size;
+
+	while (p != endp && (*p++ = *src++) != '\0')
+		;
+
+	return (dest);
+}
+
+/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
+int
+BCMROMFN(bcm_ether_atoe)(char *p, struct ether_addr *ea)
+{
+	int i = 0;
+
+	for (;;) {
+		ea->octet[i++] = (char) bcm_strtoul(p, &p, 16);
+		if (!*p++ || i == 6)
+			break;
+	}
+
+	return (i == 6);
+}
+#endif	/* !BCMROMOFFLOAD */
+
+#if defined(CONFIG_USBRNDIS_RETAIL) || defined(NDIS_MINIPORT_DRIVER)
+/* registry routine buffer preparation utility functions:
+ * parameter order is like strncpy, but returns count
+ * of bytes copied. Minimum bytes copied is null char(1)/wchar(2)
+ */
+ulong
+wchar2ascii(
+	char *abuf,
+	ushort *wbuf,
+	ushort wbuflen,
+	ulong abuflen
+)
+{
+	ulong copyct = 1;
+	ushort i;
+
+	if (abuflen == 0)
+		return 0;
+
+	/* wbuflen is in bytes */
+	wbuflen /= sizeof(ushort);
+
+	for (i = 0; i < wbuflen; ++i) {
+		if (--abuflen == 0)
+			break;
+		*abuf++ = (char) *wbuf++;
+		++copyct;
+	}
+	*abuf = '\0';
+
+	return copyct;
+}
+#endif /* CONFIG_USBRNDIS_RETAIL || NDIS_MINIPORT_DRIVER */
+
+char *
+bcm_ether_ntoa(struct ether_addr *ea, char *buf)
+{
+	snprintf(buf, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
+		ea->octet[0]&0xff, ea->octet[1]&0xff, ea->octet[2]&0xff,
+		ea->octet[3]&0xff, ea->octet[4]&0xff, ea->octet[5]&0xff);
+	return (buf);
+}
+
+char *
+bcm_ip_ntoa(struct ipv4_addr *ia, char *buf)
+{
+	snprintf(buf, 16, "%d.%d.%d.%d",
+	         ia->addr[0], ia->addr[1], ia->addr[2], ia->addr[3]);
+	return (buf);
+}
+
+#ifdef BCMDRIVER
+
+void
+bcm_mdelay(uint ms)
+{
+	uint i;
+
+	for (i = 0; i < ms; i++) {
+		OSL_DELAY(1000);
+	}
+}
+
+/*
+ * Search the name=value vars for a specific one and return its value.
+ * Returns NULL if not found.
+ */
+char *
+getvar(char *vars, const char *name)
+{
+#ifdef	_MINOSL_
+	return NULL;
+#else
+	char *s;
+	int len;
+
+	if (!name)
+		return NULL;
+
+	len = strlen(name);
+	if (len == 0)
+		return NULL;
+
+	/* first look in vars[] */
+	for (s = vars; s && *s;) {
+		/* CSTYLED */
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len+1]);
+
+		while (*s++)
+			;
+	}
+
+	/* then query nvram */
+	return (nvram_get(name));
+#endif	/* _MINOSL_ */
+}
+
+/*
+ * Search the vars for a specific one and return its value as
+ * an integer. Returns 0 if not found.
+ */
+int
+getintvar(char *vars, const char *name)
+{
+#ifdef	_MINOSL_
+	return 0;
+#else
+	char *val;
+
+	if ((val = getvar(vars, name)) == NULL)
+		return (0);
+
+	return (bcm_strtoul(val, NULL, 0));
+#endif	/* _MINOSL_ */
+}
+
+
+/* Search for token in comma separated token-string */
+static int
+findmatch(char *string, char *name)
+{
+	uint len;
+	char *c;
+
+	len = strlen(name);
+	/* CSTYLED */
+	while ((c = strchr(string, ',')) != NULL) {
+		if (len == (uint)(c - string) && !strncmp(string, name, len))
+			return 1;
+		string = c + 1;
+	}
+
+	return (!strcmp(string, name));
+}
+
+/* Return gpio pin number assigned to the named pin
+ *
+ * Variable should be in format:
+ *
+ *	gpio<N>=pin_name,pin_name
+ *
+ * This format allows multiple features to share the gpio with mutual
+ * understanding.
+ *
+ * 'def_pin' is returned if a specific gpio is not defined for the requested functionality
+ * and if def_pin is not used by others.
+ */
+uint
+getgpiopin(char *vars, char *pin_name, uint def_pin)
+{
+	char name[] = "gpioXXXX";
+	char *val;
+	uint pin;
+
+	/* Go thru all possibilities till a match in pin name */
+	for (pin = 0; pin < GPIO_NUMPINS; pin ++) {
+		snprintf(name, sizeof(name), "gpio%d", pin);
+		val = getvar(vars, name);
+		if (val && findmatch(val, pin_name))
+			return pin;
+	}
+
+	if (def_pin != GPIO_PIN_NOTDEFINED) {
+		/* make sure the default pin is not used by someone else */
+		snprintf(name, sizeof(name), "gpio%d", def_pin);
+		if (getvar(vars, name)) {
+			def_pin =  GPIO_PIN_NOTDEFINED;
+		}
+	}
+
+	return def_pin;
+}
+
+#ifdef BCMPERFSTATS
+
+#define	LOGSIZE	256			/* should be power of 2 to avoid div below */
+static struct {
+	uint	cycles;
+	char	*fmt;
+	uint	a1;
+	uint	a2;
+} logtab[LOGSIZE];
+
+/* last entry logged  */
+static uint logi = 0;
+/* next entry to read */
+static uint readi = 0;
+
+void
+bcm_perf_enable()
+{
+	BCMPERF_ENABLE_INSTRCOUNT();
+	BCMPERF_ENABLE_ICACHE_MISS();
+	BCMPERF_ENABLE_ICACHE_HIT();
+}
+
+void
+bcmlog(char *fmt, uint a1, uint a2)
+{
+	static uint last = 0;
+	uint cycles, i;
+	OSL_GETCYCLES(cycles);
+
+	i = logi;
+
+	logtab[i].cycles = cycles - last;
+	logtab[i].fmt = fmt;
+	logtab[i].a1 = a1;
+	logtab[i].a2 = a2;
+
+	logi = (i + 1) % LOGSIZE;
+	last = cycles;
+}
+
+
+void
+bcmstats(char *fmt)
+{
+	static uint last = 0;
+	static uint32 ic_miss = 0;
+	static uint32 instr_count = 0;
+	uint32 ic_miss_cur;
+	uint32 instr_count_cur;
+	uint cycles, i;
+
+	OSL_GETCYCLES(cycles);
+	BCMPERF_GETICACHE_MISS(ic_miss_cur);
+	BCMPERF_GETINSTRCOUNT(instr_count_cur);
+
+	i = logi;
+
+	logtab[i].cycles = cycles - last;
+	logtab[i].a1 = ic_miss_cur - ic_miss;
+	logtab[i].a2 = instr_count_cur - instr_count;
+	logtab[i].fmt = fmt;
+
+	logi = (i + 1) % LOGSIZE;
+
+	last = cycles;
+	instr_count = instr_count_cur;
+	ic_miss = ic_miss_cur;
+}
+
+
+void
+bcmdumplog(char *buf, int size)
+{
+	char *limit, *line;
+	int j = 0;
+	int num;
+
+	limit = buf + size - 80;
+	*buf = '\0';
+
+	num = logi - readi;
+
+	if (num < 0)
+		num += LOGSIZE;
+
+	/* print in chronological order */
+
+	for (j = 0; j < num && (buf < limit); readi = (readi + 1) % LOGSIZE, j++) {
+		if (logtab[readi].fmt == NULL)
+		    continue;
+		line = buf;
+		buf += sprintf(buf, "%d\t", logtab[readi].cycles);
+		buf += sprintf(buf, logtab[readi].fmt, logtab[readi].a1, logtab[readi].a2);
+		buf += sprintf(buf, "\n");
+	}
+
+}
+
+
+/*
+ * Dump one log entry at a time.
+ * Return index of next entry or -1 when no more .
+ */
+int
+bcmdumplogent(char *buf, uint i)
+{
+	bool hit;
+
+	/*
+	 * If buf is NULL, return the starting index,
+	 * interpreting i as the indicator of last 'i' entries to dump.
+	 */
+	if (buf == NULL) {
+		i = ((i > 0) && (i < (LOGSIZE - 1))) ? i : (LOGSIZE - 1);
+		return ((logi - i) % LOGSIZE);
+	}
+
+	*buf = '\0';
+
+	ASSERT(i < LOGSIZE);
+
+	if (i == logi)
+		return (-1);
+
+	hit = FALSE;
+	for (; (i != logi) && !hit; i = (i + 1) % LOGSIZE) {
+		if (logtab[i].fmt == NULL)
+			continue;
+		buf += sprintf(buf, "%d: %d\t", i, logtab[i].cycles);
+		buf += sprintf(buf, logtab[i].fmt, logtab[i].a1, logtab[i].a2);
+		buf += sprintf(buf, "\n");
+		hit = TRUE;
+	}
+
+	return (i);
+}
+
+#endif	/* BCMPERFSTATS */
+
+
+/* Takes an Ethernet frame and sets out-of-bound PKTPRIO.
+ * Also updates the inplace vlan tag if requested.
+ * For debugging, it returns an indication of what it did.
+ */
+uint
+pktsetprio(void *pkt, bool update_vtag)
+{
+	struct ether_header *eh;
+	struct ethervlan_header *evh;
+	uint8 *pktdata;
+	int priority = 0;
+	int rc = 0;
+
+	pktdata = (uint8 *) PKTDATA(NULL, pkt);
+	ASSERT(ISALIGNED((uintptr)pktdata, sizeof(uint16)));
+
+	eh = (struct ether_header *) pktdata;
+
+	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
+		uint16 vlan_tag;
+		int vlan_prio, dscp_prio = 0;
+
+		evh = (struct ethervlan_header *)eh;
+
+		vlan_tag = ntoh16(evh->vlan_tag);
+		vlan_prio = (int) (vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
 
-	while (bcm_isxdigit(*cp) &&
-	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
-		result = result*base + value;
-		cp++;
+		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
+			uint8 *ip_body = pktdata + sizeof(struct ethervlan_header);
+			uint8 tos_tc = IP_TOS(ip_body);
+			dscp_prio = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
 	}
 
-	if (minus)
-		result = (ulong)(result * -1);
-
-	if (endp)
-		*endp = (char *)cp;
+		/* DSCP priority gets precedence over 802.1P (vlan tag) */
+		if (dscp_prio != 0) {
+			priority = dscp_prio;
+			rc |= PKTPRIO_VDSCP;
+		} else {
+			priority = vlan_prio;
+			rc |= PKTPRIO_VLAN;
+		}
+		/* 
+		 * If the DSCP priority is not the same as the VLAN priority,
+		 * then overwrite the priority field in the vlan tag, with the
+		 * DSCP priority value. This is required for Linux APs because
+		 * the VLAN driver on Linux, overwrites the skb->priority field
+		 * with the priority value in the vlan tag
+		 */
+		if (update_vtag && (priority != vlan_prio)) {
+			vlan_tag &= ~(VLAN_PRI_MASK << VLAN_PRI_SHIFT);
+			vlan_tag |= (uint16)priority << VLAN_PRI_SHIFT;
+			evh->vlan_tag = hton16(vlan_tag);
+			rc |= PKTPRIO_UPD;
+		}
+	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
+		uint8 *ip_body = pktdata + sizeof(struct ether_header);
+		uint8 tos_tc = IP_TOS(ip_body);
+		priority = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
+		rc |= PKTPRIO_DSCP;
+	}
 
-	return (result);
+	ASSERT(priority >= 0 && priority <= MAXPRIO);
+	PKTSETPRIO(pkt, priority);
+	return (rc | priority);
 }
 
-uint
-bcm_atoi(char *s)
+static char bcm_undeferrstr[BCME_STRLEN];
+
+static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;
+
+/* Convert the error codes into related error strings  */
+const char *
+bcmerrorstr(int bcmerror)
 {
-	uint n;
+	/* check if someone added a bcmerror code but forgot to add errorstring */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
+
+	if (bcmerror > 0 || bcmerror < BCME_LAST) {
+		snprintf(bcm_undeferrstr, BCME_STRLEN, "Undefined error %d", bcmerror);
+		return bcm_undeferrstr;
+	}
 
-	n = 0;
+	ASSERT(strlen(bcmerrorstrtable[-bcmerror]) < BCME_STRLEN);
 
-	while (bcm_isdigit(*s))
-		n = (n * 10) + *s++ - '0';
-	return (n);
+	return bcmerrorstrtable[-bcmerror];
 }
 
-/* return pointer to location of substring 'needle' in 'haystack' */
-char*
-bcmstrstr(char *haystack, char *needle)
+static void
+BCMINITFN(bcm_nvram_refresh)(char *flash)
 {
-	int len, nlen;
 	int i;
+	int ret = 0;
 
-	if ((haystack == NULL) || (needle == NULL))
-		return (haystack);
+	ASSERT(flash);
 
-	nlen = strlen(needle);
-	len = strlen(haystack) - nlen + 1;
+	/* default "empty" vars cache */
+	bzero(flash, 2);
 
-	for (i = 0; i < len; i++)
-		if (bcmp(needle, &haystack[i], nlen) == 0)
-			return (&haystack[i]);
-	return (NULL);
+	if ((ret = nvram_getall(flash, NVRAM_SPACE)))
+		return;
+
+	/* determine nvram length */
+	for (i = 0; i < NVRAM_SPACE; i++) {
+		if (flash[i] == '\0' && flash[i+1] == '\0')
+			break;
+	}
+
+	if (i > 1)
+		vars_len = i + 2;
+	else
+		vars_len = 0;
 }
 
-char*
-bcmstrcat(char *dest, const char *src)
+char *
+bcm_nvram_vars(uint *length)
 {
-	strcpy(&dest[strlen(dest)], src);
-	return (dest);
+#ifndef BCMNVRAMR
+	/* cache may be stale if nvram is read/write */
+	if (nvram_vars) {
+		ASSERT(!bcmreclaimed);
+		bcm_nvram_refresh(nvram_vars);
+	}
+#endif
+	if (length)
+		*length = vars_len;
+	return nvram_vars;
 }
 
-#if defined(CONFIG_USBRNDIS_RETAIL) || defined(NDIS_MINIPORT_DRIVER)
-/* registry routine buffer preparation utility functions:
- * parameter order is like strncpy, but returns count
- * of bytes copied. Minimum bytes copied is null char(1)/wchar(2)
- */
-ulong
-wchar2ascii(
-	char *abuf,
-	ushort *wbuf,
-	ushort wbuflen,
-	ulong abuflen
-)
+/* copy nvram vars into locally-allocated multi-string array */
+int
+BCMINITFN(bcm_nvram_cache)(void *sbh)
 {
-	ulong copyct = 1;
-	ushort i;
-
-	if (abuflen == 0)
+	void *osh;
+	int ret = 0;
+	char *flash = NULL;
+
+	if (vars_len >= 0) {
+#ifndef BCMNVRAMR
+		bcm_nvram_refresh(nvram_vars);
+#endif
 		return 0;
+	}
 
-	/* wbuflen is in bytes */
-	wbuflen /= sizeof(ushort);
+	osh = sb_osh((sb_t *)sbh);
 
-	for (i = 0; i < wbuflen; ++i) {
-		if (--abuflen == 0)
-			break;
-		*abuf++ = (char) *wbuf++;
-		++copyct;
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE))) {
+		ret = BCME_NOMEM;
+		goto exit;
 	}
-	*abuf = '\0';
 
-	return copyct;
-}
-#endif
+	bcm_nvram_refresh(flash);
 
-char*
-bcm_ether_ntoa(char *ea, char *buf)
-{
-	sprintf(buf,"%02x:%02x:%02x:%02x:%02x:%02x",
-		(uchar)ea[0]&0xff, (uchar)ea[1]&0xff, (uchar)ea[2]&0xff,
-		(uchar)ea[3]&0xff, (uchar)ea[4]&0xff, (uchar)ea[5]&0xff);
-	return (buf);
+#ifdef BCMNVRAMR
+	if (vars_len > 3) {
+		/* copy into a properly-sized buffer */
+		if (!(nvram_vars = MALLOC(osh, vars_len))) {
+			ret = BCME_NOMEM;
+		} else
+			bcopy(flash, nvram_vars, vars_len);
+	}
+	MFREE(osh, flash, NVRAM_SPACE);
+#else
+	/* cache must be full size of nvram if read/write */
+	nvram_vars = flash;
+#endif	/* BCMNVRAMR */
+
+exit:
+	return ret;
 }
 
-/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
-int
-bcm_ether_atoe(char *p, char *ea)
+#ifdef BCMDBG_PKT       /* pkt logging for debugging */
+/* Add a packet to the pktlist */
+void
+pktlist_add(pktlist_info_t *pktlist, void *pkt)
 {
-	int i = 0;
+	uint i;
+	ASSERT(pktlist->count < PKTLIST_SIZE);
 
-	for (;;) {
-		ea[i++] = (char) bcm_strtoul(p, &p, 16);
-		if (!*p++ || i == 6)
-			break;
+	/* Verify the packet is not already part of the list */
+	for (i = 0; i < pktlist->count; i++) {
+		if (pktlist->list[i] == pkt)
+			ASSERT(0);
 	}
-
-	return (i == 6);
+	pktlist->list[pktlist->count] = pkt;
+	pktlist->count++;
+	return;
 }
 
+/* Remove a packet from the pktlist */
 void
-bcm_mdelay(uint ms)
+pktlist_remove(pktlist_info_t *pktlist, void *pkt)
 {
 	uint i;
+	uint num = pktlist->count;
 
-	for (i = 0; i < ms; i++) {
-		OSL_DELAY(1000);
+	/* find the index where pkt exists */
+	for (i = 0; i < num; i++)
+	{
+		/* check for the existence of pkt in the list */
+		if (pktlist->list[i] == pkt)
+		{
+			/* replace with the last element */
+			pktlist->list[i] = pktlist->list[num-1];
+			pktlist->count--;
+			return;
+		}
 	}
+	ASSERT(0);
 }
 
-/*
- * Search the name=value vars for a specific one and return its value.
- * Returns NULL if not found.
+/* Dump the pktlist (and the contents of each packet if 'data'
+ * is set). 'buf' should be large enough
  */
-char*
-getvar(char *vars, char *name)
+
+char *
+pktlist_dump(pktlist_info_t *pktlist, char *buf)
 {
-	char *s;
-	int len;
+	char *obuf;
+	uint i;
 
-	len = strlen(name);
+	obuf = buf;
 
-	/* first look in vars[] */
-	for (s = vars; s && *s; ) {
-		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len+1]);
+	buf += sprintf(buf, "Packet list dump:\n");
 
-		while (*s++)
-			;
+	for (i = 0; i < (pktlist->count); i++) {
+		buf += sprintf(buf, "0x%p\t", pktlist->list[i]);
+
+#ifdef NOTDEF     /* Remove this ifdef to print pkttag and pktdata */
+		if (PKTTAG(pktlist->list[i])) {
+			/* Print pkttag */
+			buf += sprintf(buf, "Pkttag(in hex): ");
+			buf += bcm_format_hex(buf, PKTTAG(pktlist->list[i]), OSL_PKTTAG_SZ);
 	}
+		buf += sprintf(buf, "Pktdata(in hex): ");
+		buf += bcm_format_hex(buf, PKTDATA(NULL, pktlist->list[i]),
+			PKTLEN(NULL, pktlist->list[i]));
+#endif /* NOTDEF */
 
-	/* then query nvram */
-	return (BCMINIT(nvram_get)(name));
+		buf += sprintf(buf, "\n");
+	}
+	return obuf;
 }
+#endif  /* BCMDBG_PKT */
 
-/*
- * Search the vars for a specific one and return its value as
- * an integer. Returns 0 if not found.
- */
-int
-getintvar(char *vars, char *name)
+/* iovar table lookup */
+const bcm_iovar_t*
+bcm_iovar_lookup(const bcm_iovar_t *table, const char *name)
 {
-	char *val;
+	const bcm_iovar_t *vi;
+	const char *lookup_name;
 
-	if ((val = getvar(vars, name)) == NULL)
-		return (0);
+	/* skip any ':' delimited option prefixes */
+	lookup_name = strrchr(name, ':');
+	if (lookup_name != NULL)
+		lookup_name++;
+	else
+		lookup_name = name;
 
-	return (bcm_strtoul(val, NULL, 0));
+	ASSERT(table);
+
+	for (vi = table; vi->name; vi++) {
+		if (!strcmp(vi->name, lookup_name))
+			return vi;
+	}
+	/* ran to end of table */
+
+	return NULL; /* var name not found */
 }
 
-/* Return gpio pin number assigned to the named pin */
-/*
-* Variable should be in format:
-*
-*	gpio<N>=pin_name
-*
-* 'def_pin' is returned if there is no such variable found.
-*/
-uint
-getgpiopin(char *vars, char *pin_name, uint def_pin)
+int
+bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 {
-	char name[] = "gpioXXXX";
-	char *val;
-	uint pin;
+	int bcmerror = 0;
 
-	/* Go thru all possibilities till a match in pin name */
-	for (pin = 0; pin < GPIO_NUMPINS; pin ++) {
-		sprintf(name, "gpio%d", pin);
-		val = getvar(vars, name);
-		if (val && !strcmp(val, pin_name))
-			return pin;
+	/* length check on io buf */
+	switch (vi->type) {
+	case IOVT_BOOL:
+	case IOVT_INT8:
+	case IOVT_INT16:
+	case IOVT_INT32:
+	case IOVT_UINT8:
+	case IOVT_UINT16:
+	case IOVT_UINT32:
+		/* all integers are int32 sized args at the ioctl interface */
+		if (len < (int)sizeof(int)) {
+			bcmerror = BCME_BUFTOOSHORT;
 	}
-	return def_pin;
+		break;
+
+	case IOVT_BUFFER:
+		/* buffer must meet minimum length requirement */
+		if (len < vi->minlen) {
+			bcmerror = BCME_BUFTOOSHORT;
+		}
+		break;
+
+	case IOVT_VOID:
+		if (!set) {
+			/* Cannot return nil... */
+			bcmerror = BCME_UNSUPPORTED;
+		} else if (len) {
+			/* Set is an action w/o parameters */
+			bcmerror = BCME_BUFTOOLONG;
+		}
+		break;
+
+	default:
+		/* unknown type for length check in iovar info */
+		ASSERT(0);
+		bcmerror = BCME_UNSUPPORTED;
+	}
+
+	return bcmerror;
 }
 
-#endif	/* #ifdef BCMDRIVER */
+#endif	/* BCMDRIVER */
 
+
+#ifndef	BCMROMOFFLOAD
 /*******************************************************************************
  * crc8
  *
@@ -507,9 +1277,10 @@
  *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
  *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
  *
- ******************************************************************************/
+ * ****************************************************************************
+ */
 
-static uint8 crc8_table[256] = {
+static const uint8 crc8_table[256] = {
     0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
     0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
     0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
@@ -548,14 +1319,15 @@
     (c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
 
 uint8
-hndcrc8(
+BCMROMFN(hndcrc8)(
 	uint8 *pdata,	/* pointer to array of data to process */
 	uint  nbytes,	/* number of input data bytes to process */
 	uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
 )
 {
 	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
-	 * to avoid the undefined and unnecessary (uint8 >> 8) operation. */
+	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 */
 	while (nbytes-- > 0)
 		crc = crc8_table[(crc ^ *pdata++) & 0xff];
 
@@ -581,9 +1353,10 @@
  *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
  *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
  *
- ******************************************************************************/
+ * ****************************************************************************
+ */
 
-static uint16 crc16_table[256] = {
+static const uint16 crc16_table[256] = {
     0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
     0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
     0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
@@ -619,7 +1392,7 @@
 };
 
 uint16
-hndcrc16(
+BCMROMFN(hndcrc16)(
     uint8 *pdata,  /* pointer to array of data to process */
     uint nbytes, /* number of input data bytes to process */
     uint16 crc     /* either CRC16_INIT_VALUE or previous return value */
@@ -630,7 +1403,7 @@
     return crc;
 }
 
-static uint32 crc32_table[256] = {
+static const uint32 crc32_table[256] = {
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
     0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
@@ -698,7 +1471,7 @@
 };
 
 uint32
-hndcrc32(
+BCMROMFN(hndcrc32)(
     uint8 *pdata,  /* pointer to array of data to process */
     uint   nbytes, /* number of input data bytes to process */
     uint32 crc     /* either CRC32_INIT_VALUE or previous return value */
@@ -718,7 +1491,8 @@
     /* handle bulk of data as 32-bit words */
     pend = pdata + (nbytes & 0xfffffffc);
     while (pdata < pend) {
-	*tptr = *((ulong *)pdata)++;
+		*tptr = *(ulong *)pdata;
+		pdata += sizeof(ulong *);
         CRC_INNER_LOOP(32, crc, tmp[0]);
         CRC_INNER_LOOP(32, crc, tmp[1]);
         CRC_INNER_LOOP(32, crc, tmp[2]);
@@ -733,19 +1507,19 @@
     pend = pdata + nbytes;
     while (pdata < pend)
         CRC_INNER_LOOP(32, crc, *pdata++);
-#endif
+#endif /* __mips__ */
        
     return crc;
 }
 
 #ifdef notdef
-#define CLEN 	1499
+#define CLEN 	1499 	/*  CRC Length */
 #define CBUFSIZ 	(CLEN+4)
-#define CNBUFS		5
+#define CNBUFS		5 /* # of bufs */
 
 void testcrc32(void)
 {
-	uint j,k,l;
+	uint j, k, l;
 	uint8 *buf;
 	uint len[CNBUFS];
 	uint32 crcr;
@@ -755,14 +1529,14 @@
 	ASSERT((buf = MALLOC(CBUFSIZ*CNBUFS)) != NULL);
 
 	/* step through all possible alignments */
-	for (l=0;l<=4;l++) {
-		for (j=0; j<CNBUFS; j++) {
+	for (l = 0; l <= 4; l++) {
+		for (j = 0; j < CNBUFS; j++) {
 			len[j] = CLEN;
-			for (k=0; k<len[j]; k++)
+			for (k = 0; k < len[j]; k++)
 				*(buf + j*CBUFSIZ + (k+l)) = (j+k) & 0xff;
 		}
 
-		for (j=0; j<CNBUFS; j++) {
+		for (j = 0; j < CNBUFS; j++) {
 			crcr = crc32(buf + j*CBUFSIZ + l, len[j], CRC32_INIT_VALUE);
 			ASSERT(crcr == crc32tv[j]);
 		}
@@ -771,8 +1545,7 @@
 	MFREE(buf, CBUFSIZ*CNBUFS);
 	return;
 }
-#endif
-
+#endif /* notdef */
 
 /* 
  * Advance from the current 1-byte tag/1-byte length/variable-length value 
@@ -777,26 +1550,28 @@
 /* 
  * Advance from the current 1-byte tag/1-byte length/variable-length value 
  * triple, to the next, returning a pointer to the next.
+ * If the current or next TLV is invalid (does not fit in given buffer length),
+ * NULL is returned.
+ * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
+ * by the TLV parameter's length if it is valid.
  */
 bcm_tlv_t *
-bcm_next_tlv(bcm_tlv_t *elt, int *buflen)
+BCMROMFN(bcm_next_tlv)(bcm_tlv_t *elt, int *buflen)
 {
 	int len;
 
 	/* validate current elt */
-	if (*buflen < 2) {
+	if (!bcm_valid_tlv(elt, *buflen))
 		return NULL;
-	}
 	
+	/* advance to next elt */
 	len = elt->len;
-
-	/* validate remaining buflen */
-	if (*buflen >= (2 + len + 2)) {
 		elt = (bcm_tlv_t*)(elt->data + len);
 		*buflen -= (2 + len);
-	} else {
-		elt = NULL;
-	}
+
+	/* validate next elt */
+	if (!bcm_valid_tlv(elt, *buflen))
+		return NULL;
 	
 	return elt;
 }
@@ -807,7 +1582,7 @@
  * matches tag
  */
 bcm_tlv_t *
-bcm_parse_tlvs(void *buf, int buflen, uint key)
+BCMROMFN(bcm_parse_tlvs)(void *buf, int buflen, uint key)
 {
 	bcm_tlv_t *elt;
 	int totlen;
@@ -837,7 +1612,7 @@
  * than the target key. 
  */
 bcm_tlv_t *
-bcm_parse_ordered_tlvs(void *buf, int buflen, uint key)
+BCMROMFN(bcm_parse_ordered_tlvs)(void *buf, int buflen, uint key)
 {
 	bcm_tlv_t *elt;
 	int totlen;
@@ -852,7 +1627,7 @@
 		
 		/* Punt if we start seeing IDs > than target key */
 		if (id > key)
-			return(NULL);
+			return (NULL);
 
 		/* validate remaining totlen */
 		if ((id == key) && (totlen >= (len + 2)))
@@ -863,5 +1638,233 @@
 	}
 	return NULL;
 }
+#endif	/* !BCMROMOFFLOAD */
+
+
+/* Produce a human-readable string for boardrev */
+char *
+bcm_brev_str(uint16 brev, char *buf)
+{
+	if (brev < 0x100)
+		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
+	else
+		snprintf(buf, 8, "%c%03x", ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
+
+	return (buf);
+}
+
+#define BUFSIZE_TODUMP_ATONCE 512 /* Buffer size */
+
+/* dump large strings to console */
+void
+printfbig(char *buf)
+{
+	uint len, max_len;
+	char c;
+
+	len = strlen(buf);
+
+	max_len = BUFSIZE_TODUMP_ATONCE;
+
+	while (len > max_len) {
+		c = buf[max_len];
+		buf[max_len] = '\0';
+		printf("%s", buf);
+		buf[max_len] = c;
+
+		buf += max_len;
+		len -= max_len;
+	}
+	/* print the remaining string */
+	printf("%s\n", buf);
+	return;
+}
+
+/* routine to dump fields in a fileddesc structure */
+uint
+bcmdumpfields(readreg_rtn read_rtn, void *arg0, void *arg1, struct fielddesc *fielddesc_array,
+	char *buf, uint32 bufsize)
+{
+	uint  filled_len;
+	int len;
+	struct fielddesc *cur_ptr;
+
+	filled_len = 0;
+	cur_ptr = fielddesc_array;
+
+	while (bufsize > 1) {
+		if (cur_ptr->nameandfmt == NULL)
+			break;
+		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
+		               read_rtn(arg0, arg1, cur_ptr->offset));
+		/* check for snprintf overflow or error */
+		if (len < 0 || (uint32)len >= bufsize)
+			len = bufsize - 1;
+		buf += len;
+		bufsize -= len;
+		filled_len += len;
+		cur_ptr++;
+	}
+	return filled_len;
+}
+
+uint
+bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
+{
+	uint len;
+
+	len = strlen(name) + 1;
+
+	if ((len + datalen) > buflen)
+		return 0;
+
+	strncpy(buf, name, buflen);
+
+	/* append data onto the end of the name string */
+	memcpy(&buf[len], data, datalen);
+	len += datalen;
+
+	return len;
+}
+
+#ifndef	BCMROMOFFLOAD
+
+/* Quarter dBm units to mW
+ * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
+ * Table is offset so the last entry is largest mW value that fits in
+ * a uint16.
+ */
+
+#define QDBM_OFFSET 153		/* Offset for first entry */
+#define QDBM_TABLE_LEN 40	/* Table size */
+
+/* Smallest mW value that will round up to the first table entry, QDBM_OFFSET.
+ * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
+ */
+#define QDBM_TABLE_LOW_BOUND 6493 /* Low bound */
+
+/* Largest mW value that will round down to the last table entry,
+ * QDBM_OFFSET + QDBM_TABLE_LEN-1.
+ * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
+ */
+#define QDBM_TABLE_HIGH_BOUND 64938 /* High bound */
+
+static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+/* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
+/* 153: */      6683,	7079,	7499,	7943,	8414,	8913,	9441,	10000,
+/* 161: */      10593,	11220,	11885,	12589,	13335,	14125,	14962,	15849,
+/* 169: */      16788,	17783,	18836,	19953,	21135,	22387,	23714,	25119,
+/* 177: */      26607,	28184,	29854,	31623,	33497,	35481,	37584,	39811,
+/* 185: */      42170,	44668,	47315,	50119,	53088,	56234,	59566,	63096
+};
+
+uint16
+BCMROMFN(bcm_qdbm_to_mw)(uint8 qdbm)
+{
+	uint factor = 1;
+	int idx = qdbm - QDBM_OFFSET;
+
+	if (idx > QDBM_TABLE_LEN) {
+		/* clamp to max uint16 mW value */
+		return 0xFFFF;
+	}
+
+	/* scale the qdBm index up to the range of the table 0-40
+	 * where an offset of 40 qdBm equals a factor of 10 mW.
+	 */
+	while (idx < 0) {
+		idx += 40;
+		factor *= 10;
+	}
+
+	/* return the mW value scaled down to the correct factor of 10,
+	 * adding in factor/2 to get proper rounding.
+	 */
+	return ((nqdBm_to_mW_map[idx] + factor/2) / factor);
+}
+
+uint8
+BCMROMFN(bcm_mw_to_qdbm)(uint16 mw)
+{
+	uint8 qdbm;
+	int offset;
+	uint mw_uint = mw;
+	uint boundary;
+
+	/* handle boundary case */
+	if (mw_uint <= 1)
+		return 0;
+
+	offset = QDBM_OFFSET;
+
+	/* move mw into the range of the table */
+	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
+		mw_uint *= 10;
+		offset -= 40;
+	}
+
+	for (qdbm = 0; qdbm < QDBM_TABLE_LEN-1; qdbm++) {
+		boundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm+1] -
+		                                    nqdBm_to_mW_map[qdbm])/2;
+		if (mw_uint < boundary) break;
+	}
+
+	qdbm += (uint8)offset;
+
+	return (qdbm);
+}
+
+
+uint
+BCMROMFN(bcm_bitcount)(uint8 *bitmap, uint length)
+{
+	uint bitcount = 0, i;
+	uint8 tmp;
+	for (i = 0; i < length; i++) {
+		tmp = bitmap[i];
+		while (tmp) {
+			bitcount++;
+			tmp &= (tmp - 1);
+		}
+	}
+	return bitcount;
+}
 
+#endif /* !BCMROMOFFLOAD */
 
+#ifdef BCMDRIVER
+
+/* Initialization of bcmstrbuf structure */
+void
+bcm_binit(struct bcmstrbuf *b, char *buf, uint size)
+{
+	b->origsize = b->size = size;
+	b->origbuf = b->buf = buf;
+}
+
+/* Buffer sprintf wrapper to guard against buffer overflow */
+int
+bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
+{
+	va_list ap;
+	int r;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+
+	/* Non Ansi C99 compliant returns -1,
+	 * Ansi compliant return r >= b->size,
+	 * bcmstdlib returns 0, handle all
+	 */
+	if ((r == -1) || (r >= (int)b->size) || (r == 0)) {
+		b->size = 0;
+	} else {
+		b->size -= r;
+		b->buf += r;
+	}
+
+	va_end(ap);
+
+	return r;
+}
+#endif /* BCMDRIVER */
--- src/shared.1927/boot.S	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/boot.S	2007-11-19 06:40:26.000000000 +0300
@@ -17,38 +17,90 @@
 #include "mipsinc.h"
 #include "sbconfig.h"
 #include "sbchipc.h"
+#include "bcmdevs.h"
 
 	.text
 	LEAF(startup)
 	.set	noreorder
 
+
+	li	a0,KSEG1ADDR(SB_ENUM_BASE)
+
        	# XXX: the following code snipet sets clk frequency to 200M
         # correct pll clk freq to real speed in the 5350 case.
+	# unless its vsim which we detect as pkg option 1 (should be 0xe)
         # It is Ugly...but
+	li	a3,BCM5350_CHIP_ID		# 5350 ChipID
+	lw	t1,CC_CHIPID(a0)		# ChipID register
+	li	t2,CID_ID_MASK			# chip id is bit 0-15
+	and	t2,t1,t2
+	bne	t2,a3,2f			# if not 5350 then skip
+	nop
+	
+	li	t2,CID_PKG_MASK			# if it is a vsim 5350, also skip
+	and	t2,t1,t2
+	li	a3,(HDLSIM5350_PKG_ID << CID_PKG_SHIFT)
+	beq	t2,a3,2f			# if pkg opt 1 then skip
+	nop
+
+	li	a3,CLKC_5350_N
+	lw	t1,CC_CLKC_N(a0)
+	beq	a3,t1,2f			# move ahead if clk freq set correctly
+	nop
+	sw	a3,CC_CLKC_N(a0)		# set control N1 to select 6
+	li	t1,1
+	sw	t1,CC_WATCHDOG(a0)		# set WatchDog Reset
+1:	b	1b
+	nop
+
+2:
+#ifdef	BCM5354
+	lw	t1,CC_CHIPID(a0)		# ChipID register
+	li	t2,CID_ID_MASK			# chip id is bit 0-15
+	li	a3,BCM5354_CHIP_ID		# 5354 ChipID
+	and	t2,t1,t2
+	bne	t2,a3,ramcheck			# if not 5354 then skip
+	nop
+
+	li	t2,0x1				# Need define
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x6800000			# Should only affect the switch bits
+	sw	t3,PMU_REG_CONTROL_DATA(a0)
+	
+	/* 
+	 * Trim the output voltage of the 1.2V BB switcher and 2.5V
+	 * regulator to the correct value.
+	 */
+	li	t2,0x0
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x2000			# Reduce the output voltage of
+	sw	t3,PMU_REG_CONTROL_DATA(a0)	# BB switcher to get 1.2V
+	li	t2,0x3
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x02000000			# Increase the output voltage
+	sw	t3,PMU_REG_CONTROL_DATA(a0)	# of VDDP LDO to get 2.5V
+
+	lw	t2,PMU_CTL(a0)			# Check if PLL has been programmed
+	andi	t2,t2,PCTL_XTALFREQ_MASK
+	bnez	t2,3f				# Yup, leave it alone
+	nop
+	li	t2,0x7ffff			# Should only turn off the PLL bit
+	sw	t2,PMU_MIN_RES_MASK(a0)		# Disable base band PLL
+	sw	t2,PMU_MAX_RES_MASK(a0)
+	nop
+
+	/* Init code for FF4 space without TLB, enabling RAC */
+3:	li 	t0,0x1fa0000c			# Set up CBR to 0x1fax_xxxx
+	mtc0 	t0,$22,6
+	li 	t1,0x1fa00000
+	lw 	t2,0x14(t1)
+	or 	t3,t2,0xc0000000		# enable ffxx_xxxx space # without programming TLB
+	sw 	t3,0x14(t1) 
+	li 	t0,0xff40000c			# change CBR to ff4x_xxxx
+	mtc0 	t0,$22,6
+#endif	/* BCM5354 */
 
-	li      t0,KSEG1ADDR(SB_ENUM_BASE)      # Is there a chipcommon core?
-	lw      t1,(SBCONFIGOFF + SBIDHIGH)(t0)
-	and     t1,t1,SBIDH_CC_MASK
-	srl     t1,t1,SBIDH_CC_SHIFT
-	bne     t1,SB_CC,_move_ahead
-	nop
-        li      a2,KSEG1ADDR(SB_ENUM_BASE)
-        li      a3, 0x5350            # 5350 ChipID
-        ll      t1, 0(a2)             # ChipID register
-        andi    t1, 0x0ffff             # chip id is bit 0-15
-        bne     a3, t1, _move_ahead   # if not 5350 then skip
-        nop
-        li      a3, 0x311
-        ll      t1, 0x90(a2)
-        beq     a3, t1, _move_ahead   # move ahead if clk freq set correctly
-        nop
-        sw      a3, 0x90(a2)          # set control N1 to select 6
-        li      t1, 0x1
-        sw      t1, 0x80(a2)          # set WatchDog Reset
-_move_ahead:
-        nop
-
-
+ramcheck:
 	/* Check if we booted from SDRAM */
 	bal	1f
 	nop
@@ -65,18 +117,29 @@
 	nop
 
 inflash:
-	/* Is this chipc rev 11 or 12 and an Atmel serial flash? */
+	/* Is this chipc rev 11 or 12 and a serial flash? */
 	li	t0,KSEG1ADDR(SB_ENUM_BASE)
 	lw	t1,(SBCONFIGOFF + SBIDHIGH)(t0)
 	and	t2,t1,SBIDH_CC_MASK
 	srl	t2,t2,SBIDH_CC_SHIFT
 	bne	t2,SB_CC,checkcon		/* Not chipc */
 	nop
+	and	t2,t1,SBIDH_RC_MASK
+	and	t3,t1,SBIDH_RCE_MASK
+	srl	t3,t3,SBIDH_RCE_SHIFT
+	or	t2,t3
+	ble	t2,10,checkcon			/* ccrev <= 10 */
+	nop
+	bge	t2,13,checkcon			/* ccrev >= 13 */
+	nop
 	lw	t0,CC_CAPABILITIES(t0)
-	and	t0,t0,CAP_FLASH_MASK
-	beq	t0,SFLASH_AT,switchkseg0
+	and	t0,t0,CC_CAP_FLASH_MASK
+	beq	t0,SFLASH_AT,switchkseg0	/* Atmel sflash */
+	nop
+	beq	t0,SFLASH_ST,switchkseg0	/* ST sflash */
 	nop
 
+
 checkcon:
 	/* Check if the caches are already on */
 	mfc0	t0,C0_CONFIG
@@ -90,7 +153,7 @@
 initcaches:
 	/* Turn on the caches in the CP0 register */
 	mfc0	t0,C0_DIAGNOSTIC
-	or	t0,0xc0000000		/* Enable both I$ and D$ */
+	or	t0,(BRCM_IC_ENABLE | BRCM_DC_ENABLE) /* Enable both I$ and D$ */
 	mtc0	t0,C0_DIAGNOSTIC
 
 
@@ -220,11 +283,11 @@
 #else
 	li	a0,KSEG0ADDR(SB_FLASH1)
 	la	a1,text_start
-	and	a1,PHYSADDR_MASK
-	or	a1, KSEG1
-	la	a2,input_data
+	and	a1,PHYSADDR_MASK	/* Uncached writes to avoid a flush */
+	or	a1,KSEG1
+	la	a2,_end
 	and	a2,PHYSADDR_MASK
-	or	a2, KSEG1
+	or	a2,KSEG1
 #endif
 1:	lw	t0,0(a0)
 	sw	t0,0(a1)
@@ -232,8 +295,43 @@
 	add	a1,4
 	blt	a1,a2,1b
 	nop
+	b	setsp
+	nop
+
+	/* Black hole for traps with BEV on */
+	.org	0x380
+bevtrap: nop
+	nop
+	.set	mips32
+	wait
+	.set	mips0
+	nop
+	nop
+	b	bevtrap
+	nop
+
+	/* Record the size of the binary */
+	.org	BISZ_OFFSET
+	.word	BISZ_MAGIC
+	.word	text_start
+	.word	text_end
+	.word	data_start
+	.word	data_end
+	.word	bss_start
+	.word	bss_end
+	.word	_end
+
+	/* Embedded NVRAM */
+	.balign	0x400	
+	.globl	embedded_nvram
+embedded_nvram:
+	.fill	0x100,4,~(0x48534c46)
 
 setsp:
+	/* Record the memory size */
+	la	t0,_memsize
+	sw	v0,0(t0)
+
 	/* Set up stack pointer */
 	or	v0,KSEG0
 	sub	sp,v0,4
@@ -247,6 +345,7 @@
 	nop
 
 	/* Setup trap handlers */
+#ifdef CONFIG_XIP
 	li	t0,KSEG0ADDR(SB_FLASH1)
 	la	t1,text_start
 	la	t2,trap_init
@@ -254,6 +353,11 @@
 	add	t2,t2,t0
 	jalr	t2
 	nop
+#else
+	la	t0,trap_init
+	jalr	t0
+	nop
+#endif
 
 	/* Jump to C */
 	la	t0,c_main
@@ -271,33 +375,10 @@
 	b	theend
 	nop
 
-	/* Black hole for traps with BEV on */
-	.org	0x380
-bevtrap: nop
-	nop
-	.set	mips32
-	wait
-	.set	mips0
-	nop
-	nop
-	b	bevtrap
-	nop
-
-	/* Record the size of the binary */
-	.org	BISZ_OFFSET
-	.word	BISZ_MAGIC
-	.word	text_start
-	.word	text_end
-	.word	data_start
-	.word	data_end
-	.word	bss_start
-	.word	bss_end
-
-	/* Embedded NVRAM */
-	.balign	0x400	
-	.globl	embedded_nvram
-embedded_nvram:
-	.fill	0x100,4,~(0x48534c46)
-	
 	.set reorder
 	END(startup)
+
+	.data
+	.globl	_memsize
+_memsize:
+	.word	0
--- src/shared.1927/bzip2_inflate.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bzip2_inflate.c	2007-11-19 06:40:26.000000000 +0300
@@ -76,7 +76,7 @@
 --*/
 
 /*-- General stuff. --*/
-
+/* FILE-CSTYLED */
 #define BZ_VERSION  "1.0.2, 30-Dec-2001"
 
 typedef char            Char;
--- src/shared.1927/cfe_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/cfe_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,7 +13,29 @@
  */
 
 #include <typedefs.h>
-#include <cfe_osl.h>
+#include <bcmdefs.h>
+#include <osl.h>
+
+osl_t *
+osl_attach(void *pdev)
+{
+	osl_t *osh;
+
+	osh = (osl_t *)KMALLOC(sizeof(osl_t), 0);
+	ASSERT(osh);
+
+	bzero(osh, sizeof(osl_t));
+	osh->pdev = pdev;
+	return osh;
+}
+
+void
+osl_detach(osl_t *osh)
+{
+	if (osh == NULL)
+		return;
+	KFREE((void*) KERNADDR(PHYSADDR((ulong)osh)));
+}
 
 struct lbuf *
 osl_pktget(uint len)
@@ -37,10 +58,13 @@
 }
 
 void
-osl_pktfree(struct lbuf *lb)
+osl_pktfree(osl_t *osh, struct lbuf *lb, bool send)
 {
 	struct lbuf *next;
 
+	if (send && osh->tx_fn)
+		osh->tx_fn(osh->tx_ctx, lb, 0);
+
 	for (; lb; lb = next) {
 		ASSERT(!lb->link);
 		next = lb->next;
@@ -115,11 +138,54 @@
 	KFREE((void *) KERNADDR(PHYSADDR((ulong) va)));
 }
 
+#ifdef BCMDBG_ASSERT
+void
+osl_assert(char *exp, char *file, int line)
+{
+	printf("assertion \"%s\" failed: file \"%s\", line %d\n", exp, file, line);
+	*((int *) 0) = 0;
+}
+#endif /* BCMDBG_ASSERT */
 
 int
 osl_busprobe(uint32 *val, uint32 addr)
 {
-	*val = R_REG((volatile uint32 *) addr);
+	*val = R_REG(NULL, (volatile uint32 *) addr);
+
+	return 0;
+}
 
+/* translate bcmerros */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror)
+		return -1;
+	else
 	return 0;
 }
+
+/* Converts a OS packet to driver packet.
+ * The original packet data is copied to the new driver packet
+ */
+void
+osl_pkt_frmnative(iocb_buffer_t *buffer, struct lbuf *lb)
+{
+	bcopy(buffer->buf_ptr, PKTDATA(NULL, lb), buffer->buf_length);
+}
+
+/* Converts a driver packet into OS packet.
+ * The data is copied to the OS packet
+ */
+void
+osl_pkt_tonative(struct lbuf* lb, iocb_buffer_t *buffer)
+{
+	bcopy(PKTDATA(NULL, lb), buffer->buf_ptr, PKTLEN(NULL, lb));
+	buffer->buf_retlen = PKTLEN(NULL, lb);
+
+	/* RFC894: Minimum length of IP over Ethernet packet is 46 octets */
+	if (buffer->buf_retlen < 60) {
+		bzero(buffer->buf_ptr + buffer->buf_retlen, 60 - buffer->buf_retlen);
+		buffer->buf_retlen = 60;
+	}
+}
--- src/shared.1927/flashutl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/flashutl.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,118 +12,132 @@
  * $Id$
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
 #include <typedefs.h>
+#include <osl.h>
 
 #define DECLARE_FLASHES
+#include <bcmutils.h>
 #include <sbutils.h>
 #include <sbconfig.h>
 #include <flash.h>
 #include <sflash.h>
 #include <flashutl.h>
 #include <bcmnvram.h>
-#include <bcmutils.h>
-#include <osl.h>
 
 #define DPRINT(x) 
 
-#define ERR2	0x30
-#define DONE	0x80
-#define WBUFSIZE 32
+#define ERR2	0x30 /* Mask for err UNUSED */
+#define DONE	0x80 /* Mask for done */
+#define WBUFSIZE 32  /* Write Buffer size */
 #define FLASH_TRIES 4000000 /* retry count */
 #define CMD_ADDR ((unsigned long)0xFFFFFFFF)
 
 /* 'which' param for block() */
-#define BLOCK_BASE	0
-#define BLOCK_LIM	1
+#define BLOCK_BASE	0  /* Base of block */
+#define BLOCK_LIM	1  /* Limit of block */
 
 #define FLASH_ADDR(off) ((unsigned long)flashutl_base + (off))
 
-static chipcregs_t *cc;
+/* Local vars */
+static sb_t *sbh = NULL;
+static chipcregs_t *cc = NULL;
 
 /* Global vars */
-char*		flashutl_base	= NULL;
-flash_desc_t*	flashutl_desc	= NULL;
-flash_cmds_t*	flashutl_cmd	= NULL;
+uint8		*flashutl_base	= NULL;
+flash_desc_t	*flashutl_desc	= NULL;
+flash_cmds_t	*flashutl_cmd	= NULL;
+uint8 flashutl_wsz = sizeof(uint16);
 
 static void		scmd(uint16 cmd, unsigned long off);
 static void		cmd(uint16 cmd, unsigned long off);
 static void		flash_reset(void);
 static int		flash_poll(unsigned long off, uint16 data);
 static unsigned long	block(unsigned long addr, int which);
-static int	flash_erase(void);
 static int	flash_eraseblk(unsigned long off);
-static int	flash_write(unsigned long off, uint16 *src, uint nbytes);
-static unsigned long	flash_block_base(unsigned long off);
-static unsigned long	flash_block_lim(unsigned long off);
-static chipcregs_t *cc;
+static int	flash_write(unsigned long off, uint8 *src, uint nbytes);
+static uint16 INLINE flash_readword(unsigned long addr);
+static void INLINE flash_writeword(unsigned long addr, uint16 data);
+
+int sysFlashErase(uint off, unsigned int numbytes);
 
 /* Read the flash ID and set the globals */
 int
 sysFlashInit(char *flash_str)
 {
+	osl_t *osh;
 	uint32 fltype = PFLASH;
 	uint16 flash_vendid = 0;
 	uint16 flash_devid = 0;
-	uint16* flash = (uint16*)0xbfc00000;
 	int idx;
 	struct sflash *sflash;
-	void *sbh;
 
 	/*
 	 * Check for serial flash.
 	 */
-	sbh = sb_kattach();
+	sbh = sb_kattach(SB_OSH);
 	ASSERT(sbh);
-	cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0);
 
+	osh = sb_osh(sbh);
+
+	flashutl_base = (uint8*)OSL_UNCACHED(SB_FLASH1);
+	flashutl_wsz = sizeof(uint16);
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
 	if (cc) {
-		flash = (uint16*)0xbc000000;
-		fltype = R_REG(&cc->capabilities) & CAP_FLASH_MASK;
+		flashutl_base = (uint8*)OSL_UNCACHED(SB_FLASH2);
+		flashutl_wsz = (R_REG(osh, &cc->flash_config) & CC_CFG_DS) ?
+		        sizeof(uint16) : sizeof(uint8);
 		/* Select SFLASH ? */
+		fltype = R_REG(osh, &cc->capabilities) & CC_CAP_FLASH_MASK;
 		if (fltype == SFLASH_ST || fltype == SFLASH_AT) {
-			sflash = sflash_init(cc);
+			sflash = sflash_init(sbh, cc);
 			flashutl_cmd = &sflash_cmd_t;
 			flashutl_desc = &sflash_desc;
 			flashutl_desc->size = sflash->size;
 			if (flash_str) 
 				sprintf(flash_str, "SFLASH %d kB", sflash->size/1024);
-			return(0);
+			return (0);
 		}
 	}
 
-	flashutl_base = (uint8*)flash;
+	ASSERT(flashutl_wsz == sizeof(uint8) || flashutl_wsz == sizeof(uint16));
 
 	/* 
 	 * Parallel flash support
 	 *  Some flashes have different unlock addresses, try each it turn
 	 */
-	idx = sizeof(flash_cmds)/sizeof(flash_cmds_t) - 2;
-	flashutl_cmd = &flash_cmds[idx--];
-	while((fltype == PFLASH) && flashutl_cmd->type) {
+	for (idx = 0;
+	     fltype == PFLASH && idx < ARRAYSIZE(flash_cmds);
+	     idx ++) {
+		flashutl_cmd = &flash_cmds[idx];
+		if (flashutl_cmd->type == OLD)
+			continue;
 
 		if (flashutl_cmd->read_id)
 			cmd(flashutl_cmd->read_id, CMD_ADDR);
 
 #ifdef MIPSEB
-		flash_vendid = *(flash + 1);
-		flash_devid = *flash;	
+		flash_vendid = flash_readword(FLASH_ADDR(2));
+		flash_devid = flash_readword(FLASH_ADDR(0));
 #else
-		flash_vendid = *flash;
-		flash_devid = *(flash + 1);
-#endif
-
-		/* Funky AMD */
+		flash_vendid = flash_readword(FLASH_ADDR(0));
+		flash_devid = flash_readword(FLASH_ADDR(2));
+#endif /* MIPSEB */
+
+		/* Funky AMD, uses 3 byte device ID so use first byte (4th addr) to
+		 * identify it is a 3-byte ID and use the next two bytes (5th & 6th addr)
+		 * to form a word for unique identification of format xxyy, where
+		 * xx = 5th addr and yy = 6th addr
+		 */
 		if ((flash_vendid == 1) && (flash_devid == 0x227e)) {
 			/* Get real devid */
+			uint16 flash_devid_5th;
 #ifdef MIPSEB
-			flash_devid = *(flash+0xe);	
+			flash_devid_5th = flash_readword(FLASH_ADDR(0x1e)) << 8;
+			flash_devid = (flash_readword(FLASH_ADDR(0x1c)) & 0xff) | flash_devid_5th;
 #else
-			flash_devid = *(flash+0xf);
-#endif
+			flash_devid_5th = flash_readword(FLASH_ADDR(0x1c)) << 8;
+			flash_devid = (flash_readword(FLASH_ADDR(0x1e)) & 0xff) | flash_devid_5th;
+#endif /* MIPSEB */
 		}
 
 		flashutl_desc = flashes;
@@ -134,8 +148,6 @@
 		}
 		if (flashutl_desc->mfgid != 0)
 			break;
-
-		flashutl_cmd = &flash_cmds[idx--];
 	}
 
 	if (flashutl_desc->mfgid == 0) {
@@ -168,21 +180,6 @@
 }
 
 static int
-flash_erase()
-{
-	unsigned long size = flashutl_desc->size;
-	unsigned long addr;
-	int err = 0;
-	
-	for (addr = 0; addr < size; addr = block(addr, BLOCK_LIM)) {
-		err = flash_eraseblk(addr);
-		if (err) break;
-	}
-	
-	return err;
-}
-
-static int
 flash_eraseblk(unsigned long addr)
 {
 	unsigned long a;
@@ -194,7 +191,7 @@
 	
 	a = block(a, BLOCK_BASE);
 
-	/* Ensure blocks are unlocked (for intel chips)*/ 
+	/* Ensure blocks are unlocked (for intel chips) */
 	if (flashutl_cmd->type == BSC) {
 		scmd((unsigned char)INTEL_UNLOCK1, a);
 		scmd((unsigned char)INTEL_UNLOCK2, a);
@@ -207,6 +204,9 @@
 	if (flashutl_cmd->confirm)
 		scmd(flashutl_cmd->confirm, a);
 
+	if (flashutl_wsz == sizeof(uint8))
+		st = flash_poll(a, 0xff);
+	else
 	st = flash_poll(a, 0xffff);
 	
 	flash_reset();
@@ -217,15 +217,15 @@
 		return st;
 	}
 
-	DPRINT(("Erase of block 0x%08lx-0x%08lx done", a, block((unsigned long)addr, BLOCK_LIM)));
+	DPRINT(("Erase of block 0x%08lx-0x%08lx done\n", a, block((unsigned long)addr, BLOCK_LIM)));
 
 	return 0;
 }
 
 static int
-flash_write(unsigned long off, uint16 *src, uint nbytes)
+flash_write(unsigned long off, uint8 *src, uint nbytes)
 {
-	uint16* dest;
+	uint8 *dest;
 	uint16 st, data;
 	uint i, len;
 
@@ -234,7 +234,9 @@
 	if (off >= flashutl_desc->size)
 		return 1;
 
-	dest = (uint16*)FLASH_ADDR(off);
+	ASSERT(!(off & (flashutl_wsz - 1)));
+
+	dest = (uint8*)FLASH_ADDR(off);
 	st = 0;
 
 	while (nbytes) {
@@ -251,11 +253,12 @@
 
 #ifndef MIPSEB
 			/* write (length - 1) */
-			cmd((len / 2) - 1, off);
+			cmd(len / sizeof(uint16) - 1, off);
 
 			/* write data */
-			for (i = 0; i < len; i += 2, dest++, src++)
-				*dest = *src;
+			for (i = 0; i < len; i += sizeof(uint16),
+			             dest += sizeof(uint16), src += sizeof(uint16))
+				*(uint16 *)dest = *(uint16 *)src;
 #else
 			/* 
 			 * BCM4710 endianness is word consistent but
@@ -268,14 +271,16 @@
 			 */
 
 			/* write (padded length - 1) */
-			cmd((ROUNDUP(len, 4) / 2) - 1, off);
+			cmd((ROUNDUP(len, sizeof(uint32)) / sizeof(uint16)) - 1, off);
 
 			/* write data (plus pad if necessary) */
-			for (i = 0; i < ROUNDUP(len, 4); i += 4, dest += 2, src += 2) {
-				*(dest + 1) = ((i + 2) < len) ? *(src + 1) : 0xffff;
-				*dest = *src;
+			for (i = 0; i < ROUNDUP(len, sizeof(uint32)); i += sizeof(uint32),
+			             dest += sizeof(uint32), src += sizeof(uint32)) {
+				*((uint16 *)dest + 1) = ((i + sizeof(uint16)) < len) ?
+				        *((uint16 *)src + 1) : 0xffff;
+				*(uint16 *)dest = *(uint16 *)src;
 			}
-#endif
+#endif /* MIPSEB */
 
 			/* write confirm */
 			if (flashutl_cmd->confirm)
@@ -289,13 +294,16 @@
 				cmd(flashutl_cmd->write_word, CMD_ADDR);
 
 			/* write data */
-			len = MIN(nbytes, 2);
-			data = *src++;
-			*dest++ = data;
+			data = flash_readword((unsigned long)src);
+			flash_writeword((unsigned long)dest, data);
 
 			/* poll for done */
 			if ((st = flash_poll(off, data)))
 				break;
+
+			len = MIN(nbytes, flashutl_wsz);
+			dest += len;
+			src += len;
 		}
 
 		nbytes -= len;
@@ -307,27 +315,31 @@
 	return st;
 }
 
-static unsigned long
-flash_block_base(unsigned long off)
+static uint16 INLINE
+flash_readword(unsigned long addr)
 {
-	return block(off, BLOCK_BASE);
+	if (flashutl_wsz == sizeof(uint8))
+		return *(uint8*)addr;
+	else
+		return *(uint16*)addr;
 }
 
-static unsigned long
-flash_block_lim(unsigned long off)
+static void INLINE
+flash_writeword(unsigned long addr, uint16 data)
 {
-	return block(off, BLOCK_LIM);
+	if (flashutl_wsz == sizeof(uint8))
+		*(uint8*)addr = (uint8)data;
+	else
+		*(uint16*)addr = data;
 }
 
 /* Writes a single command to the flash. */
 static void
 scmd(uint16 cmd, unsigned long off)
 {
-	ASSERT(flashutl_base != NULL);
-	
 	/*  cmd |= cmd << 8; */
 
-	*(uint16*)(flashutl_base + off) = cmd;
+	flash_writeword(FLASH_ADDR(off), cmd);
 }
 
 /* Writes a command to flash, performing an unlock if needed. */
@@ -335,40 +347,48 @@
 cmd(uint16 cmd, unsigned long off)
 {
 	int i;
-	unlock_cmd_t *ul=NULL;
-	unsigned long cmd_off;
+	unlock_cmd_t *ul = NULL;
 
 	ASSERT(flashutl_cmd != NULL);
 
 	switch (flashutl_cmd->type) {
 	case AMD:
 		ul = &unlock_cmd_amd;
-		cmd_off = AMD_CMD;
 		break;
 	case SST:
 		ul = &unlock_cmd_sst;
-		cmd_off = SST_CMD;
 		break;
 	default:
-		cmd_off = 0;
 		break;
 	}
 	
 	if (flashutl_cmd->need_unlock) {
+		ASSERT(ul);
 		for (i = 0; i < UNLOCK_CMD_WORDS; i++)
-			*(uint16*)(flashutl_base + ul->addr[i]) = ul->cmd[i];
+			flash_writeword(FLASH_ADDR(ul->addr[i]), ul->cmd[i]);
 	}
 	
 	/* cmd |= cmd << 8; */
 
-	if (off == CMD_ADDR) 
-		off = cmd_off;
+	if (off == CMD_ADDR) {
+		switch (flashutl_cmd->type) {
+		case AMD:
+			off = AMD_CMD;
+			break;
+		case SST:
+			off = SST_CMD;
+			break;
+		default:
+			off = 0;
+			break;
+		}
+	}
 
 #ifdef MIPSEB
 	off ^= 2;
-#endif
+#endif /* MIPSEB */
 	
-	*(uint16*)(flashutl_base + off) = cmd;
+	flash_writeword(FLASH_ADDR(off), cmd);
 }
 
 static void
@@ -385,7 +405,7 @@
 static int
 flash_poll(unsigned long off, uint16 data)
 {
-	volatile uint16* addr;
+	unsigned long addr;
 	int cnt = FLASH_TRIES;
 	uint16 st;
 
@@ -393,18 +413,18 @@
 
 	if (flashutl_desc->type == AMD || flashutl_desc->type == SST) {
 		/* AMD style poll checkes the address being written */
-		addr = (volatile uint16*)FLASH_ADDR(off);
-		while ((st = *addr) != data && cnt != 0)
+		addr = FLASH_ADDR(off);
+		while ((st = flash_readword(addr)) != data && cnt != 0)
 			cnt--;
 		if (cnt == 0) {
-			DPRINT(("flash_poll: timeout, read 0x%x, expected 0x%x\n", st, data));
+			DPRINT(("flash_poll: timeout, off %lx, read 0x%x, expected 0x%x\n",
+			        off, st, data));
 			return -1;
 		}
 	} else {
 		/* INTEL style poll is at second word of the block being written */
-		addr = (volatile uint16*)FLASH_ADDR(block(off, BLOCK_BASE));
-		addr++;
-		while (((st = *addr) & DONE) == 0 && cnt != 0)
+		addr = FLASH_ADDR(block(off, BLOCK_BASE)+sizeof(uint16));
+		while (((st = flash_readword(addr)) & DONE) == 0 && cnt != 0)
 			cnt--;
 		if (cnt == 0) {
 			DPRINT(("flash_poll: timeout, error status = 0x%x\n", st));
@@ -453,7 +474,6 @@
 		}
 	}
 
-	ASSERT(1);
 	return 0;
 }
 
@@ -464,6 +484,23 @@
 	sysFlashWrite(off, (uchar*)data, len);
 }
 
+void
+nvWriteChars(unsigned char *data, unsigned int len)
+{
+	uint off = flashutl_desc->size - NVRAM_SPACE;
+	int err;
+
+	if (flashutl_cmd->type == SFLASH)
+		err = sflash_commit(sbh, cc, off, len, data);
+	else /* PFLASH */
+		err = flash_write(off, data, len);
+
+	if (err)
+		DPRINT(("nvWriteChars failed\n"));
+	else
+		DPRINT(("nvWriteChars succeeded\n"));
+}
+
 int
 sysFlashErase(uint off, unsigned int numbytes)
 {
@@ -471,14 +508,13 @@
 	int err = 0;
 	
 	if (flashutl_cmd->type == SFLASH) {
-		err = sflash_commit(cc, off, numbytes, NULL);
+		err = sflash_commit(sbh, cc, off, numbytes, NULL);
 	} else {
-		ASSERT(!(off & 1));
 		while (off < end) {
 			err = flash_eraseblk(off);
 			if (err)
 				break;
-			off = flash_block_lim(off);
+			off = block(off, BLOCK_LIM);
 		}
 	}
 
@@ -495,15 +531,14 @@
 {
 	int err;
 	
-	DPRINT(("Writing 0x%x bytes to flash off @0x%x ...\n", (unsigned int)numbytes, off));
+	DPRINT(("Writing 0x%x bytes to flash @0x%x ...\n", (unsigned int)numbytes, off));
 
 	if (flashutl_cmd->type == SFLASH)
-		err = sflash_commit(cc, off, numbytes, src);
+		err = sflash_commit(sbh, cc, off, numbytes, src);
 	else {
-		ASSERT(!(off & 1));
 		if (!sysFlashErase(off, numbytes)) 
 			return 0;
-		err = flash_write(off, (uint16*)src, numbytes);
+		err = flash_write(off, src, numbytes);
 	}
 
 	if (err) 
@@ -517,30 +552,28 @@
 int 
 sysFlashRead(uint off, uchar *buf, uint numbytes)
 {
-	uint read, total_read=0;
-	uint16 *src, *dst;
+	uint read, total_read = 0;
 
 	if (flashutl_cmd->type == SFLASH) {
 		while (numbytes) {
-			read = sflash_read(cc, off, numbytes, buf);
+			read = sflash_read(sbh, cc, off, numbytes, buf);
 			numbytes -= read;
 			buf += read;
 			off += read;
 			total_read += read;
 		}
 	} else {
-		ASSERT(!(off & 1));
-		ASSERT(!(numbytes & 1));
-		
-		src = (uint16*)(flashutl_base + off);
-		dst = (uint16*)buf;
+		ASSERT(!(off & (flashutl_wsz - 1)));
+		ASSERT(!(numbytes & (flashutl_wsz - 1)));
 		
-		while(numbytes) {
-			*dst++ = *src++;
-			numbytes-=2;
-			total_read+=2;
+		while (numbytes) {
+			flash_writeword((unsigned long)buf, flash_readword(FLASH_ADDR(off)));
+			numbytes -= flashutl_wsz;
+			buf += flashutl_wsz;
+			off += flashutl_wsz;
+			total_read += flashutl_wsz;
 		}
 	}
 
-	return(total_read);
+	return (total_read);
 }
--- src/shared.1927/gzip_inflate.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/gzip_inflate.c	2007-11-19 06:40:26.000000000 +0300
@@ -107,6 +107,8 @@
       the two sets of lengths.
  */
 
+/* FILE-CSTYLED */
+
 #ifdef RCSID
 static char rcsid[] = "#Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp #";
 #endif
--- src/shared.1927/hnddma.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/hnddma.c	2007-11-19 06:40:26.000000000 +0300
@@ -14,64 +14,95 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
 #include <bcmendian.h>
 #include <sbconfig.h>
 #include <bcmutils.h>
+#include <bcmdevs.h>
+#include <sbutils.h>
 
-struct dma_info;	/* forward declaration */
-#define di_t struct dma_info
+#include <sbhnddma.h>
 #include <hnddma.h>
 
 /* debug/trace */
 #define DMA_ERROR(args)
 #define	DMA_TRACE(args)
 
-/* default dma message level(if input msg_level pointer is null in dma_attach()) */
-static uint dma_msg_level = 0;
+/* default dma message level (if input msg_level pointer is null in dma_attach()) */
+static uint dma_msg_level =
+	0;
 
-#define	MAXNAMEL	8
-#define	MAXDD		(DMAMAXRINGSZ / sizeof (dmadd_t))
+#define	MAXNAMEL	8		/* 8 char names */
+
+#define	DI_INFO(dmah)	(dma_info_t *)dmah
 
 /* dma engine software state */
 typedef struct dma_info {
-	hnddma_t	hnddma;		/* exported structure */
+	struct hnddma_pub hnddma;	/* exported structure, don't use hnddma_t,
+					 * which could be const
+					 */
 	uint		*msg_level;	/* message level pointer */
-
 	char		name[MAXNAMEL];	/* callers name for diag msgs */
-	void		*drv;		/* driver handle */
+
 	void		*osh;		/* os handle */
-	dmaregs_t	*regs;		/* dma engine registers */
+	sb_t		*sbh;		/* sb handle */
 
-	dmadd_t		*txd;		/* pointer to chip-specific tx descriptor ring */
+	bool		dma64;		/* dma64 enabled */
+	bool		addrext;	/* this dma engine supports DmaExtendedAddrChanges */
+
+	dma32regs_t	*d32txregs;	/* 32 bits dma tx engine registers */
+	dma32regs_t	*d32rxregs;	/* 32 bits dma rx engine registers */
+	dma64regs_t	*d64txregs;	/* 64 bits dma tx engine registers */
+	dma64regs_t	*d64rxregs;	/* 64 bits dma rx engine registers */
+
+	uint32		dma64align;	/* either 8k or 4k depends on number of dd */
+	dma32dd_t	*txd32;		/* pointer to dma32 tx descriptor ring */
+	dma64dd_t	*txd64;		/* pointer to dma64 tx descriptor ring */
+	uint		ntxd;		/* # tx descriptors tunable */
 	uint		txin;		/* index of next descriptor to reclaim */
 	uint		txout;		/* index of next descriptor to post */
-	uint		txavail;	/* # free tx descriptors */
 	void		**txp;		/* pointer to parallel array of pointers to packets */
+	osldma_t 	*tx_dmah;	/* DMA TX descriptor ring handle */
+	osldma_t	**txp_dmah;	/* DMA TX packet data handle */
 	ulong		txdpa;		/* physical address of descriptor ring */
 	uint		txdalign;	/* #bytes added to alloc'd mem to align txd */
 	uint		txdalloc;	/* #bytes allocated for the ring */
 
-	dmadd_t		*rxd;		/* pointer to chip-specific rx descriptor ring */
+	dma32dd_t	*rxd32;		/* pointer to dma32 rx descriptor ring */
+	dma64dd_t	*rxd64;		/* pointer to dma64 rx descriptor ring */
+	uint		nrxd;		/* # rx descriptors tunable */
 	uint		rxin;		/* index of next descriptor to reclaim */
 	uint		rxout;		/* index of next descriptor to post */
 	void		**rxp;		/* pointer to parallel array of pointers to packets */
+	osldma_t 	*rx_dmah;	/* DMA RX descriptor ring handle */
+	osldma_t	**rxp_dmah;	/* DMA RX packet data handle */
 	ulong		rxdpa;		/* physical address of descriptor ring */
 	uint		rxdalign;	/* #bytes added to alloc'd mem to align rxd */
 	uint		rxdalloc;	/* #bytes allocated for the ring */
 
 	/* tunables */
-	uint		ntxd;		/* # tx descriptors */
-	uint		nrxd;		/* # rx descriptors */
-	uint		rxbufsize;	/* rx buffer size in bytes */
+	uint		rxbufsize;	/* rx buffer size in bytes,
+					   not including the extra headroom
+					*/
 	uint		nrxpost;	/* # rx buffers to keep posted */
 	uint		rxoffset;	/* rxcontrol offset */
-	uint		ddoffset;	/* add to get dma address of descriptor ring */
-	uint		dataoffset;	/* add to get dma address of data buffer */
+	uint		ddoffsetlow;	/* add to get dma address of descriptor ring, low 32 bits */
+	uint		ddoffsethigh;	/*   high 32 bits */
+	uint		dataoffsetlow;	/* add to get dma address of data buffer, low 32 bits */
+	uint		dataoffsethigh;	/*   high 32 bits */
 } dma_info_t;
 
+#ifdef BCMDMA64
+#define	DMA64_ENAB(di)	((di)->dma64)
+#define DMA64_CAP	TRUE
+#else
+#define	DMA64_ENAB(di)	(0)
+#define DMA64_CAP	FALSE
+#endif
+
 /* descriptor bumping macros */
-#define	XXD(x, n)	((x) & ((n) - 1))
+#define	XXD(x, n)	((x) & ((n) - 1))	/* faster than %, but n must be power of 2 */
 #define	TXD(x)		XXD((x), di->ntxd)
 #define	RXD(x)		XXD((x), di->nrxd)
 #define	NEXTTXD(i)	TXD(i + 1)
@@ -81,118 +112,452 @@
 #define	NRXDACTIVE(h, t)	RXD(t - h)
 
 /* macros to convert between byte offsets and indexes */
-#define	B2I(bytes)	((bytes) / sizeof (dmadd_t))
-#define	I2B(index)	((index) * sizeof (dmadd_t))
+#define	B2I(bytes, type)	((bytes) / sizeof(type))
+#define	I2B(index, type)	((index) * sizeof(type))
 
-/*
- * This assume the largest i/o address is, in fact, the pci big window
- * and that the pci core sb2pcitranslation2 register has been left with
- * the default 0x0 pci base address.
- */
-#define	MAXDMAADDR		SB_PCI_DMA_SZ
-#define	DMA_ADDRESSABLE(x)	!((x) & ~(MAXDMAADDR - 1))
-
-/* prototypes */
-
-void* 
-dma_attach(void *drv, void *osh, char *name, dmaregs_t *regs, uint ntxd, uint nrxd,
-	uint rxbufsize, uint nrxpost, uint rxoffset, uint ddoffset, uint dataoffset, uint *msg_level)
+#define	PCI32ADDR_HIGH		0xc0000000	/* address[31:30] */
+#define	PCI32ADDR_HIGH_SHIFT	30		/* address[31:30] */
+
+
+/* common prototypes */
+static bool _dma_isaddrext(dma_info_t *di);
+static bool _dma_alloc(dma_info_t *di, uint direction);
+static void _dma_detach(dma_info_t *di);
+static void _dma_ddtable_init(dma_info_t *di, uint direction, ulong pa);
+static void _dma_rxinit(dma_info_t *di);
+static void *_dma_rx(dma_info_t *di);
+static void _dma_rxfill(dma_info_t *di);
+static void _dma_rxreclaim(dma_info_t *di);
+static void _dma_rxenable(dma_info_t *di);
+static void * _dma_getnextrxp(dma_info_t *di, bool forceall);
+
+static void _dma_txblock(dma_info_t *di);
+static void _dma_txunblock(dma_info_t *di);
+static uint _dma_txactive(dma_info_t *di);
+
+static void* _dma_peeknexttxp(dma_info_t *di);
+static uintptr _dma_getvar(dma_info_t *di, const char *name);
+static void _dma_counterreset(dma_info_t *di);
+static void _dma_fifoloopbackenable(dma_info_t *di);
+
+/* ** 32 bit DMA prototypes */
+static bool dma32_alloc(dma_info_t *di, uint direction);
+static bool dma32_txreset(dma_info_t *di);
+static bool dma32_rxreset(dma_info_t *di);
+static bool dma32_txsuspendedidle(dma_info_t *di);
+static int  dma32_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma32_getnexttxp(dma_info_t *di, bool forceall);
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall);
+static void dma32_txrotate(dma_info_t *di);
+static bool dma32_rxidle(dma_info_t *di);
+static void dma32_txinit(dma_info_t *di);
+static bool dma32_txenabled(dma_info_t *di);
+static void dma32_txsuspend(dma_info_t *di);
+static void dma32_txresume(dma_info_t *di);
+static bool dma32_txsuspended(dma_info_t *di);
+static void dma32_txreclaim(dma_info_t *di, bool forceall);
+static bool dma32_txstopped(dma_info_t *di);
+static bool dma32_rxstopped(dma_info_t *di);
+static bool dma32_rxenabled(dma_info_t *di);
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs);
+
+/* ** 64 bit DMA prototypes and stubs */
+#ifdef BCMDMA64
+static bool dma64_alloc(dma_info_t *di, uint direction);
+static bool dma64_txreset(dma_info_t *di);
+static bool dma64_rxreset(dma_info_t *di);
+static bool dma64_txsuspendedidle(dma_info_t *di);
+static int  dma64_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma64_getnexttxp(dma_info_t *di, bool forceall);
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall);
+static void dma64_txrotate(dma_info_t *di);
+
+static bool dma64_rxidle(dma_info_t *di);
+static void dma64_txinit(dma_info_t *di);
+static bool dma64_txenabled(dma_info_t *di);
+static void dma64_txsuspend(dma_info_t *di);
+static void dma64_txresume(dma_info_t *di);
+static bool dma64_txsuspended(dma_info_t *di);
+static void dma64_txreclaim(dma_info_t *di, bool forceall);
+static bool dma64_txstopped(dma_info_t *di);
+static bool dma64_rxstopped(dma_info_t *di);
+static bool dma64_rxenabled(dma_info_t *di);
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
+
+#else
+static bool dma64_alloc(dma_info_t *di, uint direction) { return FALSE; }
+static bool dma64_txreset(dma_info_t *di) { return FALSE; }
+static bool dma64_rxreset(dma_info_t *di) { return FALSE; }
+static bool dma64_txsuspendedidle(dma_info_t *di) { return FALSE;}
+static int  dma64_txfast(dma_info_t *di, void *p0, bool commit) { return 0; }
+static void *dma64_getnexttxp(dma_info_t *di, bool forceall) { return NULL; }
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall) { return NULL; }
+static void dma64_txrotate(dma_info_t *di) { return; }
+
+static bool dma64_rxidle(dma_info_t *di) { return FALSE; }
+static void dma64_txinit(dma_info_t *di) { return; }
+static bool dma64_txenabled(dma_info_t *di) { return FALSE; }
+static void dma64_txsuspend(dma_info_t *di) { return; }
+static void dma64_txresume(dma_info_t *di) { return; }
+static bool dma64_txsuspended(dma_info_t *di) {return FALSE; }
+static void dma64_txreclaim(dma_info_t *di, bool forceall) { return; }
+static bool dma64_txstopped(dma_info_t *di) { return FALSE; }
+static bool dma64_rxstopped(dma_info_t *di) { return FALSE; }
+static bool dma64_rxenabled(dma_info_t *di) { return FALSE; }
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs) { return FALSE; }
+
+#endif	/* BCMDMA64 */
+
+
+
+static di_fcn_t dma64proc = {
+	(di_detach_t)_dma_detach,
+	(di_txinit_t)dma64_txinit,
+	(di_txreset_t)dma64_txreset,
+	(di_txenabled_t)dma64_txenabled,
+	(di_txsuspend_t)dma64_txsuspend,
+	(di_txresume_t)dma64_txresume,
+	(di_txsuspended_t)dma64_txsuspended,
+	(di_txsuspendedidle_t)dma64_txsuspendedidle,
+	(di_txfast_t)dma64_txfast,
+	(di_txstopped_t)dma64_txstopped,
+	(di_txreclaim_t)dma64_txreclaim,
+	(di_getnexttxp_t)dma64_getnexttxp,
+	(di_peeknexttxp_t)_dma_peeknexttxp,
+	(di_txblock_t)_dma_txblock,
+	(di_txunblock_t)_dma_txunblock,
+	(di_txactive_t)_dma_txactive,
+	(di_txrotate_t)dma64_txrotate,
+
+	(di_rxinit_t)_dma_rxinit,
+	(di_rxreset_t)dma64_rxreset,
+	(di_rxidle_t)dma64_rxidle,
+	(di_rxstopped_t)dma64_rxstopped,
+	(di_rxenable_t)_dma_rxenable,
+	(di_rxenabled_t)dma64_rxenabled,
+	(di_rx_t)_dma_rx,
+	(di_rxfill_t)_dma_rxfill,
+	(di_rxreclaim_t)_dma_rxreclaim,
+	(di_getnextrxp_t)_dma_getnextrxp,
+
+	(di_fifoloopbackenable_t)_dma_fifoloopbackenable,
+	(di_getvar_t)_dma_getvar,
+	(di_counterreset_t)_dma_counterreset,
+
+	NULL,
+	NULL,
+	NULL,
+	34
+};
+
+static di_fcn_t dma32proc = {
+	(di_detach_t)_dma_detach,
+	(di_txinit_t)dma32_txinit,
+	(di_txreset_t)dma32_txreset,
+	(di_txenabled_t)dma32_txenabled,
+	(di_txsuspend_t)dma32_txsuspend,
+	(di_txresume_t)dma32_txresume,
+	(di_txsuspended_t)dma32_txsuspended,
+	(di_txsuspendedidle_t)dma32_txsuspendedidle,
+	(di_txfast_t)dma32_txfast,
+	(di_txstopped_t)dma32_txstopped,
+	(di_txreclaim_t)dma32_txreclaim,
+	(di_getnexttxp_t)dma32_getnexttxp,
+	(di_peeknexttxp_t)_dma_peeknexttxp,
+	(di_txblock_t)_dma_txblock,
+	(di_txunblock_t)_dma_txunblock,
+	(di_txactive_t)_dma_txactive,
+	(di_txrotate_t)dma32_txrotate,
+
+	(di_rxinit_t)_dma_rxinit,
+	(di_rxreset_t)dma32_rxreset,
+	(di_rxidle_t)dma32_rxidle,
+	(di_rxstopped_t)dma32_rxstopped,
+	(di_rxenable_t)_dma_rxenable,
+	(di_rxenabled_t)dma32_rxenabled,
+	(di_rx_t)_dma_rx,
+	(di_rxfill_t)_dma_rxfill,
+	(di_rxreclaim_t)_dma_rxreclaim,
+	(di_getnextrxp_t)_dma_getnextrxp,
+
+	(di_fifoloopbackenable_t)_dma_fifoloopbackenable,
+	(di_getvar_t)_dma_getvar,
+	(di_counterreset_t)_dma_counterreset,
+
+	NULL,
+	NULL,
+	NULL,
+	34
+};
+
+hnddma_t *
+dma_attach(osl_t *osh, char *name, sb_t *sbh, void *dmaregstx, void *dmaregsrx,
+           uint ntxd, uint nrxd, uint rxbufsize, uint nrxpost, uint rxoffset, uint *msg_level)
 {
 	dma_info_t *di;
 	uint size;
-	void *va;
-
-	ASSERT(ntxd <= MAXDD);
-	ASSERT(ISPOWEROF2(ntxd));
-	ASSERT(nrxd <= MAXDD);
-	ASSERT(ISPOWEROF2(nrxd));
 
 	/* allocate private info structure */
 	if ((di = MALLOC(osh, sizeof (dma_info_t))) == NULL) {
 		return (NULL);
 	}
-	bzero((char*)di, sizeof (dma_info_t));
+	bzero((char *)di, sizeof(dma_info_t));
 
-	/* allocate tx packet pointer vector */
-	if (ntxd) {
-		size = ntxd * sizeof (void*);
-		if ((di->txp = MALLOC(osh, size)) == NULL)
-			goto fail;
-		bzero((char*)di->txp, size);
-	}
+	di->msg_level = msg_level ? msg_level : &dma_msg_level;
 
-	/* allocate rx packet pointer vector */
-	if (nrxd) {
-		size = nrxd * sizeof (void*);
-		if ((di->rxp = MALLOC(osh, size)) == NULL)
+	/* old chips w/o sb is no longer supported */
+	ASSERT(sbh != NULL);
+
+	di->dma64 = ((sb_coreflagshi(sbh, 0, 0) & SBTMH_DMA64) == SBTMH_DMA64);
+
+#ifndef BCMDMA64
+	if (di->dma64) {
+		DMA_ERROR(("dma_attach: driver doesn't have the capability to support "
+		           "64 bits DMA\n"));
 			goto fail;
-		bzero((char*)di->rxp, size);
 	}
+#endif
 
-	/* set message level */
-	di->msg_level = msg_level ? msg_level : &dma_msg_level;
+	/* check arguments */
+	ASSERT(ISPOWEROF2(ntxd));
+	ASSERT(ISPOWEROF2(nrxd));
+	if (nrxd == 0)
+		ASSERT(dmaregsrx == NULL);
+	if (ntxd == 0)
+		ASSERT(dmaregstx == NULL);
+
+
+	/* init dma reg pointer */
+	if (di->dma64) {
+		ASSERT(ntxd <= D64MAXDD);
+		ASSERT(nrxd <= D64MAXDD);
+		di->d64txregs = (dma64regs_t *)dmaregstx;
+		di->d64rxregs = (dma64regs_t *)dmaregsrx;
+
+		di->dma64align = D64RINGALIGN;
+		if ((ntxd < D64MAXDD / 2) && (nrxd < D64MAXDD / 2)) {
+			/* for smaller dd table, HW relax the alignment requirement */
+			di->dma64align = D64RINGALIGN / 2;
+		}
+	} else {
+		ASSERT(ntxd <= D32MAXDD);
+		ASSERT(nrxd <= D32MAXDD);
+		di->d32txregs = (dma32regs_t *)dmaregstx;
+		di->d32rxregs = (dma32regs_t *)dmaregsrx;
+	}
 
-	DMA_TRACE(("%s: dma_attach: drv %p osh %p regs %p ntxd %d nrxd %d rxbufsize %d nrxpost %d rxoffset %d ddoffset 0x%x dataoffset 0x%x\n", name, drv, osh, regs, ntxd, nrxd, rxbufsize, nrxpost, rxoffset, ddoffset, dataoffset));
+	DMA_TRACE(("%s: dma_attach: %s osh %p ntxd %d nrxd %d rxbufsize %d nrxpost %d "
+	           "rxoffset %d dmaregstx %p dmaregsrx %p\n",
+	           name, (di->dma64 ? "DMA64" : "DMA32"), osh, ntxd, nrxd, rxbufsize,
+	           nrxpost, rxoffset, dmaregstx, dmaregsrx));
 
 	/* make a private copy of our callers name */
 	strncpy(di->name, name, MAXNAMEL);
 	di->name[MAXNAMEL-1] = '\0';
 
-	di->drv = drv;
 	di->osh = osh;
-	di->regs = regs;
+	di->sbh = sbh;
+
+	/* save tunables */
+	di->ntxd = ntxd;
+	di->nrxd = nrxd;
 
-	/* allocate transmit descriptor ring */
+	/* the actual dma size doesn't include the extra headroom */
+	if (rxbufsize > BCMEXTRAHDROOM)
+		di->rxbufsize = rxbufsize - BCMEXTRAHDROOM;
+	else
+		di->rxbufsize = rxbufsize;
+
+	di->nrxpost = nrxpost;
+	di->rxoffset = rxoffset;
+
+	/*
+	 * figure out the DMA physical address offset for dd and data
+	 *   for old chips w/o sb, use zero
+	 *   for new chips w sb,
+	 *     PCI/PCIE: they map silicon backplace address to zero based memory, need offset
+	 *     Other bus: use zero
+	 *     SB_BUS BIGENDIAN kludge: use sdram swapped region for data buffer, not descriptor
+	 */
+	di->ddoffsetlow = 0;
+	di->dataoffsetlow = 0;
+	/* for pci bus, add offset */
+	if (sbh->bustype == PCI_BUS) {
+		if ((sbh->buscoretype == SB_PCIE) && di->dma64) {
+			/* pcie with DMA64 */
+			di->ddoffsetlow = 0;
+			di->ddoffsethigh = SB_PCIE_DMA_H32;
+		} else {
+			/* pci(DMA32/DMA64) or pcie with DMA32 */
+			di->ddoffsetlow = SB_PCI_DMA;
+			di->ddoffsethigh = 0;
+		}
+		di->dataoffsetlow =  di->ddoffsetlow;
+		di->dataoffsethigh =  di->ddoffsethigh;
+	}
+
+#if defined(__mips__) && defined(IL_BIGENDIAN)
+	di->dataoffsetlow = di->dataoffsetlow + SB_SDRAM_SWAPPED;
+#endif
+
+	di->addrext = _dma_isaddrext(di);
+
+	/* allocate tx packet pointer vector */
 	if (ntxd) {
-		/* only need ntxd descriptors but it must be DMARINGALIGNed */
-		size = ntxd * sizeof (dmadd_t);
-		if (!ISALIGNED(DMA_CONSISTENT_ALIGN, DMARINGALIGN))
-			size += DMARINGALIGN;
-		if ((va = DMA_ALLOC_CONSISTENT(osh, size, &di->txdpa)) == NULL)
+		size = ntxd * sizeof(void *);
+		if ((di->txp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of tx memory, malloced %d bytes\n",
+			           di->name, MALLOCED(osh)));
 			goto fail;
-		di->txd = (dmadd_t*) ROUNDUP((uintptr)va, DMARINGALIGN);
-		di->txdalign = (uint)((int8*)di->txd - (int8*)va);
-		di->txdpa += di->txdalign;
-		di->txdalloc = size;
-		ASSERT(ISALIGNED((uintptr)di->txd, DMARINGALIGN));
-		ASSERT(DMA_ADDRESSABLE(di->txdpa));
+		}
+		bzero((char *)di->txp, size);
 	}
 
-	/* allocate receive descriptor ring */
+	/* allocate rx packet pointer vector */
 	if (nrxd) {
-		/* only need nrxd descriptors but it must be DMARINGALIGNed */
-		size = nrxd * sizeof (dmadd_t);
-		if (!ISALIGNED(DMA_CONSISTENT_ALIGN, DMARINGALIGN))
-			size += DMARINGALIGN;
-		if ((va = DMA_ALLOC_CONSISTENT(osh, size, &di->rxdpa)) == NULL)
+		size = nrxd * sizeof(void *);
+		if ((di->rxp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of rx memory, malloced %d bytes\n",
+			           di->name, MALLOCED(osh)));
 			goto fail;
-		di->rxd = (dmadd_t*) ROUNDUP((uintptr)va, DMARINGALIGN);
-		di->rxdalign = (uint)((int8*)di->rxd - (int8*)va);
-		di->rxdpa += di->rxdalign;
-		di->rxdalloc = size;
-		ASSERT(ISALIGNED((uintptr)di->rxd, DMARINGALIGN));
-		ASSERT(DMA_ADDRESSABLE(di->rxdpa));
+		}
+		bzero((char *)di->rxp, size);
 	}
 
-	/* save tunables */
-	di->ntxd = ntxd;
-	di->nrxd = nrxd;
-	di->rxbufsize = rxbufsize;
-	di->nrxpost = nrxpost;
-	di->rxoffset = rxoffset;
-	di->ddoffset = ddoffset;
-	di->dataoffset = dataoffset;
+	/* allocate transmit descriptor ring, only need ntxd descriptors but it must be aligned */
+	if (ntxd) {
+		if (!_dma_alloc(di, DMA_TX))
+			goto fail;
+	}
+
+	/* allocate receive descriptor ring, only need nrxd descriptors but it must be aligned */
+	if (nrxd) {
+		if (!_dma_alloc(di, DMA_RX))
+			goto fail;
+	}
+
+	if ((di->ddoffsetlow == SB_PCI_DMA) && (di->txdpa > SB_PCI_DMA_SZ) && !di->addrext) {
+		DMA_ERROR(("%s: dma_attach: txdpa 0x%lx: addrext not supported\n",
+		           di->name, di->txdpa));
+		goto fail;
+	}
+	if ((di->ddoffsetlow == SB_PCI_DMA) && (di->rxdpa > SB_PCI_DMA_SZ) && !di->addrext) {
+		DMA_ERROR(("%s: dma_attach: rxdpa 0x%lx: addrext not supported\n",
+		           di->name, di->rxdpa));
+		goto fail;
+	}
+
+	DMA_TRACE(("ddoffsetlow 0x%x ddoffsethigh 0x%x dataoffsetlow 0x%x dataoffsethigh "
+	           "0x%x addrext %d\n", di->ddoffsetlow, di->ddoffsethigh, di->dataoffsetlow,
+	           di->dataoffsethigh, di->addrext));
+
+	/* allocate tx packet pointer vector and DMA mapping vectors */
+	if (ntxd) {
+
+		size = ntxd * sizeof(osldma_t **);
+		if ((di->txp_dmah = (osldma_t **)MALLOC(osh, size)) == NULL)
+			goto fail;
+		bzero((char*)di->txp_dmah, size);
+	}else
+		di->txp_dmah = NULL;
+
+	/* allocate rx packet pointer vector and DMA mapping vectors */
+	if (nrxd) {
+
+		size = nrxd * sizeof(osldma_t **);
+		if ((di->rxp_dmah = (osldma_t **)MALLOC(osh, size)) == NULL)
+			goto fail;
+		bzero((char*)di->rxp_dmah, size);
 
-	return ((void*)di);
+	}else
+		di->rxp_dmah = NULL;
+
+	/* initialize opsvec of function pointers */
+	di->hnddma.di_fn = DMA64_ENAB(di) ? dma64proc : dma32proc;
+
+	return ((hnddma_t *)di);
 
 fail:
-	dma_detach((void*)di);
+	_dma_detach(di);
 	return (NULL);
 }
 
-/* may be called with core in reset */
-void
-dma_detach(dma_info_t *di)
+/* init the tx or rx descriptor */
+static INLINE void
+dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, ulong pa, uint outidx, uint32 *flags,
+             uint32 bufcount)
+{
+	/* dma32 uses 32 bits control to fit both flags and bufcounter */
+	*flags = *flags | (bufcount & CTRL_BC_MASK);
+
+	if ((di->dataoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+		W_SM(&ddring[outidx].addr, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	} else {
+		/* address extension */
+		uint32 ae;
+		ASSERT(di->addrext);
+		ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		pa &= ~PCI32ADDR_HIGH;
+
+		*flags |= (ae << CTRL_AE_SHIFT);
+		W_SM(&ddring[outidx].addr, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	}
+}
+
+static INLINE void
+dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, ulong pa, uint outidx, uint32 *flags,
+             uint32 bufcount)
+{
+	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
+
+	/* PCI bus with big(>1G) physical address, use address extension */
+	if ((di->dataoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+		W_SM(&ddring[outidx].addrlow, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh, BUS_SWAP32(0 + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	} else {
+		/* address extension */
+		uint32 ae;
+		ASSERT(di->addrext);
+
+		ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		pa &= ~PCI32ADDR_HIGH;
+
+		ctrl2 |= (ae << D64_CTRL2_AE_SHIFT) & D64_CTRL2_AE;
+		W_SM(&ddring[outidx].addrlow, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh, BUS_SWAP32(0 + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	}
+}
+
+static bool
+_dma32_addrext(osl_t *osh, dma32regs_t *dma32regs)
+{
+	uint32 w;
+
+	OR_REG(osh, &dma32regs->control, XC_AE);
+	w = R_REG(osh, &dma32regs->control);
+	AND_REG(osh, &dma32regs->control, ~XC_AE);
+	return ((w & XC_AE) == XC_AE);
+}
+
+static bool
+_dma_alloc(dma_info_t *di, uint direction)
+{
+	if (DMA64_ENAB(di)) {
+		return dma64_alloc(di, direction);
+	} else {
+		return dma32_alloc(di, direction);
+	}
+}
+
+/* !! may be called with core in reset */
+static void
+_dma_detach(dma_info_t *di)
 {
 	if (di == NULL)
 		return;
@@ -204,331 +569,1089 @@
 	ASSERT(di->rxin == di->rxout);
 
 	/* free dma descriptor rings */
-	if (di->txd)
-		DMA_FREE_CONSISTENT(di->osh, ((int8*)di->txd - di->txdalign),
-			di->txdalloc, (di->txdpa - di->txdalign));
-	if (di->rxd)
-		DMA_FREE_CONSISTENT(di->osh, ((int8*)di->rxd - di->rxdalign),
-			di->rxdalloc, (di->rxdpa - di->rxdalign));
+	if (DMA64_ENAB(di)) {
+		if (di->txd64)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->txd64 - di->txdalign),
+			                    di->txdalloc, (di->txdpa - di->txdalign), &di->tx_dmah);
+		if (di->rxd64)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->rxd64 - di->rxdalign),
+			                    di->rxdalloc, (di->rxdpa - di->rxdalign), &di->rx_dmah);
+	} else {
+		if (di->txd32)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->txd32 - di->txdalign),
+			                    di->txdalloc, (di->txdpa - di->txdalign), &di->tx_dmah);
+		if (di->rxd32)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->rxd32 - di->rxdalign),
+			                    di->rxdalloc, (di->rxdpa - di->rxdalign), &di->rx_dmah);
+	}
 
 	/* free packet pointer vectors */
 	if (di->txp)
-		MFREE(di->osh, (void*)di->txp, (di->ntxd * sizeof (void*)));
+		MFREE(di->osh, (void *)di->txp, (di->ntxd * sizeof(void *)));
 	if (di->rxp)
-		MFREE(di->osh, (void*)di->rxp, (di->nrxd * sizeof (void*)));
+		MFREE(di->osh, (void *)di->rxp, (di->nrxd * sizeof(void *)));
+
+	/* free tx packet DMA handles */
+	if (di->txp_dmah)
+		MFREE(di->osh, (void *)di->txp_dmah, di->ntxd * sizeof(osldma_t **));
+
+	/* free rx packet DMA handles */
+	if (di->rxp_dmah)
+		MFREE(di->osh, (void *)di->rxp_dmah, di->nrxd * sizeof(osldma_t **));
 
 	/* free our private info structure */
-	MFREE(di->osh, (void*)di, sizeof (dma_info_t));
+	MFREE(di->osh, (void *)di, sizeof(dma_info_t));
+
 }
 
+/* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
+static bool
+_dma_isaddrext(dma_info_t *di)
+{
+	if (DMA64_ENAB(di)) {
+		/* DMA64 supports full 32 bits or 64 bits. AE is always valid */
 
-void
-dma_txreset(dma_info_t *di)
+		/* not all tx or rx channel are available */
+		if (di->d64txregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64txregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 tx doesn't have AE set\n",
+					di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		} else if (di->d64rxregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64rxregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 rx doesn't have AE set\n",
+					di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		}
+		return FALSE;
+	} else if (di->d32txregs)
+		return (_dma32_addrext(di->osh, di->d32txregs));
+	else if (di->d32rxregs)
+		return (_dma32_addrext(di->osh, di->d32rxregs));
+	return FALSE;
+}
+
+/* initialize descriptor table base address */
+static void
+_dma_ddtable_init(dma_info_t *di, uint direction, ulong pa)
+{
+	if (DMA64_ENAB(di)) {
+
+		if ((di->ddoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh, di->ddoffsethigh);
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh, di->ddoffsethigh);
+			}
+		} else {
+			/* DMA64 32bits address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+			pa &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh, di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64txregs->control, D64_XC_AE,
+					(ae << D64_XC_AE_SHIFT));
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh, di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64rxregs->control, D64_RC_AE,
+					(ae << D64_RC_AE_SHIFT));
+			}
+		}
+
+	} else {
+		if ((di->ddoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX)
+				W_REG(di->osh, &di->d32txregs->addr, (pa + di->ddoffsetlow));
+			else
+				W_REG(di->osh, &di->d32rxregs->addr, (pa + di->ddoffsetlow));
+		} else {
+			/* dma32 address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+			pa &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d32txregs->addr, (pa + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32txregs->control, XC_AE, ae <<XC_AE_SHIFT);
+			} else {
+				W_REG(di->osh, &di->d32rxregs->addr, (pa + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32rxregs->control, RC_AE, ae <<RC_AE_SHIFT);
+			}
+		}
+	}
+}
+
+static void
+_dma_fifoloopbackenable(dma_info_t *di)
 {
-	uint32 status;
+	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
+	if (DMA64_ENAB(di))
+		OR_REG(di->osh, &di->d64txregs->control, D64_XC_LE);
+	else
+		OR_REG(di->osh, &di->d32txregs->control, XC_LE);
+}
 
-	DMA_TRACE(("%s: dma_txreset\n", di->name));
+static void
+_dma_rxinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxinit\n", di->name));
 
-	/* suspend tx DMA first */
-	W_REG(&di->regs->xmtcontrol, XC_SE);
-	SPINWAIT((status = (R_REG(&di->regs->xmtstatus) & XS_XS_MASK)) != XS_XS_DISABLED &&
-		 status != XS_XS_IDLE &&
-		 status != XS_XS_STOPPED,
-		 10000);
+	if (di->nrxd == 0)
+		return;
 
-	W_REG(&di->regs->xmtcontrol, 0);
-	SPINWAIT((status = (R_REG(&di->regs->xmtstatus) & XS_XS_MASK)) != XS_XS_DISABLED,
-		 10000);
+	di->rxin = di->rxout = 0;
 
-	if (status != XS_XS_DISABLED) {
-		DMA_ERROR(("%s: dma_txreset: dma cannot be stopped\n", di->name));
+	/* clear rx descriptor ring */
+	if (DMA64_ENAB(di))
+		BZERO_SM((void *)(uintptr)di->rxd64, (di->nrxd * sizeof(dma64dd_t)));
+	else
+		BZERO_SM((void *)(uintptr)di->rxd32, (di->nrxd * sizeof(dma32dd_t)));
+
+	_dma_rxenable(di);
+	_dma_ddtable_init(di, DMA_RX, di->rxdpa);
+}
+
+static void
+_dma_rxenable(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxenable\n", di->name));
+
+	if (DMA64_ENAB(di))
+		W_REG(di->osh, &di->d64rxregs->control,
+		      ((di->rxoffset << D64_RC_RO_SHIFT) | D64_RC_RE));
+	else
+		W_REG(di->osh, &di->d32rxregs->control, ((di->rxoffset << RC_RO_SHIFT) | RC_RE));
+}
+
+/* !! rx entry routine, returns a pointer to the next frame received,
+ * or NULL if there are no more
+ */
+static void *
+_dma_rx(dma_info_t *di)
+{
+	void *p;
+	uint len;
+	int skiplen = 0;
+
+	while ((p = _dma_getnextrxp(di, FALSE))) {
+		/* skip giant packets which span multiple rx descriptors */
+		if (skiplen > 0) {
+			skiplen -= di->rxbufsize;
+			if (skiplen < 0)
+				skiplen = 0;
+			PKTFREE(di->osh, p, FALSE);
+			continue;
 	}
 
-	/* wait for the last transaction to complete */
-	OSL_DELAY(300);
+		len = ltoh16(*(uint16*)(PKTDATA(di->osh, p)));
+		DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
+
+		/* bad frame length check */
+		if (len > (di->rxbufsize - di->rxoffset)) {
+			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n", di->name, len));
+			if (len > 0)
+				skiplen = len - (di->rxbufsize - di->rxoffset);
+			PKTFREE(di->osh, p, FALSE);
+			di->hnddma.rxgiants++;
+			continue;
+		}
+
+		/* set actual length */
+		PKTSETLEN(di->osh, p, (di->rxoffset + len));
+
+		break;
+	}
+
+	return (p);
 }
 
-void
-dma_rxreset(dma_info_t *di)
+/* post receive buffers */
+static void
+_dma_rxfill(dma_info_t *di)
 {
-	uint32 status;
+	void *p;
+	uint rxin, rxout;
+	uint32 flags = 0;
+	uint n;
+	uint i;
+	uint32 pa;
+	uint extra_offset = 0;
 
-	DMA_TRACE(("%s: dma_rxreset\n", di->name));
+	/*
+	 * Determine how many receive buffers we're lacking
+	 * from the full complement, allocate, initialize,
+	 * and post them, then update the chip rx lastdscr.
+	 */
 
-	W_REG(&di->regs->rcvcontrol, 0);
-	SPINWAIT((status = (R_REG(&di->regs->rcvstatus) & RS_RS_MASK)) != RS_RS_DISABLED,
-		 10000);
+	rxin = di->rxin;
+	rxout = di->rxout;
+
+	n = di->nrxpost - NRXDACTIVE(rxin, rxout);
+
+	DMA_TRACE(("%s: dma_rxfill: post %d\n", di->name, n));
+
+	if (di->rxbufsize > BCMEXTRAHDROOM)
+		extra_offset = BCMEXTRAHDROOM;
+
+	for (i = 0; i < n; i++) {
+		/* the di->rxbufsize doesn't include the extra headroom, we need to add it to the
+		   size to be allocated
+		*/
+		if ((p = PKTGET(di->osh, di->rxbufsize + extra_offset,
+		                FALSE)) == NULL) {
+			DMA_ERROR(("%s: dma_rxfill: out of rxbufs\n", di->name));
+			di->hnddma.rxnobuf++;
+			break;
+		}
+		/* reserve an extra headroom, if applicable */
+		if (extra_offset)
+			PKTPULL(di->osh, p, extra_offset);
+
+		/* Do a cached write instead of uncached write since DMA_MAP
+		 * will flush the cache.
+		 */
+		*(uint32*)(PKTDATA(di->osh, p)) = 0;
+
+		pa = (uint32) DMA_MAP(di->osh, PKTDATA(di->osh, p),
+		                      di->rxbufsize, DMA_RX, p,
+		                      &di->rxp_dmah[rxout]);
+
+		ASSERT(ISALIGNED(pa, 4));
+
+		/* save the free packet pointer */
+		ASSERT(di->rxp[rxout] == NULL);
+		di->rxp[rxout] = p;
+
+		/* reset flags for each descriptor */
+		flags = 0;
+		if (DMA64_ENAB(di)) {
+			if (rxout == (di->nrxd - 1))
+				flags = D64_CTRL1_EOT;
+
+			dma64_dd_upd(di, di->rxd64, pa, rxout, &flags, di->rxbufsize);
+		} else {
+			if (rxout == (di->nrxd - 1))
+				flags = CTRL_EOT;
+
+			dma32_dd_upd(di, di->rxd32, pa, rxout, &flags, di->rxbufsize);
+		}
+		rxout = NEXTRXD(rxout);
+	}
+
+	di->rxout = rxout;
 
-	if (status != RS_RS_DISABLED) {
-		DMA_ERROR(("%s: dma_rxreset: dma cannot be stopped\n", di->name));
+	/* update the chip lastdscr pointer */
+	if (DMA64_ENAB(di)) {
+		W_REG(di->osh, &di->d64rxregs->ptr, I2B(rxout, dma64dd_t));
+	} else {
+		W_REG(di->osh, &di->d32rxregs->ptr, I2B(rxout, dma32dd_t));
 	}
 }
 
-void
-dma_txinit(dma_info_t *di)
+/* like getnexttxp but no reclaim */
+static void *
+_dma_peeknexttxp(dma_info_t *di)
 {
-	DMA_TRACE(("%s: dma_txinit\n", di->name));
+	uint end, i;
 
-	di->txin = di->txout = 0;
-	di->txavail = di->ntxd - 1;
+	if (di->ntxd == 0)
+		return (NULL);
 
-	/* clear tx descriptor ring */
-	BZERO_SM((void*)di->txd, (di->ntxd * sizeof (dmadd_t)));
+	if (DMA64_ENAB(di)) {
+		end = B2I(R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_CD_MASK, dma64dd_t);
+	} else {
+		end = B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK, dma32dd_t);
+	}
+
+	for (i = di->txin; i != end; i = NEXTTXD(i))
+		if (di->txp[i])
+			return (di->txp[i]);
 
-	W_REG(&di->regs->xmtcontrol, XC_XE);
-	W_REG(&di->regs->xmtaddr, (di->txdpa + di->ddoffset));
+	return (NULL);
 }
 
-bool
-dma_txenabled(dma_info_t *di)
+static void
+_dma_rxreclaim(dma_info_t *di)
 {
-	uint32 xc;
+	void *p;
 
-	/* If the chip is dead, it is not enabled :-) */
-	xc = R_REG(&di->regs->xmtcontrol);
-	return ((xc != 0xffffffff) && (xc & XC_XE));
+	/* "unused local" warning suppression for OSLs that
+	 * define PKTFREE() without using the di->osh arg
+	 */
+	di = di;
+
+	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
+
+	while ((p = _dma_getnextrxp(di, TRUE)))
+		PKTFREE(di->osh, p, FALSE);
+}
+
+static void *
+_dma_getnextrxp(dma_info_t *di, bool forceall)
+{
+	if (di->nrxd == 0)
+		return (NULL);
+
+	if (DMA64_ENAB(di)) {
+		return dma64_getnextrxp(di, forceall);
+	} else {
+		return dma32_getnextrxp(di, forceall);
+	}
+}
+
+static void
+_dma_txblock(dma_info_t *di)
+{
+	di->hnddma.txavail = 0;
 }
 
-void
-dma_txsuspend(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
-	OR_REG(&di->regs->xmtcontrol, XC_SE);
+static void
+_dma_txunblock(dma_info_t *di)
+{
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+}
+
+static uint
+_dma_txactive(dma_info_t *di)
+{
+	return (NTXDACTIVE(di->txin, di->txout));
+}
+
+static void
+_dma_counterreset(dma_info_t *di)
+{
+	/* reset all software counter */
+	di->hnddma.rxgiants = 0;
+	di->hnddma.rxnobuf = 0;
+	di->hnddma.txnobuf = 0;
+}
+
+/* get the address of the var in order to change later */
+static uintptr
+_dma_getvar(dma_info_t *di, const char *name)
+{
+	if (!strcmp(name, "&txavail"))
+		return ((uintptr) &(di->hnddma.txavail));
+	else {
+		ASSERT(0);
+	}
+	return (0);
+}
+
+void
+dma_txpioloopback(osl_t *osh, dma32regs_t *regs)
+{
+	OR_REG(osh, &regs->control, XC_LE);
+}
+
+
+
+/* 32 bits DMA functions */
+static void
+dma32_txinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr)di->txd32, (di->ntxd * sizeof(dma32dd_t)));
+	W_REG(di->osh, &di->d32txregs->control, XC_XE);
+	_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool
+dma32_txenabled(dma_info_t *di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d32txregs->control);
+	return ((xc != 0xffffffff) && (xc & XC_XE));
+}
+
+static void
+dma32_txsuspend(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d32txregs->control, XC_SE);
+}
+
+static void
+dma32_txresume(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d32txregs->control, ~XC_SE);
+}
+
+static bool
+dma32_txsuspended(dma_info_t *di)
+{
+	return (di->ntxd == 0) || ((R_REG(di->osh, &di->d32txregs->control) & XC_SE) == XC_SE);
+}
+
+static void
+dma32_txreclaim(dma_info_t *di, bool forceall)
+{
+	void *p;
+
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
+
+	while ((p = dma32_getnexttxp(di, forceall)))
+		PKTFREE(di->osh, p, TRUE);
+}
+
+static bool
+dma32_txstopped(dma_info_t *di)
+{
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) == XS_XS_STOPPED);
+}
+
+static bool
+dma32_rxstopped(dma_info_t *di)
+{
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_RS_MASK) == RS_RS_STOPPED);
+}
+
+static bool
+dma32_alloc(dma_info_t *di, uint direction)
+{
+	uint size;
+	uint ddlen;
+	void *va;
+
+	ddlen = sizeof(dma32dd_t);
+
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
+
+	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, D32RINGALIGN))
+		size += D32RINGALIGN;
+
+
+	if (direction == DMA_TX) {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->txdpa, &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(ntxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+
+		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr)va, D32RINGALIGN);
+		di->txdalign = (uint)((int8*)(uintptr)di->txd32 - (int8*)va);
+		di->txdpa += di->txdalign;
+		di->txdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->txd32, D32RINGALIGN));
+	} else {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->rxdpa, &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(nrxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr)va, D32RINGALIGN);
+		di->rxdalign = (uint)((int8*)(uintptr)di->rxd32 - (int8*)va);
+		di->rxdpa += di->rxdalign;
+		di->rxdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->rxd32, D32RINGALIGN));
+	}
+
+	return TRUE;
+}
+
+static bool
+dma32_txreset(dma_info_t *di)
+{
+	uint32 status;
+
+	if (di->ntxd == 0)
+		return TRUE;
+
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d32txregs->control, XC_SE);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK))
+		 != XS_XS_DISABLED) &&
+		 (status != XS_XS_IDLE) &&
+		 (status != XS_XS_STOPPED),
+		 (10000));
+
+	W_REG(di->osh, &di->d32txregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+	         &di->d32txregs->status) & XS_XS_MASK)) != XS_XS_DISABLED),
+	         10000);
+
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
+
+	return (status == XS_XS_DISABLED);
+}
+
+static bool
+dma32_rxidle(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK) ==
+	        R_REG(di->osh, &di->d32rxregs->ptr));
+}
+
+static bool
+dma32_rxreset(dma_info_t *di)
+{
+	uint32 status;
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	W_REG(di->osh, &di->d32rxregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+	         &di->d32rxregs->status) & RS_RS_MASK)) != RS_RS_DISABLED),
+	         10000);
+
+	return (status == RS_RS_DISABLED);
+}
+
+static bool
+dma32_rxenabled(dma_info_t *di)
+{
+	uint32 rc;
+
+	rc = R_REG(di->osh, &di->d32rxregs->control);
+	return ((rc != 0xffffffff) && (rc & RC_RE));
+}
+
+static bool
+dma32_txsuspendedidle(dma_info_t *di)
+{
+	if (di->ntxd == 0)
+		return TRUE;
+
+	if (!(R_REG(di->osh, &di->d32txregs->control) & XC_SE))
+		return 0;
+
+	if ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) != XS_XS_IDLE)
+		return 0;
+
+	OSL_DELAY(2);
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) == XS_XS_IDLE);
+}
+
+/* !! tx entry routine
+ * supports full 32bit dma engine buffer addressing so
+ * dma buffers can cross 4 Kbyte page boundaries.
+ */
+static int
+dma32_txfast(dma_info_t *di, void *p0, bool commit)
+{
+	void *p, *next;
+	uchar *data;
+	uint len;
+	uint txout;
+	uint32 flags = 0;
+	uint32 pa;
+
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
+
+	txout = di->txout;
+
+	/*
+	 * Walk the chain of packet buffers
+	 * allocating and initializing transmit descriptor entries.
+	 */
+	for (p = p0; p; p = next) {
+		data = PKTDATA(di->osh, p);
+		len = PKTLEN(di->osh, p);
+		next = PKTNEXT(di->osh, p);
+
+		/* return nonzero if out of tx descriptors */
+		if (NEXTTXD(txout) == di->txin)
+			goto outoftxd;
+
+		if (len == 0)
+			continue;
+
+		/* get physical address of buffer start */
+		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p, &di->txp_dmah[txout]);
+
+		flags = 0;
+		if (p == p0)
+			flags |= CTRL_SOF;
+		if (next == NULL)
+			flags |= (CTRL_IOC | CTRL_EOF);
+		if (txout == (di->ntxd - 1))
+			flags |= CTRL_EOT;
+
+		dma32_dd_upd(di, di->txd32, pa, txout, &flags, len);
+		ASSERT(di->txp[txout] == NULL);
+
+		txout = NEXTTXD(txout);
+	}
+
+	/* if last txd eof not set, fix it */
+	if (!(flags & CTRL_EOF))
+		W_SM(&di->txd32[PREVTXD(txout)].ctrl, BUS_SWAP32(flags | CTRL_IOC | CTRL_EOF));
+
+	/* save the packet */
+	di->txp[PREVTXD(txout)] = p0;
+
+	/* bump the tx descriptor index */
+	di->txout = txout;
+
+	/* kick the chip */
+	if (commit)
+		W_REG(di->osh, &di->d32txregs->ptr, I2B(txout, dma32dd_t));
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (0);
+
+outoftxd:
+	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
+	di->hnddma.txnobuf++;
+	return (-1);
+}
+
+/*
+ * Reclaim next completed txd (txds if using chained buffers) and
+ * return associated packet.
+ * If 'force' is true, reclaim txd(s) and return associated packet
+ * regardless of the value of the hardware "curr" pointer.
+ */
+static void *
+dma32_getnexttxp(dma_info_t *di, bool forceall)
+{
+	uint start, end, i;
+	void *txp;
+
+	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name, forceall ? "all" : ""));
+
+	if (di->ntxd == 0)
+		return (NULL);
+
+	txp = NULL;
+
+	start = di->txin;
+	if (forceall)
+		end = di->txout;
+	else
+		end = B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK, dma32dd_t);
+
+	if ((start == 0) && (end > di->txout))
+		goto bogus;
+
+	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
+		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd32[i].addr)) - di->dataoffsetlow),
+		          (BUS_SWAP32(R_SM(&di->txd32[i].ctrl)) & CTRL_BC_MASK),
+		          DMA_TX, di->txp[i], &di->txp_dmah[i]);
+
+		W_SM(&di->txd32[i].addr, 0xdeadbeef);
+		txp = di->txp[i];
+		di->txp[i] = NULL;
+	}
+
+	di->txin = i;
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (txp);
+
+bogus:
+/*
+	DMA_ERROR(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n",
+		start, end, di->txout, forceall));
+*/
+	return (NULL);
+}
+
+static void *
+dma32_getnextrxp(dma_info_t *di, bool forceall)
+{
+	uint i;
+	void *rxp;
+
+	/* if forcing, dma engine must be disabled */
+	ASSERT(!forceall || !dma32_rxenabled(di));
+
+	i = di->rxin;
+
+	/* return if no packets posted */
+	if (i == di->rxout)
+		return (NULL);
+
+	/* ignore curr if forceall */
+	if (!forceall && (i == B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK, dma32dd_t)))
+		return (NULL);
+
+	/* get the packet pointer that corresponds to the rx descriptor */
+	rxp = di->rxp[i];
+	ASSERT(rxp);
+	di->rxp[i] = NULL;
+
+	/* clear this packet from the descriptor ring */
+	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd32[i].addr)) - di->dataoffsetlow),
+	          di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd32[i].addr, 0xdeadbeef);
+
+	di->rxin = NEXTRXD(i);
+
+	return (rxp);
+}
+
+/*
+ * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
+ */
+static void
+dma32_txrotate(dma_info_t *di)
+{
+	uint ad;
+	uint nactive;
+	uint rot;
+	uint old, new;
+	uint32 w;
+	uint first, last;
+
+	ASSERT(dma32_txsuspendedidle(di));
+
+	nactive = _dma_txactive(di);
+	ad = B2I(((R_REG(di->osh, &di->d32txregs->status) & XS_AD_MASK) >> XS_AD_SHIFT), dma32dd_t);
+	rot = TXD(ad - di->txin);
+
+	ASSERT(rot < di->ntxd);
+
+	/* full-ring case is a lot harder - don't worry about this */
+	if (rot >= (di->ntxd - nactive)) {
+		DMA_ERROR(("%s: dma_txrotate: ring full - punt\n", di->name));
+		return;
+	}
+
+	first = di->txin;
+	last = PREVTXD(di->txout);
+
+	/* move entries starting at last and moving backwards to first */
+	for (old = last; old != PREVTXD(first); old = PREVTXD(old)) {
+		new = TXD(old + rot);
+
+		/*
+		 * Move the tx dma descriptor.
+		 * EOT is set only in the last entry in the ring.
+		 */
+		w = BUS_SWAP32(R_SM(&di->txd32[old].ctrl)) & ~CTRL_EOT;
+		if (new == (di->ntxd - 1))
+			w |= CTRL_EOT;
+		W_SM(&di->txd32[new].ctrl, BUS_SWAP32(w));
+		W_SM(&di->txd32[new].addr, R_SM(&di->txd32[old].addr));
+
+		/* zap the old tx dma descriptor address field */
+		W_SM(&di->txd32[old].addr, BUS_SWAP32(0xdeadbeef));
+
+		/* move the corresponding txp[] entry */
+		ASSERT(di->txp[new] == NULL);
+		di->txp[new] = di->txp[old];
+		di->txp[old] = NULL;
+	}
+
+	/* update txin and txout */
+	di->txin = ad;
+	di->txout = TXD(di->txout + rot);
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	/* kick the chip */
+	W_REG(di->osh, &di->d32txregs->ptr, I2B(di->txout, dma32dd_t));
+}
+
+/* 64 bits DMA functions */
+
+#ifdef BCMDMA64
+static void
+dma64_txinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr)di->txd64, (di->ntxd * sizeof(dma64dd_t)));
+	W_REG(di->osh, &di->d64txregs->control, D64_XC_XE);
+	_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool
+dma64_txenabled(dma_info_t *di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d64txregs->control);
+	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
+}
+
+static void
+dma64_txsuspend(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+}
+
+static void
+dma64_txresume(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d64txregs->control, ~D64_XC_SE);
 }
 
-void
-dma_txresume(dma_info_t *di)
+static bool
+dma64_txsuspended(dma_info_t *di)
 {
-	DMA_TRACE(("%s: dma_txresume\n", di->name));
-	AND_REG(&di->regs->xmtcontrol, ~XC_SE);
+	return (di->ntxd == 0) || ((R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE)
+	        == D64_XC_SE);
 }
 
-bool
-dma_txsuspended(dma_info_t *di)
+static void
+dma64_txreclaim(dma_info_t *di, bool forceall)
 {
-	if (!(R_REG(&di->regs->xmtcontrol) & XC_SE))
-		return 0;
+	void *p;
 	
-	if ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) != XS_XS_IDLE)
-		return 0;
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
 
-	OSL_DELAY(2);
-	return ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) == XS_XS_IDLE);
+	while ((p = dma64_getnexttxp(di, forceall)))
+		PKTFREE(di->osh, p, TRUE);
 }
 
-bool
-dma_txstopped(dma_info_t *di)
+static bool
+dma64_txstopped(dma_info_t *di)
 {
-	return ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) == XS_XS_STOPPED);
+	return ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) == D64_XS0_XS_STOPPED);
 }
 
-bool
-dma_rxstopped(dma_info_t *di)
+static bool
+dma64_rxstopped(dma_info_t *di)
 {
-	return ((R_REG(&di->regs->rcvstatus) & RS_RS_MASK) == RS_RS_STOPPED);
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK) == D64_RS0_RS_STOPPED);
 }
 
-void
-dma_fifoloopbackenable(dma_info_t *di)
+static bool
+dma64_alloc(dma_info_t *di, uint direction)
 {
-	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
-	OR_REG(&di->regs->xmtcontrol, XC_LE);
-}
+	uint size;
+	uint ddlen;
+	uint32 alignbytes;
+	void *va;
 
-void
-dma_rxinit(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_rxinit\n", di->name));
+	ddlen = sizeof(dma64dd_t);
 
-	di->rxin = di->rxout = 0;
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
 
-	/* clear rx descriptor ring */
-	BZERO_SM((void*)di->rxd, (di->nrxd * sizeof (dmadd_t)));
+	alignbytes = di->dma64align;
 
-	dma_rxenable(di);
-	W_REG(&di->regs->rcvaddr, (di->rxdpa + di->ddoffset));
-}
+	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, alignbytes))
+		size += alignbytes;
 
-void
-dma_rxenable(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_rxenable\n", di->name));
-	W_REG(&di->regs->rcvcontrol, ((di->rxoffset << RC_RO_SHIFT) | RC_RE));
-}
+	if (direction == DMA_TX) {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->txdpa, &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(ntxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
 
-bool
-dma_rxenabled(dma_info_t *di)
-{
-	uint32 rc;
+		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr)va, alignbytes);
+		di->txdalign = (uint)((int8*)(uintptr)di->txd64 - (int8*)va);
+		di->txdpa += di->txdalign;
+		di->txdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->txd64, alignbytes));
+	} else {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->rxdpa, &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(nrxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr)va, alignbytes);
+		di->rxdalign = (uint)((int8*)(uintptr)di->rxd64 - (int8*)va);
+		di->rxdpa += di->rxdalign;
+		di->rxdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->rxd64, alignbytes));
+	}
 
-	rc = R_REG(&di->regs->rcvcontrol);
-	return ((rc != 0xffffffff) && (rc & RC_RE));
+	return TRUE;
 }
 
-/*
- * The BCM47XX family supports full 32bit dma engine buffer addressing so
- * dma buffers can cross 4 Kbyte page boundaries.
- */
-int
-dma_txfast(dma_info_t *di, void *p0, uint32 coreflags)
+static bool
+dma64_txreset(dma_info_t *di)
 {
-	void *p, *next;
-	uchar *data;
-	uint len;
-	uint txout;
-	uint32 ctrl;
-	uint32 pa;
+	uint32 status;
 
-	DMA_TRACE(("%s: dma_txfast\n", di->name));
+	if (di->ntxd == 0)
+		return TRUE;
 
-	txout = di->txout;
-	ctrl = 0;
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK)) !=
+	          D64_XS0_XS_DISABLED) &&
+	         (status != D64_XS0_XS_IDLE) &&
+	         (status != D64_XS0_XS_STOPPED),
+	         10000);
 
-	/*
-	 * Walk the chain of packet buffers
-	 * allocating and initializing transmit descriptor entries.
-	 */
-	for (p = p0; p; p = next) {
-		data = PKTDATA(di->drv, p);
-		len = PKTLEN(di->drv, p);
-		next = PKTNEXT(di->drv, p);
+	W_REG(di->osh, &di->d64txregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK)) !=
+	          D64_XS0_XS_DISABLED),
+	         10000);
 
-		/* return nonzero if out of tx descriptors */
-		if (NEXTTXD(txout) == di->txin)
-			goto outoftxd;
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
 
-		if (len == 0)
-			continue;
+	return (status == D64_XS0_XS_DISABLED);
+}
 
-		/* get physical address of buffer start */
-		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p);
-		ASSERT(DMA_ADDRESSABLE(pa));
+static bool
+dma64_rxidle(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
-		/* build the descriptor control value */
-		ctrl = len & CTRL_BC_MASK;
+	if (di->nrxd == 0)
+		return TRUE;
 
-		ctrl |= coreflags;
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) ==
+		R_REG(di->osh, &di->d64rxregs->ptr));
+}
 		
-		if (p == p0)
-			ctrl |= CTRL_SOF;
-		if (next == NULL)
-			ctrl |= (CTRL_IOC | CTRL_EOF);
-		if (txout == (di->ntxd - 1))
-			ctrl |= CTRL_EOT;
+static bool
+dma64_rxreset(dma_info_t *di)
+{
+	uint32 status;
 
-		/* init the tx descriptor */
-		W_SM(&di->txd[txout].ctrl, BUS_SWAP32(ctrl));
-		W_SM(&di->txd[txout].addr, BUS_SWAP32(pa + di->dataoffset));
+	if (di->nrxd == 0)
+		return TRUE;
 
-		ASSERT(di->txp[txout] == NULL);
+	W_REG(di->osh, &di->d64rxregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK)) !=
+	          D64_RS0_RS_DISABLED),
+	         10000);
 
-		txout = NEXTTXD(txout);
-	}
+	return (status == D64_RS0_RS_DISABLED);
+}
 
-	/* if last txd eof not set, fix it */
-	if (!(ctrl & CTRL_EOF))
-		W_SM(&di->txd[PREVTXD(txout)].ctrl, BUS_SWAP32(ctrl | CTRL_IOC | CTRL_EOF));
+static bool
+dma64_rxenabled(dma_info_t *di)
+{
+	uint32 rc;
 
-	/* save the packet */
-	di->txp[PREVTXD(txout)] = p0;
+	rc = R_REG(di->osh, &di->d64rxregs->control);
+	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
+}
 
-	/* bump the tx descriptor index */
-	di->txout = txout;
+static bool
+dma64_txsuspendedidle(dma_info_t *di)
+{
 
-	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(txout));
+	if (di->ntxd == 0)
+		return TRUE;
 
-	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	if (!(R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE))
+		return 0;
 
-	return (0);
+	if ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) == D64_XS0_XS_IDLE)
+		return 1;
 
-outoftxd:
-	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
-	PKTFREE(di->drv, p0, TRUE);
-	di->txavail = 0;
-	di->hnddma.txnobuf++;
-	return (-1);
+	return 0;
 }
 
-#define	PAGESZ		4096
-#define	PAGEBASE(x)	((uintptr)(x) & ~4095)
 
-/*
- * Just like above except go through the extra effort of splitting
- * buffers that cross 4Kbyte boundaries into multiple tx descriptors.
- */
-int
-dma_tx(dma_info_t *di, void *p0, uint32 coreflags)
+/* !! tx entry routine */
+static int
+dma64_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
 	uchar *data;
-	uint plen, len;
-	uchar *page, *start, *end;
+	uint len;
 	uint txout;
-	uint32 ctrl;
+	uint32 flags = 0;
 	uint32 pa;
 
-	DMA_TRACE(("%s: dma_tx\n", di->name));
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
 
 	txout = di->txout;
-	ctrl = 0;
 
 	/*
 	 * Walk the chain of packet buffers
-	 * splitting those that cross 4 Kbyte boundaries
 	 * allocating and initializing transmit descriptor entries.
 	 */
 	for (p = p0; p; p = next) {
-		data = PKTDATA(di->drv, p);
-		plen = PKTLEN(di->drv, p);
-		next = PKTNEXT(di->drv, p);
-
-		if (plen == 0)
-			continue;
-
-		for (page = (uchar*)PAGEBASE(data);
-			page <= (uchar*)PAGEBASE(data + plen - 1);
-			page += PAGESZ) {
+		data = PKTDATA(di->osh, p);
+		len = PKTLEN(di->osh, p);
+		next = PKTNEXT(di->osh, p);
 
 			/* return nonzero if out of tx descriptors */
 			if (NEXTTXD(txout) == di->txin)
 				goto outoftxd;
 
-			start = (page == (uchar*)PAGEBASE(data))?  data: page;
-			end = (page == (uchar*)PAGEBASE(data + plen))?
-				(data + plen): (page + PAGESZ);
-			len = (uint)(end - start);
-
-			/* build the descriptor control value */
-			ctrl = len & CTRL_BC_MASK;
-
-			ctrl |= coreflags;
-
-			if ((p == p0) && (start == data))
-				ctrl |= CTRL_SOF;
-			if ((next == NULL) && (end == (data + plen)))
-				ctrl |= (CTRL_IOC | CTRL_EOF);
-			if (txout == (di->ntxd - 1))
-				ctrl |= CTRL_EOT;
+		if (len == 0)
+			continue;
 
 			/* get physical address of buffer start */
-			pa = (uint32) DMA_MAP(di->osh, start, len, DMA_TX, p);
-			ASSERT(DMA_ADDRESSABLE(pa));
+		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p, &di->txp_dmah[txout]);
 
-			/* init the tx descriptor */
-			W_SM(&di->txd[txout].ctrl, BUS_SWAP32(ctrl));
-			W_SM(&di->txd[txout].addr, BUS_SWAP32(pa + di->dataoffset));
+		flags = 0;
+		if (p == p0)
+			flags |= D64_CTRL1_SOF;
+		if (next == NULL)
+			flags |= (D64_CTRL1_IOC | D64_CTRL1_EOF);
+		if (txout == (di->ntxd - 1))
+			flags |= D64_CTRL1_EOT;
 
+		dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
 			ASSERT(di->txp[txout] == NULL);
 
 			txout = NEXTTXD(txout);
 		}
-	}
 
 	/* if last txd eof not set, fix it */
-	if (!(ctrl & CTRL_EOF))
-		W_SM(&di->txd[PREVTXD(txout)].ctrl, BUS_SWAP32(ctrl | CTRL_IOC | CTRL_EOF));
+	if (!(flags & D64_CTRL1_EOF))
+		W_SM(&di->txd64[PREVTXD(txout)].ctrl1,
+		     BUS_SWAP32(flags | D64_CTRL1_IOC | D64_CTRL1_EOF));
 
 	/* save the packet */
 	di->txp[PREVTXD(txout)] = p0;
@@ -537,162 +1660,58 @@
 	di->txout = txout;
 
 	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(txout));
+	if (commit)
+		W_REG(di->osh, &di->d64txregs->ptr, I2B(txout, dma64dd_t));
 
 	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	return (0);
 
 outoftxd:
-	DMA_ERROR(("%s: dma_tx: out of txds\n", di->name));
-	PKTFREE(di->drv, p0, TRUE);
-	di->txavail = 0;
+	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
 	return (-1);
 }
 
-/* returns a pointer to the next frame received, or NULL if there are no more */
-void*
-dma_rx(dma_info_t *di)
-{
-	void *p;
-	uint len;
-	int skiplen = 0;
-
-	while ((p = dma_getnextrxp(di, FALSE))) {
-		/* skip giant packets which span multiple rx descriptors */
-		if (skiplen > 0) {
-			skiplen -= di->rxbufsize;
-			if (skiplen < 0)
-				skiplen = 0;
-			PKTFREE(di->drv, p, FALSE);
-			continue;
-		}
-
-		len = ltoh16(*(uint16*)(PKTDATA(di->drv, p)));
-		DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
-
-		/* bad frame length check */
-		if (len > (di->rxbufsize - di->rxoffset)) {
-			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n", di->name, len));
-			if (len > 0)
-				skiplen = len - (di->rxbufsize - di->rxoffset);
-			PKTFREE(di->drv, p, FALSE);
-			di->hnddma.rxgiants++;
-			continue;
-		}
-
-		/* set actual length */
-		PKTSETLEN(di->drv, p, (di->rxoffset + len));
-
-		break;
-	}
-
-	return (p);
-}
-
-/* post receive buffers */
-void
-dma_rxfill(dma_info_t *di)
-{
-	void *p;
-	uint rxin, rxout;
-	uint ctrl;
-	uint n;
-	uint i;
-	uint32 pa;
-	uint rxbufsize;
-
-	/*
-	 * Determine how many receive buffers we're lacking
-	 * from the full complement, allocate, initialize,
-	 * and post them, then update the chip rx lastdscr.
-	 */
-
-	rxin = di->rxin;
-	rxout = di->rxout;
-	rxbufsize = di->rxbufsize;
-
-	n = di->nrxpost - NRXDACTIVE(rxin, rxout);
-
-	DMA_TRACE(("%s: dma_rxfill: post %d\n", di->name, n));
-
-	for (i = 0; i < n; i++) {
-		if ((p = PKTGET(di->drv, rxbufsize, FALSE)) == NULL) {
-			DMA_ERROR(("%s: dma_rxfill: out of rxbufs\n", di->name));
-			di->hnddma.rxnobuf++;
-			break;
-		}
-
-		*(uint32*)(OSL_UNCACHED(PKTDATA(di->drv, p))) = 0;
-
-		pa = (uint32) DMA_MAP(di->osh, PKTDATA(di->drv, p), rxbufsize, DMA_RX, p);
-		ASSERT(ISALIGNED(pa, 4));
-		ASSERT(DMA_ADDRESSABLE(pa));
-
-		/* save the free packet pointer */
-		ASSERT(di->rxp[rxout] == NULL);
-		di->rxp[rxout] = p;
-
-		/* prep the descriptor control value */
-		ctrl = rxbufsize;
-		if (rxout == (di->nrxd - 1))
-			ctrl |= CTRL_EOT;
-
-		/* init the rx descriptor */
-		W_SM(&di->rxd[rxout].ctrl, BUS_SWAP32(ctrl));
-		W_SM(&di->rxd[rxout].addr, BUS_SWAP32(pa + di->dataoffset));
-
-		rxout = NEXTRXD(rxout);
-	}
-
-	di->rxout = rxout;
-
-	/* update the chip lastdscr pointer */
-	W_REG(&di->regs->rcvptr, I2B(rxout));
-}
-
-void
-dma_txreclaim(dma_info_t *di, bool forceall)
-{
-	void *p;
-
-	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
-
-	while ((p = dma_getnexttxp(di, forceall)))
-		PKTFREE(di->drv, p, TRUE);
-}
-
 /*
  * Reclaim next completed txd (txds if using chained buffers) and
  * return associated packet.
  * If 'force' is true, reclaim txd(s) and return associated packet
  * regardless of the value of the hardware "curr" pointer.
  */
-void*
-dma_getnexttxp(dma_info_t *di, bool forceall)
+static void *
+dma64_getnexttxp(dma_info_t *di, bool forceall)
 {
 	uint start, end, i;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name, forceall ? "all" : ""));
 
+	if (di->ntxd == 0)
+		return (NULL);
+
 	txp = NULL;
 
 	start = di->txin;
 	if (forceall)
 		end = di->txout;
 	else
-		end = B2I(R_REG(&di->regs->xmtstatus) & XS_CD_MASK);
+		end = B2I(R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_CD_MASK, dma64dd_t);
 
 	if ((start == 0) && (end > di->txout))
 		goto bogus;
 
 	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
-		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd[i].addr)) - di->dataoffset),
-			  (BUS_SWAP32(R_SM(&di->txd[i].ctrl)) & CTRL_BC_MASK), DMA_TX, di->txp[i]);
-		W_SM(&di->txd[i].addr, 0xdeadbeef);
+		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd64[i].addrlow)) - di->dataoffsetlow),
+		          (BUS_SWAP32(R_SM(&di->txd64[i].ctrl2)) & D64_CTRL2_BC_MASK),
+		          DMA_TX, di->txp[i], &di->txp_dmah[i]);
+
+		W_SM(&di->txd64[i].addrlow, 0xdeadbeef);
+		W_SM(&di->txd64[i].addrhigh, 0xdeadbeef);
+
 		txp = di->txp[i];
 		di->txp[i] = NULL;
 	}
@@ -700,7 +1719,7 @@
 	di->txin = i;
 
 	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	return (txp);
 
@@ -712,40 +1731,14 @@
 	return (NULL);
 }
 
-/* like getnexttxp but no reclaim */
-void*
-dma_peeknexttxp(dma_info_t *di)
-{
-	uint end, i;
-
-	end = B2I(R_REG(&di->regs->xmtstatus) & XS_CD_MASK);
-
-	for (i = di->txin; i != end; i = NEXTTXD(i))
-		if (di->txp[i])
-			return (di->txp[i]);
-
-	return (NULL);
-}
-
-void
-dma_rxreclaim(dma_info_t *di)
-{
-	void *p;
-
-	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
-
-	while ((p = dma_getnextrxp(di, TRUE)))
-		PKTFREE(di->drv, p, FALSE);
-}
-
-void *
-dma_getnextrxp(dma_info_t *di, bool forceall)
+static void *
+dma64_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i;
 	void *rxp;
 
 	/* if forcing, dma engine must be disabled */
-	ASSERT(!forceall || !dma_rxenabled(di));
+	ASSERT(!forceall || !dma64_rxenabled(di));
 
 	i = di->rxin;
 
@@ -754,7 +1747,8 @@
 		return (NULL);
 
 	/* ignore curr if forceall */
-	if (!forceall && (i == B2I(R_REG(&di->regs->rcvstatus) & RS_CD_MASK)))
+	if (!forceall &&
+	    (i == B2I(R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK, dma64dd_t)))
 		return (NULL);
 
 	/* get the packet pointer that corresponds to the rx descriptor */
@@ -763,50 +1757,32 @@
 	di->rxp[i] = NULL;
 
 	/* clear this packet from the descriptor ring */
-	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd[i].addr)) - di->dataoffset),
-		  di->rxbufsize, DMA_RX, rxp);
-	W_SM(&di->rxd[i].addr, 0xdeadbeef);
+	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd64[i].addrlow)) - di->dataoffsetlow),
+	          di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd64[i].addrlow, 0xdeadbeef);
+	W_SM(&di->rxd64[i].addrhigh, 0xdeadbeef);
 
 	di->rxin = NEXTRXD(i);
 
 	return (rxp);
 }
 
-
-uintptr
-dma_getvar(dma_info_t *di, char *name)
-{
-	if (!strcmp(name, "&txavail"))
-		return ((uintptr) &di->txavail);
-	else {
-		ASSERT(0);
-	}
-	return (0);
-}
-
-void
-dma_txblock(dma_info_t *di)
-{
-	di->txavail = 0;
-}
-
-void
-dma_txunblock(dma_info_t *di)
-{
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
-}
-
-uint
-dma_txactive(dma_info_t *di)
+static bool
+_dma64_addrext(osl_t *osh, dma64regs_t *dma64regs)
 {
-	return (NTXDACTIVE(di->txin, di->txout));
+	uint32 w;
+	OR_REG(osh, &dma64regs->control, D64_XC_AE);
+	w = R_REG(osh, &dma64regs->control);
+	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
+	return ((w & D64_XC_AE) == D64_XC_AE);
 }
 
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-void
-dma_txrotate(di_t *di)
+static void
+dma64_txrotate(dma_info_t *di)
 {
 	uint ad;
 	uint nactive;
@@ -815,10 +1791,10 @@
 	uint32 w;
 	uint first, last;
 
-	ASSERT(dma_txsuspended(di));
+	ASSERT(dma64_txsuspendedidle(di));
 
-	nactive = dma_txactive(di);
-	ad = B2I((R_REG(&di->regs->xmtstatus) & XS_AD_MASK) >> XS_AD_SHIFT);
+	nactive = _dma_txactive(di);
+	ad = B2I((R_REG(di->osh, &di->d64txregs->status1) & D64_XS1_AD_MASK), dma64dd_t);
 	rot = TXD(ad - di->txin);
 
 	ASSERT(rot < di->ntxd);
@@ -840,14 +1816,20 @@
 		 * Move the tx dma descriptor.
 		 * EOT is set only in the last entry in the ring.
 		 */
-		w = R_SM(&di->txd[old].ctrl) & ~CTRL_EOT;
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl1)) & ~D64_CTRL1_EOT;
 		if (new == (di->ntxd - 1))
-			w |= CTRL_EOT;
-		W_SM(&di->txd[new].ctrl, w);
-		W_SM(&di->txd[new].addr, R_SM(&di->txd[old].addr));
+			w |= D64_CTRL1_EOT;
+		W_SM(&di->txd64[new].ctrl1, BUS_SWAP32(w));
+
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl2));
+		W_SM(&di->txd64[new].ctrl2, BUS_SWAP32(w));
+
+		W_SM(&di->txd64[new].addrlow, R_SM(&di->txd64[old].addrlow));
+		W_SM(&di->txd64[new].addrhigh, R_SM(&di->txd64[old].addrhigh));
 
 		/* zap the old tx dma descriptor address field */
-		W_SM(&di->txd[old].addr, 0xdeadbeef);
+		W_SM(&di->txd64[old].addrlow, BUS_SWAP32(0xdeadbeef));
+		W_SM(&di->txd64[old].addrhigh, BUS_SWAP32(0xdeadbeef));
 
 		/* move the corresponding txp[] entry */
 		ASSERT(di->txp[new] == NULL);
@@ -858,8 +1840,50 @@
 	/* update txin and txout */
 	di->txin = ad;
 	di->txout = TXD(di->txout + rot);
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(di->txout));
+	W_REG(di->osh, &di->d64txregs->ptr, I2B(di->txout, dma64dd_t));
+}
+
+#endif	/* BCMDMA64 */
+
+uint
+dma_addrwidth(sb_t *sbh, void *dmaregs)
+{
+	dma32regs_t *dma32regs;
+	osl_t *osh;
+
+	osh = sb_osh(sbh);
+
+	if (DMA64_CAP) {
+		/* DMA engine is 64-bit capable */
+		if (((sb_coreflagshi(sbh, 0, 0) & SBTMH_DMA64) == SBTMH_DMA64)) {
+			/* backplane are 64 bits capable */
+			if (sb_backplane64(sbh))
+				/* If bus is System Backplane or PCIE then we can access 64-bits */
+				if ((BUSTYPE(sbh->bustype) == SB_BUS) ||
+				    ((BUSTYPE(sbh->bustype) == PCI_BUS) &&
+					sbh->buscoretype == SB_PCIE))
+					return (DMADDRWIDTH_64);
+
+			/* DMA64 is always 32 bits capable, AE is always TRUE */
+#ifdef BCMDMA64
+			ASSERT(_dma64_addrext(osh, (dma64regs_t *)dmaregs));
+#endif
+			return (DMADDRWIDTH_32);
+		}
+	}
+
+	/* Start checking for 32-bit / 30-bit addressing */
+	dma32regs = (dma32regs_t *)dmaregs;
+
+	/* For System Backplane, PCIE bus or addrext feature, 32-bits ok */
+	if ((BUSTYPE(sbh->bustype) == SB_BUS) ||
+	    ((BUSTYPE(sbh->bustype) == PCI_BUS) && sbh->buscoretype == SB_PCIE) ||
+	    (_dma32_addrext(osh, dma32regs)))
+		return (DMADDRWIDTH_32);
+
+	/* Fallthru */
+	return (DMADDRWIDTH_30);
 }
--- src/shared.1927/hndrte.lds.in	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/hndrte.lds.in	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-OUTPUT_ARCH(mips)
+OUTPUT_ARCH(TARGET_ARCH)
 ENTRY(startup)
 SECTIONS {
 	. = TEXT_START;
@@ -9,10 +9,12 @@
 		*(.text)
 		*(.text.*)
 		*(.fini)
+		*(.glue_7t)
+		*(.glue_7)
+		*(.rdata)
+		*(.rdata.*)
 		*(.rodata)
 		*(.rodata.*)
-		_rstart = .;
-		*(.textini.*)
 		_etext = .;
 		text_end = .;
 	}
@@ -20,9 +22,6 @@
 	.data : {
 		data_start = .;
 		_fdata = .;
-		*(.dataini.*)
-		_rend = .;
-		*(.rdata)
 		*(.data)
 		*(.data.*)
 		*(.sdata)
@@ -36,8 +35,22 @@
 		*(.sbss)
 		*(.scommon)
 		*(.bss)
+		*(.bss.*)
 		*(COMMON)
 		bss_end = .;
 	}
+
+	.textrc : {
+		_rstart = .;
+		*(.textini.*)
+		. = ALIGN(16);
+		_retext = .;
+	}
+
+	.datarc : {
+		*(.dataini.*)
+		. = ALIGN(4);
+		_rend = .;
+	}
 	_end = .;
 }
--- src/shared.1927/linux_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/linux_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -16,20 +16,20 @@
 
 #include <typedefs.h>
 #include <bcmendian.h>
-#include <linux/module.h>
 #include <linuxver.h>
-#include <linux_osl.h>
+#include <bcmdefs.h>
+#include <osl.h>
 #include <bcmutils.h>
 #include <linux/delay.h>
 #ifdef mips
 #include <asm/paccess.h>
-#endif
+#endif /* mips */
 #include <pcicfg.h>
 
 #define PCI_CFG_RETRY 		10	
 
-#define OS_HANDLE_MAGIC		0x1234abcd
-#define BCM_MEM_FILENAME_LEN 	24
+#define OS_HANDLE_MAGIC		0x1234abcd	/* Magic # to recognise osh */
+#define BCM_MEM_FILENAME_LEN 	24		/* Mem. filename length */
 
 typedef struct bcm_mem_link {
 	struct bcm_mem_link *prev;
@@ -39,91 +39,203 @@
 	char	file[BCM_MEM_FILENAME_LEN];
 } bcm_mem_link_t;
 
-typedef struct os_handle {
+struct osl_info {
+	osl_pubinfo_t pub;
 	uint magic;
 	void *pdev;
 	uint malloced;
 	uint failed;
+	uint bustype;
 	bcm_mem_link_t *dbgmem_list;
-} os_handle_t;
+#if defined(DSLCPE_DELAY)
+	shared_osl_t *oshsh; /* osh shared */
+#endif
+#ifdef BCMDBG_PKT      /* pkt logging for debugging */
+	pktlist_info_t pktlist;
+#endif  /* BCMDBG_PKT */
+};
+
+static int16 linuxbcmerrormap[] =  \
+{	0, 			/* 0 */
+	-EINVAL,		/* BCME_ERROR */
+	-EINVAL,		/* BCME_BADARG */
+	-EINVAL,		/* BCME_BADOPTION */
+	-EINVAL,		/* BCME_NOTUP */
+	-EINVAL,		/* BCME_NOTDOWN */
+	-EINVAL,		/* BCME_NOTAP */
+	-EINVAL,		/* BCME_NOTSTA */
+	-EINVAL,		/* BCME_BADKEYIDX */
+	-EINVAL,		/* BCME_RADIOOFF */
+	-EINVAL,		/* BCME_NOTBANDLOCKED */
+	-EINVAL, 		/* BCME_NOCLK */
+	-EINVAL, 		/* BCME_BADRATESET */
+	-EINVAL, 		/* BCME_BADBAND */
+	-E2BIG,			/* BCME_BUFTOOSHORT */
+	-E2BIG,			/* BCME_BUFTOOLONG */
+	-EBUSY, 		/* BCME_BUSY */
+	-EINVAL, 		/* BCME_NOTASSOCIATED */
+	-EINVAL, 		/* BCME_BADSSIDLEN */
+	-EINVAL, 		/* BCME_OUTOFRANGECHAN */
+	-EINVAL, 		/* BCME_BADCHAN */
+	-EFAULT, 		/* BCME_BADADDR */
+	-ENOMEM, 		/* BCME_NORESOURCE */
+	-EOPNOTSUPP,		/* BCME_UNSUPPORTED */
+	-EMSGSIZE,		/* BCME_BADLENGTH */
+	-EINVAL,		/* BCME_NOTREADY */
+	-EPERM,			/* BCME_NOTPERMITTED */
+	-ENOMEM, 		/* BCME_NOMEM */
+	-EINVAL, 		/* BCME_ASSOCIATED */
+	-ERANGE, 		/* BCME_RANGE */
+	-EINVAL, 		/* BCME_NOTFOUND */
+	-EINVAL, 		/* BCME_WME_NOT_ENABLED */
+	-EINVAL, 		/* BCME_TSPEC_NOTFOUND */
+	-EINVAL, 		/* BCME_ACM_NOTSUPPORTED */
+	-EINVAL,		/* BCME_NOT_WME_ASSOCIATION */
+	-EIO,			/* BCME_SDIO_ERROR */
+	-ENODEV,		/* BCME_DONGLE_DOWN */
+	-EINVAL			/* BCME_VERSION */
 
-void *
-osl_attach(void *pdev)
+/* When an new error code is added to bcmutils.h, add os 
+ * spcecific error translation here as well
+ */
+/* check if BCME_LAST changed since the last time this function was updated */
+#if BCME_LAST != -37
+#error "You need to add a OS error translation in the linuxbcmerrormap \
+	for new error code defined in bcmuitls.h"
+#endif /* BCME_LAST != -37 */
+};
+
+/* translate bcmerrors into linux errors */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror > 0)
+		bcmerror = 0;
+	else if (bcmerror < BCME_LAST)
+		bcmerror = BCME_ERROR;
+
+	/* Array bounds covered by ASSERT in osl_attach */
+	return linuxbcmerrormap[-bcmerror];
+}
+
+osl_t *
+osl_attach(void *pdev, uint bustype, bool pkttag)
 {
-	os_handle_t *osh;
+	osl_t *osh;
 
-	osh = kmalloc(sizeof(os_handle_t), GFP_ATOMIC);
+	osh = kmalloc(sizeof(osl_t), GFP_ATOMIC);
 	ASSERT(osh);
 
+	bzero(osh, sizeof(osl_t));
+
+	/* Check that error map has the right number of entries in it */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(linuxbcmerrormap) - 1));
+
 	osh->magic = OS_HANDLE_MAGIC;
 	osh->malloced = 0;
 	osh->failed = 0;
 	osh->dbgmem_list = NULL;
 	osh->pdev = pdev;
+	osh->pub.pkttag = pkttag;
+	osh->bustype = bustype;
+
+	switch (bustype) {
+		case PCI_BUS:
+		case SB_BUS:
+		case PCMCIA_BUS:
+			osh->pub.mmbus = TRUE;
+			break;
+		case JTAG_BUS:
+		case SDIO_BUS:
+		case USB_BUS:
+			osh->pub.mmbus = FALSE;
+			break;
+		default:
+			ASSERT(FALSE);
+			break;
+	}
 
 	return osh;
 }
 
 void
-osl_detach(void *osh)
+osl_detach(osl_t *osh)
 {
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	if (osh == NULL)
+		return;
+
+	ASSERT(osh->magic == OS_HANDLE_MAGIC);
 	kfree(osh);
 }
 
+/* Return a new packet. zero out pkttag */
 void*
-osl_pktget(void *drv, uint len, bool send)
+osl_pktget(osl_t *osh, uint len)
 {
 	struct sk_buff *skb;
 
-	if ((skb = dev_alloc_skb(len)) == NULL)
-		return (NULL);
-
+	if ((skb = dev_alloc_skb(len))) {
 	skb_put(skb, len);
+		skb->priority = 0;
 
-	/* ensure the cookie field is cleared */ 
-	PKTSETCOOKIE(skb, NULL);
+#ifdef BCMDBG_PKT
+	pktlist_add(&(osh->pktlist), (void *) skb);
+#endif  /* BCMDBG_PKT */
+
+		osh->pub.pktalloced++;
+	}
 
 	return ((void*) skb);
 }
 
+/* Free the driver packet. Free the tag if present */
 void
-osl_pktfree(void *p)
+osl_pktfree(osl_t *osh, void *p, bool send)
 {
 	struct sk_buff *skb, *nskb;
 
 	skb = (struct sk_buff*) p;
 
+	if (send && osh->pub.tx_fn)
+		osh->pub.tx_fn(osh->pub.tx_ctx, p, 0);
+
 	/* perversion: we use skb->next to chain multi-skb packets */
 	while (skb) {
 		nskb = skb->next;
 		skb->next = NULL;
+
+#ifdef BCMDBG_PKT
+		pktlist_remove(&(osh->pktlist), (void *) skb);
+#endif  /* BCMDBG_PKT */
+
 		if (skb->destructor) {
-			/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists */
+			/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists
+			 */
 			dev_kfree_skb_any(skb);
 		} else {
 			/* can free immediately (even in_irq()) if destructor does not exist */
 			dev_kfree_skb(skb);
 		}
+
+		osh->pub.pktalloced--;
+
 		skb = nskb;
 	}
 }
 
 uint32
-osl_pci_read_config(void *osh, uint offset, uint size)
+osl_pci_read_config(osl_t *osh, uint offset, uint size)
 {
-	struct pci_dev *pdev;
 	uint val;
-	uint retry=PCI_CFG_RETRY;	 
+	uint retry = PCI_CFG_RETRY;	 
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	/* only 4byte access supported */
 	ASSERT(size == 4);
 
-	pdev = ((os_handle_t *)osh)->pdev;
 	do {
-		pci_read_config_dword(pdev, offset, &val);
+		pci_read_config_dword(osh->pdev, offset, &val);
 		if (val != 0xffffffff)
 			break;
 	} while (retry--);
@@ -133,41 +245,56 @@
 }
 
 void
-osl_pci_write_config(void *osh, uint offset, uint size, uint val)
+osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
 {
-	struct pci_dev *pdev;
-	uint retry=PCI_CFG_RETRY;	 
+	uint retry = PCI_CFG_RETRY;	 
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	/* only 4byte access supported */
 	ASSERT(size == 4);
 
-	pdev = ((os_handle_t *)osh)->pdev;
-
 	do {
-		pci_write_config_dword(pdev, offset, val);
-		if (offset!=PCI_BAR0_WIN)
+		pci_write_config_dword(osh->pdev, offset, val);
+		if (offset != PCI_BAR0_WIN)
 			break;
-		if (osl_pci_read_config(osh,offset,size) == val) 
+		if (osl_pci_read_config(osh, offset, size) == val)
 			break;
 	} while (retry--);
 
 }
 
+/* return bus # for the pci device pointed by osh->pdev */
+uint
+osl_pci_bus(osl_t *osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return ((struct pci_dev *)osh->pdev)->bus->number;
+}
+
+/* return slot # for the pci device pointed by osh->pdev */
+uint
+osl_pci_slot(osl_t *osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
+}
+
 static void
-osl_pcmcia_attr(void *osh, uint offset, char *buf, int size, bool write)
+osl_pcmcia_attr(osl_t *osh, uint offset, char *buf, int size, bool write)
 {
 }
 
 void
-osl_pcmcia_read_attr(void *osh, uint offset, void *buf, int size)
+osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *) buf, size, FALSE);
 }
 
 void
-osl_pcmcia_write_attr(void *osh, uint offset, void *buf, int size)
+osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *) buf, size, TRUE);
 }
@@ -176,19 +303,15 @@
 #ifdef BCMDBG_MEM
 
 void*
-osl_debug_malloc(void *osh, uint size, int line, char* file)
+osl_debug_malloc(osl_t *osh, uint size, int line, char* file)
 {
 	bcm_mem_link_t *p;
 	char* basename;
-	os_handle_t *h = (os_handle_t *)osh;
 	
-	if (size == 0) {
-		return NULL;
-	}
+	ASSERT(size);
 	
-	p = (bcm_mem_link_t*)osl_malloc(osh, sizeof(bcm_mem_link_t) + size);
-	if (p == NULL)
-		return p;
+	if ((p = (bcm_mem_link_t*)osl_malloc(osh, sizeof(bcm_mem_link_t) + size)) == NULL)
+		return (NULL);
 	
 	p->size = size;
 	p->line = line;
@@ -206,31 +329,33 @@
 
 	/* link this block */
 	p->prev = NULL;
-	p->next = h->dbgmem_list;
+	p->next = osh->dbgmem_list;
 	if (p->next)
 		p->next->prev = p;
-	h->dbgmem_list = p;
+	osh->dbgmem_list = p;
 
 	return p + 1;
 }
 
 void
-osl_debug_mfree(void *osh, void *addr, uint size, int line, char* file)
+osl_debug_mfree(osl_t *osh, void *addr, uint size, int line, char* file)
 {
 	bcm_mem_link_t *p = (bcm_mem_link_t *)((int8*)addr - sizeof(bcm_mem_link_t));
-	os_handle_t *h = (os_handle_t *)osh;
 	
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	if (p->size == 0) {
-		printk("osl_debug_mfree: double free on addr 0x%x size %d at line %d file %s\n", 
-			(uint)addr, size, line, file);
+		printk("osl_debug_mfree: double free on addr %p size %d at line %d file %s\n",
+			addr, size, line, file);
+		ASSERT(p->size);
 		return;
 	}
 
 	if (p->size != size) {
-		printk("osl_debug_mfree: dealloc size %d does not match alloc size %d on addr 0x%x at line %d file %s\n",
-		       size, p->size, (uint)addr, line, file);
+		printk("osl_debug_mfree: dealloc size %d does not match alloc size %d on addr %p"
+		       " at line %d file %s\n",
+		       size, p->size, addr, line, file);
+		ASSERT(p->size == size);
 		return;
 	}
 
@@ -239,123 +364,111 @@
 		p->prev->next = p->next;
 	if (p->next)
 		p->next->prev = p->prev;
-	if (h->dbgmem_list == p)
-		h->dbgmem_list = p->next;
+	if (osh->dbgmem_list == p)
+		osh->dbgmem_list = p->next;
 	p->next = p->prev = NULL;
 
 	osl_mfree(osh, p, size + sizeof(bcm_mem_link_t));
 }
 
-char*
-osl_debug_memdump(void *osh, char *buf, uint sz)
+int
+osl_debug_memdump(osl_t *osh, struct bcmstrbuf *b)
 {
 	bcm_mem_link_t *p;
-	char *obuf;
-	os_handle_t *h = (os_handle_t *)osh;
 
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	obuf = buf;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	buf += sprintf(buf, "   Address\tSize\tFile:line\n");
-	for (p = h->dbgmem_list; p && ((buf - obuf) < (sz - 128)); p = p->next)
-		buf += sprintf(buf, "0x%08x\t%5d\t%s:%d\n",
-			(int)p + sizeof(bcm_mem_link_t), p->size, p->file, p->line);
+	bcm_bprintf(b, "   Address\tSize\tFile:line\n");
+	for (p = osh->dbgmem_list; p; p = p->next)
+		bcm_bprintf(b, "0x%08x\t%5d\t%s:%d\n",
+			(uintptr)p + sizeof(bcm_mem_link_t), p->size, p->file, p->line);
 
-	return (obuf);
+	return 0;
 }
 
 #endif	/* BCMDBG_MEM */
 
 void*
-osl_malloc(void *osh, uint size)
+osl_malloc(osl_t *osh, uint size)
 {
-	os_handle_t *h = (os_handle_t *)osh;
 	void *addr;
 
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	h->malloced += size;
-	addr = kmalloc(size, GFP_ATOMIC);
-	if (!addr)
-		h->failed++;
+	/* only ASSERT if osh is defined */
+	if (osh)
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+
+	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+		if (osh)
+			osh->failed++;
+		return (NULL);
+	}
+	if (osh)
+		osh->malloced += size;
+
 	return (addr);
 }
 
 void
-osl_mfree(void *osh, void *addr, uint size)
+osl_mfree(osl_t *osh, void *addr, uint size)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	h->malloced -= size;
+	if (osh) {
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+		osh->malloced -= size;
+	}
 	kfree(addr);
 }
 
 uint
-osl_malloced(void *osh)
+osl_malloced(osl_t *osh)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	return (h->malloced);
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->malloced);
 }
 
-uint osl_malloc_failed(void *osh)
+uint
+osl_malloc_failed(osl_t *osh)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	return (h->failed);
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->failed);
 }
 
 void*
-osl_dma_alloc_consistent(void *osh, uint size, ulong *pap)
+osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap)
 {
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
-	return (pci_alloc_consistent(dev, size, (dma_addr_t*)pap));
+	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap));
 }
 
 void
-osl_dma_free_consistent(void *osh, void *va, uint size, ulong pa)
+osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
 {
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
-	pci_free_consistent(dev, size, va, (dma_addr_t)pa);
+	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
 }
 
 uint
-osl_dma_map(void *osh, void *va, uint size, int direction)
+osl_dma_map(osl_t *osh, void *va, uint size, int direction)
 {
 	int dir;
-	struct pci_dev *dev;
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
-
-	dev = ((os_handle_t *)osh)->pdev;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
-	return (pci_map_single(dev, va, size, dir));
+	return (pci_map_single(osh->pdev, va, size, dir));
 }
 
 void
-osl_dma_unmap(void *osh, uint pa, uint size, int direction)
+osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction)
 {
 	int dir;
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
-	pci_unmap_single(dev, (uint32)pa, size, dir);
+	pci_unmap_single(osh->pdev, (uint32)pa, size, dir);
 }
 
-#if defined(BINOSL)
+#if defined(BINOSL) || defined(CONFIG_BCMDBG_ASSERT)
 void
 osl_assert(char *exp, char *file, int line)
 {
@@ -364,7 +477,128 @@
 	sprintf(tempbuf, "assertion \"%s\" failed: file \"%s\", line %d\n", exp, file, line);
 	panic(tempbuf);
 }
-#endif	/* BCMDBG || BINOSL */
+#endif	/* BCMDBG_ASSERT || BINOSL */
+
+void
+osl_delay(uint usec)
+{
+	uint d;
+
+	while (usec > 0) {
+		d = MIN(usec, 1000);
+		udelay(d);
+		usec -= d;
+	}
+}
+
+#if defined(DSLCPE_DELAY)
+
+void
+osl_oshsh_init(osl_t *osh, shared_osl_t* oshsh)
+{
+	extern unsigned long loops_per_jiffy;
+	osh->oshsh = oshsh;
+	osh->oshsh->MIPS = loops_per_jiffy / (500000/HZ);
+}
+
+int
+in_long_delay(osl_t *osh)
+{
+	return osh->oshsh->long_delay;
+}
+
+void
+osl_long_delay(osl_t *osh, uint usec, bool yield)
+{
+	uint d;
+	bool yielded = TRUE;
+	int usec_to_delay = usec;
+	unsigned long tick1, tick2, tick_diff = 0;
+
+	/* delay at least requested usec */
+	while (usec_to_delay > 0) {
+		if (!yield || !yielded) {
+			d = MIN(usec_to_delay, 10);
+			udelay(d);
+			usec_to_delay -= d;
+		}
+		if (usec_to_delay > 0) {
+			osh->oshsh->long_delay++;
+			OSL_GETCYCLES(tick1);
+			spin_unlock_bh(osh->oshsh->lock);
+			if (usec_to_delay > 0 && !in_irq() && !in_softirq() && !in_interrupt()) {
+				schedule();
+				yielded = TRUE;
+			} else {
+				yielded = FALSE;
+			}
+			spin_lock_bh(osh->oshsh->lock);
+			OSL_GETCYCLES(tick2);
+
+			if (yielded) {
+				tick_diff = TICKDIFF(tick2, tick1);
+				tick_diff = (tick_diff * 2)/(osh->oshsh->MIPS);
+				if (tick_diff) {
+					usec_to_delay -= tick_diff;
+				} else
+					yielded = 0;
+			}
+			osh->oshsh->long_delay--;
+			ASSERT(osh->oshsh->long_delay >= 0);
+		}
+	}
+}
+#endif /* DSLCPE_DELAY */
+
+/* Clone a packet.
+ * The pkttag contents are NOT cloned.
+ */
+void *
+osl_pktdup(osl_t *osh, void *skb)
+{
+	void * p;
+
+	if ((p = skb_clone((struct sk_buff*)skb, GFP_ATOMIC)) == NULL)
+		return NULL;
+
+	/* skb_clone copies skb->cb.. we don't want that */
+	if (osh->pub.pkttag)
+		bzero((void*)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	osh->pub.pktalloced++;
+#ifdef BCMDBG_PKT
+	pktlist_add(&(osh->pktlist), (void *) p);
+#endif  /* BCMDBG_PKT */
+	return (p);
+}
+
+uint
+osl_pktalloced(osl_t *osh)
+{
+	return (osh->pub.pktalloced);
+}
+
+#ifdef BCMDBG_PKT
+char *
+osl_pktlist_dump(osl_t *osh, char *buf)
+{
+	pktlist_dump(&(osh->pktlist), buf);
+	return buf;
+}
+
+void
+osl_pktlist_add(osl_t *osh, void *p)
+{
+	pktlist_add(&(osh->pktlist), p);
+}
+
+void
+osl_pktlist_remove(osl_t *osh, void *p)
+{
+	pktlist_remove(&(osh->pktlist), p);
+}
+#endif /* BCMDBG_PKT */
 
 /*
  * BINOSL selects the slightly slower function-call-based binary compatible osl.
@@ -380,10 +614,10 @@
 
 	/* sprintf into a local buffer because there *is* no "vprintk()".. */
 	va_start(args, format);
-	len = vsprintf(buf, format, args);
+	len = vsnprintf(buf, 1024, format, args);
 	va_end(args);
 
-	if (len > sizeof (buf)) {
+	if (len > sizeof(buf)) {
 		printk("osl_printf: buffer overrun\n");
 		return (0);
 	}
@@ -416,7 +650,7 @@
 }
 
 int
-osl_strlen(char *s)
+osl_strlen(const char *s)
 {
 	return (strlen(s));
 }
@@ -494,7 +728,7 @@
 	return ((void*)KSEG1ADDR(va));
 #else
 	return ((void*)va);
-#endif
+#endif /* mips */
 }
 
 uint
@@ -508,7 +742,7 @@
 	rdtscl(cycles);
 #else
 	cycles = 0;
-#endif
+#endif /* defined(mips) */
 	return cycles;
 }
 
@@ -528,45 +762,45 @@
 osl_busprobe(uint32 *val, uint32 addr)
 {
 #ifdef mips
-	return get_dbe(*val, (uint32*)addr);
+	return get_dbe(*val, (uint32 *)addr);
 #else
-	*val = readl(addr);
+	*val = readl((uint32 *)(uintptr)addr);
 	return 0;
-#endif
+#endif /* mips */
 }
 
-void
-osl_delay(uint usec)
+bool
+osl_pktshared(void *skb)
 {
-	udelay(usec);
+	return (((struct sk_buff*)skb)->cloned);
 }
 
 uchar*
-osl_pktdata(void *drv, void *skb)
+osl_pktdata(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->data);
 }
 
 uint
-osl_pktlen(void *drv, void *skb)
+osl_pktlen(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->len);
 }
 
 uint
-osl_pktheadroom(void *drv, void *skb)
+osl_pktheadroom(osl_t *osh, void *skb)
 {
 	return (uint) skb_headroom((struct sk_buff *) skb);
 }
 
 uint
-osl_pkttailroom(void *drv, void *skb)
+osl_pkttailroom(osl_t *osh, void *skb)
 {
 	return (uint) skb_tailroom((struct sk_buff *) skb);
 }
 
 void*
-osl_pktnext(void *drv, void *skb)
+osl_pktnext(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->next);
 }
@@ -578,39 +812,27 @@
 }
 
 void
-osl_pktsetlen(void *drv, void *skb, uint len)
+osl_pktsetlen(osl_t *osh, void *skb, uint len)
 {
 	__skb_trim((struct sk_buff*)skb, len);
 }
 
 uchar*
-osl_pktpush(void *drv, void *skb, int bytes)
+osl_pktpush(osl_t *osh, void *skb, int bytes)
 {
 	return (skb_push((struct sk_buff*)skb, bytes));
 }
 
 uchar*
-osl_pktpull(void *drv, void *skb, int bytes)
+osl_pktpull(osl_t *osh, void *skb, int bytes)
 {
 	return (skb_pull((struct sk_buff*)skb, bytes));
 }
 
 void*
-osl_pktdup(void *drv, void *skb)
-{
-	return (skb_clone((struct sk_buff*)skb, GFP_ATOMIC));
-}
-
-void*
-osl_pktcookie(void *skb)
-{
-	return ((void*)((struct sk_buff*)skb)->csum);
-}
-
-void
-osl_pktsetcookie(void *skb, void *x)
+osl_pkttag(void *skb)
 {
-	((struct sk_buff*)skb)->csum = (uint)x;
+	return ((void*)(((struct sk_buff*)skb)->cb));
 }
 
 void*
@@ -637,4 +859,51 @@
 	((struct sk_buff*)skb)->priority = x;
 }
 
+/* Convert a driver packet to native(OS) packet
+ * In the process, packettag is zeroed out before sending up
+ * IP code depends on skb->cb to be setup correctly with various options
+ * In our case, that means it should be 0
+ */
+struct sk_buff *
+osl_pkt_tonative(osl_t *osh, void *pkt)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pub.pkttag)
+		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
+
+	/* Decrement the packet counter */
+	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		pktlist_remove(&(osh->pktlist), (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pub.pktalloced--;
+	}
+
+	return (struct sk_buff *)pkt;
+}
+
+/* Convert a native(OS) packet to driver packet.
+ * In the process, native packet is destroyed, there is no copying
+ * Also, a packettag is zeroed out
+ */
+void *
+osl_pkt_frmnative(osl_t *osh, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pub.pkttag)
+		bzero((void*)skb->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	for (nskb = skb; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		pktlist_add(&(osh->pktlist), (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pub.pktalloced++;
+	}
+
+	return (void *)skb;
+}
+
 #endif	/* BINOSL */
--- src/shared.1927/load.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/load.c	2007-11-19 07:01:01.000000000 +0300
@@ -14,21 +14,21 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
-#include <bcmdevs.h>
 #include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
 #include <sbconfig.h>
-#include <sbextif.h>
 #include <sbchipc.h>
 #include <hndmips.h>
 #include <sbmemc.h>
 #include <sflash.h>
-#include <sbutils.h>
 #include <bcmsrom.h>
 
 void c_main(unsigned long ra);
 
-static void *sbh;
+static sb_t *sbh;
 static chipcregs_t *cc;
 
 static struct sflash *sflash;
@@ -37,7 +37,7 @@
 extern char data_start[], data_end[];
 extern char bss_start[], bss_end[];
 
-#define INBUFSIZ 4096
+#define INBUFSIZ 4096	/* Buffer size */
 #define WSIZE 0x8000    	/* window size--must be a power of two, and */
 				/*  at least 32K for zip's deflate method */
 
@@ -57,10 +57,11 @@
 
 	for (insize = 0; insize < INBUFSIZ; insize += bytes, inoff += bytes) {
 		if (sflash) {
-			if ((bytes = sflash_read(cc, inoff, INBUFSIZ - insize, &inbuf[insize])) < 0)
+			if ((bytes = sflash_read(cc, inoff, INBUFSIZ - insize,
+			                         &inbuf[insize])) < 0)
 				return bytes;
 		} else {
-			*((uint32 *) &inbuf[insize]) = *((uint32 *) KSEG1ADDR(0x1fc00000 + inoff));
+			*((uint32 *) &inbuf[insize]) = *((uint32 *) KSEG1ADDR(SB_FLASH1 + inoff));
 			bytes = sizeof(uint32);
 		}
 	}
@@ -101,12 +102,12 @@
 
 /* Diagnostic functions (stubbed out) */
 
-#define Assert(cond,msg)
+#define Assert(cond, msg)
 #define Trace(x)
 #define Tracev(x)
 #define Tracevv(x)
-#define Tracec(c,x)
-#define Tracecv(c,x)
+#define Tracec(c, x)
+#define Tracecv(c, x)
 
 static uchar *window;		/* Sliding window buffer */
 static unsigned outcnt;		/* bytes in window buffer */
@@ -157,7 +158,7 @@
  * bzip2 declarations
  */
 
-void bz_internal_error (int i)
+void bz_internal_error(int i)
 {
 	char msg[128];
 
@@ -204,7 +205,7 @@
 	return ret;
 }
 
-#endif
+#endif /* defined(USE_GZIP) */
 
 extern char input_data[];
 extern int input_len;
@@ -219,7 +220,7 @@
 	inoff = ((ulong)text_end - (ulong)text_start) + ((ulong)input_data - (ulong)data_start);
 #else
 	inoff = (ulong) input_data - (ulong) text_start;
-#endif
+#endif /* CONFIG_XIP */
 	outbuf = (uchar *) LOADADDR;
 	bytes_out = 0;
 	inbuf = malloc(INBUFSIZ);	/* input buffer */
@@ -240,7 +241,7 @@
 		memcpy(&outbuf[bytes_out], inbuf, insize);
 		bytes_out += insize;
 	}
-#endif
+#endif /* defined(USE_GZIP) */
 	if (ret) {
 		printf("error %d\n", ret);
 	} else
@@ -286,12 +287,12 @@
 c_main(unsigned long ra)
 {
 	/* Basic initialization */
-	sbh = osl_init();
+	sbh = (sb_t *)osl_init();
 
 #ifndef CFG_UNCACHED
 	/* Initialize and turn caches on */
 	caches_on();
-#endif
+#endif /* CFG_UNCACHED */
 
 	cc = sb_setcore(sbh, SB_CC, 0);
 
@@ -299,7 +300,7 @@
 	sflash = cc ? sflash_init(cc) : NULL;
 
 	/* Copy self to flash if we booted from SDRAM */
-	if (PHYSADDR(ra) < 0x1fc00000) {
+	if (PHYSADDR(ra) < SB_FLASH1) {
 		if (sflash)
 			sflash_self(cc);
 	}
--- src/shared.1927/min_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/min_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,9 +13,14 @@
  * $Id$
  */
 
+#include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <bcmutils.h>
 #include <sbutils.h>
-#include <hndmips.h>
+#include <hndcpu.h>
+#include <sbchipc.h>
+#include <hndchipc.h>
 
 /* Cache support */
 
@@ -35,11 +40,9 @@
 	if ((prid & (PRID_COMP_MASK | PRID_IMP_MASK)) ==
 	    (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) {
 		c0reg = MFC0(C0_BROADCOM, 0);
-		/* Enable icache */
-		c0reg |= (1 << 31);
-		/* Enable dcache */
-		c0reg |= (1 << 30);
-		MTC0(C0_BROADCOM, 0 , c0reg);
+		/* Enable icache & dcache */
+		c0reg |= BRCM_IC_ENABLE | BRCM_DC_ENABLE;
+		MTC0(C0_BROADCOM, 0, c0reg);
 	}
 }	
 static void (*change_cachability)(uint32);
@@ -61,6 +64,9 @@
 	dcache_size = size;
 	dc_lsize = lsize;
 	
+	/* If caches are not in the default state then
+	 * presume that caches are already init'd
+	 */
 	if ((MFC0(C0_CONFIG, 0) & CONF_CM_CMASK) != CONF_CM_UNCACHED) {
 		blast_dcache();
 		blast_icache();
@@ -73,7 +79,7 @@
 	MTC0(C0_TAGLO, 0, 0);
 	MTC0(C0_TAGHI, 0, 0);
 	while (start < end) {
-		cache_unroll(start, Index_Store_Tag_I);
+		cache_op(start, Index_Store_Tag_I);
 		start += ic_lsize;
 	}
 	
@@ -83,7 +89,7 @@
 	MTC0(C0_TAGLO, 0, 0);
 	MTC0(C0_TAGHI, 0, 0);
 	while (start < end) {
-		cache_unroll(start, Index_Store_Tag_D);
+		cache_op(start, Index_Store_Tag_D);
 		start += dc_lsize;
 	}
 
@@ -93,7 +99,7 @@
 }
 
 
-#define BCM4710_DUMMY_RREG() (((sbconfig_t *)(KSEG1ADDR(0x18000000 + SBCONFIGOFF)))->sbimstate)
+#define BCM4710_DUMMY_RREG() (((sbconfig_t *)(KSEG1ADDR(SB_ENUM_BASE + SBCONFIGOFF)))->sbimstate)
 
 void
 blast_dcache(void)
@@ -103,9 +109,9 @@
 	start = KSEG0;
 	end = start + dcache_size;
 
-	while(start < end) {
+	while (start < end) {
 		BCM4710_DUMMY_RREG();
-		cache_unroll(start, Index_Writeback_Inv_D);
+		cache_op(start, Index_Writeback_Inv_D);
 		start += dc_lsize;
 	}
 }
@@ -118,8 +124,8 @@
 	start = KSEG0;
 	end = start + icache_size;
 
-	while(start < end) {
-		cache_unroll(start, Index_Invalidate_I);
+	while (start < end) {
+		cache_op(start, Index_Invalidate_I);
 		start += ic_lsize;
 	}
 }
@@ -127,13 +133,13 @@
 /* uart output */
 
 struct serial_struct {
-	unsigned char	*iomem_base;
-	unsigned short	iomem_reg_shift;
+	unsigned char	*reg_base;
+	unsigned short	reg_shift;
 	int	irq;
 	int	baud_base;
 };
 
-static struct serial_struct hndrte_uart;
+static struct serial_struct min_uart;
 
 #define LOG_BUF_LEN	(1024)
 #define LOG_BUF_MASK	(LOG_BUF_LEN-1)
@@ -144,14 +150,14 @@
 static inline int
 serial_in(struct serial_struct *info, int offset)
 {
-	return ((int)R_REG((uint8 *)(info->iomem_base + (offset << info->iomem_reg_shift))));
+	return ((int)R_REG(NULL, (uint8 *)(info->reg_base + (offset << info->reg_shift))));
 }
 
 static inline void
 serial_out(struct serial_struct *info, int offset, int value)
 {
-	W_REG((uint8 *)(info->iomem_base + (offset << info->iomem_reg_shift)), value);
-	*((volatile unsigned int *) KSEG1ADDR(0x18000000));
+	W_REG(NULL, (uint8 *)(info->reg_base + (offset << info->reg_shift)), value);
+	*((volatile unsigned int *) KSEG1ADDR(SB_ENUM_BASE));
 }
 
 void
@@ -166,15 +172,22 @@
 	log_start = (log_start + 1) & LOG_BUF_MASK;
 
 	/* No UART */
-	if (!hndrte_uart.iomem_base)
+	if (!min_uart.reg_base)
 		return;
 
-	while (!(serial_in(&hndrte_uart, UART_LSR) & UART_LSR_THRE));
-	serial_out(&hndrte_uart, UART_TX, c);
+	while (!(serial_in(&min_uart, UART_LSR) & UART_LSR_THRE));
+	serial_out(&min_uart, UART_TX, c);
 }
 
 /* assert & debugging */
 
+#ifdef BCMDBG_ASSERT
+void
+assfail(char *exp, char *file, int line)
+{
+	printf("ASSERT %s file %s line %d\n", exp, file, line);
+}
+#endif /* BCMDBG_ASSERT */
 
 /* general purpose memory allocation */
 
@@ -222,7 +235,7 @@
 static inline void
 __delay(uint loops)
 {
-        __asm__ __volatile__ (
+	__asm__ __volatile__(
                 ".set\tnoreorder\n"
                 "1:\tbnez\t%0,1b\n\t"
                 "subu\t%0,1\n\t"
@@ -241,12 +254,6 @@
 	__delay(loops);
 }
 
-extern int
-getintvar(char *vars, char *name)
-{
-	return 0;
-}
-
 /* No trap handling in self-decompressing boots */
 extern void trap_init(void);
 
@@ -261,20 +268,20 @@
 {
 	int quot;
 
-	if (hndrte_uart.iomem_base)
+	if (min_uart.reg_base)
 		return;
 
-	hndrte_uart.iomem_base = regs;
-	hndrte_uart.irq = irq;
-	hndrte_uart.baud_base = baud_base / 16;
-	hndrte_uart.iomem_reg_shift = reg_shift;
+	min_uart.reg_base = regs;
+	min_uart.irq = irq;
+	min_uart.baud_base = baud_base / 16;
+	min_uart.reg_shift = reg_shift;
 
 	/* Set baud and 8N1 */
-	quot = hndrte_uart.baud_base / 115200;
-	serial_out(&hndrte_uart, UART_LCR, UART_LCR_DLAB);
-	serial_out(&hndrte_uart, UART_DLL, quot & 0xff);
-	serial_out(&hndrte_uart, UART_DLM, quot >> 8);
-	serial_out(&hndrte_uart, UART_LCR, UART_LCR_WLEN8);
+	quot = (min_uart.baud_base + 57600) / 115200;
+	serial_out(&min_uart, UART_LCR, UART_LCR_DLAB);
+	serial_out(&min_uart, UART_DLL, quot & 0xff);
+	serial_out(&min_uart, UART_DLM, quot >> 8);
+	serial_out(&min_uart, UART_LCR, UART_LCR_WLEN8);
 
 	/* According to the Synopsys website: "the serial clock
 	 * modules must have time to see new register values
@@ -292,22 +299,32 @@
 osl_init()
 {
 	uint32 c0reg;
-	void *sbh;
+	sb_t *sbh;
 
 	/* Disable interrupts */
 	c0reg = MFC0(C0_STATUS, 0);
 	c0reg &= ~ST0_IE;
-	MTC0(C0_STATUS, 0 , c0reg);
+	MTC0(C0_STATUS, 0, c0reg);
 
 	/* Scan backplane */
-	sbh = sb_kattach();
+	sbh = sb_kattach(SB_OSH);
 
-	sb_mips_init(sbh);
+	sb_mips_init(sbh, 0);
 	sb_serial_init(sbh, serial_add);
 
 	/* Init malloc */
 	free_mem_ptr = (ulong) bss_end;
 	free_mem_ptr_end = ((ulong)&c0reg) - 8192;	/* Enough stack? */
 
-	return (sbh);
+	return ((void *)sbh);
+}
+
+/* translate bcmerros */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror)
+		return -1;
+	else
+		return 0;
 }
--- src/shared.1927/nvram/bcm94320pflsh.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320pflsh.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320pflsh board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x045e
 boardnum=${serno}
-# Board revision 4.3
-boardrev=0x43
+# Board revision 4.6
+boardrev=0x46
 # Flags: NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0x448
+boardflags=0x648
 sromrev=2
 
 # Make the d11 i/f single band
@@ -21,12 +21,13 @@
 # 4320 802.11g parameters
 il0macaddr=00:90:4c:87:${maclo}
 aa0=3
-ag0=2
-pa0maxpwr=76
+ag0=5
+pa0maxpwr=80
 pa0itssit=62
 pa0b0=0x1707
 pa0b1=0xfa61
 pa0b2=0xfeac
+opo=8
 
 # Commons wireless parameters
 cctl=0
--- src/shared.1927/nvram/bcm94320ph.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320ph.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320ph board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x045a
 boardnum=${serno}
-# Board revision 2.0
-boardrev=0x20
+# Board revision 3.6
+boardrev=0x36
 # Flags: NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0x448
+boardflags=0x648
 sromrev=2
 
 # Make the d11 i/f single band
@@ -21,13 +21,13 @@
 # 4320 802.11g parameters
 il0macaddr=00:90:4c:82:${maclo}
 aa0=3
-ag0=5
-pa0maxpwr=80
+ag0=0x82
+pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x1670
-pa0b1=0xfa71
-pa0b2=0xfe8c
-opo=2
+pa0b0=0x1665
+pa0b1=0xfa60
+pa0b2=0xfe83
+opo=8
 
 # Commons wireless parameters
 cctl=0
--- src/shared.1927/nvram/bcm94320r.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320r.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320Retail board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x0461
 boardnum=${serno}
-# Board revision 1.0
-boardrev=0x10
-# Flags: FEM, NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0xc48
+# Board revision 3.1
+boardrev=0x31
+# Flags: FEM, NOPCI, CCKHIPWR & ADCDIV, Afterburner ON.
+boardflags=0xe48
 sromrev=2
 
 # Make the d11 i/f single band
@@ -24,10 +24,15 @@
 ag0=2
 pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x1707
-pa0b1=0xfa61
-pa0b2=0xfeac
+pa0b0=5516
+pa0b1=-1417
+pa0b2=-368
+opo=16
 
 # Commons wireless parameters
 cctl=0
 ccode=0
+
+# PID and VID
+product_id=0xD11B
+vendor_id=0x0A5C
--- src/shared.1927/nvram/bcm94333u.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94333u.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94333U board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -37,5 +37,5 @@
 vendor_id=0x0a5c
 product_id=0xd11b
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
--- src/shared.1927/nvram/bcm94702ap-5325e.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap-5325e.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board with BCM5325E
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,8 +37,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # GPIO mapping
 gpio6=robo_reset
--- src/shared.1927/nvram/bcm94702ap-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board as l2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,8 +37,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 et1 wl0 wl1
--- src/shared.1927/nvram/bcm94702ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,6 +37,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94702mn.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702mn.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702MN board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -37,5 +37,5 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
--- src/shared.1927/nvram/bcm94704agr-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94704agr-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94704agr board as l2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -43,7 +43,7 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Reset 
 reset_gpio=7
--- src/shared.1927/nvram/bcm94704agr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94704agr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94704agr board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -43,7 +43,7 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Reset 
 reset_gpio=7
--- src/shared.1927/nvram/bcm94710ap-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710ap-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710AP board as switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,8 +38,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 et1 wl0 wl1 il0
--- src/shared.1927/nvram/bcm94710ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710AP board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,6 +38,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94710r1.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710r1.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710R1 board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -40,6 +40,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94710r4.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710r4.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710R4 board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,6 +38,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94712agr-sd-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr-sd-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board with sdram as l2 switch.
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -65,7 +65,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 wl0 wl1
--- src/shared.1927/nvram/bcm94712agr-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board with sdram.
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -74,4 +74,4 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712agr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -74,4 +74,4 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712ap-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712ap-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM4712ap board with SDRAM memory
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -49,10 +49,6 @@
 cctl=0
 ccode=0
 
-# It's an AP only
-router_disable=1
-lan_ifnames="eth0 eth1"
-
 # Bootlaoder variables
 dl_ram_addr=a0001000
 os_ram_addr=80001000
@@ -63,4 +59,9 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
+
+# glue between bootloader and OS
+landevs=et0 wl0
+wandevs=
+
--- src/shared.1927/nvram/bcm94712ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM4712ap board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -49,9 +49,9 @@
 cctl=0
 ccode=0
 
-# It's an AP only
-router_disable=1
-lan_ifnames="eth0 eth1"
+# glue between bootloader and OS
+landevs=et0 wl0
+wandevs=
 
 # Bootlaoder variables
 dl_ram_addr=a0001000
@@ -63,4 +63,4 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712lgr-sd-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sd-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR SDR board as L2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712lgr-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR SDR board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -9,9 +9,10 @@
 # $Id$
 boardtype=0x0460
 boardnum=${serno}
-# Board revision 1.8
-boardrev=0x18
-boardflags=0x0758
+# Board revision 2.1 
+boardrev=0x21
+boardflags=0x1758
+# EXT_LNA enabled
 sromrev=2
 
 # MIPS clock frequency in MHz
@@ -40,9 +41,9 @@
 ag0=2
 pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x153d
-pa0b1=0xfb91
-pa0b2=0xfeb7
+pa0b0=0x183d
+pa0b1=0xf9fa
+pa0b2=0xfe74
 opo=8
 
 # Commons wireless parameters
--- src/shared.1927/nvram/bcm94712lgr-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR DDR board as L2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712lgr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR DDR board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712p.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712p.txt	2007-11-19 06:40:26.000000000 +0300
@@ -9,8 +9,8 @@
 # $Id$
 boardtype=0x0446
 boardnum=${serno}
-# Board revision 5.1
-boardrev=0x51
+# Board revision 6.0
+boardrev=0x60
 boardflags=0x48
 sromrev=2
 
@@ -55,4 +55,4 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm95350rg-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm95350rg-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM95350RG sdram board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -39,7 +39,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Make the d11 i/f single band
 wl0id=0x4320
--- src/shared.1927/nvram/bcm95350rg.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm95350rg.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM95350RG sdram board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -39,7 +39,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Make the d11 i/f single band
 wl0id=0x4320
--- src/shared.1927/nvram/nvram.c	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/nvram.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,23 +13,27 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmendian.h>
 #include <bcmnvram.h>
-#include <bcmutils.h>
 #include <sbsdram.h>
 
-extern struct nvram_tuple * BCMINIT(_nvram_realloc)(struct nvram_tuple *t, const char *name, const char *value);
-extern void BCMINIT(_nvram_free)(struct nvram_tuple *t);
-extern int BCMINIT(_nvram_read)(void *buf);
-
-char * BCMINIT(_nvram_get)(const char *name);
-int BCMINIT(_nvram_set)(const char *name, const char *value);
-int BCMINIT(_nvram_unset)(const char *name);
-int BCMINIT(_nvram_getall)(char *buf, int count);
-int BCMINIT(_nvram_commit)(struct nvram_header *header);
-int BCMINIT(_nvram_init)(void);
-void BCMINIT(_nvram_exit)(void);
+extern struct nvram_tuple * _nvram_realloc(struct nvram_tuple *t, const char *name,
+                                           const char *value);
+extern void _nvram_free(struct nvram_tuple *t);
+extern int _nvram_read(void *buf);
+
+char * _nvram_get(const char *name);
+int _nvram_set(const char *name, const char *value);
+int _nvram_unset(const char *name);
+int _nvram_getall(char *buf, int count);
+int _nvram_commit(struct nvram_header *header);
+int _nvram_init(void *sb);
+void _nvram_exit(void);
+uint8 nvram_calc_crc(struct nvram_header * nvh);
 
 static struct nvram_tuple * BCMINITDATA(nvram_hash)[257];
 static struct nvram_tuple * nvram_dead;
@@ -42,23 +46,23 @@
 	struct nvram_tuple *t, *next;
 
 	/* Free hash table */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = next) {
 			next = t->next;
-			BCMINIT(_nvram_free)(t);
+			_nvram_free(t);
 		}
-		BCMINIT(nvram_hash)[i] = NULL;
+		nvram_hash[i] = NULL;
 	}
 
 	/* Free dead table */
 	for (t = nvram_dead; t; t = next) {
 		next = t->next;
-		BCMINIT(_nvram_free)(t);
+		_nvram_free(t);
 	}
 	nvram_dead = NULL;
 
 	/* Indicate to per-port code that all tuples have been freed */
-	BCMINIT(_nvram_free)(NULL);
+	_nvram_free(NULL);
 }
 
 /* String hash */
@@ -80,7 +84,7 @@
 	char buf[] = "0xXXXXXXXX", *name, *value, *end, *eq;
 
 	/* (Re)initialize hash table */
-	BCMINIT(nvram_free)();
+	nvram_free();
 
 	/* Parse and set "name=value\0 ... \0\0" */
 	name = (char *) &header[1];
@@ -91,26 +95,26 @@
 			break;
 		*eq = '\0';
 		value = eq + 1;
-		BCMINIT(_nvram_set)(name, value);
+		_nvram_set(name, value);
 		*eq = '=';
 	}
 
 	/* Set special SDRAM parameters */
-	if (!BCMINIT(_nvram_get)("sdram_init")) {
+	if (!_nvram_get("sdram_init")) {
 		sprintf(buf, "0x%04X", (uint16)(header->crc_ver_init >> 16));
-		BCMINIT(_nvram_set)("sdram_init", buf);
+		_nvram_set("sdram_init", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_config")) {
+	if (!_nvram_get("sdram_config")) {
 		sprintf(buf, "0x%04X", (uint16)(header->config_refresh & 0xffff));
-		BCMINIT(_nvram_set)("sdram_config", buf);
+		_nvram_set("sdram_config", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_refresh")) {
+	if (!_nvram_get("sdram_refresh")) {
 		sprintf(buf, "0x%04X", (uint16)((header->config_refresh >> 16) & 0xffff));
-		BCMINIT(_nvram_set)("sdram_refresh", buf);
+		_nvram_set("sdram_refresh", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_ncdl")) {
+	if (!_nvram_get("sdram_ncdl")) {
 		sprintf(buf, "0x%08X", header->config_ncdl);
-		BCMINIT(_nvram_set)("sdram_ncdl", buf);
+		_nvram_set("sdram_ncdl", buf);
 	}
 
 	return 0;
@@ -118,7 +122,7 @@
 
 /* Get the value of an NVRAM variable. Should be locked. */
 char * 
-BCMINITFN(_nvram_get)(const char *name)
+_nvram_get(const char *name)
 {
 	uint i;
 	struct nvram_tuple *t;
@@ -128,17 +132,17 @@
 		return NULL;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (t = BCMINIT(nvram_hash)[i]; t && strcmp(t->name, name); t = t->next);
+	for (t = nvram_hash[i]; t && strcmp(t->name, name); t = t->next);
 
 	value = t ? t->value : NULL;
 
 	return value;
 }
 
-/* Get the value of an NVRAM variable. Should be locked. */
+/* Set the value of an NVRAM variable. Should be locked. */
 int 
 BCMINITFN(_nvram_set)(const char *name, const char *value)
 {
@@ -146,13 +150,14 @@
 	struct nvram_tuple *t, *u, **prev;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (prev = &BCMINIT(nvram_hash)[i], t = *prev; t && strcmp(t->name, name); prev = &t->next, t = *prev);
+	for (prev = &nvram_hash[i], t = *prev; t && strcmp(t->name, name);
+	     prev = &t->next, t = *prev);
 
 	/* (Re)allocate tuple */
-	if (!(u = BCMINIT(_nvram_realloc)(t, name, value)))
+	if (!(u = _nvram_realloc(t, name, value)))
 		return -12; /* -ENOMEM */
 
 	/* Value reallocated */
@@ -167,8 +172,8 @@
 	}
 
 	/* Add new tuple to the hash table */
-	u->next = BCMINIT(nvram_hash)[i];
-	BCMINIT(nvram_hash)[i] = u;
+	u->next = nvram_hash[i];
+	nvram_hash[i] = u;
 
 	return 0;
 }
@@ -184,10 +189,11 @@
 		return 0;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (prev = &BCMINIT(nvram_hash)[i], t = *prev; t && strcmp(t->name, name); prev = &t->next, t = *prev);
+	for (prev = &nvram_hash[i], t = *prev; t && strcmp(t->name, name);
+	     prev = &t->next, t = *prev);
 
 	/* Move it to the dead table */
 	if (t) {
@@ -201,7 +207,7 @@
 
 /* Get all NVRAM variables. Should be locked. */
 int 
-BCMINITFN(_nvram_getall)(char *buf, int count)
+_nvram_getall(char *buf, int count)
 {
 	uint i;
 	struct nvram_tuple *t;
@@ -210,8 +216,8 @@
 	bzero(buf, count);
 
 	/* Write name=value\0 ... \0\0 */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = t->next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = t->next) {
 			if ((count - len) > (strlen(t->name) + 1 + strlen(t->value) + 1))
 				len += sprintf(buf + len, "%s=%s", t->name, t->value) + 1;
 			else
@@ -230,16 +236,14 @@
 	char *ptr, *end;
 	int i;
 	struct nvram_tuple *t;
-	struct nvram_header tmp;
-	uint8 crc;
 
 	/* Regenerate header */
 	header->magic = NVRAM_MAGIC;
 	header->crc_ver_init = (NVRAM_VERSION << 8);
-	if (!(init = BCMINIT(_nvram_get)("sdram_init")) ||
-	    !(config = BCMINIT(_nvram_get)("sdram_config")) ||
-	    !(refresh = BCMINIT(_nvram_get)("sdram_refresh")) ||
-	    !(ncdl = BCMINIT(_nvram_get)("sdram_ncdl"))) {
+	if (!(init = _nvram_get("sdram_init")) ||
+	    !(config = _nvram_get("sdram_config")) ||
+	    !(refresh = _nvram_get("sdram_refresh")) ||
+	    !(ncdl = _nvram_get("sdram_ncdl"))) {
 		header->crc_ver_init |= SDRAM_INIT << 16;
 		header->config_refresh = SDRAM_CONFIG;
 		header->config_refresh |= SDRAM_REFRESH << 16;
@@ -259,8 +263,8 @@
 	end = (char *) header + NVRAM_SPACE - 2;
 
 	/* Write out all tuples */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = t->next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = t->next) {
 			if ((ptr + strlen(t->name) + 1 + strlen(t->value) + 1) > end)
 				break;
 			ptr += sprintf(ptr, "%s=%s", t->name, t->value) + 1;
@@ -273,43 +277,31 @@
 	/* Set new length */
 	header->len = ROUNDUP(ptr - (char *) header, 4);
 
-	/* Little-endian CRC8 over the last 11 bytes of the header */
-	tmp.crc_ver_init = htol32(header->crc_ver_init);
-	tmp.config_refresh = htol32(header->config_refresh);
-	tmp.config_ncdl = htol32(header->config_ncdl);
-	crc = hndcrc8((char *) &tmp + 9, sizeof(struct nvram_header) - 9, CRC8_INIT_VALUE);
-
-	/* Continue CRC8 over data bytes */
-	crc = hndcrc8((char *) &header[1], header->len - sizeof(struct nvram_header), crc);
-
 	/* Set new CRC8 */
-	header->crc_ver_init |= crc;
+	header->crc_ver_init |= nvram_calc_crc(header);
 
 	/* Reinitialize hash table */
-	return BCMINIT(nvram_rehash)(header);
+	return nvram_rehash(header);
 }
 
 /* Initialize hash table. Should be locked. */
 int 
-BCMINITFN(_nvram_init)(void)
+BCMINITFN(_nvram_init)(void *sb)
 {
 	struct nvram_header *header;
 	int ret;
-	void *osh;
 
-	/* get kernel osl handler */
-	osh = osl_attach(NULL);
 
-	if (!(header = (struct nvram_header *) MALLOC(osh, NVRAM_SPACE))) {
-		printf("nvram_init: out of memory, malloced %d bytes\n", MALLOCED(osh));
+	if (!(header = (struct nvram_header *) MALLOC(sb_osh(sb), NVRAM_SPACE))) {
+		printf("nvram_init: out of memory\n");
 		return -12; /* -ENOMEM */
 	}
 
-	if ((ret = BCMINIT(_nvram_read)(header)) == 0 &&
+	if ((ret = _nvram_read(header)) == 0 &&
 	    header->magic == NVRAM_MAGIC)
-		BCMINIT(nvram_rehash)(header);
+		nvram_rehash(header);
 
-	MFREE(osh, header, NVRAM_SPACE);
+	MFREE(sb_osh(sb), header, NVRAM_SPACE);
 	return ret;
 }
 
@@ -317,5 +309,27 @@
 void 
 BCMINITFN(_nvram_exit)(void)
 {
-	BCMINIT(nvram_free)();
+	nvram_free();
+}
+
+/* returns the CRC8 of the nvram */
+uint8
+BCMINITFN(nvram_calc_crc)(struct nvram_header * nvh)
+{
+	struct nvram_header tmp;
+	uint8 crc;
+
+	/* Little-endian CRC8 over the last 11 bytes of the header */
+	tmp.crc_ver_init = htol32((nvh->crc_ver_init & NVRAM_CRC_VER_MASK));
+	tmp.config_refresh = htol32(nvh->config_refresh);
+	tmp.config_ncdl = htol32(nvh->config_ncdl);
+
+	crc = hndcrc8((uint8 *) &tmp + NVRAM_CRC_START_POSITION,
+		sizeof(struct nvram_header) - NVRAM_CRC_START_POSITION,
+		CRC8_INIT_VALUE);
+
+	/* Continue CRC8 over data bytes */
+	crc = hndcrc8((uint8 *) &nvh[1], nvh->len - sizeof(struct nvram_header), crc);
+
+	return crc;
 }
--- src/shared.1927/nvram/README	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/README	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvramstubs.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/nvramstubs.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,7 +12,10 @@
  * $Id$
  */
 
-#include <osl.h>
+#include <typedefs.h>
+#include <bcmutils.h>
+#undef strcmp
+#define strcmp(s1,s2)	0	/* always match */
 #include <bcmnvram.h>
 
 int
@@ -21,8 +24,14 @@
 	return 0;
 }
 
+int
+nvram_append(void *sb, char *vars, uint varsz)
+{
+	return 0;
+}
+
 void
-nvram_exit(void)
+nvram_exit(void *sbh)
 {
 }
 
@@ -53,5 +62,9 @@
 int
 nvram_getall(char *buf, int count)
 {
+	/* add null string as terminator */
+	if (count < 1)
+		return BCME_BUFTOOSHORT;
+	*buf = '\0';
 	return 0;
 }
--- src/shared.1927/sbsdram.S	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/sbsdram.S	2007-11-19 06:40:26.000000000 +0300
@@ -78,6 +78,9 @@
  */
 
 
+	.text
+	.set	mips32
+
 	LEAF(board_draminit)
 	.set	noreorder
 
@@ -112,7 +115,7 @@
 1:	li	t0,PHYSADDR_MASK
 	and	t0,t0,ra
 	li	t1,SB_FLASH1
-	blt	t0,t1,szmem
+	blt	t0,t1,memprio_szmem
 	nop
 
 	/* For socram we don't need any nvram parms, just do a core reset */
@@ -121,7 +124,7 @@
 	bal	sb_core_reset
 	li	a2,0
 	/* and size memory */
-	b	szmem
+	b	memprio_szmem
 	nop
 
 read_nvram:
@@ -134,15 +137,19 @@
 	nop
 
 	/* It is a chipcommon core: */
-	/* 1: Isolate corerev in v1 */
+	/* 1: Isolate memc's corerev in v1 */
+	and	t2,v1,SBIDH_RCE_MASK
+	srl	t2,t2,SBIDH_RCE_SHIFT
 	and	v1,v1,SBIDH_RC_MASK
+	or	v1,t2
 
 	/* 1.5: 5365a0 lies about its revision, it is really 1 */
 	bnez	v1,1f
 	nop
-	lw	t1,0(t0)		# Check chipid
-	andi	t1,CID_ID_MASK
-	bne	t1,BCM5365_DEVICE_ID,1f
+
+	lw	t1,CC_CHIPID(t0)		# Get chipid
+	andi	t1,CID_ID_MASK			# Check chipid
+	bne	t1,BCM5365_CHIP_ID,1f
 	nop
 	li	v1,1
 
@@ -159,11 +166,11 @@
 
 find_nvram:
 	li	t3,FLASH_MIN 
-	li	t0, NVRAM_MAGIC
+	li	t0,NVRAM_MAGIC
 
 1:
 	add	a2,t2,t3
-	lw	t1, 0(a2)
+	lw	t1,0(a2)
 	beq	t0,t1,read_parms
 	nop
 
@@ -261,7 +268,7 @@
 	TRACE(1, dll)
 	andi	dll,dll,0xfe
 	srl	dll,dll,1
-	beqz	dll,szmem		/* If zero, leave the default values */
+	beqz	dll,memprio_szmem		/* If zero, leave the default values */
 	nop
 
 	move	wrlim,dll		/* dll value is lim for wr, rd and g */
@@ -387,7 +394,7 @@
 	bal	ddr_do_init
 	nop
 
-	b	szmem
+	b	memprio_szmem
 	nop
 
 memc_sdr_init:
@@ -535,7 +542,7 @@
 	bal	sdr_do_init
 	nop
 
-	b	szmem
+	b	memprio_szmem
 	nop
 
 sdram_init:
@@ -570,30 +577,71 @@
 	sw	t2, 8(a0)		# SDRAM refresh
 
 
+	/* Change the memory priority inversion counter value */
 	/* Determine memory size and return */
-szmem:
-	lw	t0,(SBCONFIGOFF + SBIDHIGH)(a0)
-	and	t0,t0,SBIDH_CC_MASK
-	srl	t0,t0,SBIDH_CC_SHIFT
-	bne	t0,SB_SOCRAM,szmem_alias
+memprio_szmem:
+
+#ifdef APPLE
+	lw	t0, MEMC_PRIORINV(a0) 
+	li 	t1, 0xFFFF0000
+	and     t0, t0, t1
+	ori	t0, t0, 0x1
+	sw      t0, MEMC_PRIORINV(a0)
+#else
+	li	t0,KSEG1ADDR(SB_ENUM_BASE)	# is there a chipcommon core?
+	lw	t1,(SBCONFIGOFF + SBIDHIGH)(t0)
+	and	t1,t1,SBIDH_CC_MASK
+	srl	t1,t1,SBIDH_CC_SHIFT
+	bne	t1,SB_CC,0f
+	nop
+	lw	t1,CC_CHIPID(t0)		# is this BCM4785 chip?
+	and	t1,t1,CID_ID_MASK
+	bne	t1,BCM4785_CHIP_ID,0f
+	nop
+	lw	t0,MEMC_PRIORINV(a0)		# change PriorInvTim to 2
+	and     t0,t0,0xFFFF0000
+	ori	t0,t0,0x02
+	sw      t0,MEMC_PRIORINV(a0)
+#endif
+0:	lw	t0,(SBCONFIGOFF + SBIDHIGH)(a0)
+	and	t1,t0,SBIDH_CC_MASK
+	srl	t1,t1,SBIDH_CC_SHIFT
+	bne	t1,SB_SOCRAM,szmem_alias
 	nop
 
 	/* The socram core tells us how much memory there is */
-	lw	t0,SOCRAM_MEMSIZE(a0)
-	addi	t0,SOCRAM_MEMSIZE_BASESHIFT
+	lw	t1,SR_COREINFO(a0)
+	and	t0,t0,SBIDH_RC_MASK		/* Find corerev */
+	beq	t0,zero,crev0
+
+	/* Its corerev >= 1 */
+	and	t2,t1,SRCI_SRNB_MASK		/* Find number of blocks */
+	srl	t2,t2,SRCI_SRNB_SHIFT
+	and	t1,t1,SRCI_SRBSZ_MASK		/* Find block size */
+	addi	t1,t1,SR_BSZ_BASE
+	li	t0,1
+	sll	t0,t0,t1
+	mul	v0,t0,t2
+	jr	t6
+	nop
+
+crev0:
+	and	t1,t1,SRCI_MS0_MASK
+	add	t1,t1,SR_MS0_BASE
 	li	v0,1
-	sll	v0,v0,t0
+	sll	v0,v0,t1
 	jr	t6
 	nop
 	
 szmem_alias:
 	li	t0,KSEG1
 	li	t2,0xaa55beef
-	sw	t2,0(t0)
+	sw	zero,0(t0)
 	li	v0,(1 << 20)
 
-1:
-	or	t0,v0,KSEG1
+1:	or	t0,v0,KSEG1
+	sw	t2,0(t0)
+	li	t0,KSEG1
 	lw	t1,0(t0)
 	beq	t1,t2,done
 	nop
@@ -711,7 +759,7 @@
 	 *	t3:	memc rd ncdl value
 	 *	t4:	memc g ncdl value
 	 *
-	 * Uses a1, t7, t8, t9 (here and by calling sb_core_reset)
+	 * Uses a1, a2, t7, t8, t9 (here and by calling sb_core_reset)
 	 */
 ddr_do_init:
 
@@ -723,6 +771,8 @@
 
 	li	a1,MEMC_CONFIG_INIT
 	or	a1,a1,t0
+	lui	a2, 0x8			# set DQMGate for memc rev 4 or more
+	or	a1, a1, a2
 	sw	a1,MEMC_CONFIG(a0)
 
 	li	a1,MEMC_DRAMTIM25_INIT	# Assume CAS latency of 2.5
@@ -733,7 +783,48 @@
 1:	
 	sw	a1,MEMC_DRAMTIM(a0)
 
-	andi	t8,t3,0xff
+#ifndef	BCM_ATE
+	li	t8,KSEG1ADDR(SB_ENUM_BASE)	# Get package options
+	lw	a1,CC_CHIPID(t8)		# Get chipid
+	li	t9,CID_PKG_MASK			# Check package options
+	and	a1,a1,t9
+	srl	a1,a1,CID_PKG_SHIFT
+	addi	t8,SBCONFIGOFF			# Get corerev for chipcommon
+	lw	a2,SBIDHIGH(t8)
+	li	t8,SBIDH_RCE_MASK
+	and	t8,t8,a2
+	srl	t8,SBIDH_RCE_SHIFT
+	li	t9,SBIDH_RC_MASK
+	and	t9,t9,a2
+	or	t8,t8,t9
+	bge	t8,10,1f			# If ccrev is >= 10 use 4bit pkg opt
+	nop
+	ori	a1,8				#  else add a bit to the 3bit field
+1:
+	beq	a1,HDLSIM_PKG_ID,hdlsim		# Special case for hdl sim:
+	nop
+
+	li	t8,KSEG1ADDR(SB_ENUM_BASE)	# Get chipid again
+	lw	a2,CC_CHIPID(t8)
+	li	t9,BCM5350_CHIP_ID		# 5350 ChipID
+	li	t8,CID_ID_MASK
+	and	t8,t8,a2
+	bne	t8,t9,notsim			# if not 5350keep going
+	nop
+
+	bne	a1,(8 | HDLSIM5350_PKG_ID),notsim	# If 5350, is it (3/4-bit) vsim?
+	nop
+#endif	/* !BCM_ATE */
+
+hdlsim:
+	li	a1,MEMC_RDNCDLCOR_SIMINIT	#  Fixed 0xf6 rdncdl and no inits
+	sw	a1,MEMC_RDNCDLCOR(a0)		#  of wrncdl, dqsgate and miscdly.
+
+#ifndef	BCM_ATE
+	b	simskip
+	nop
+
+notsim:	andi	t8,t3,0xff
 	sll	a1,t8,8			# Replicate rd ncdl 4 times
 	or	a1,a1,t8
 	sll	t8,a1,16
@@ -764,7 +855,9 @@
 	li	a1,MEMC_MISCDLYCTL_INIT
 2:
 	sw	a1,MEMC_MISCDLYCTL(a0)
+#endif	/* !BCM_ATE */
 
+simskip:
 	li	a1,MEMC_NCDLCTL_INIT
 	sw	a1,MEMC_NCDLCTL(a0)
 
--- src/shared.1927/sbutils.c	2004-12-03 22:05:11.000000000 +0300
+++ src/shared/sbutils.c	2007-11-19 06:57:06.000000000 +0300
@@ -13,36 +13,43 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmdevs.h>
 #include <sbconfig.h>
 #include <sbchipc.h>
 #include <sbpci.h>
+#include <sbpcie.h>
 #include <pcicfg.h>
 #include <sbpcmcia.h>
-#include <sbextif.h>
-#include <sbutils.h>
+#include <sbsocram.h>
+#include <bcmnvram.h>
 #include <bcmsrom.h>
+#include <hndpmu.h>
 
 /* debug/trace */
 #define	SB_ERROR(args)
 
-
-#define CLOCK_BASE_5350		12500000 /* Specific to 5350*/
+#define	SB_MSG(args)
 
 typedef uint32 (*sb_intrsoff_t)(void *intr_arg);
 typedef void (*sb_intrsrestore_t)(void *intr_arg, uint32 arg);
 typedef bool (*sb_intrsenabled_t)(void *intr_arg);
 
+typedef struct gpioh_item {
+	void			*arg;
+	bool			level;
+	gpio_handler_t		handler;
+	uint32			event;
+	struct gpioh_item	*next;
+} gpioh_item_t;
+
 /* misc sb info needed by some of the routines */
 typedef struct sb_info {
-	uint	chip;			/* chip number */
-	uint	chiprev;		/* chip revision */
-	uint	chippkg;		/* chip package option */
-	uint	boardtype;		/* board type */
-	uint	boardvendor;		/* board vendor id */
-	uint	bustype;		/* what bus type we are going through */
+
+	struct sb_pub  	sb;		/* back plane public state (must be first field) */
 
 	void	*osh;			/* osl os handle */
 	void	*sdh;			/* bcmsdh handle */
@@ -52,49 +59,97 @@
 
 	uint	curidx;			/* current core index */
 	uint	dev_coreid;		/* the core provides driver functions */
-	uint	pciidx;			/* pci core index */
-	uint	pcirev;			/* pci core rev */
 
-	uint	pcmciaidx;		/* pcmcia core index */
-	uint	pcmciarev;		/* pcmcia core rev */
 	bool	memseg;			/* flag to toggle MEM_SEG register */
 
-	uint	ccrev;			/* chipc core rev */
-
-	uint	gpioidx;		/* gpio control core index */
-	uint	gpioid;			/* gpio control coretype */
-
 	uint	numcores;		/* # discovered cores */
 	uint	coreid[SB_MAXCORES];	/* id of each core */
+	uint32	coresba[SB_MAXCORES];	/* backplane address of each core */
 
 	void	*intr_arg;		/* interrupt callback function arg */
-	sb_intrsoff_t		intrsoff_fn;		/* function turns chip interrupts off */
-	sb_intrsrestore_t	intrsrestore_fn;	/* function restore chip interrupts */
-	sb_intrsenabled_t	intrsenabled_fn;	/* function to check if chip interrupts are enabled */
+	sb_intrsoff_t intrsoff_fn;	/* turns chip interrupts off */
+	sb_intrsrestore_t intrsrestore_fn; /* restore chip interrupts */
+	sb_intrsenabled_t intrsenabled_fn; /* check if interrupts are enabled */
+
+	uint8	pciecap_lcreg_offset; /* PCIE capability LCreg offset in the config space */
+	bool	pr42767_war; 
+	uint8	pcie_polarity; 
+	bool pcie_war_ovr; /* Override ASPM/Clkreq settings */
+
+	uint8 pmecap_offset;	/* PM Capability offset in the config space */
+	bool pmecap;		/* Capable of generating PME */
+
+	gpioh_item_t *gpioh_head; 	/* GPIO event handlers list */
+
+	char *vars;
+	uint varsz;
 } sb_info_t;
 
 /* local prototypes */
-static void* BCMINIT(sb_doattach)(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
-static void BCMINIT(sb_scan)(sb_info_t *si);
-static uint sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val);
-static uint _sb_coreidx(void *sbh);
-static uint sb_findcoreidx(void *sbh, uint coreid, uint coreunit);
-static uint BCMINIT(sb_pcidev2chip)(uint pcidev);
-static uint BCMINIT(sb_chip2numcores)(uint chip);
-
-#define	SB_INFO(sbh)	(sb_info_t*)sbh
-#define	SET_SBREG(sbh, r, mask, val)	W_SBREG((sbh), (r), ((R_SBREG((sbh), (r)) & ~(mask)) | (val)))
-#define	GOODCOREADDR(x)	(((x) >= SB_ENUM_BASE) && ((x) <= SB_ENUM_LIM) && ISALIGNED((x), SB_CORE_SIZE))
+static sb_info_t * sb_doattach(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+                               uint bustype, void *sdh, char **vars, uint *varsz);
+static void sb_scan(sb_info_t *si, void *regs, uint devid);
+static uint _sb_coreidx(sb_info_t *si, uint32 sba);
+static uint _sb_scan(sb_info_t *si, uint32 sba, void *regs, uint bus, uint32 sbba,
+                     uint ncores);
+static uint32 _sb_coresba(sb_info_t *si);
+static void *_sb_setcoreidx(sb_info_t *si, uint coreidx);
+static uint sb_chip2numcores(uint chip);
+static bool sb_ispcie(sb_info_t *si);
+static uint8 sb_find_pci_capability(sb_info_t *si, uint8 req_cap_id,
+                                    uchar *buf, uint32 *buflen);
+static int sb_pci_fixcfg(sb_info_t *si);
+/* routines to access mdio slave device registers */
+static int sb_pcie_mdiowrite(sb_info_t *si,  uint physmedia, uint readdr, uint val);
+static int sb_pcie_mdioread(sb_info_t *si,  uint physmedia, uint readdr, uint *ret_val);
+
+/* dev path concatenation util */
+static char *sb_devpathvar(sb_t *sbh, char *var, int len, const char *name);
+
+/* WARs */
+static void sb_war43448(sb_t *sbh);
+static void sb_war43448_aspm(sb_t *sbh);
+static void sb_war32414_forceHT(sb_t *sbh, bool forceHT);
+static void sb_war30841(sb_info_t *si);
+static void sb_war42767(sb_t *sbh);
+static void sb_war42767_clkreq(sb_t *sbh);
+
+/* delay needed between the mdio control/ mdiodata register data access */
+#define PR28829_DELAY() OSL_DELAY(10)
+
+/* size that can take bitfielddump */
+#define BITFIELD_DUMP_SIZE  32
+
+/* global variable to indicate reservation/release of gpio's */
+static uint32 sb_gpioreservation = 0;
+
+/* global flag to prevent shared resources from being initialized multiple times in sb_attach() */
+static bool sb_onetimeinit = FALSE;
+
+#define	SB_INFO(sbh)	(sb_info_t*)(uintptr)sbh
+#define	SET_SBREG(si, r, mask, val)	\
+		W_SBREG((si), (r), ((R_SBREG((si), (r)) & ~(mask)) | (val)))
+#define	GOODCOREADDR(x, b) (((x) >= (b)) && ((x) < ((b) + SB_MAXCORES * SB_CORE_SIZE)) && \
+		ISALIGNED((x), SB_CORE_SIZE))
 #define	GOODREGS(regs)	((regs) && ISALIGNED((uintptr)(regs), SB_CORE_SIZE))
 #define	REGS2SB(va)	(sbconfig_t*) ((int8*)(va) + SBCONFIGOFF)
+#define BADCOREADDR	0
 #define	GOODIDX(idx)	(((uint)idx) < SB_MAXCORES)
 #define	BADIDX		(SB_MAXCORES+1)
-#define	NOREV		(SBIDH_RC_MASK + 1)
+#define	NOREV		-1		/* Invalid rev */
 
-#define	R_SBREG(sbh, sbr)	sb_read_sbreg((sbh), (sbr))
-#define	W_SBREG(sbh, sbr, v)	sb_write_sbreg((sbh), (sbr), (v))
-#define	AND_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) & (v)))
-#define	OR_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) | (v)))
+#define PCI(si)		((BUSTYPE(si->sb.bustype) == PCI_BUS) && (si->sb.buscoretype == SB_PCI))
+#define PCIE(si)	((BUSTYPE(si->sb.bustype) == PCI_BUS) && (si->sb.buscoretype == SB_PCIE))
+#define PCMCIA(si)	((BUSTYPE(si->sb.bustype) == PCMCIA_BUS) && (si->memseg == TRUE))
+
+/* sonicsrev */
+#define	SONICS_2_2	(SBIDL_RV_2_2 >> SBIDL_RV_SHIFT)
+#define	SONICS_2_3	(SBIDL_RV_2_3 >> SBIDL_RV_SHIFT)
+
+#define	R_SBREG(si, sbr)	sb_read_sbreg((si), (sbr))
+#define	W_SBREG(si, sbr, v)	sb_write_sbreg((si), (sbr), (v))
+#define	AND_SBREG(si, sbr, v)	W_SBREG((si), (sbr), (R_SBREG((si), (sbr)) & (v)))
+#define	OR_SBREG(si, sbr, v)	W_SBREG((si), (sbr), (R_SBREG((si), (sbr)) | (v)))
 
 /*
  * Macros to disable/restore function core(D11, ENET, ILINE20, etc) interrupts before/
@@ -107,27 +162,37 @@
 	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
 		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
 
-/* power control defines */
+/* dynamic clock control defines */
 #define	LPOMINFREQ	25000			/* low power oscillator min */
 #define	LPOMAXFREQ	43000			/* low power oscillator max */
-#define	XTALMINFREQ	19800000		/* 20mhz - 1% */
-#define	XTALMAXFREQ	20200000		/* 20mhz + 1% */
-#define	PCIMINFREQ	25000000		/* 25mhz */
-#define	PCIMAXFREQ	34000000		/* 33mhz + fudge */
-#define SCC_DEF_DIV	0			/* default slow clock divider */
+#define	XTALMINFREQ		19800000	/* 20 MHz - 1% */
+#define	XTALMAXFREQ		20200000	/* 20 MHz + 1% */
+#define	PCIMINFREQ		25000000	/* 25 MHz */
+#define	PCIMAXFREQ		34000000	/* 33 MHz + fudge */
+
+#define	ILP_DIV_5MHZ		0		/* ILP = 5 MHz */
+#define	ILP_DIV_1MHZ		4		/* ILP = 1 MHz */
+
+/* force HT war check */
+#define FORCEHT_WAR32414(si)	\
+	(((PCIE(si)) && (si->sb.chip == BCM4311_CHIP_ID) && ((si->sb.chiprev <= 1))) || \
+	((PCI(si) || PCIE(si)) && (si->sb.chip == BCM4321_CHIP_ID) && (si->sb.chiprev <= 3)))
+
+#define PCIE_ASPMWARS(si)	\
+	((PCIE(si)) && ((si->sb.buscorerev >= 3) && (si->sb.buscorerev <= 5)))
+
+/* GPIO Based LED powersave defines */
+#define DEFAULT_GPIO_ONTIME	10		/* Default: 10% on */
+#define DEFAULT_GPIO_OFFTIME	90		/* Default: 10% on */
 
-#define XTAL_ON_DELAY		1000	/* Xtal power on delay in us */
-
-#define SCC_LOW2FAST_LIMIT	5000	/* turn on fast clock time, in unit of ms */
+#define DEFAULT_GPIOTIMERVAL  ((DEFAULT_GPIO_ONTIME << GPIO_ONTIME_SHIFT) | DEFAULT_GPIO_OFFTIME)
 
 static uint32
-sb_read_sbreg(void *sbh, volatile uint32 *sbr)
+sb_read_sbreg(sb_info_t *si, volatile uint32 *sbr)
 {
-	sb_info_t *si;
 	uint8 tmp;
 	uint32 val, intr_val = 0;
 
-	si = SB_INFO(sbh);
 
 	/*
 	 * compact flash only has 11 bits address, while we needs 12 bits address.
@@ -135,16 +200,16 @@
 	 * so we program MEM_SEG with 12th bit when necessary(access sb regsiters).
 	 * For normal PCMCIA bus(CFTable_regwinsz > 2k), do nothing special
 	 */
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		INTR_OFF(si, intr_val);
 		tmp = 1;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
-		(uintptr)sbr &= ~(1 << 11);	/* mask out bit 11*/
+		sbr = (volatile uint32 *)((uintptr)sbr & ~(1 << 11)); /* mask out bit 11 */
 	}
 
-	val = R_REG(sbr);
+	val = R_REG(si->osh, sbr);
 
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		tmp = 0;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
 		INTR_RESTORE(si, intr_val);
@@ -154,14 +219,12 @@
 }
 
 static void
-sb_write_sbreg(void *sbh, volatile uint32 *sbr, uint32 v)
+sb_write_sbreg(sb_info_t *si, volatile uint32 *sbr, uint32 v)
 {
-	sb_info_t *si;
 	uint8 tmp;
 	volatile uint32 dummy;
 	uint32 intr_val = 0;
 
-	si = SB_INFO(sbh);
 
 	/*
 	 * compact flash only has 11 bits address, while we needs 12 bits address.
@@ -169,29 +232,29 @@
 	 * so we program MEM_SEG with 12th bit when necessary(access sb regsiters).
 	 * For normal PCMCIA bus(CFTable_regwinsz > 2k), do nothing special
 	 */
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		INTR_OFF(si, intr_val);
 		tmp = 1;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
-		(uintptr)sbr &= ~(1 << 11);	/* mask out bit 11 */
+		sbr = (volatile uint32 *)((uintptr)sbr & ~(1 << 11)); /* mask out bit 11 */
 	}
 
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
 #ifdef IL_BIGENDIAN
-		dummy = R_REG(sbr);
-		W_REG(((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
-		dummy = R_REG(sbr);
-		W_REG((volatile uint16 *)sbr, (uint16)(v & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, ((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, (volatile uint16 *)sbr, (uint16)(v & 0xffff));
 #else
-		dummy = R_REG(sbr);
-		W_REG((volatile uint16 *)sbr, (uint16)(v & 0xffff));
-		dummy = R_REG(sbr);
-		W_REG(((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
-#endif
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, (volatile uint16 *)sbr, (uint16)(v & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, ((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
+#endif	/* IL_BIGENDIAN */
 	} else
-		W_REG(sbr, v);
+		W_REG(si->osh, sbr, v);
 
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		tmp = 0;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
 		INTR_RESTORE(si, intr_val);
@@ -207,8 +270,9 @@
  * vars - pointer to a pointer area for "environment" variables
  * varsz - pointer to int to return the size of the vars
  */
-void* 
-BCMINITFN(sb_attach)(uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz)
+sb_t *
+BCMINITFN(sb_attach)(uint devid, osl_t *osh, void *regs,
+                     uint bustype, void *sdh, char **vars, uint *varsz)
 {
 	sb_info_t *si;
 
@@ -218,11 +282,14 @@
 		return (NULL);
 	}
 
-	if (BCMINIT(sb_doattach)(si, devid, osh, regs, bustype, sdh, vars, varsz) == NULL) {
-		MFREE(osh, si, sizeof (sb_info_t));
+	if (sb_doattach(si, devid, osh, regs, bustype, sdh, vars, varsz) == NULL) {
+		MFREE(osh, si, sizeof(sb_info_t));
 		return (NULL);
 	}
-	return si;
+	si->vars = vars ? *vars : NULL;
+	si->varsz = varsz ? *varsz : 0;
+
+	return (sb_t *)si;
 }
 
 /* Using sb_kattach depends on SB_BUS support, either implicit  */
@@ -233,201 +300,318 @@
 static sb_info_t ksi;
 
 /* generic kernel variant of sb_attach() */
-void* 
-BCMINITFN(sb_kattach)()
+sb_t *
+BCMINITFN(sb_kattach)(osl_t *osh)
 {
-	uint32 *regs;
-	char *unused;
-	int varsz;
-
-	if (ksi.curmap == NULL) {
-		uint32 cid;
-
-		regs = (uint32 *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
-		cid = R_REG((uint32 *)regs);
-		if (((cid & CID_ID_MASK) == BCM4712_DEVICE_ID) &&
-		    ((cid & CID_PKG_MASK) != BCM4712LARGE_PKG_ID) &&
-		    ((cid & CID_REV_MASK) <= 0x00020000)) {
-			uint32 *scc, val;
-
-			scc = (uint32 *)((uchar*)regs + OFFSETOF(chipcregs_t, slow_clk_ctl));
-			val = R_REG(scc);
-			SB_ERROR(("    initial scc = 0x%x\n", val));
-			val |= SCC_SS_XTAL;
-			W_REG(scc, val);
-		}
+	static bool ksi_attached = FALSE;
+
+	if (!ksi_attached) {
+		void *regs = (void *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
 
-		if (BCMINIT(sb_doattach)(&ksi, BCM4710_DEVICE_ID, NULL, (void*)regs,
-			SB_BUS, NULL, &unused, &varsz) == NULL) {
+		if (sb_doattach(&ksi, BCM4710_DEVICE_ID, osh, regs,
+		                SB_BUS, NULL,
+		                osh != SB_OSH ? &ksi.vars : NULL,
+		                osh != SB_OSH ? &ksi.varsz : NULL) == NULL) {
+			SB_ERROR(("sb_kattach: sb_doattach failed\n"));
 			return NULL;
 		}
+
+		ksi_attached = TRUE;
 	}
 
-	return &ksi;
+	return &ksi.sb;
 }
-#endif
+#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SB_BUS) */
 
-static void* 
-BCMINITFN(sb_doattach)(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz)
+static sb_info_t *
+BCMINITFN(sb_doattach)(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+                       uint bustype, void *sdh, char **vars, uint *varsz)
 {
 	uint origidx;
 	chipcregs_t *cc;
+	sbconfig_t *sb;
 	uint32 w;
-	int res;
+	char *pvars;
 
 	ASSERT(GOODREGS(regs));
 
-	bzero((uchar*)si, sizeof (sb_info_t));
+	bzero((uchar*)si, sizeof(sb_info_t));
 
-	si->pciidx = si->gpioidx = BADIDX;
+	si->sb.buscoreidx = BADIDX;
 
-	si->osh = osh;
 	si->curmap = regs;
 	si->sdh = sdh;
+	si->osh = osh;
 
 	/* check to see if we are a sb core mimic'ing a pci core */
 	if (bustype == PCI_BUS) {
-		if (OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof (uint32)) == 0xffffffff)
+		if (OSL_PCI_READ_CONFIG(si->osh, PCI_SPROM_CONTROL, sizeof(uint32)) == 0xffffffff) {
+			SB_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SB "
+			          "devid:0x%x\n", __FUNCTION__, devid));
 			bustype = SB_BUS;
-		else
-			bustype = PCI_BUS;
 	}
-
-	si->bustype = bustype;
-	if (si->bustype != BUSTYPE(si->bustype)) {
+	}
+	si->sb.bustype = bustype;
+	if (si->sb.bustype != BUSTYPE(si->sb.bustype)) {
 		SB_ERROR(("sb_doattach: bus type %d does not match configured bus type %d\n",
-			  si->bustype, BUSTYPE(si->bustype)));
+		          si->sb.bustype, BUSTYPE(si->sb.bustype)));
 		return NULL;
 	}
 
 	/* need to set memseg flag for CF card first before any sb registers access */
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS)
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS)
 		si->memseg = TRUE;
 
 	/* kludge to enable the clock on the 4306 which lacks a slowclock */
-	if (BUSTYPE(si->bustype) == PCI_BUS)
-		sb_pwrctl_xtal((void*)si, XTAL|PLL, ON);
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS && !sb_ispcie(si))
+		sb_clkctl_xtal(&si->sb, XTAL|PLL, ON);
 
-	/* initialize current core index value */
-	si->curidx = _sb_coreidx((void*)si);
-	if (si->curidx == BADIDX) {
-		return NULL;
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32));
+		if (!GOODCOREADDR(w, SB_ENUM_BASE))
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32), SB_ENUM_BASE);
 	}
 
-	/* keep and reuse the initial register mapping */
-	origidx = si->curidx;
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		si->regs[origidx] = regs;
 
-	/* is core-0 a chipcommon core? */
-	si->numcores = 1;
-	cc = (chipcregs_t*) sb_setcoreidx((void*)si, 0);
-	if (sb_coreid((void*)si) != SB_CC)
-		cc = NULL;
-
-	/* determine chip id and rev */
-	if (cc) {
-		/* chip common core found! */
-		si->chip = R_REG(&cc->chipid) & CID_ID_MASK;
-		si->chiprev = (R_REG(&cc->chipid) & CID_REV_MASK) >> CID_REV_SHIFT;
-		si->chippkg = (R_REG(&cc->chipid) & CID_PKG_MASK) >> CID_PKG_SHIFT;
-	} else {
-		/* The only pcmcia chip without a chipcommon core is a 4301 */
-		if (BUSTYPE(si->bustype) == PCMCIA_BUS)
-			devid = BCM4301_DEVICE_ID;
-
-		/* no chip common core -- must convert device id to chip id */
-		if ((si->chip = BCMINIT(sb_pcidev2chip)(devid)) == 0) {
-			SB_ERROR(("sb_attach: unrecognized device id 0x%04x\n", devid));
+	/* get sonics backplane revision */
+	sb = REGS2SB(regs);
+	si->sb.sonicsrev = (R_SBREG(si, &sb->sbidlow) & SBIDL_RV_MASK) >> SBIDL_RV_SHIFT;
+
+	/* scan for cores */
+	sb_scan(si, regs, devid);
+
+	/* no cores found, bail out */
+	if (si->numcores == 0) {
+		SB_ERROR(("sb_doattach: could not find any cores\n"));
 			return NULL;
 		}
-	}
 
-	/* get chipcommon rev */
-	si->ccrev = cc ? sb_corerev((void*)si) : NOREV;
+	/* save the current core index */
+	origidx = si->curidx;
 
-	/* determine numcores */
-	if (cc && ((si->ccrev == 4) || (si->ccrev >= 6)))
-		si->numcores = (R_REG(&cc->chipid) & CID_CC_MASK) >> CID_CC_SHIFT;
-	else
-		si->numcores = BCMINIT(sb_chip2numcores)(si->chip);
+	/* don't go beyond if there is no chipc core in the chip */
+	if (!(cc = sb_setcore(&si->sb, SB_CC, 0)))
+		return si;
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS &&
+	    (si->sb.chip == BCM4712_CHIP_ID) &&
+	    (si->sb.chippkg != BCM4712LARGE_PKG_ID) &&
+	    (si->sb.chiprev <= 3))
+		OR_REG(si->osh, &cc->slow_clk_ctl, SCC_SS_XTAL);
+
+	/* fixup necessary chip/core configurations */
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS && sb_pci_fixcfg(si)) {
+		SB_ERROR(("sb_doattach: sb_pci_fixcfg failed\n"));
+		return NULL;
+	}
 
-	/* return to original core */
-	sb_setcoreidx((void*)si, origidx);
 
-	/* sanity checks */
-	ASSERT(si->chip);
+	/* Switch back to the original core, nvram/srom init needs it */
+	sb_setcoreidx(&si->sb, origidx);
 
-	/* scan for cores */
-	BCMINIT(sb_scan)(si);
+	/* Init nvram from flash if it exists */
+	//nvram_init((void *)&si->sb);
 
-	/* srom_var_init() depends on sb_scan() info */
-	if ((res = srom_var_init(si, si->bustype, si->curmap, osh, vars, varsz))) {
-		SB_ERROR(("sb_attach: srom_var_init failed: bad srom\n"));
+	/* Init nvram from sprom/otp if they exist */
+	if (srom_var_init(&si->sb, BUSTYPE(si->sb.bustype), regs, si->osh, vars, varsz)) {
+		SB_ERROR(("sb_doattach: srom_var_init failed: bad srom\n"));
 		return (NULL);
 	}
+	pvars = vars ? *vars : NULL;
 	
-	if (cc == NULL) {
-		/*
-		 * The chip revision number is hardwired into all
-		 * of the pci function config rev fields and is
-		 * independent from the individual core revision numbers.
-		 * For example, the "A0" silicon of each chip is chip rev 0.
-		 * For PCMCIA we get it from the CIS instead.
-		 */
-		if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-			ASSERT(vars);
-			si->chiprev = getintvar(*vars, "chiprev");
-		} else if (BUSTYPE(si->bustype) == PCI_BUS) {
-			w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_REV, sizeof (uint32));
-			si->chiprev = w & 0xff;
-		} else
-			si->chiprev = 0;
+	/* PMU specific initializations */
+	if ((si->sb.cccaps & CC_CAP_PMU) && !sb_onetimeinit) {
+		sb_pmu_init(&si->sb, si->osh);
+		/* Find out Crystal frequency and init PLL */
+		sb_pmu_pll_init(&si->sb, si->osh, getintvar(pvars, "xtalfreq"));
+		/* Initialize PMU resources (up/dn timers, dep masks, etc.) */
+		sb_pmu_res_init(&si->sb, si->osh);
 	}
 
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-		w = getintvar(*vars, "regwindowsz");
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+		w = getintvar(pvars, "regwindowsz");
 		si->memseg = (w <= CFTABLE_REGWIN_2K) ? TRUE : FALSE;
 	}
 
-	/* gpio control core is required */
-	if (!GOODIDX(si->gpioidx)) {
-		SB_ERROR(("sb_attach: gpio control core not found\n"));
-		return NULL;
-	}
-
 	/* get boardtype and boardrev */
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 	case PCI_BUS:
 		/* do a pci config read to get subsystem id and subvendor id */
-		w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_SVID, sizeof (uint32));
-		si->boardvendor = w & 0xffff;
-		si->boardtype = (w >> 16) & 0xffff;
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_SVID, sizeof(uint32));
+		/* Let nvram variables override subsystem Vend/ID */
+		if ((si->sb.boardvendor = (uint16)sb_getdevpathintvar(&si->sb, "boardvendor")) == 0)
+			si->sb.boardvendor = w & 0xffff;
+		else
+			SB_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n",
+			          si->sb.boardvendor, w & 0xffff));
+		if ((si->sb.boardtype = (uint16)sb_getdevpathintvar(&si->sb, "boardtype")) == 0)
+			si->sb.boardtype = (w >> 16) & 0xffff;
+		else
+			SB_ERROR(("Overriding boardtype: 0x%x instead of 0x%x\n",
+			          si->sb.boardtype, (w >> 16) & 0xffff));
 		break;
 
 	case PCMCIA_BUS:
-	case SDIO_BUS:
-		si->boardvendor = getintvar(*vars, "manfid");
-		si->boardtype = getintvar(*vars, "prodid");
+		si->sb.boardvendor = getintvar(pvars, "manfid");
+		si->sb.boardtype = getintvar(pvars, "prodid");
 		break;
 
 	case SB_BUS:
-		si->boardvendor = VENDOR_BROADCOM;
-		si->boardtype = 0xffff;
+	case JTAG_BUS:
+		si->sb.boardvendor = VENDOR_BROADCOM;
+		if (pvars == NULL || ((si->sb.boardtype = getintvar(pvars, "prodid")) == 0))
+			if ((si->sb.boardtype = getintvar(NULL, "boardtype")) == 0)
+				si->sb.boardtype = 0xffff;
 		break;
 	}
 
-	if (si->boardtype == 0) {
-		SB_ERROR(("sb_attach: unknown board type\n"));
-		ASSERT(si->boardtype);
+	if (si->sb.boardtype == 0) {
+		SB_ERROR(("sb_doattach: unknown board type\n"));
+		ASSERT(si->sb.boardtype);
+	}
+
+	si->sb.boardflags = getintvar(pvars, "boardflags");
+
+	/* setup the GPIO based LED powersave register */
+	if (si->sb.ccrev >= 16) {
+		if ((pvars == NULL) || ((w = getintvar(pvars, "leddc")) == 0))
+			w = DEFAULT_GPIOTIMERVAL;
+		sb_corereg(&si->sb, SB_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	}
+
+	/* Determine if this board needs override */
+	if (PCIE(si) && (si->sb.chip == BCM4321_CHIP_ID))
+		si->pcie_war_ovr = ((si->sb.boardvendor == VENDOR_APPLE) &&
+		                    ((uint8)getintvar(pvars, "sromrev") == 4) &&
+		                    ((uint8)getintvar(pvars, "boardrev") <= 0x71)) ||
+		        ((uint32)getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR);
+
+	if (PCIE_ASPMWARS(si)) {
+		sb_war43448_aspm((void *)si);
+		sb_war42767_clkreq((void *)si);
+	}
+
+	if (FORCEHT_WAR32414(si)) {
+		si->sb.pr32414 = TRUE;
+		sb_clkctl_init(&si->sb);
+		sb_war32414_forceHT(&si->sb, 1);
+	}
+
+	if (PCIE(si) && ((si->sb.buscorerev == 6) || (si->sb.buscorerev == 7)))
+		si->sb.pr42780 = TRUE;
+
+	if (PCIE_ASPMWARS(si))
+		sb_pcieclkreq(&si->sb, 1, 0);
+
+	if (PCIE(si) &&
+	    (((si->sb.chip == BCM4311_CHIP_ID) && (si->sb.chiprev == 2)) ||
+	     ((si->sb.chip == BCM4312_CHIP_ID) && (si->sb.chiprev == 0))))
+		sb_set_initiator_to(&si->sb, 0x3, sb_findcoreidx(&si->sb, SB_D11, 0));
+
+	/* Disable gpiopullup and gpiopulldown */
+	if (!sb_onetimeinit && si->sb.ccrev >= 20) {
+		cc = (chipcregs_t *)sb_setcore(&si->sb, SB_CC, 0);
+		W_REG(osh, &cc->gpiopullup, 0);
+		W_REG(osh, &cc->gpiopulldown, 0);
+		sb_setcoreidx(&si->sb, origidx);
 	}
 
 
-	return ((void*)si);
+#ifdef HNDRTE
+	sb_onetimeinit = TRUE;
+#endif
+
+	return (si);
+}
+
+/* Enable/Disable clkreq for PCIE (4311B0/4321B1) */
+void
+BCMINITFN(sb_war42780_clkreq)(sb_t *sbh, bool clkreq)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* Don't change clkreq value if serdespll war has not yet been applied */
+	if (!si->pr42767_war && PCIE_ASPMWARS(si))
+		return;
+
+	sb_pcieclkreq(sbh, 1, (int32)clkreq);
+}
+
+static void
+BCMINITFN(sb_war43448)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	/* Restore the polarity */
+	if (si->pcie_polarity != 0)
+		sb_pcie_mdiowrite((void *)(uintptr)&si->sb, MDIODATA_DEV_RX,
+		                  SERDES_RX_CTRL, si->pcie_polarity);
+}
+
+static void
+BCMINITFN(sb_war43448_aspm)(sb_t *sbh)
+{
+	uint32 w;
+	uint16 val16, *reg16;
+	sbpcieregs_t *pcieregs;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	/* no ASPM stuff on QT or VSIM */
+	if (si->sb.chippkg == HDLSIM_PKG_ID || si->sb.chippkg == HWSIM_PKG_ID)
+		return;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
+
+	/* Enable ASPM in the shadow SROM and Link control */
+	reg16 = &pcieregs->sprom[SRSH_ASPM_OFFSET];
+	val16 = R_REG(si->osh, reg16);
+	if (!si->pcie_war_ovr)
+		val16 |= SRSH_ASPM_ENB;
+	else
+		val16 &= ~SRSH_ASPM_ENB;
+	W_REG(si->osh, reg16, val16);
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+	if (!si->pcie_war_ovr)
+		w |= PCIE_ASPM_ENAB;
+	else
+		w &= ~PCIE_ASPM_ENAB;
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32), w);
+}
+
+static void
+BCMINITFN(sb_war32414_forceHT)(sb_t *sbh, bool forceHT)
+{
+	sb_info_t *si;
+	uint32 val = 0;
+
+	si = SB_INFO(sbh);
+
+	ASSERT(FORCEHT_WAR32414(si));
+
+
+	if (forceHT)
+		val = SYCC_HR;
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, system_clk_ctl),
+	           SYCC_HR, val);
 }
 
 uint
-sb_coreid(void *sbh)
+sb_coreid(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -435,37 +619,57 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
+	return ((R_SBREG(si, &sb->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
 }
 
 uint
-sb_coreidx(void *sbh)
+sb_flag(sb_t *sbh)
 {
 	sb_info_t *si;
+	sbconfig_t *sb;
 
 	si = SB_INFO(sbh);
-	return (si->curidx);
+	sb = REGS2SB(si->curmap);
+
+	return R_SBREG(si, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
 }
 
-/* return current index of core */
-static uint
-_sb_coreidx(void *sbh)
+uint
+sb_coreidx(sb_t *sbh)
 {
 	sb_info_t *si;
-	sbconfig_t *sb;
-	uint32 sbaddr = 0;
 
 	si = SB_INFO(sbh);
-	ASSERT(si);
+	return (si->curidx);
+}
 
-	switch (BUSTYPE(si->bustype)) {
-	case SB_BUS:
-		sb = REGS2SB(si->curmap);
-		sbaddr = sb_base(R_SBREG(sbh, &sb->sbadmatch0));
+/* return core index of the core with address 'sba' */
+static uint
+BCMINITFN(_sb_coreidx)(sb_info_t *si, uint32 sba)
+{
+	uint i;
+
+	for (i = 0; i < si->numcores; i ++)
+		if (sba == si->coresba[i])
+			return i;
+	return BADIDX;
+}
+
+/* return core address of the current core */
+static uint32
+BCMINITFN(_sb_coresba)(sb_info_t *si)
+{
+	uint32 sbaddr;
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case SB_BUS: {
+		sbconfig_t *sb = REGS2SB(si->curmap);
+		sbaddr = sb_base(R_SBREG(si, &sb->sbadmatch0));
 		break;
+	}
 
 	case PCI_BUS:
-		sbaddr = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof (uint32));
+		sbaddr = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32));
 		break;
 
 	case PCMCIA_BUS: {
@@ -470,27 +674,33 @@
 
 	case PCMCIA_BUS: {
 		uint8 tmp = 0;
-
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR0, &tmp, 1);
-		sbaddr  = (uint)tmp << 12;
+		sbaddr  = (uint32)tmp << 12;
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR1, &tmp, 1);
-		sbaddr |= (uint)tmp << 16;
+		sbaddr |= (uint32)tmp << 16;
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR2, &tmp, 1);
-		sbaddr |= (uint)tmp << 24;
+		sbaddr |= (uint32)tmp << 24;
 		break;
 	}
+
+
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		sbaddr = (uint32)(uintptr)si->curmap;
+		break;
+#endif	/* BCMJTAG */
+
 	default:
-		ASSERT(0);
+		sbaddr = BADCOREADDR;
+		break;
 	}
 
-	if (!GOODCOREADDR(sbaddr))
-		return BADIDX;
-
-	return ((sbaddr - SB_ENUM_BASE) / SB_CORE_SIZE);
+	SB_MSG(("_sb_coresba: current core is 0x%08x\n", sbaddr));
+	return sbaddr;
 }
 
 uint
-sb_corevendor(void *sbh)
+sb_corevendor(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -498,23 +708,25 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
+	return ((R_SBREG(si, &sb->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
 }
 
 uint
-sb_corerev(void *sbh)
+sb_corerev(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
+	uint sbidh;
 
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
+	sbidh = R_SBREG(si, &sb->sbidhigh);
 
-	return (R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_RC_MASK);
+	return (SBCOREREV(sbidh));
 }
 
 void *
-sb_osh(void *sbh)
+sb_osh(sb_t *sbh)
 {
 	sb_info_t *si;
 
@@ -522,11 +734,40 @@
 	return si->osh;
 }
 
-#define	SBTML_ALLOW	(SBTML_PE | SBTML_FGC | SBTML_FL_MASK)
+void
+sb_setosh(sb_t *sbh, osl_t *osh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	if (si->osh != NULL) {
+		SB_ERROR(("osh is already set....\n"));
+		ASSERT(!si->osh);
+	}
+	si->osh = osh;
+}
+
+/* set sbtmstatelow core-specific flags */
+void
+sb_coreflags_wo(sb_t *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint32 w;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	ASSERT((val & ~mask) == 0);
+
+	/* mask and set */
+	w = (R_SBREG(si, &sb->sbtmstatelow) & ~mask) | val;
+	W_SBREG(si, &sb->sbtmstatelow, w);
+}
 
 /* set/clear sbtmstatelow core-specific flags */
 uint32
-sb_coreflags(void *sbh, uint32 mask, uint32 val)
+sb_coreflags(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -536,21 +777,22 @@
 	sb = REGS2SB(si->curmap);
 
 	ASSERT((val & ~mask) == 0);
-	ASSERT((mask & ~SBTML_ALLOW) == 0);
 
 	/* mask and set */
 	if (mask || val) {
-		w = (R_SBREG(sbh, &sb->sbtmstatelow) & ~mask) | val;
-		W_SBREG(sbh, &sb->sbtmstatelow, w);
+		w = (R_SBREG(si, &sb->sbtmstatelow) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatelow, w);
 	}
 
-	/* return the new value */
-	return (R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_ALLOW);
+	/* return the new value
+	 * for write operation, the following readback ensures the completion of write opration.
+	 */
+	return (R_SBREG(si, &sb->sbtmstatelow));
 }
 
 /* set/clear sbtmstatehigh core-specific flags */
 uint32
-sb_coreflagshi(void *sbh, uint32 mask, uint32 val)
+sb_coreflagshi(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -564,16 +806,41 @@
 
 	/* mask and set */
 	if (mask || val) {
-		w = (R_SBREG(sbh, &sb->sbtmstatehigh) & ~mask) | val;
-		W_SBREG(sbh, &sb->sbtmstatehigh, w);
+		w = (R_SBREG(si, &sb->sbtmstatehigh) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatehigh, w);
 	}
 
 	/* return the new value */
-	return (R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_FL_MASK);
+	return (R_SBREG(si, &sb->sbtmstatehigh));
+}
+
+/* Run bist on current core. Caller needs to take care of core-specific bist hazards */
+int
+sb_corebist(sb_t *sbh)
+{
+	uint32 sblo;
+	sb_info_t *si;
+	sbconfig_t *sb;
+	int result = 0;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	sblo = R_SBREG(si, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (sblo | SBTML_FGC | SBTML_BE));
+
+	SPINWAIT(((R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BISTD) == 0), 100000);
+
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BISTF)
+		result = BCME_ERROR;
+
+	W_SBREG(si, &sb->sbtmstatelow, sblo);
+
+	return result;
 }
 
 bool
-sb_iscoreup(void *sbh)
+sb_iscoreup(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -581,7 +848,8 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK);
+	return ((R_SBREG(si, &sb->sbtmstatelow) &
+	         (SBTML_RESET | SBTML_REJ_MASK | SBTML_CLK)) == SBTML_CLK);
 }
 
 /*
@@ -587,172 +855,554 @@
 /*
  * Switch to 'coreidx', issue a single arbitrary 32bit register mask&set operation,
  * switch back to the original core, and return the new value.
+ *
+ * When using the silicon backplane, no fidleing with interrupts or core switches are needed.
+ *
+ * Also, when using pci/pcie, we can optimize away the core switching for pci registers
+ * and (on newer pci cores) chipcommon registers.
  */
-static uint
-sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val)
+uint
+sb_corereg(sb_t *sbh, uint coreidx, uint regoff, uint mask, uint val)
 {
-	sb_info_t *si;
-	uint origidx;
-	uint32 *r;
+	uint origidx = 0;
+	uint32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
+	bool fast = FALSE;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
 
 	ASSERT(GOODIDX(coreidx));
 	ASSERT(regoff < SB_CORE_SIZE);
 	ASSERT((val & ~mask) == 0);
 
-	si = SB_INFO(sbh);
+	if (BUSTYPE(si->sb.bustype) == SB_BUS) {
+		/* If internal bus, we can always get at everything */
+		fast = TRUE;
+		/* map if does not exist */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void*)REG_MAP(si->coresba[coreidx],
+			                                   SB_CORE_SIZE);
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		r = (uint32 *)((uchar *)si->regs[coreidx] + regoff);
+	} else if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		/* If pci/pcie, we can get at pci/pcie regs and on newer cores to chipc */
+
+		if ((si->coreid[coreidx] == SB_CC) &&
+		    ((si->sb.buscoretype == SB_PCIE) ||
+		     (si->sb.buscorerev >= 13))) {
+			/* Chipc registers are mapped at 12KB */
+
+			fast = TRUE;
+			r = (uint32 *)((char *)si->curmap + PCI_16KB0_CCREGS_OFFSET + regoff);
+		} else if (si->sb.buscoreidx == coreidx) {
+			/* pci registers are at either in the last 2KB of an 8KB window
+			 * or, in pcie and pci rev 13 at 8KB
+			 */
+			fast = TRUE;
+			if ((si->sb.buscoretype == SB_PCIE) ||
+			    (si->sb.buscorerev >= 13))
+				r = (uint32 *)((char *)si->curmap +
+				               PCI_16KB0_PCIREGS_OFFSET + regoff);
+			else
+				r = (uint32 *)((char *)si->curmap +
+				               ((regoff >= SBCONFIGOFF) ?
+				                PCI_BAR0_PCISBR_OFFSET : PCI_BAR0_PCIREGS_OFFSET) +
+				               regoff);
+		}
+	}
 
+	if (!fast) {
 	INTR_OFF(si, intr_val);
 
 	/* save current core index */
-	origidx = sb_coreidx(sbh);
+		origidx = sb_coreidx(&si->sb);
 
 	/* switch core */
-	r = (uint32*) ((uchar*) sb_setcoreidx(sbh, coreidx) + regoff);
+		r = (uint32*) ((uchar*) sb_setcoreidx(&si->sb, coreidx) + regoff);
+	}
+	ASSERT(r);
 
 	/* mask and set */
 	if (mask || val) {
 		if (regoff >= SBCONFIGOFF) {
-			w = (R_SBREG(sbh, r) & ~mask) | val;
-			W_SBREG(sbh, r, w);
+			w = (R_SBREG(si, r) & ~mask) | val;
+			W_SBREG(si, r, w);
 		} else {
-			w = (R_REG(r) & ~mask) | val;
-			W_REG(r, w);
+			w = (R_REG(si->osh, r) & ~mask) | val;
+			W_REG(si->osh, r, w);
 		}
 	}
 
 	/* readback */
 	if (regoff >= SBCONFIGOFF)
-		w = R_SBREG(sbh, r);
-	else
-		w = R_REG(r);
+		w = R_SBREG(si, r);
+	else {
+#if defined(CONFIG_BCM5354)
+		if ((si->sb.chip == BCM5354_CHIP_ID) &&
+		    (coreidx == SB_CC_IDX) &&
+		    (regoff == OFFSETOF(chipcregs_t, watchdog))) {
+			w = val;
+		} else
+#endif	/* BCM5354 */
+			w = R_REG(si->osh, r);
+	}
 
+	if (!fast) {
 	/* restore core index */
 	if (origidx != coreidx)
-		sb_setcoreidx(sbh, origidx);
+			sb_setcoreidx(&si->sb, origidx);
 
 	INTR_RESTORE(si, intr_val);
+	}
+
 	return (w);
 }
 
-/* scan the sb enumerated space to identify all cores */
-static void
-BCMINITFN(sb_scan)(sb_info_t *si)
+#define DWORD_ALIGN(x)  (x & ~(0x03))
+#define BYTE_POS(x) (x & 0x3)
+#define WORD_POS(x) (x & 0x1)
+
+#define BYTE_SHIFT(x)  (8 * BYTE_POS(x))
+#define WORD_SHIFT(x)  (16 * WORD_POS(x))
+
+#define BYTE_VAL(a, x) ((a >> BYTE_SHIFT(x)) & 0xFF)
+#define WORD_VAL(a, x) ((a >> WORD_SHIFT(x)) & 0xFFFF)
+
+#define read_pci_cfg_byte(a) \
+	(BYTE_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xff)
+
+#define read_pci_cfg_word(a) \
+	(WORD_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xffff)
+
+
+/* return cap_offset if requested capability exists in the PCI config space */
+static uint8
+sb_find_pci_capability(sb_info_t *si, uint8 req_cap_id, uchar *buf, uint32 *buflen)
 {
-	void *sbh;
-	uint origidx;
-	uint i;
+	uint8 cap_id;
+	uint8 cap_ptr = 0;
+	uint32 	bufsize;
+	uint8 byte_val;
 
-	sbh = (void*) si;
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+	       goto end;
 
-	/* numcores should already be set */
-	ASSERT((si->numcores > 0) && (si->numcores <= SB_MAXCORES));
+	/* check for Header type 0 */
+	byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
+	if ((byte_val & 0x7f) != PCI_HEADER_NORMAL)
+		goto end;
 
-	/* save current core index */
-	origidx = sb_coreidx(sbh);
+	/* check if the capability pointer field exists */
+	byte_val = read_pci_cfg_byte(PCI_CFG_STAT);
+	if (!(byte_val & PCI_CAPPTR_PRESENT))
+		goto end;
 
-	si->pciidx = si->pcmciaidx = si->gpioidx = BADIDX;
-	si->pcirev = si->pcmciarev = NOREV;
+	cap_ptr = read_pci_cfg_byte(PCI_CFG_CAPPTR);
+	/* check if the capability pointer is 0x00 */
+	if (cap_ptr == 0x00)
+		goto end;
 
-	for (i = 0; i < si->numcores; i++) {
-		sb_setcoreidx(sbh, i);
-		si->coreid[i] = sb_coreid(sbh);
+	/* loop thr'u the capability list and see if the pcie capabilty exists */
 
-		if (si->coreid[i] == SB_PCI) {
-			si->pciidx = i;
-			si->pcirev = sb_corerev(sbh);
+	cap_id = read_pci_cfg_byte(cap_ptr);
 
-		} else if (si->coreid[i] == SB_PCMCIA) {
-			si->pcmciaidx = i;
-			si->pcmciarev = sb_corerev(sbh);
+	while (cap_id != req_cap_id) {
+		cap_ptr = read_pci_cfg_byte((cap_ptr+1));
+		if (cap_ptr == 0x00) break;
+		cap_id = read_pci_cfg_byte(cap_ptr);
 		}
+	if (cap_id != req_cap_id) {
+		goto end;
 	}
+	/* found the caller requested capability */
+	if ((buf != NULL) && (buflen != NULL)) {
+		uint8 cap_data;
 
-	/*
-	 * Find the gpio "controlling core" type and index.
-	 * Precedence:
-	 * - if there's a chip common core - use that
-	 * - else if there's a pci core (rev >= 2) - use that
-	 * - else there had better be an extif core (4710 only)
-	 */
-	if (GOODIDX(sb_findcoreidx(sbh, SB_CC, 0))) {
-		si->gpioidx = sb_findcoreidx(sbh, SB_CC, 0);
-		si->gpioid = SB_CC;
-	} else if (GOODIDX(si->pciidx) && (si->pcirev >= 2)) {
-		si->gpioidx = si->pciidx;
-		si->gpioid = SB_PCI;
-	} else if (sb_findcoreidx(sbh, SB_EXTIF, 0)) {
-		si->gpioidx = sb_findcoreidx(sbh, SB_EXTIF, 0);
-		si->gpioid = SB_EXTIF;
-	} else
-		ASSERT(si->gpioidx != BADIDX);
-
-	/* return to original core index */
-	sb_setcoreidx(sbh, origidx);
+		bufsize = *buflen;
+		if (!bufsize) goto end;
+		*buflen = 0;
+		/* copy the cpability data excluding cap ID and next ptr */
+		cap_data = cap_ptr + 2;
+		if ((bufsize + cap_data)  > SZPCR)
+			bufsize = SZPCR - cap_data;
+		*buflen = bufsize;
+		while (bufsize--) {
+			*buf = read_pci_cfg_byte(cap_data);
+			cap_data++;
+			buf++;
+		}
+	}
+end:
+	return cap_ptr;
 }
 
-/* may be called with core in reset */
-void
-sb_detach(void *sbh)
+uint8
+sb_pcieclkreq(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
-	uint idx;
+	uint32 reg_val;
+	uint8 offset;
 
 	si = SB_INFO(sbh);
 
-	if (si == NULL)
-		return;
+	offset = si->pciecap_lcreg_offset;
+	if (!offset)
+		return 0;
 
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		for (idx = 0; idx < SB_MAXCORES; idx++)
-			if (si->regs[idx]) {
-				REG_UNMAP(si->regs[idx]);
-				si->regs[idx] = NULL;
+	reg_val = OSL_PCI_READ_CONFIG(si->osh, offset, sizeof(uint32));
+	/* set operation */
+	if (mask) {
+		if (val)
+			reg_val |= PCIE_CLKREQ_ENAB;
+		else
+			reg_val &= ~PCIE_CLKREQ_ENAB;
+		OSL_PCI_WRITE_CONFIG(si->osh, offset, sizeof(uint32), reg_val);
+		reg_val = OSL_PCI_READ_CONFIG(si->osh, offset, sizeof(uint32));
 			}
-
-	MFREE(si->osh, si, sizeof (sb_info_t));
+	if (reg_val & PCIE_CLKREQ_ENAB)
+		return 1;
+	else
+		return 0;
 }
 
-/* use pci dev id to determine chip id for chips not having a chipcommon core */
-static uint
-BCMINITFN(sb_pcidev2chip)(uint pcidev)
+
+
+/* return TRUE if PCIE capability exists in the pci config space */
+static bool
+sb_ispcie(sb_info_t *si)
 {
-	if ((pcidev >= BCM4710_DEVICE_ID) && (pcidev <= BCM47XX_USB_ID))
-		return (BCM4710_DEVICE_ID);
-	if ((pcidev >= BCM4610_DEVICE_ID) && (pcidev <= BCM4610_USB_ID))
-		return (BCM4610_DEVICE_ID);
-	if ((pcidev >= BCM4402_DEVICE_ID) && (pcidev <= BCM4402_V90_ID))
-		return (BCM4402_DEVICE_ID);
-	if (pcidev == BCM4401_ENET_ID)
-		return (BCM4402_DEVICE_ID);
-	if ((pcidev >= BCM4307_V90_ID) && (pcidev <= BCM4307_D11B_ID))
-		return (BCM4307_DEVICE_ID);
-	if (pcidev == BCM4301_DEVICE_ID)
-		return (BCM4301_DEVICE_ID);
+	uint8 cap_ptr;
 
-	return (0);
+	cap_ptr = sb_find_pci_capability(si, PCI_CAP_PCIECAP_ID, NULL, NULL);
+	if (!cap_ptr)
+	    return FALSE;
+
+	si->pciecap_lcreg_offset = cap_ptr + PCIE_CAP_LINKCTRL_OFFSET;
+
+	return TRUE;
 }
 
-/* convert chip number to number of i/o cores */
-static uint
-BCMINITFN(sb_chip2numcores)(uint chip)
+/* Wake-on-wireless-LAN (WOWL) support functions */
+/* return TRUE if PM capability exists in the pci config space */
+bool
+sb_pci_pmecap(sb_t *sbh)
 {
-	if (chip == 0x4710)
-		return (9);
-	if (chip == 0x4610)
-		return (9);
-	if (chip == 0x4402)
-		return (3);
-	if ((chip == 0x4307) || (chip == 0x4301))
-		return (5);
-	if (chip == 0x4310)
-		return (8);
-	if (chip == 0x4306)	/* < 4306c0 */
+	uint8 cap_ptr;
+	uint32 pmecap;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL || !(PCI(si) || PCIE(si)))
+		return FALSE;
+
+	if (!si->pmecap_offset) {
+		cap_ptr = sb_find_pci_capability(si, PCI_CAP_POWERMGMTCAP_ID, NULL, NULL);
+		if (!cap_ptr)
+			return FALSE;
+
+		si->pmecap_offset = cap_ptr;
+
+		pmecap = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset, sizeof(uint32));
+
+		/* At least one state can generate PME */
+		si->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
+	}
+
+	return (si->pmecap);
+}
+
+/* Enable PME generation and disable clkreq */
+void
+sb_pci_pmeen(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	si = SB_INFO(sbh);
+
+	/* if not pmecapable return */
+	if (!sb_pci_pmecap(sbh))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32));
+	w |= (PME_CSR_PME_EN);
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32), w);
+
+	/* Disable clkreq */
+	if (si->pr42767_war) {
+		sb_pcieclkreq(sbh, 1, 0);
+		si->pr42767_war = FALSE;
+	} else if (si->sb.pr42780) {
+		sb_pcieclkreq(sbh, 1, 1);
+	}
+}
+
+/* Disable PME generation, clear the PME status bit if set and
+ * return TRUE if PME status set
+ */
+bool
+sb_pci_pmeclr(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	bool ret = FALSE;
+
+	si = SB_INFO(sbh);
+
+	if (!sb_pci_pmecap(sbh))
+		return ret;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32));
+
+	SB_ERROR(("sb_pci_pmeclr PMECSR : 0x%x\n", w));
+	ret = (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
+
+	/* PMESTAT is cleared by writing 1 to it */
+	w &= ~(PME_CSR_PME_EN);
+
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32), w);
+
+	return ret;
+}
+
+/* Scan the enumeration space to find all cores starting from the given
+ * bus 'sbba'. Append coreid and other info to the lists in 'si'. 'sba'
+ * is the default core address at chip POR time and 'regs' is the virtual
+ * address that the default core is mapped at. 'ncores' is the number of
+ * cores expected on bus 'sbba'. It returns the total number of cores
+ * starting from bus 'sbba', inclusive.
+ */
+#define SB_MAXBUSES	2
+static uint
+BCMINITFN(_sb_scan)(sb_info_t *si, uint32 sba, void *regs, uint bus, uint32 sbba, uint numcores)
+{
+	uint next;
+	uint ncc = 0;
+	uint i;
+
+	if (bus >= SB_MAXBUSES) {
+		SB_ERROR(("_sb_scan: bus 0x%08x at level %d is too deep to scan\n", sbba, bus));
+		return 0;
+	}
+	SB_MSG(("_sb_scan: scan bus 0x%08x assume %u cores\n", sbba, numcores));
+
+	/* Scan all cores on the bus starting from core 0.
+	 * Core addresses must be contiguous on each bus.
+	 */
+	for (i = 0, next = si->numcores; i < numcores && next < SB_MAXCORES; i++, next++) {
+		si->coresba[next] = sbba + i * SB_CORE_SIZE;
+
+		/* keep and reuse the initial register mapping */
+		if (BUSTYPE(si->sb.bustype) == SB_BUS && si->coresba[next] == sba) {
+			SB_MSG(("_sb_scan: reuse mapped regs %p for core %u\n", regs, next));
+			si->regs[next] = regs;
+		}
+
+		/* change core to 'next' and read its coreid */
+		si->curmap = _sb_setcoreidx(si, next);
+		si->curidx = next;
+
+		si->coreid[next] = sb_coreid(&si->sb);
+
+		/* core specific processing... */
+		/* chipc on bus SB_ENUM_BASE provides # cores in the chip and lots of
+		 * other stuff.
+		 */
+		if (sbba == SB_ENUM_BASE && si->coreid[next] == SB_CC) {
+			chipcregs_t *cc = (chipcregs_t *)si->curmap;
+
+			/* get chip id and rev */
+			si->sb.chip = R_REG(si->osh, &cc->chipid) & CID_ID_MASK;
+			si->sb.chiprev = (R_REG(si->osh, &cc->chipid) & CID_REV_MASK) >>
+			        CID_REV_SHIFT;
+			si->sb.chippkg = (R_REG(si->osh, &cc->chipid) & CID_PKG_MASK) >>
+			        CID_PKG_SHIFT;
+
+			/* get chipcommon rev */
+			si->sb.ccrev = (int)sb_corerev(&si->sb);
+
+			/* get chipcommon chipstatus */
+			if (si->sb.ccrev >= 11)
+				si->sb.chipst = R_REG(si->osh, &cc->chipstatus);
+
+			/* get chipcommon capabilites */
+			si->sb.cccaps = R_REG(si->osh, &cc->capabilities);
+
+			/* get pmu rev and caps */
+			if ((si->sb.cccaps & CC_CAP_PMU)) {
+				si->sb.pmucaps = R_REG(si->osh, &cc->pmucapabilities);
+				si->sb.pmurev = si->sb.pmucaps & PCAP_REV_MASK;
+			}
+
+			/* determine numcores - this is the total # cores in the chip */
+			if (((si->sb.ccrev == 4) || (si->sb.ccrev >= 6)))
+				numcores = (R_REG(si->osh, &cc->chipid) & CID_CC_MASK) >>
+				        CID_CC_SHIFT;
+			else
+				numcores = sb_chip2numcores(si->sb.chip);
+			SB_MSG(("_sb_scan: there are %u cores in the chip\n", numcores));
+		}
+		/* scan bridged SB(s) and add results to the end of the list */
+		else if (si->coreid[next] == SB_OCP) {
+			sbconfig_t *sb = REGS2SB(si->curmap);
+			uint32 nsbba = R_SBREG(si, &sb->sbadmatch1);
+			uint nsbcc;
+
+			si->numcores = next + 1;
+
+			if ((nsbba & 0xfff00000) != SB_ENUM_BASE)
+				continue;
+			nsbba &= 0xfffff000;
+			if (_sb_coreidx(si, nsbba) != BADIDX)
+				continue;
+
+			nsbcc = (R_SBREG(si, &sb->sbtmstatehigh) & 0x000f0000) >> 16;
+			nsbcc = _sb_scan(si, sba, regs, bus + 1, nsbba, nsbcc);
+			if (sbba == SB_ENUM_BASE)
+				numcores -= nsbcc;
+			ncc += nsbcc;
+		}
+	}
+
+	SB_MSG(("_sb_scan: found %u cores on bus 0x%08x\n", i, sbba));
+
+	si->numcores = i + ncc;
+	return si->numcores;
+}
+
+/* scan the sb enumerated space to identify all cores */
+static void
+BCMINITFN(sb_scan)(sb_info_t *si, void *regs, uint devid)
+{
+	uint origidx;
+	uint32 origsba;
+	uint i;
+	bool pci;
+	bool pcie;
+	uint pciidx;
+	uint pcieidx;
+	uint pcirev;
+	uint pcierev;
+	uint numcores;
+
+	/* Save the current core info and validate it later till we know
+	 * for sure what is good and what is bad.
+	 */
+	origsba = _sb_coresba(si);
+	origidx = BADIDX;
+
+	/* Use devid as initial chipid and we'll update it later in _sb_scan */
+	si->sb.chip = devid;
+
+	/* Support chipcommon-less chips for a little while longer so the old
+	 * sdio host fpga continues to work until we can get the new one working
+	 * reliably. This particular chip has 2 cores - codec/sdio and pci.
+	 */
+	if (devid == SDIOH_FPGA_ID)
+		numcores = 2;
+	/* Expect at least one core on 0x18000000 and it must be chipcommon where
+	 * the core count for the whole chip is kept.
+	 */
+	else
+		numcores = 1;
+
+	/* scan all SB(s) starting from SB_ENUM_BASE */
+	si->numcores = _sb_scan(si, origsba, regs, 0, SB_ENUM_BASE, numcores);
+	if (si->numcores == 0)
+		return;
+
+	/* figure out bus/orignal core idx */
+	si->sb.buscorerev = NOREV;
+	si->sb.buscoreidx = BADIDX;
+
+	pci = pcie = FALSE;
+	pcirev = pcierev = NOREV;
+	pciidx = pcieidx = BADIDX;
+
+	for (i = 0; i < si->numcores; i++) {
+		sb_setcoreidx(&si->sb, i);
+
+		if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+			if (si->coreid[i] == SB_PCI) {
+				pciidx = i;
+				pcirev = sb_corerev(&si->sb);
+				pci = TRUE;
+			} else if (si->coreid[i] == SB_PCIE) {
+				pcieidx = i;
+				pcierev = sb_corerev(&si->sb);
+				pcie = TRUE;
+			}
+		} else if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+			if (si->coreid[i] == SB_PCMCIA) {
+				si->sb.buscorerev = sb_corerev(&si->sb);
+				si->sb.buscoretype = si->coreid[i];
+				si->sb.buscoreidx = i;
+			}
+		}
+
+		/* find the core idx before entering this func. */
+		if (origsba == si->coresba[i])
+			origidx = i;
+	}
+
+	if (pci && pcie) {
+		if (sb_ispcie(si))
+			pci = FALSE;
+		else
+			pcie = FALSE;
+	}
+	if (pci) {
+		si->sb.buscoretype = SB_PCI;
+		si->sb.buscorerev = pcirev;
+		si->sb.buscoreidx = pciidx;
+	} else if (pcie) {
+		si->sb.buscoretype = SB_PCIE;
+		si->sb.buscorerev = pcierev;
+		si->sb.buscoreidx = pcieidx;
+	}
+
+	/* return to the original core */
+	if (origidx != BADIDX)
+		sb_setcoreidx(&si->sb, origidx);
+	ASSERT(origidx != BADIDX);
+}
+
+/* may be called with core in reset */
+void
+sb_detach(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL)
+		return;
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS)
+		for (idx = 0; idx < SB_MAXCORES; idx++)
+			if (si->regs[idx]) {
+				REG_UNMAP(si->regs[idx]);
+				si->regs[idx] = NULL;
+			}
+#if !defined(CONFIG_BCMBUSTYPE) || (BCMBUSTYPE == SB_BUS)
+	if (si != &ksi)
+#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SB_BUS) */
+		MFREE(si->osh, si, sizeof(sb_info_t));
+}
+
+/* convert chip number to number of i/o cores */
+static uint
+BCMINITFN(sb_chip2numcores)(uint chip)
+{
+	if (chip == BCM4306_CHIP_ID)	/* < 4306c0 */
 		return (6);
-	if (chip == 0x4704)
+	if (chip == BCM4704_CHIP_ID)
 		return (9);
-	if (chip == 0x5365)
+	if (chip == BCM5365_CHIP_ID)
 		return (7);
 
 	SB_ERROR(("sb_chip2numcores: unsupported chip 0x%x\n", chip));
@@ -761,8 +1411,8 @@
 }
 
 /* return index of coreid or BADIDX if not found */
-static uint
-sb_findcoreidx(void *sbh, uint coreid, uint coreunit)
+uint
+sb_findcoreidx(sb_t *sbh, uint coreid, uint coreunit)
 {
 	sb_info_t *si;
 	uint found;
@@ -787,11 +1438,9 @@
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
 void*
-sb_setcoreidx(void *sbh, uint coreidx)
+sb_setcoreidx(sb_t *sbh, uint coreidx)
 {
 	sb_info_t *si;
-	uint32 sbaddr;
-	uint8 tmp;
 
 	si = SB_INFO(sbh);
 
@@ -804,36 +1453,66 @@
 	 */
 	ASSERT((si->intrsenabled_fn == NULL) || !(*(si)->intrsenabled_fn)((si)->intr_arg));
 
-	sbaddr = SB_ENUM_BASE + (coreidx * SB_CORE_SIZE);
+	si->curmap = _sb_setcoreidx(si, coreidx);
+	si->curidx = coreidx;
+
+	return (si->curmap);
+}
+
+/* This function changes the logical "focus" to the indiciated core.
+ * Return the current core's virtual address.
+ */
+static void *
+_sb_setcoreidx(sb_info_t *si, uint coreidx)
+{
+	uint32 sbaddr = si->coresba[coreidx];
+	void *regs;
 
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 	case SB_BUS:
 		/* map new one */
 		if (!si->regs[coreidx]) {
 			si->regs[coreidx] = (void*)REG_MAP(sbaddr, SB_CORE_SIZE);
 			ASSERT(GOODREGS(si->regs[coreidx]));
 		}
-		si->curmap = si->regs[coreidx];
+		regs = si->regs[coreidx];
 		break;
 
 	case PCI_BUS:
 		/* point bar0 window */
 		OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, 4, sbaddr);
+		regs = si->curmap;
 		break;
 
-	case PCMCIA_BUS:
-		tmp = (sbaddr >> 12) & 0x0f;
+	case PCMCIA_BUS: {
+		uint8 tmp = (sbaddr >> 12) & 0x0f;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR0, &tmp, 1);
 		tmp = (sbaddr >> 16) & 0xff;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR1, &tmp, 1);
 		tmp = (sbaddr >> 24) & 0xff;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR2, &tmp, 1);
+		regs = si->curmap;
 		break;
 	}
 
-	si->curidx = coreidx;
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		/* map new one */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void *)(uintptr)sbaddr;
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		regs = si->regs[coreidx];
+		break;
+#endif	/* BCMJTAG */
 
-	return (si->curmap);
+	default:
+		ASSERT(0);
+		regs = NULL;
+		break;
+	}
+
+	return regs;
 }
 
 /* 
@@ -842,13 +1521,10 @@
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
 void*
-sb_setcore(void *sbh, uint coreid, uint coreunit)
+sb_setcore(sb_t *sbh, uint coreid, uint coreunit)
 {
-	sb_info_t *si;
 	uint idx;
 
-	si = SB_INFO(sbh);
-
 	idx = sb_findcoreidx(sbh, coreid, coreunit);
 	if (!GOODIDX(idx))
 		return (NULL);
@@ -858,140 +1534,175 @@
 
 /* return chip number */
 uint
-BCMINITFN(sb_chip)(void *sbh)
+BCMINITFN(sb_chip)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chip);
+	return (si->sb.chip);
 }
 
 /* return chip revision number */
 uint
-BCMINITFN(sb_chiprev)(void *sbh)
+BCMINITFN(sb_chiprev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chiprev);
+	return (si->sb.chiprev);
 }
 
 /* return chip common revision number */
 uint
-BCMINITFN(sb_chipcrev)(void *sbh)
+BCMINITFN(sb_chipcrev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->ccrev);
+	return (si->sb.ccrev);
 }
 
 /* return chip package option */
 uint
-BCMINITFN(sb_chippkg)(void *sbh)
+BCMINITFN(sb_chippkg)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chippkg);
+	return (si->sb.chippkg);
 }
 
 /* return PCI core rev. */
 uint
-BCMINITFN(sb_pcirev)(void *sbh)
+BCMINITFN(sb_pcirev)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.buscorerev);
+}
+
+bool
+BCMINITFN(sb_war16165)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->pcirev);
+
+	return (PCI(si) && (si->sb.buscorerev <= 10));
+}
+
+static void
+BCMINITFN(sb_war30841)(sb_info_t *si)
+{
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_TIMER1, 0x8128);
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_CDR, 0x0100);
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_CDRBW, 0x1466);
 }
 
 /* return PCMCIA core rev. */
 uint
-BCMINITFN(sb_pcmciarev)(void *sbh)
+BCMINITFN(sb_pcmciarev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->pcmciarev);
+	return (si->sb.buscorerev);
 }
 
 /* return board vendor id */
 uint
-BCMINITFN(sb_boardvendor)(void *sbh)
+BCMINITFN(sb_boardvendor)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->boardvendor);
+	return (si->sb.boardvendor);
 }
 
 /* return boardtype */
 uint
-BCMINITFN(sb_boardtype)(void *sbh)
+BCMINITFN(sb_boardtype)(sb_t *sbh)
 {
 	sb_info_t *si;
 	char *var;
 
 	si = SB_INFO(sbh);
 
-	if (BUSTYPE(si->bustype) == SB_BUS && si->boardtype == 0xffff) {
+	if (BUSTYPE(si->sb.bustype) == SB_BUS && si->sb.boardtype == 0xffff) {
 		/* boardtype format is a hex string */
-		si->boardtype = getintvar(NULL, "boardtype");
+		si->sb.boardtype = getintvar(NULL, "boardtype");
 
 		/* backward compatibility for older boardtype string format */
-		if ((si->boardtype == 0) && (var = getvar(NULL, "boardtype"))) {
+		if ((si->sb.boardtype == 0) && (var = getvar(NULL, "boardtype"))) {
 			if (!strcmp(var, "bcm94710dev"))
-				si->boardtype = BCM94710D_BOARD;
+				si->sb.boardtype = BCM94710D_BOARD;
 			else if (!strcmp(var, "bcm94710ap"))
-				si->boardtype = BCM94710AP_BOARD;
-			else if (!strcmp(var, "bcm94310u"))
-				si->boardtype = BCM94310U_BOARD;
-			else if (!strcmp(var, "bu4711"))
-				si->boardtype = BU4711_BOARD;
+				si->sb.boardtype = BCM94710AP_BOARD;
 			else if (!strcmp(var, "bu4710"))
-				si->boardtype = BU4710_BOARD;
+				si->sb.boardtype = BU4710_BOARD;
 			else if (!strcmp(var, "bcm94702mn"))
-				si->boardtype = BCM94702MN_BOARD;
+				si->sb.boardtype = BCM94702MN_BOARD;
 			else if (!strcmp(var, "bcm94710r1"))
-				si->boardtype = BCM94710R1_BOARD;
+				si->sb.boardtype = BCM94710R1_BOARD;
 			else if (!strcmp(var, "bcm94710r4"))
-				si->boardtype = BCM94710R4_BOARD;
+				si->sb.boardtype = BCM94710R4_BOARD;
 			else if (!strcmp(var, "bcm94702cpci"))
-				si->boardtype = BCM94702CPCI_BOARD;
+				si->sb.boardtype = BCM94702CPCI_BOARD;
 			else if (!strcmp(var, "bcm95380_rr"))
-				si->boardtype = BCM95380RR_BOARD;
+				si->sb.boardtype = BCM95380RR_BOARD;
 		}
 	}
 
-	return (si->boardtype);
+	return (si->sb.boardtype);
+}
+
+/* return bus type of sbh device */
+uint
+sb_bus(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.bustype);
 }
 
-/* return bus type of sdh device */
+/* return bus core type */
 uint
-sb_bus(void *sbh)
+sb_buscoretype(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->bustype);
+
+	return (si->sb.buscoretype);
+}
+
+/* return bus core revision */
+uint
+sb_buscorerev(sb_t *sbh)
+{
+	sb_info_t *si;
+	si = SB_INFO(sbh);
+
+	return (si->sb.buscorerev);
 }
 
 /* return list of found cores */
 uint
-sb_corelist(void *sbh, uint coreid[])
+sb_corelist(sb_t *sbh, uint coreid[])
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
 
-	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof (uint)));
+	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof(uint)));
 	return (si->numcores);
 }
 
 /* return current register mapping */
 void *
-sb_coreregs(void *sbh)
+sb_coreregs(sb_t *sbh)
 {
 	sb_info_t *si;
 
@@ -1001,10 +1712,148 @@
 	return (si->curmap);
 }
 
+#if defined(CONFIG_BCMDBG_ASSERT)
+/* traverse all cores to find and clear source of serror */
+static void
+sb_serr_clear(sb_info_t *si)
+{
+	sbconfig_t *sb;
+	uint origidx;
+	uint i, intr_val = 0;
+	void * corereg = NULL;
+
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(&si->sb);
+
+	for (i = 0; i < si->numcores; i++) {
+		corereg = sb_setcoreidx(&si->sb, i);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+			if ((R_SBREG(si, &sb->sbtmstatehigh)) & SBTMH_SERR) {
+				AND_SBREG(si, &sb->sbtmstatehigh, ~SBTMH_SERR);
+				SB_ERROR(("sb_serr_clear: SError at core 0x%x\n",
+				          sb_coreid(&si->sb)));
+			}
+		}
+	}
+
+	sb_setcoreidx(&si->sb, origidx);
+	INTR_RESTORE(si, intr_val);
+}
+
+/*
+ * Check if any inband, outband or timeout errors has happened and clear them.
+ * Must be called with chip clk on !
+ */
+bool
+sb_taclear(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint origidx;
+	uint intr_val = 0;
+	bool rc = FALSE;
+	uint32 inband = 0, serror = 0, timeout = 0;
+	void *corereg = NULL;
+	volatile uint32 imstate, tmstate;
+
+	si = SB_INFO(sbh);
+
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		volatile uint32 stcmd;
+
+		/* inband error is Target abort for PCI */
+		stcmd = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_CMD, sizeof(uint32));
+		inband = stcmd & PCI_CFG_CMD_STAT_TA;
+		if (inband) {
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_CFG_CMD, sizeof(uint32), stcmd);
+		}
+
+		/* serror */
+		stcmd = OSL_PCI_READ_CONFIG(si->osh, PCI_INT_STATUS, sizeof(uint32));
+		serror = stcmd & PCI_SBIM_STATUS_SERR;
+		if (serror) {
+			sb_serr_clear(si);
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_INT_STATUS, sizeof(uint32), stcmd);
+		}
+
+		/* timeout */
+		imstate = sb_corereg(sbh, si->sb.buscoreidx,
+		                     SBCONFIGOFF + OFFSETOF(sbconfig_t, sbimstate), 0, 0);
+		if ((imstate != 0xffffffff) && (imstate & (SBIM_IBE | SBIM_TO))) {
+			sb_corereg(sbh, si->sb.buscoreidx,
+			           SBCONFIGOFF + OFFSETOF(sbconfig_t, sbimstate), ~0,
+			           (imstate & ~(SBIM_IBE | SBIM_TO)));
+			/* inband = imstate & SBIM_IBE; same as TA above */
+			timeout = imstate & SBIM_TO;
+			if (timeout) {
+			}
+		}
+
+		if (inband) {
+			/* dump errlog for sonics >= 2.3 */
+			if (si->sb.sonicsrev == SONICS_2_2)
+				;
+			else {
+				uint32 imerrlog, imerrloga;
+				imerrlog = sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOG, 0, 0);
+				if (imerrlog & SBTMEL_EC) {
+					imerrloga = sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOGA,
+						0, 0);
+					/* clear errlog */
+					sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOG, ~0, 0);
+					SB_ERROR(("sb_taclear: ImErrLog 0x%x, ImErrLogA 0x%x\n",
+						imerrlog, imerrloga));
+				}
+			}
+		}
+
+
+	} else if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+
+		INTR_OFF(si, intr_val);
+		origidx = sb_coreidx(sbh);
+
+		corereg = sb_setcore(sbh, SB_PCMCIA, 0);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+
+			imstate = R_SBREG(si, &sb->sbimstate);
+			/* handle surprise removal */
+			if ((imstate != 0xffffffff) && (imstate & (SBIM_IBE | SBIM_TO))) {
+				AND_SBREG(si, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+				inband = imstate & SBIM_IBE;
+				timeout = imstate & SBIM_TO;
+			}
+			tmstate = R_SBREG(si, &sb->sbtmstatehigh);
+			if ((tmstate != 0xffffffff) && (tmstate & SBTMH_INT_STATUS)) {
+				if (!inband) {
+					serror = 1;
+					sb_serr_clear(si);
+				}
+				OR_SBREG(si, &sb->sbtmstatelow, SBTML_INT_ACK);
+				AND_SBREG(si, &sb->sbtmstatelow, ~SBTML_INT_ACK);
+			}
+		}
+		sb_setcoreidx(sbh, origidx);
+		INTR_RESTORE(si, intr_val);
+
+	}
+
+
+	if (inband | timeout | serror) {
+		rc = TRUE;
+		SB_ERROR(("sb_taclear: inband 0x%x, serror 0x%x, timeout 0x%x!\n",
+		          inband, serror, timeout));
+	}
+
+	return (rc);
+}
+#endif	
 
 /* do buffered registers update */
 void
-sb_commit(void *sbh)
+sb_commit(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1018,30 +1867,33 @@
 	INTR_OFF(si, intr_val);
 
 	/* switch over to chipcommon core if there is one, else use pci */
-	if (si->ccrev != NOREV) {
+	if (si->sb.ccrev != NOREV) {
 		chipcregs_t *ccregs = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
 
 		/* do the buffer registers update */
-		W_REG(&ccregs->broadcastaddress, SB_COMMIT);
-		W_REG(&ccregs->broadcastdata, 0x0);
-	} else if (si->pciidx != BADIDX) {
+		W_REG(si->osh, &ccregs->broadcastaddress, SB_COMMIT);
+		W_REG(si->osh, &ccregs->broadcastdata, 0x0);
+	} else if (PCI(si)) {
 		sbpciregs_t *pciregs = (sbpciregs_t *)sb_setcore(sbh, SB_PCI, 0);
 
 		/* do the buffer registers update */
-		W_REG(&pciregs->bcastaddr, SB_COMMIT);
-		W_REG(&pciregs->bcastdata, 0x0);
-	} else {
-		ASSERT((si->ccrev != NOREV) && (si->pciidx != BADIDX));
-	}
+		W_REG(si->osh, &pciregs->bcastaddr, SB_COMMIT);
+		W_REG(si->osh, &pciregs->bcastdata, 0x0);
+	} else
+		ASSERT(0);
 
 	/* restore core index */
 	sb_setcoreidx(sbh, origidx);
 	INTR_RESTORE(si, intr_val);
 }
 
-/* reset and re-enable a core */
+/* reset and re-enable a core
+ * inputs:
+ * bits - core specific bits that are set during and after reset sequence
+ * resetbits - core specific bits that are set only during reset sequence
+ */
 void
-sb_core_reset(void *sbh, uint32 bits)
+sb_core_reset(sb_t *sbh, uint32 bits, uint32 resetbits)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -1054,158 +1906,346 @@
 	/*
 	 * Must do the disable sequence first to work for arbitrary current core state.
 	 */
-	sb_core_disable(sbh, bits);
+	sb_core_disable(sbh, (bits | resetbits));
 
 	/*
 	 * Now do the initialization sequence.
 	 */
 
 	/* set reset while enabling the clock and forcing them on throughout the core */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | SBTML_RESET | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
-
-	if (sb_coreid(sbh) == SB_ILINE100) {
-		bcm_mdelay(50);
-	} else {
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | SBTML_RESET | bits | resetbits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 		OSL_DELAY(1);
-	}
 
-	if (R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_SERR) {
-		W_SBREG(sbh, &sb->sbtmstatehigh, 0);
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_SERR) {
+		W_SBREG(si, &sb->sbtmstatehigh, 0);
 	}
-	if ((dummy = R_SBREG(sbh, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
-		AND_SBREG(sbh, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+	if ((dummy = R_SBREG(si, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
+		AND_SBREG(si, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
 	}
 
 	/* clear reset and allow it to propagate throughout the core */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
 
 	/* leave clock enabled */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_CLK | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
 }
 
 void
-sb_core_tofixup(void *sbh)
+sb_core_tofixup(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
 
 	si = SB_INFO(sbh);
 
-	if ((si->pciidx == BADIDX) || (si->pcirev >= 5))
+	if ((BUSTYPE(si->sb.bustype) != PCI_BUS) || PCIE(si) ||
+	    (PCI(si) && (si->sb.buscorerev >= 5)))
 		return;
 
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
 
-	if (BUSTYPE(si->bustype) == SB_BUS) {
-		SET_SBREG(sbh, &sb->sbimconfiglow,
+	if (BUSTYPE(si->sb.bustype) == SB_BUS) {
+		SET_SBREG(si, &sb->sbimconfiglow,
 			  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 			  (0x5 << SBIMCL_RTO_SHIFT) | 0x3);
 	} else {
 		if (sb_coreid(sbh) == SB_PCI) {
-			SET_SBREG(sbh, &sb->sbimconfiglow,
+			SET_SBREG(si, &sb->sbimconfiglow,
 				  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 				  (0x3 << SBIMCL_RTO_SHIFT) | 0x2);
 		} else {
-			SET_SBREG(sbh, &sb->sbimconfiglow, (SBIMCL_RTO_MASK | SBIMCL_STO_MASK), 0);
+			SET_SBREG(si, &sb->sbimconfiglow, (SBIMCL_RTO_MASK | SBIMCL_STO_MASK), 0);
 		}
 	}
 
 	sb_commit(sbh);
 }
 
-void
-sb_core_disable(void *sbh, uint32 bits)
-{
-	sb_info_t *si;
-	volatile uint32 dummy;
-	sbconfig_t *sb;
+/*
+ * Set the initiator timeout for the "master core".
+ * The master core is defined to be the core in control
+ * of the chip and so it issues accesses to non-memory
+ * locations (Because of dma *any* core can access memeory).
+ *
+ * The routine uses the bus to decide who is the master:
+ *	SB_BUS => mips
+ *	JTAG_BUS => chipc
+ *	PCI_BUS => pci or pcie
+ *	PCMCIA_BUS => pcmcia
+ *	SDIO_BUS => pcmcia
+ *
+ * This routine exists so callers can disable initiator
+ * timeouts so accesses to very slow devices like otp
+ * won't cause an abort. The routine allows arbitrary
+ * settings of the service and request timeouts, though.
+ *
+ * Returns the timeout state before changing it or -1
+ * on error.
+ */
 
-	si = SB_INFO(sbh);
+#define	TO_MASK	(SBIMCL_RTO_MASK | SBIMCL_STO_MASK)
+
+uint32
+sb_set_initiator_to(sb_t *sbh, uint32 to, uint idx)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+	uint32 tmp, ret = 0xffffffff;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+
+	if ((to & ~TO_MASK) != 0)
+		return ret;
+
+	/* Figure out the master core */
+	if (idx == BADIDX) {
+		switch (BUSTYPE(si->sb.bustype)) {
+		case PCI_BUS:
+			idx = si->sb.buscoreidx;
+			break;
+		case JTAG_BUS:
+			idx = SB_CC_IDX;
+			break;
+		case PCMCIA_BUS:
+			idx = sb_findcoreidx(sbh, SB_PCMCIA, 0);
+			break;
+		case SB_BUS:
+			idx = sb_findcoreidx(sbh, SB_MIPS33, 0);
+			break;
+		default:
+			ASSERT(0);
+		}
+		if (idx == BADIDX)
+			return ret;
+	}
+
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(sbh);
+
+	sb = REGS2SB(sb_setcoreidx(sbh, idx));
+
+	tmp = R_SBREG(si, &sb->sbimconfiglow);
+	ret = tmp & TO_MASK;
+	W_SBREG(si, &sb->sbimconfiglow, (tmp & ~TO_MASK) | to);
+
+	sb_commit(sbh);
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return ret;
+}
+
+void
+sb_core_disable(sb_t *sbh, uint32 bits)
+{
+	sb_info_t *si;
+	volatile uint32 dummy;
+	uint32 rej;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
 
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
 
 	/* if core is already in reset, just return */
-	if (R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_RESET)
+	if (R_SBREG(si, &sb->sbtmstatelow) & SBTML_RESET)
 		return;
 
+	/* reject value changed between sonics 2.2 and 2.3 */
+	if (si->sb.sonicsrev == SONICS_2_2)
+		rej = (1 << SBTML_REJ_SHIFT);
+	else
+		rej = (2 << SBTML_REJ_SHIFT);
+
 	/* if clocks are not enabled, put into reset and return */
-	if ((R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_CLK) == 0)
+	if ((R_SBREG(si, &sb->sbtmstatelow) & SBTML_CLK) == 0)
 		goto disable;
 
-	/* set the target reject bit and spin until busy is clear */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_CLK | SBTML_REJ));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	/* set target reject and spin until busy is clear (preserve core-specific bits) */
+	OR_SBREG(si, &sb->sbtmstatelow, rej);
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
-	SPINWAIT((R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
-
- 	if (R_SBREG(sbh, &sb->sbidlow) & SBIDL_INIT) {
-		OR_SBREG(sbh, &sb->sbimstate, SBIM_RJ);
-		dummy = R_SBREG(sbh, &sb->sbimstate);
+	SPINWAIT((R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BUSY)
+		SB_ERROR(("%s: target state still busy\n", __FUNCTION__));
+
+	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT) {
+		OR_SBREG(si, &sb->sbimstate, SBIM_RJ);
+		dummy = R_SBREG(si, &sb->sbimstate);
 		OSL_DELAY(1);
-		SPINWAIT((R_SBREG(sbh, &sb->sbimstate) & SBIM_BY), 100000);
+		SPINWAIT((R_SBREG(si, &sb->sbimstate) & SBIM_BY), 100000);
 	}
 
 	/* set reset and reject while enabling the clocks */
-	W_SBREG(sbh, &sb->sbtmstatelow, (bits | SBTML_FGC | SBTML_CLK | SBTML_REJ | SBTML_RESET));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (bits | SBTML_FGC | SBTML_CLK | rej | SBTML_RESET));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(10);
 
 	/* don't forget to clear the initiator reject bit */
-	if (R_SBREG(sbh, &sb->sbidlow) & SBIDL_INIT)
-		AND_SBREG(sbh, &sb->sbimstate, ~SBIM_RJ);
+	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT)
+		AND_SBREG(si, &sb->sbimstate, ~SBIM_RJ);
 
 disable:
 	/* leave reset and reject asserted */
-	W_SBREG(sbh, &sb->sbtmstatelow, (bits | SBTML_REJ | SBTML_RESET));
+	W_SBREG(si, &sb->sbtmstatelow, (bits | rej | SBTML_RESET));
 	OSL_DELAY(1);
 }
 
+/* set chip watchdog reset timer to fire in 'ticks' backplane cycles */
 void
-sb_watchdog(void *sbh, uint ticks)
+sb_watchdog(sb_t *sbh, uint ticks)
 {
-	sb_info_t *si = SB_INFO(sbh);
+	/* make sure we come up in fast clock mode; or if clearing, clear clock */
+	if (ticks)
+		sb_clkctl_clk(sbh, CLK_FAST);
+	else
+		sb_clkctl_clk(sbh, CLK_DYNAMIC);
+
+#if defined(CONFIG_BCM4328)
+	if (sbh->chip == BCM4328_CHIP_ID && ticks != 0)
+		sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, min_res_mask),
+		           PMURES_BIT(RES4328_ROM_SWITCH),
+		           PMURES_BIT(RES4328_ROM_SWITCH));
+#endif
 
 	/* instant NMI */
-	switch (si->gpioid) {
-	case SB_CC:
-		sb_corereg(sbh, si->gpioidx, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
-		break;
-	case SB_EXTIF:
-		sb_corereg(sbh, si->gpioidx, OFFSETOF(extifregs_t, watchdog), ~0, ticks);
-		break;
-	}
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
 }
 
 /* initialize the pcmcia core */
 void
-sb_pcmcia_init(void *sbh)
+sb_pcmcia_init(sb_t *sbh)
 {
 	sb_info_t *si;
-	uint8 cor;
+	uint8 cor = 0;
 
 	si = SB_INFO(sbh);
 
 	/* enable d11 mac interrupts */
-	if (si->chip == BCM4301_DEVICE_ID) {
-		/* Have to use FCR2 in 4301 */
-		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_FCR2 + PCMCIA_COR, &cor, 1);
-		cor |= COR_IRQEN | COR_FUNEN;
-		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_FCR2 + PCMCIA_COR, &cor, 1);
-	} else {
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_FCR0 + PCMCIA_COR, &cor, 1);
 		cor |= COR_IRQEN | COR_FUNEN;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_FCR0 + PCMCIA_COR, &cor, 1);
+
+}
+
+
+void
+BCMINITFN(sb_pci_up)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+		return;
+
+	if (FORCEHT_WAR32414(si))
+		sb_war32414_forceHT(sbh, 1);
+
+	if (PCIE_ASPMWARS(si) || si->sb.pr42780)
+		sb_pcieclkreq(sbh, 1, 0);
+
+	if (PCIE(si) &&
+	    (((si->sb.chip == BCM4311_CHIP_ID) && (si->sb.chiprev == 2)) ||
+	     ((si->sb.chip == BCM4312_CHIP_ID) && (si->sb.chiprev == 0))))
+		sb_set_initiator_to((void *)si, 0x3, sb_findcoreidx((void *)si, SB_D11, 0));
+
+}
+
+/* Unconfigure and/or apply various WARs when system is going to sleep mode */
+void
+BCMUNINITFN(sb_pci_sleep)(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+	w &= ~PCIE_CAP_LCREG_ASPML1;
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32), w);
+}
+
+/* Unconfigure and/or apply various WARs when going down */
+void
+BCMINITFN(sb_pci_down)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+		return;
+
+	if (FORCEHT_WAR32414(si))
+		sb_war32414_forceHT(sbh, 0);
+
+	if (si->pr42767_war) {
+		sb_pcieclkreq(sbh, 1, 1);
+		si->pr42767_war = FALSE;
+	} else if (si->sb.pr42780) {
+		sb_pcieclkreq(sbh, 1, 1);
 	}
+}
+
+static void
+BCMINITFN(sb_war42767_clkreq)(sb_t *sbh)
+{
+	sbpcieregs_t *pcieregs;
+	uint16 val16, *reg16;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
+	reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET];
+	val16 = R_REG(si->osh, reg16);
+	/* if clockreq is not advertized advertize it */
+	if (!si->pcie_war_ovr) {
+		val16 |= SRSH_CLKREQ_ENB;
+		si->pr42767_war = TRUE;
 
+		si->sb.pr42780 = TRUE;
+	} else
+		val16 &= ~SRSH_CLKREQ_ENB;
+	W_REG(si->osh, reg16, val16);
 }
 
+static void
+BCMINITFN(sb_war42767)(sb_t *sbh)
+{
+	uint32 w = 0;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	sb_pcie_mdioread(si, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, &w);
+	if (w & PLL_CTRL_FREQDET_EN) {
+		w &= ~PLL_CTRL_FREQDET_EN;
+		sb_pcie_mdiowrite(si, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, w);
+	}
+}
 
 /*
  * Configure the pci core for pci client (NIC) action
@@ -1213,7 +2252,7 @@
  * coremask is the bitvec of cores by index to be enabled.
  */
 void
-sb_pci_setup(void *sbh, uint32 *dmaoffset, uint coremask)
+BCMINITFN(sb_pci_setup)(sb_t *sbh, uint coremask)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -1224,14 +2263,12 @@
 
 	si = SB_INFO(sbh);
 
-	if (dmaoffset)
-		*dmaoffset = 0;
-
 	/* if not pci bus, we're done */
-	if (BUSTYPE(si->bustype) != PCI_BUS)
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
 		return;
 
-	ASSERT(si->pciidx != BADIDX);
+	ASSERT(PCI(si) || PCIE(si));
+	ASSERT(si->sb.buscoreidx != BADIDX);
 
 	/* get current core index */
 	idx = si->curidx;
@@ -1239,45 +2276,81 @@
 	/* we interrupt on this backplane flag number */
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
-	sbflag = R_SBREG(sbh, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
+	sbflag = R_SBREG(si, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
 
 	/* switch over to pci core */
-	pciregs = (sbpciregs_t*) sb_setcoreidx(sbh, si->pciidx);
+	pciregs = (sbpciregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
 	sb = REGS2SB(pciregs);
 
 	/*
 	 * Enable sb->pci interrupts.  Assume
 	 * PCI rev 2.3 support was added in pci core rev 6 and things changed..
 	 */
-	if (si->pcirev < 6) {
-		/* set sbintvec bit for our flag number */
-		OR_SBREG(sbh, &sb->sbintvec, (1 << sbflag));
-	} else {
+	if (PCIE(si) || (PCI(si) && ((si->sb.buscorerev) >= 6))) {
 		/* pci config write to set this core bit in PCIIntMask */
 		w = OSL_PCI_READ_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32));
 		w |= (coremask << PCI_SBIM_SHIFT);
 		OSL_PCI_WRITE_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32), w);
+	} else {
+		/* set sbintvec bit for our flag number */
+		OR_SBREG(si, &sb->sbintvec, (1 << sbflag));
 	}
 
-	/* enable prefetch and bursts for dma big window */
-	OR_REG(&pciregs->sbtopci2, (SBTOPCI_PREF|SBTOPCI_BURST));
-
-	/* enable read multiple for dma big window */
-	if (si->pcirev >= 11)
-		OR_REG(&pciregs->sbtopci2, SBTOPCI_RC_READMULTI);
-
-	if (si->pcirev < 5) {
-		SET_SBREG(sbh, &sb->sbimconfiglow, SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
+	if (PCI(si)) {
+		OR_REG(si->osh, &pciregs->sbtopci2, (SBTOPCI_PREF|SBTOPCI_BURST));
+		if (si->sb.buscorerev >= 11)
+			OR_REG(si->osh, &pciregs->sbtopci2, SBTOPCI_RC_READMULTI);
+		if (si->sb.buscorerev < 5) {
+			SET_SBREG(si, &sb->sbimconfiglow, SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 			(0x3 << SBIMCL_RTO_SHIFT) | 0x2);
 		sb_commit(sbh);
 	}
+	}
+
+	/* PCIE workarounds */
+	if (PCIE(si)) {
+		if ((si->sb.buscorerev == 0) || (si->sb.buscorerev == 1)) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_TLP_WORKAROUNDSREG);
+			w |= 0x8;
+			sb_pcie_writereg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_TLP_WORKAROUNDSREG, w);
+		}
+
+		if (si->sb.buscorerev == 1) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_LCREG);
+			w |= (0x40);
+			sb_pcie_writereg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS, PCIE_DLLP_LCREG, w);
+		}
+
+		if (si->sb.buscorerev == 0)
+			sb_war30841(si);
+
+		if ((si->sb.buscorerev >= 3) && (si->sb.buscorerev <= 5)) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_PMTHRESHREG);
+			w &= ~(PCIE_L1THRESHOLDTIME_MASK);
+			w |= (PCIE_L1THRESHOLD_WARVAL << PCIE_L1THRESHOLDTIME_SHIFT);
+			sb_pcie_writereg((void *)(uintptr)sbh, (void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_PMTHRESHREG, w);
+
+			sb_war43448(sbh);
+
+			sb_war42767(sbh);
+
+			sb_war43448_aspm(sbh);
+			sb_war42767_clkreq(sbh);
+		}
+	}
 
 	/* switch back to previous core */
 	sb_setcoreidx(sbh, idx);
-
-	/* use large sb pci dma window */
-	if (dmaoffset)
-		*dmaoffset = SB_PCI_DMA;
 }
 
 uint32
@@ -1330,7 +2403,7 @@
 
 /* return the core-type instantiation # of the current core */
 uint
-sb_coreunit(void *sbh)
+sb_coreunit(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint idx;
@@ -1354,8 +2427,8 @@
 	return (coreunit);
 }
 
-static INLINE uint32
-factor6(uint32 x)
+static uint32
+BCMINITFN(factor6)(uint32 x)
 {
 	switch (x) {
 	case CC_F6_2:	return 2;
@@ -1370,7 +2443,7 @@
 
 /* calculate the speed the SB would run at given a set of clockcontrol values */
 uint32
-sb_clock_rate(uint32 pll_type, uint32 n, uint32 m)
+BCMINITFN(sb_clock_rate)(uint32 pll_type, uint32 n, uint32 m)
 {
 	uint32 n1, n2, clock, m1, m2, m3, mc;
 
@@ -1382,7 +2455,10 @@
 			return CC_T6_M1;
 		else
 			return CC_T6_M0;
-	} else if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE4)|| (pll_type == PLL_TYPE3)) {
+	} else if ((pll_type == PLL_TYPE1) ||
+	           (pll_type == PLL_TYPE3) ||
+	           (pll_type == PLL_TYPE4) ||
+	           (pll_type == PLL_TYPE7)) {
 		n1 = factor6(n1);
 		n2 += CC_F5_BIAS;
 	} else if (pll_type == PLL_TYPE2) {
@@ -1393,13 +2469,13 @@
 	} else if (pll_type == PLL_TYPE5) {
 		return (100000000);
 	} else
-		ASSERT((pll_type >= PLL_TYPE1) && (pll_type <= PLL_TYPE4));
-
-	/* Special case for 5350 */
-	if (pll_type == PLL_TYPE3) 
-		clock =  CLOCK_BASE_5350 * n1 * n2;
-	else 
-		clock = CC_CLOCK_BASE * n1 * n2;
+		ASSERT(0);
+	/* PLL types 3 and 7 use BASE2 (25Mhz) */
+	if ((pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE7)) {
+		clock =  CC_CLOCK_BASE2 * n1 * n2;
+	} else
+		clock = CC_CLOCK_BASE1 * n1 * n2;
 
 	if (clock == 0)
 		return 0;
@@ -1409,7 +2485,10 @@
 	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
 	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;
 
-	if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE3)) {
+	if ((pll_type == PLL_TYPE1) ||
+	    (pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE4) ||
+	    (pll_type == PLL_TYPE7)) {
 		m1 = factor6(m1);
 		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
 			m2 += CC_F5_BIAS;
@@ -1442,16 +2521,15 @@
 		if ((mc & CC_T2MC_M3BYP) == 0)
 			clock /= m3;
 
-		return(clock);
+		return (clock);
 	}
 }
 
 /* returns the current speed the SB is running at */
 uint32
-sb_clock(void *sbh)
+BCMINITFN(sb_clock)(sb_t *sbh)
 {
 	sb_info_t *si;
-	extifregs_t *eir;
 	chipcregs_t *cc;
 	uint32 n, m;
 	uint idx;
@@ -1464,41 +2542,30 @@
 
 	INTR_OFF(si, intr_val);
 
-	/* switch to extif or chipc core */
-	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
-		n = R_REG(&eir->clockcontrol_n);
-		m = R_REG(&eir->clockcontrol_sb);
-	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
-		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
-		n = R_REG(&cc->clockcontrol_n);
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	if (sbh->cccaps & CC_CAP_PMU) {
+		rate = sb_pmu_cpu_clock(sbh, si->osh);
+		goto exit;
+	}
+
+	pll_type = sbh->cccaps & CC_CAP_PLL_MASK;
+	n = R_REG(si->osh, &cc->clockcontrol_n);
 		if (pll_type == PLL_TYPE6)
-			m = R_REG(&cc->clockcontrol_mips);
+		m = R_REG(si->osh, &cc->clockcontrol_m3);
 		else if (pll_type == PLL_TYPE3)
-		{
-			// Added by Chen-I for 5365 
-			if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID) 	
-				m = R_REG(&cc->clockcontrol_sb);
-			else m = R_REG(&cc->clockcontrol_m2);
-		}
+		m = R_REG(si->osh, &cc->clockcontrol_m2);
 		else
-			m = R_REG(&cc->clockcontrol_sb);
-	} else {
-		INTR_RESTORE(si, intr_val);
-		return 0;
-	}
+		m = R_REG(si->osh, &cc->clockcontrol_sb);
 
-	// Added by Chen-I for 5365 
-	if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
-	{
-		rate = 100000000;	
-	}
-	else
-	{
 		/* calculate rate */
 		rate = sb_clock_rate(pll_type, n, m);
-		if (pll_type == PLL_TYPE3) rate = rate / 2;
-	}
 
+	if (pll_type == PLL_TYPE3)
+		rate = rate / 2;
+
+exit:
 	/* switch back to previous core */
 	sb_setcoreidx(sbh, idx);
 
@@ -1507,20 +2574,31 @@
 	return rate;
 }
 
+uint32
+BCMINITFN(sb_alp_clock)(sb_t *sbh)
+{
+	uint32 clock = ALP_CLOCK;
+
+	if (sbh->cccaps & CC_CAP_PMU)
+		clock = sb_pmu_alp_clock(sbh, sb_osh(sbh));
+
+	return clock;
+}
+
 /* change logical "focus" to the gpio core for optimized access */
 void*
-sb_gpiosetcore(void *sbh)
+sb_gpiosetcore(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
 
-	return (sb_setcoreidx(sbh, si->gpioidx));
+	return (sb_setcoreidx(sbh, SB_CC_IDX));
 }
 
 /* mask&set gpiocontrol bits */
 uint32
-sb_gpiocontrol(void *sbh, uint32 mask, uint32 val)
+sb_gpiocontrol(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1528,25 +2606,23 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiocontrol);
-		break;
-
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpiocontrol);
-		break;
-
-	case SB_EXTIF:
-		return (0);
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio output enable bits */
 uint32
-sb_gpioouten(void *sbh, uint32 mask, uint32 val)
+sb_gpioouten(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1554,26 +2630,23 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpioouten);
-		break;
-
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioouten);
-		break;
-
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpio[0].outen);
-		break;
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpioouten);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio output bits */
 uint32
-sb_gpioout(void *sbh, uint32 mask, uint32 val)
+sb_gpioout(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1581,53 +2654,89 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
 		regoff = OFFSETOF(chipcregs_t, gpioout);
-		break;
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
+}
 
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioout);
-		break;
+/* reserve one gpio */
+uint32
+sb_gpioreserve(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
+{
+	sb_info_t *si;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpio[0].out);
-		break;
+	si = SB_INFO(sbh);
+
+	/* only cores on SB_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
 	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
+
+	/* already reserved */
+	if (sb_gpioreservation & gpio_bitmask)
+		return -1;
+	/* set reservation */
+	sb_gpioreservation |= gpio_bitmask;
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	return sb_gpioreservation;
 }
 
-/* return the current gpioin register value */
+/* release one gpio */
+/* 
+ * releasing the gpio doesn't change the current value on the GPIO last write value
+ * persists till some one overwrites it
+*/
+
 uint32
-sb_gpioin(void *sbh)
+sb_gpiorelease(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
 {
 	sb_info_t *si;
-	uint regoff;
 
 	si = SB_INFO(sbh);
-	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpioin);
-		break;
+	/* only cores on SB_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
 
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioin);
-		break;
+	/* already released */
+	if (!(sb_gpioreservation & gpio_bitmask))
+		return -1;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpioin);
-		break;
-	}
+	/* clear reservation */
+	sb_gpioreservation &= ~gpio_bitmask;
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, 0, 0));
+	return sb_gpioreservation;
 }
 
-/* mask&set gpio interrupt polarity bits */
+/* return the current gpioin register value */
 uint32
-sb_gpiointpolarity(void *sbh, uint32 mask, uint32 val)
+sb_gpioin(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1635,27 +2744,34 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
-		break;
+	regoff = OFFSETOF(chipcregs_t, gpioin);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, 0, 0));
+}
 
-	case SB_PCI:
-		/* pci gpio implementation does not support interrupt polarity */
-		ASSERT(0);
-		break;
+/* mask&set gpio interrupt polarity bits */
+uint32
+sb_gpiointpolarity(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpiointpolarity);
-		break;
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio interrupt mask bits */
 uint32
-sb_gpiointmask(void *sbh, uint32 mask, uint32 val)
+sb_gpiointmask(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1663,186 +2779,275 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiointmask);
-		break;
-
-	case SB_PCI:
-		/* pci gpio implementation does not support interrupt mask */
-		ASSERT(0);
-		break;
-
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpiointmask);
-		break;
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiointmask);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
-
-/*
- * Return the slow clock source.
- * Three sources of SLOW CLOCK: LPO, Xtal, PCI
- */
-static uint
-sb_slowclk_src(void *sbh)
+/* assign the gpio to an led */
+uint32
+sb_gpioled(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
-	chipcregs_t *cc;
-	uint32 v;
 
 	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 16)
+		return -1;
 
-	ASSERT(sb_coreid(sbh) == SB_CC);
-
-	if (si->ccrev < 6) {
-		switch (BUSTYPE(si->bustype)) {
-			case PCMCIA_BUS: return (SCC_SS_XTAL);
-			case PCI_BUS:
-				v = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32));
-				if (v & PCI_CFG_GPIO_SCS)
-					return (SCC_SS_PCI);
-				else
-					return (SCC_SS_XTAL);
-			default: return (SCC_SS_XTAL);
-		}
-	} else if (si->ccrev < 10) {
-		cc = (chipcregs_t*) sb_setcoreidx(sbh, si->curidx);
-		v = R_REG(&cc->slow_clk_ctl) & SCC_SS_MASK;
-		return (v);
-	} else {
-		return (SCC_SS_XTAL);
-	}
+	/* gpio led powersave reg */
+	return (sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask, val));
 }
 
-/*
- * Return the slowclock min or max frequency.
- * Three sources of SLOW CLOCK:
- *	1. On Chip LPO		-	32khz or 160khz
- *	2. On Chip Xtal OSC	-	20mhz/4*(divider+1)
- *	3. External PCI clock	-	66mhz/4*(divider+1)
- */
-static uint
-sb_slowclk_freq(void *sbh, bool max)
+/* mask&set gpio timer val */
+uint32
+sb_gpiotimerval(sb_t *sbh, uint32 mask, uint32 gpiotimerval)
 {
 	sb_info_t *si;
-	chipcregs_t *cc;
-	uint32 slowclk;
-	uint div;
+	si = SB_INFO(sbh);
+
+	if (si->sb.ccrev < 16)
+		return -1;
+
+	return (sb_corereg(sbh, SB_CC_IDX,
+		OFFSETOF(chipcregs_t, gpiotimerval), mask, gpiotimerval));
+}
+
+uint32
+sb_gpiopull(sb_t *sbh, bool updown, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint offs;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 20)
+		return -1;
+
+	offs = (updown ? OFFSETOF(chipcregs_t, gpiopulldown) : OFFSETOF(chipcregs_t, gpiopullup));
+	return (sb_corereg(sbh, SB_CC_IDX, offs, mask, val));
+}
+
+uint32
+sb_gpioevent(sb_t *sbh, uint regtype, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint offs;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return -1;
+
+	if (regtype == GPIO_REGEVT)
+		offs = OFFSETOF(chipcregs_t, gpioevent);
+	else if (regtype == GPIO_REGEVT_INTMSK)
+		offs = OFFSETOF(chipcregs_t, gpioeventintmask);
+	else if (regtype == GPIO_REGEVT_INTPOL)
+		offs = OFFSETOF(chipcregs_t, gpioeventintpolarity);
+	else
+		return -1;
+
+	return (sb_corereg(sbh, SB_CC_IDX, offs, mask, val));
+}
+
+void*
+BCMINITFN(sb_gpio_handler_register)(sb_t *sbh, uint32 event,
+	bool level, gpio_handler_t cb, void *arg)
+{
+	sb_info_t *si;
+	gpioh_item_t *gi;
+
+	ASSERT(event);
+	ASSERT(cb);
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return NULL;
+
+	if ((gi = MALLOC(si->osh, sizeof(gpioh_item_t))) == NULL)
+		return NULL;
+
+	bzero(gi, sizeof(gpioh_item_t));
+	gi->event = event;
+	gi->handler = cb;
+	gi->arg = arg;
+	gi->level = level;
+
+	gi->next = si->gpioh_head;
+	si->gpioh_head = gi;
+
+	return (void*)(gi);
+}
+
+void
+BCMINITFN(sb_gpio_handler_unregister)(sb_t *sbh, void* gpioh)
+{
+	sb_info_t *si;
+	gpioh_item_t *p, *n;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return;
+
+	ASSERT(si->gpioh_head);
+	if ((void*)si->gpioh_head == gpioh) {
+		si->gpioh_head = si->gpioh_head->next;
+		MFREE(si->osh, gpioh, sizeof(gpioh_item_t));
+		return;
+	}
+	else {
+		p = si->gpioh_head;
+		n = p->next;
+		while (n) {
+			if ((void*)n == gpioh) {
+				p->next = n->next;
+				MFREE(si->osh, gpioh, sizeof(gpioh_item_t));
+				return;
+			}
+			p = n;
+			n = n->next;
+		}
+	}
+
+	ASSERT(0); /* Not found in list */
+}
+
+void
+sb_gpio_handler_process(sb_t *sbh)
+{
+	sb_info_t *si;
+	gpioh_item_t *h;
+	uint32 status;
+	uint32 level = sb_gpioin(sbh);
+	uint32 edge = sb_gpioevent(sbh, GPIO_REGEVT, 0, 0);
 
 	si = SB_INFO(sbh);
+	for (h = si->gpioh_head; h != NULL; h = h->next) {
+		if (h->handler) {
+			status = (h->level ? level : edge);
+
+			if (status & h->event)
+				h->handler(status, h->arg);
+		}
+	}
+
+	sb_gpioevent(sbh, GPIO_REGEVT, edge, edge); /* clear edge-trigger status */
+}
+
+uint32
+sb_gpio_int_enable(sb_t *sbh, bool enable)
+{
+	sb_info_t *si;
+	uint offs;
 
-	ASSERT(sb_coreid(sbh) == SB_CC);
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return -1;
 
-	cc = (chipcregs_t*) sb_setcoreidx(sbh, si->curidx);
+	offs = OFFSETOF(chipcregs_t, intmask);
+	return (sb_corereg(sbh, SB_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
+}
 
-	/* shouldn't be here unless we've established the chip has dynamic power control */
-	ASSERT(R_REG(&cc->capabilities) & CAP_PWR_CTL);
 
-	slowclk = sb_slowclk_src(sbh);
-	if (si->ccrev < 6) {
+/* return the slow clock source - LPO, XTAL, or PCI */
+static uint
+sb_slowclk_src(sb_info_t *si)
+{
+	chipcregs_t *cc;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	if (si->sb.ccrev < 6) {
+		if ((BUSTYPE(si->sb.bustype) == PCI_BUS) &&
+		    (OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32)) &
+		     PCI_CFG_GPIO_SCS))
+			return (SCC_SS_PCI);
+		else
+			return (SCC_SS_XTAL);
+	} else if (si->sb.ccrev < 10) {
+		cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+		return (R_REG(si->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
+	} else	/* Insta-clock */
+		return (SCC_SS_XTAL);
+}
+
+/* return the ILP (slowclock) min or max frequency */
+static uint
+sb_slowclk_freq(sb_info_t *si, bool max_freq)
+{
+	chipcregs_t *cc;
+	uint32 slowclk;
+	uint div;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+
+	/* shouldn't be here unless we've established the chip has dynamic clk control */
+	ASSERT(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL);
+
+	slowclk = sb_slowclk_src(si);
+	if (si->sb.ccrev < 6) {
 		if (slowclk == SCC_SS_PCI)
-			return (max? (PCIMAXFREQ/64) : (PCIMINFREQ/64));
+			return (max_freq ? (PCIMAXFREQ / 64) : (PCIMINFREQ / 64));
 		else
-			return (max? (XTALMAXFREQ/32) : (XTALMINFREQ/32));
-	} else if (si->ccrev < 10) {
-		div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHF) + 1);
+			return (max_freq ? (XTALMAXFREQ / 32) : (XTALMINFREQ / 32));
+	} else if (si->sb.ccrev < 10) {
+		div = 4 * (((R_REG(si->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
 		if (slowclk == SCC_SS_LPO)
-			return (max? LPOMAXFREQ : LPOMINFREQ);
+			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
 		else if (slowclk == SCC_SS_XTAL)
-			return (max? (XTALMAXFREQ/div) : (XTALMINFREQ/div));
+			return (max_freq ? (XTALMAXFREQ / div) : (XTALMINFREQ / div));
 		else if (slowclk == SCC_SS_PCI)
-			return (max? (PCIMAXFREQ/div) : (PCIMINFREQ/div));
+			return (max_freq ? (PCIMAXFREQ / div) : (PCIMINFREQ / div));
 		else
 			ASSERT(0);
 	} else {
 		/* Chipc rev 10 is InstaClock */
-		div = R_REG(&cc->system_clk_ctl) >> SYCC_CD_SHF;
+		div = R_REG(si->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
 		div = 4 * (div + 1);
-		return (max ? XTALMAXFREQ : (XTALMINFREQ/div));
+		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
 	}
 	return (0);
 }
 
 static void
-sb_pwrctl_setdelay(void *sbh, void *chipcregs)
+BCMINITFN(sb_clkctl_setdelay)(sb_info_t *si, void *chipcregs)
 {
-	sb_info_t *si;
 	chipcregs_t * cc;
 	uint slowmaxfreq, pll_delay, slowclk;
 	uint pll_on_delay, fref_sel_delay;
 
-	si = SB_INFO(sbh);
 	pll_delay = PLL_DELAY;
 
 	/* If the slow clock is not sourced by the xtal then add the xtal_on_delay
-	 * since the xtal will also be powered down by dynamic power control logic.
+	 * since the xtal will also be powered down by dynamic clk control logic.
 	 */
-	slowclk = sb_slowclk_src(sbh);
+
+	slowclk = sb_slowclk_src(si);
 	if (slowclk != SCC_SS_XTAL)
 		pll_delay += XTAL_ON_DELAY;
 
 	/* Starting with 4318 it is ILP that is used for the delays */
-	slowmaxfreq = sb_slowclk_freq(sbh, (si->ccrev >= 10) ? FALSE : TRUE);
+	slowmaxfreq = sb_slowclk_freq(si, (si->sb.ccrev >= 10) ? FALSE : TRUE);
 
 	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
 	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
 
 	cc = (chipcregs_t *)chipcregs;
-	W_REG(&cc->pll_on_delay, pll_on_delay);
-	W_REG(&cc->fref_sel_delay, fref_sel_delay);
-}
-
-/* set or get slow clock divider */
-int
-sb_pwrctl_slowclk(void *sbh, bool set, uint *div)
-{
-	sb_info_t *si;
-	uint origidx;
-	chipcregs_t *cc;
-	uint intr_val = 0;
-	uint err = 0;
-	
-	si = SB_INFO(sbh);
-
-	/* chipcommon cores prior to rev6 don't support slowclkcontrol */
-	if (si->ccrev < 6)
-		return 1;
-
-	/* chipcommon cores rev10 are a whole new ball game */
-	if (si->ccrev >= 10)
-		return 1;
-
-	if (set && ((*div % 4) || (*div < 4)))
-		return 2;
-	
-	INTR_OFF(si, intr_val);
-	origidx = si->curidx;
-	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
-	ASSERT(cc != NULL);
-	
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL)) {
-		err = 3;
-		goto done;
-	}
-
-	if (set) {
-		SET_REG(&cc->slow_clk_ctl, SCC_CD_MASK, ((*div / 4 - 1) << SCC_CD_SHF));
-		sb_pwrctl_setdelay(sbh, (void *)cc);
-	} else
-		*div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHF) + 1);
-
-done:
-	sb_setcoreidx(sbh, origidx);
-	INTR_RESTORE(si, intr_val);
-	return err;
+	W_REG(si->osh, &cc->pll_on_delay, pll_on_delay);
+	W_REG(si->osh, &cc->fref_sel_delay, fref_sel_delay);
 }
 
 /* initialize power control delay registers */
 void
-sb_pwrctl_init(void *sbh)
+BCMINITFN(sb_clkctl_init)(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1855,16 +3060,19 @@
 	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
 		return;
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if ((si->sb.chip == BCM4321_CHIP_ID) && (si->sb.chiprev < 2))
+		W_REG(si->osh, &cc->chipcontrol,
+		      (si->sb.chiprev == 0) ? CHIPCTRL_4321A0_DEFAULT : CHIPCTRL_4321A1_DEFAULT);
+
+	if (!(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL))
 		goto done;
 
-	/* 4317pc does not work with SlowClock less than 5Mhz */
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-		if ((si->ccrev >= 6) && (si->ccrev < 10))
-			SET_REG(&cc->slow_clk_ctl, SCC_CD_MASK, (SCC_DEF_DIV << SCC_CD_SHF));
-	}
+	/* set all Instaclk chip ILP to 1 MHz */
+	if (si->sb.ccrev >= 10)
+		SET_REG(si->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
+		        (ILP_DIV_1MHZ << SYCC_CD_SHIFT));
 	
-	sb_pwrctl_setdelay(sbh, (void *)cc);
+	sb_clkctl_setdelay(si, (void *)(uintptr)cc);
 
 done:
 	sb_setcoreidx(sbh, origidx);
@@ -1872,7 +3080,7 @@
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
 uint16
-sb_pwrctl_fast_pwrup_delay(void *sbh)
+BCMINITFN(sb_clkctl_fast_pwrup_delay)(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1885,19 +3093,22 @@
 	fpdelay = 0;
 	origidx = si->curidx;
 
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		goto done;
-
 	INTR_OFF(si, intr_val);
 
 	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
 		goto done;
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if (sbh->cccaps & CC_CAP_PMU) {
+		fpdelay = sb_pmu_fast_pwrup_delay(sbh, si->osh);
+		goto done;
+	}
+
+	if (!(sbh->cccaps & CC_CAP_PWR_CTL))
 		goto done;
 
-	slowminfreq = sb_slowclk_freq(sbh, FALSE);
-	fpdelay = (((R_REG(&cc->pll_on_delay) + 2) * 1000000) + (slowminfreq - 1)) / slowminfreq;
+	slowminfreq = sb_slowclk_freq(si, FALSE);
+	fpdelay = (((R_REG(si->osh, &cc->pll_on_delay) + 2) * 1000000) +
+	           (slowminfreq - 1)) / slowminfreq;
 
 done:
 	sb_setcoreidx(sbh, origidx);
@@ -1907,14 +3118,14 @@
 
 /* turn primary xtal and/or pll off/on */
 int
-sb_pwrctl_xtal(void *sbh, uint what, bool on)
+sb_clkctl_xtal(sb_t *sbh, uint what, bool on)
 {
 	sb_info_t *si;
 	uint32 in, out, outen;
 
 	si = SB_INFO(sbh);
 
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 
 
 		case PCMCIA_BUS:
@@ -1923,9 +3134,13 @@
 
 		case PCI_BUS:
 
-			in = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_IN, sizeof (uint32));
-			out = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32));
-			outen = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32));
+			/* pcie core doesn't have any mapping to control the xtal pu */
+			if (PCIE(si))
+				return -1;
+
+			in = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_IN, sizeof(uint32));
+			out = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32));
+			outen = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof(uint32));
 
 			/*
 			 * Avoid glitching the clock if GPRS is already using it.
@@ -1946,15 +3161,18 @@
 					out |= PCI_CFG_GPIO_XTAL;
 					if (what & PLL)
 						out |= PCI_CFG_GPIO_PLL;
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT,
+					                     sizeof(uint32), out);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN,
+					                     sizeof(uint32), outen);
 					OSL_DELAY(XTAL_ON_DELAY);
 				}
 
 				/* turn pll on */
 				if (what & PLL) {
 					out &= ~PCI_CFG_GPIO_PLL;
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT,
+					                     sizeof(uint32), out);
 					OSL_DELAY(2000);
 				}
 			} else {
@@ -1962,8 +3180,9 @@
 					out &= ~PCI_CFG_GPIO_XTAL;
 				if (what & PLL)
 					out |= PCI_CFG_GPIO_PLL;
-				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
-				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32), out);
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof(uint32),
+				                     outen);
 			}
 
 		default:
@@ -1973,79 +3192,100 @@
 	return (0);
 }
 
-/* set dynamic power control mode (forceslow, forcefast, dynamic) */
-/*   returns true if ignore pll off is set and false if it is not */
+/* set dynamic clk control mode (forceslow, forcefast, dynamic) */
+/*   returns true if we are forcing fast clock */
 bool
-sb_pwrctl_clk(void *sbh, uint mode)
+sb_clkctl_clk(sb_t *sbh, uint mode)
 {
 	sb_info_t *si;
 	uint origidx;
 	chipcregs_t *cc;
 	uint32 scc;
-	bool forcefastclk=FALSE;
 	uint intr_val = 0;
 
 	si = SB_INFO(sbh);
 
-	/* chipcommon cores prior to rev6 don't support slowclkcontrol */
-	if (si->ccrev < 6)
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (si->sb.ccrev < 6)
 		return (FALSE);
 
-	/* chipcommon cores rev10 are a whole new ball game */
-	if (si->ccrev >= 10)
-		return (FALSE);
+
+	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
+	ASSERT(si->sb.ccrev != 10);
 
 	INTR_OFF(si, intr_val);
 
 	origidx = si->curidx;
 
+	if (sb_setcore(sbh, SB_MIPS33, 0) && (sb_corerev(&si->sb) <= 7) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (si->sb.ccrev >= 10))
+		goto done;
+
+	if (FORCEHT_WAR32414(si))
+		goto done;
+
 	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
 	ASSERT(cc != NULL);
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if (!(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL) && (si->sb.ccrev < 20))
 		goto done;
 
 	switch (mode) {
 	case CLK_FAST:	/* force fast (pll) clock */
+		if (si->sb.ccrev < 10) {
 		/* don't forget to force xtal back on before we clear SCC_DYN_XTAL.. */
-		sb_pwrctl_xtal(sbh, XTAL, ON);
+			sb_clkctl_xtal(&si->sb, XTAL, ON);
 
-		SET_REG(&cc->slow_clk_ctl, (SCC_XC | SCC_FS | SCC_IP), SCC_IP);
-		break;
-
-	case CLK_SLOW:	/* force slow clock */
-		if ((BUSTYPE(si->bustype) == SDIO_BUS) || (BUSTYPE(si->bustype) == PCMCIA_BUS))
-			return (-1);
+			SET_REG(si->osh, &cc->slow_clk_ctl, (SCC_XC | SCC_FS | SCC_IP), SCC_IP);
+		} else if (si->sb.ccrev < 20) {
+			OR_REG(si->osh, &cc->system_clk_ctl, SYCC_HR);
+		} else {
+			OR_REG(si->osh, &cc->clk_ctl_st, CCS_FORCEHT);
+		}
 
-		if (si->ccrev >= 6)
-			OR_REG(&cc->slow_clk_ctl, SCC_FS);
+		/* wait for the PLL */
+		if (R_REG(si->osh, &cc->capabilities) & CC_CAP_PMU) {
+			SPINWAIT(((R_REG(si->osh, &cc->clk_ctl_st) & CCS_HTAVAIL) == 0),
+			         PMU_MAX_TRANSITION_DLY);
+			ASSERT(R_REG(si->osh, &cc->clk_ctl_st) & CCS_HTAVAIL);
+		} else {
+			OSL_DELAY(PLL_DELAY);
+		}
 		break;
 
-	case CLK_DYNAMIC:	/* enable dynamic power control */
-		scc = R_REG(&cc->slow_clk_ctl);
+	case CLK_DYNAMIC:	/* enable dynamic clock control */
+		if (si->sb.ccrev < 10) {
+			scc = R_REG(si->osh, &cc->slow_clk_ctl);
 		scc &= ~(SCC_FS | SCC_IP | SCC_XC);
 		if ((scc & SCC_SS_MASK) != SCC_SS_XTAL)
 			scc |= SCC_XC;
-		W_REG(&cc->slow_clk_ctl, scc);
+			W_REG(si->osh, &cc->slow_clk_ctl, scc);
 
 		/* for dynamic control, we have to release our xtal_pu "force on" */
 		if (scc & SCC_XC)
-			sb_pwrctl_xtal(sbh, XTAL, OFF);
-		break;
+				sb_clkctl_xtal(&si->sb, XTAL, OFF);
+		} else if (si->sb.ccrev < 20) {
+			/* Instaclock */
+			AND_REG(si->osh, &cc->system_clk_ctl, ~SYCC_HR);
+		} else {
+			AND_REG(si->osh, &cc->clk_ctl_st, ~CCS_FORCEHT);
 	}
+		break;
 
-	/* Is the h/w forcing the use of the fast clk */
-	forcefastclk = (bool)((R_REG(&cc->slow_clk_ctl) & SCC_IP) == SCC_IP);
+	default:
+		ASSERT(0);
+	}
 
 done:
 	sb_setcoreidx(sbh, origidx);
 	INTR_RESTORE(si, intr_val);
-	return (forcefastclk);
+	return (mode == CLK_FAST);
 }
 
 /* register driver interrupt disabling and restoring callback functions */
 void
-sb_register_intr_callback(void *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intrsenabled_fn, void *intr_arg)
+sb_register_intr_callback(sb_t *sbh, void *intrsoff_fn, void *intrsrestore_fn,
+                          void *intrsenabled_fn, void *intr_arg)
 {
 	sb_info_t *si;
 
@@ -2060,4 +3300,624 @@
 	si->dev_coreid = si->coreid[si->curidx];
 }
 
+void
+sb_deregister_intr_callback(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	si->intrsoff_fn = NULL;
+}
+
+
+uint16
+BCMINITFN(sb_d11_devid)(sb_t *sbh)
+{
+	sb_info_t *si = SB_INFO(sbh);
+	uint16 device;
+
+#if defined(CONFIG_BCM4328)
+	/* Fix device id for dual band BCM4328 */
+	if (sbh->chip == BCM4328_CHIP_ID &&
+	    (sbh->chippkg == BCM4328USBDUAL_PKG_ID || sbh->chippkg == BCM4328SDIODUAL_PKG_ID))
+		device = BCM4328_D11DUAL_ID;
+	else
+#endif	/* BCM4328 */
+	/* Let an nvram variable with devpath override devid */
+	if ((device = (uint16)sb_getdevpathintvar(sbh, "devid")) != 0)
+		;
+	/* Get devid from OTP/SPROM depending on where the SROM is read */
+	else if ((device = (uint16)getintvar(si->vars, "devid")) != 0)
+		;
+	/*
+	 * no longer support wl0id, but keep the code
+	 * here for backward compatibility.
+	 */
+	else if ((device = (uint16)getintvar(si->vars, "wl0id")) != 0)
+		;
+	/* Chip specific conversion */
+	else if (sbh->chip == BCM4712_CHIP_ID) {
+		if (sbh->chippkg == BCM4712SMALL_PKG_ID)
+			device = BCM4306_D11G_ID;
+		else
+			device = BCM4306_D11DUAL_ID;
+	}
+	/* ignore it */
+	else
+		device = 0xffff;
+
+	return device;
+}
+
+int
+BCMINITFN(sb_corepciid)(sb_t *sbh, uint func, uint16 *pcivendor, uint16 *pcidevice,
+                        uint8 *pciclass, uint8 *pcisubclass, uint8 *pciprogif,
+                        uint8 *pciheader)
+{
+	uint16 vendor = 0xffff, device = 0xffff;
+	uint8 class, subclass, progif = 0;
+	uint8 header = PCI_HEADER_NORMAL;
+	uint32 core = sb_coreid(sbh);
+
+	/* Verify whether the function exists for the core */
+	if (func >= (uint)(core == SB_USB20H ? 2 : 1))
+		return BCME_ERROR;
+
+	/* Known vendor translations */
+	switch (sb_corevendor(sbh)) {
+	case SB_VEND_BCM:
+		vendor = VENDOR_BROADCOM;
+		break;
+	default:
+		return BCME_ERROR;
+	}
+
+	/* Determine class based on known core codes */
+	switch (core) {
+	case SB_ILINE20:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_ILINE_ID;
+		break;
+	case SB_ENET:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_ENET_ID;
+		break;
+	case SB_GIGETH:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_GIGETH_ID;
+		break;
+	case SB_SDRAM:
+	case SB_MEMC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_RAM;
+		device = (uint16)core;
+		break;
+	case SB_PCI:
+	case SB_PCIE:
+		class = PCI_CLASS_BRIDGE;
+		subclass = PCI_BRIDGE_PCI;
+		device = (uint16)core;
+		header = PCI_HEADER_BRIDGE;
+		break;
+	case SB_MIPS33:
+		class = PCI_CLASS_CPU;
+		subclass = PCI_CPU_MIPS;
+		device = (uint16)core;
+		break;
+	case SB_CODEC:
+		class = PCI_CLASS_COMM;
+		subclass = PCI_COMM_MODEM;
+		device = BCM47XX_V90_ID;
+		break;
+	case SB_USB:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		device = BCM47XX_USB_ID;
+		break;
+	case SB_USB11H:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		device = BCM47XX_USBH_ID;
+		break;
+	case SB_USB20H:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = func == 0 ? 0x10 : 0x20; /* OHCI/EHCI */
+		device = BCM47XX_USB20H_ID;
+		header = 0x80; /* multifunction */
+		break;
+	case SB_IPSEC:
+		class = PCI_CLASS_CRYPT;
+		subclass = PCI_CRYPT_NETWORK;
+		device = BCM47XX_IPSEC_ID;
+		break;
+	case SB_ROBO:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		device = BCM47XX_ROBO_ID;
+		break;
+	case SB_CC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_FLASH;
+		device = (uint16)core;
+		break;
+	case SB_SATAXOR:
+		class = PCI_CLASS_XOR;
+		subclass = PCI_XOR_QDMA;
+		device = BCM47XX_SATAXOR_ID;
+		break;
+	case SB_ATA100:
+		class = PCI_CLASS_DASDI;
+		subclass = PCI_DASDI_IDE;
+		device = BCM47XX_ATA100_ID;
+		break;
+	case SB_USB11D:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		device = BCM47XX_USBD_ID;
+		break;
+	case SB_USB20D:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		device = BCM47XX_USB20D_ID;
+		break;
+	case SB_D11:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		device = sb_d11_devid(sbh);
+		break;
+
+	default:
+		class = subclass = progif = 0xff;
+		device = (uint16)core;
+		break;
+	}
+
+	*pcivendor = vendor;
+	*pcidevice = device;
+	*pciclass = class;
+	*pcisubclass = subclass;
+	*pciprogif = progif;
+	*pciheader = header;
+
+	return 0;
+}
+
+/* use the mdio interface to read from mdio slaves */
+static int
+sb_pcie_mdioread(sb_info_t *si,  uint physmedia, uint regaddr, uint *regval)
+{
+	uint mdiodata;
+	uint i = 0;
+	sbpcieregs_t *pcieregs;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(&si->sb, si->sb.buscoreidx);
+	ASSERT(pcieregs);
+
+	/* enable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+	mdiodata = MDIODATA_START | MDIODATA_READ |
+	        (physmedia << MDIODATA_DEVADDR_SHF) |
+		(regaddr << MDIODATA_REGADDR_SHF) | MDIODATA_TA;
+
+	W_REG(si->osh, &pcieregs->mdiodata, mdiodata);
+
+	PR28829_DELAY();
+
+	/* retry till the transaction is complete */
+	while (i < 10) {
+		if (R_REG(si->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+			PR28829_DELAY();
+			*regval = (R_REG(si->osh, &(pcieregs->mdiodata)) & MDIODATA_MASK);
+			/* Disable mdio access to SERDES */
+			W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+			return 0;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	SB_ERROR(("sb_pcie_mdioread: timed out\n"));
+	/* Disable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+	return 1;
+}
+
+
+/* use the mdio interface to write to mdio slaves */
+static int
+sb_pcie_mdiowrite(sb_info_t *si,  uint physmedia, uint regaddr, uint val)
+{
+	uint mdiodata;
+	uint i = 0;
+	sbpcieregs_t *pcieregs;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(&si->sb, si->sb.buscoreidx);
+	ASSERT(pcieregs);
+
+	/* enable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+	mdiodata = MDIODATA_START | MDIODATA_WRITE |
+		(physmedia << MDIODATA_DEVADDR_SHF) |
+		(regaddr << MDIODATA_REGADDR_SHF) | MDIODATA_TA | val;
+
+	W_REG(si->osh, (&pcieregs->mdiodata), mdiodata);
+
+	PR28829_DELAY();
+
+	/* retry till the transaction is complete */
+	while (i < 10) {
+		if (R_REG(si->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+			/* Disable mdio access to SERDES */
+			W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+			return 0;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	SB_ERROR(("sb_pcie_mdiowrite: timed out\n"));
+	/* Disable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+	return 1;
+
+}
+
+/* indirect way to read pcie config regs */
+uint
+sb_pcie_readreg(void *sb, void* arg1, uint offset)
+{
+	sb_info_t *si;
+	sb_t   *sbh;
+	uint retval = 0xFFFFFFFF;
+	sbpcieregs_t *pcieregs;
+	uint addrtype;
+
+	sbh = (sb_t *)sb;
+	si = SB_INFO(sbh);
+	ASSERT(PCIE(si));
+
+	pcieregs = (sbpcieregs_t *)sb_setcore(sbh, SB_PCIE, 0);
+	ASSERT(pcieregs);
+
+	addrtype = (uint)((uintptr)arg1);
+	switch (addrtype) {
+		case PCIE_CONFIGREGS:
+			W_REG(si->osh, (&pcieregs->configaddr), offset);
+			retval = R_REG(si->osh, &(pcieregs->configdata));
+			break;
+		case PCIE_PCIEREGS:
+			W_REG(si->osh, &(pcieregs->pcieindaddr), offset);
+			retval = R_REG(si->osh, &(pcieregs->pcieinddata));
+			break;
+		default:
+			ASSERT(0);
+			break;
+	}
+	return retval;
+}
+
+/* indirect way to write pcie config/mdio/pciecore regs */
+uint
+sb_pcie_writereg(sb_t *sbh, void *arg1,  uint offset, uint val)
+{
+	sb_info_t *si;
+	sbpcieregs_t *pcieregs;
+	uint addrtype;
+
+	si = SB_INFO(sbh);
+	ASSERT(PCIE(si));
+
+	pcieregs = (sbpcieregs_t *)sb_setcore(sbh, SB_PCIE, 0);
+	ASSERT(pcieregs);
+
+	addrtype = (uint)((uintptr)arg1);
+
+	switch (addrtype) {
+		case PCIE_CONFIGREGS:
+			W_REG(si->osh, (&pcieregs->configaddr), offset);
+			W_REG(si->osh, (&pcieregs->configdata), val);
+			break;
+		case PCIE_PCIEREGS:
+			W_REG(si->osh, (&pcieregs->pcieindaddr), offset);
+			W_REG(si->osh, (&pcieregs->pcieinddata), val);
+			break;
+		default:
+			ASSERT(0);
+			break;
+	}
+	return 0;
+}
+
+
+/* Build device path. Support SB, PCI, and JTAG for now. */
+int
+BCMINITFN(sb_devpath)(sb_t *sbh, char *path, int size)
+{
+	int slen;
+	ASSERT(path);
+	ASSERT(size >= SB_DEVPATH_BUFSZ);
+
+	if (!path || size <= 0)
+		return -1;
+
+	switch (BUSTYPE((SB_INFO(sbh))->sb.bustype)) {
+	case SB_BUS:
+	case JTAG_BUS:
+		slen = snprintf(path, (size_t)size, "sb/%u/", sb_coreidx(sbh));
+		break;
+	case PCI_BUS:
+		ASSERT((SB_INFO(sbh))->osh);
+		slen = snprintf(path, (size_t)size, "pci/%u/%u/",
+		                OSL_PCI_BUS((SB_INFO(sbh))->osh),
+		                OSL_PCI_SLOT((SB_INFO(sbh))->osh));
+		break;
+	case PCMCIA_BUS:
+		SB_ERROR(("sb_devpath: OSL_PCMCIA_BUS() not implemented, bus 1 assumed\n"));
+		SB_ERROR(("sb_devpath: OSL_PCMCIA_SLOT() not implemented, slot 1 assumed\n"));
+		slen = snprintf(path, (size_t)size, "pc/1/1/");
+		break;
+	default:
+		slen = -1;
+		ASSERT(0);
+		break;
+	}
 
+	if (slen < 0 || slen >= size) {
+		path[0] = '\0';
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+char *
+BCMINITFN(sb_getdevpathvar)(sb_t *sbh, const char *name)
+{
+	char varname[SB_DEVPATH_BUFSZ + 32];
+
+	sb_devpathvar(sbh, varname, sizeof(varname), name);
+
+	return (getvar(NULL, varname));
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+int
+BCMINITFN(sb_getdevpathintvar)(sb_t *sbh, const char *name)
+{
+	char varname[SB_DEVPATH_BUFSZ + 32];
+
+	sb_devpathvar(sbh, varname, sizeof(varname), name);
+
+	return (getintvar(NULL, varname));
+}
+
+/* Concatenate the dev path with a varname into the given 'var' buffer
+ * and return the 'var' pointer.
+ * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
+ * On overflow, the first char will be set to '\0'.
+ */
+static char *
+BCMINITFN(sb_devpathvar)(sb_t *sbh, char *var, int len, const char *name)
+{
+	uint path_len;
+
+	if (!var || len <= 0)
+		return var;
+
+	if (sb_devpath(sbh, var, len) == 0) {
+		path_len = strlen(var);
+
+		if (strlen(name) + 1 > (uint)(len - path_len))
+			var[0] = '\0';
+		else
+			strncpy(var + path_len, name, len - path_len - 1);
+	}
+
+	return var;
+}
+
+
+/*
+ * Fixup SROMless PCI device's configuration.
+ * The current core may be changed upon return.
+ */
+static int
+sb_pci_fixcfg(sb_info_t *si)
+{
+	uint origidx, pciidx;
+	sbpciregs_t *pciregs;
+	sbpcieregs_t *pcieregs = NULL;
+	uint16 val16, *reg16;
+	uint32 w;
+
+	ASSERT(BUSTYPE(si->sb.bustype) == PCI_BUS);
+
+	/* Fixup PI in SROM shadow area to enable the correct PCI core access */
+	/* save the current index */
+	origidx = sb_coreidx(&si->sb);
+
+	/* check 'pi' is correct and fix it if not */
+	if (si->sb.buscoretype == SB_PCIE) {
+		pcieregs = (sbpcieregs_t *)sb_setcore(&si->sb, SB_PCIE, 0);
+		ASSERT(pcieregs);
+		reg16 = &pcieregs->sprom[SRSH_PI_OFFSET];
+	} else if (si->sb.buscoretype == SB_PCI) {
+		pciregs = (sbpciregs_t *)sb_setcore(&si->sb, SB_PCI, 0);
+		ASSERT(pciregs);
+		reg16 = &pciregs->sprom[SRSH_PI_OFFSET];
+	} else {
+		ASSERT(0);
+		return -1;
+	}
+	pciidx = sb_coreidx(&si->sb);
+	val16 = R_REG(si->osh, reg16);
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16)pciidx) {
+		val16 = (uint16)(pciidx << SRSH_PI_SHIFT) | (val16 & ~SRSH_PI_MASK);
+		W_REG(si->osh, reg16, val16);
+	}
+
+	if (PCIE_ASPMWARS(si)) {
+		w = sb_pcie_readreg((void *)(uintptr)&si->sb, (void *)PCIE_PCIEREGS,
+		                    PCIE_PLP_STATUSREG);
+
+		/* Detect the current polarity at attach and force that polarity and
+		 * disable changing the polarity
+		 */
+		if ((w & PCIE_PLP_POLARITYINV_STAT) == 0) {
+			si->pcie_polarity = (SERDES_RX_CTRL_FORCE);
+		} else {
+			si->pcie_polarity = (SERDES_RX_CTRL_FORCE |
+			                     SERDES_RX_CTRL_POLARITY);
+		}
+
+		w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+		if (w & PCIE_CLKREQ_ENAB) {
+			reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET];
+			val16 = R_REG(si->osh, reg16);
+			/* if clockreq is not advertized clkreq should not be enabled */
+			if (!(val16 & SRSH_CLKREQ_ENB))
+				SB_ERROR(("WARNING: CLK REQ enabled already  0x%x\n", w));
+		}
+
+		sb_war43448(&si->sb);
+
+		sb_war42767(&si->sb);
+
+	}
+
+	/* restore the original index */
+	sb_setcoreidx(&si->sb, origidx);
+
+	return 0;
+}
+
+/* Return ADDR64 capability of the backplane */
+bool
+sb_backplane64(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return ((si->sb.cccaps & CC_CAP_BKPLN64) != 0);
+}
+
+void
+sb_btcgpiowar(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+	chipcregs_t *cc;
+	si = SB_INFO(sbh);
+
+	/* Make sure that there is ChipCommon core present &&
+	 * UART_TX is strapped to 1
+	 */
+	if (!(si->sb.cccaps & CC_CAP_UARTGPIO))
+		return;
+
+	/* sb_corereg cannot be used as we have to guarantee 8-bit read/writes */
+	INTR_OFF(si, intr_val);
+
+	origidx = sb_coreidx(sbh);
+
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	W_REG(si->osh, &cc->uart0mcr, R_REG(si->osh, &cc->uart0mcr) | 0x04);
+
+	/* restore the original index */
+	sb_setcoreidx(sbh, origidx);
+
+	INTR_RESTORE(si, intr_val);
+}
+
+/* check if the device is removed */
+bool
+sb_deviceremoved(sb_t *sbh)
+{
+	uint32 w;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case PCI_BUS:
+		ASSERT(si->osh);
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_VID, sizeof(uint32));
+		if ((w & 0xFFFF) != VENDOR_BROADCOM)
+			return TRUE;
+		else
+			return FALSE;
+	default:
+		return FALSE;
+	}
+	return FALSE;
+}
+
+/* Return the RAM size of the SOCRAM core */
+uint32
+BCMINITFN(sb_socram_size)(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+
+	sbsocramregs_t *regs;
+	bool wasup;
+	uint corerev;
+	uint32 coreinfo;
+	uint memsize = 0;
+
+	si = SB_INFO(sbh);
+	ASSERT(si);
+
+	/* Block ints and save current core */
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(sbh);
+
+	/* Switch to SOCRAM core */
+	if (!(regs = sb_setcore(sbh, SB_SOCRAM, 0)))
+		goto done;
+
+	/* Get info for determining size */
+	if (!(wasup = sb_iscoreup(sbh)))
+		sb_core_reset(sbh, 0, 0);
+	corerev = sb_corerev(sbh);
+	coreinfo = R_REG(si->osh, &regs->coreinfo);
+
+	/* Calculate size from coreinfo based on rev */
+	if (corerev == 0)
+		memsize = 1 << (16 + (coreinfo & SRCI_MS0_MASK));
+	else if (corerev < 3) {
+		memsize = 1 << (SR_BSZ_BASE + (coreinfo & SRCI_SRBSZ_MASK));
+		memsize *= (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+	}
+	else {
+		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+		uint bsz = (coreinfo & SRCI_SRBSZ_MASK);
+		uint lss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;
+		if (lss != 0)
+			nb --;
+		memsize = nb * (1 << (bsz + SR_BSZ_BASE));
+		if (lss != 0)
+			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
+	}
+	/* Return to previous state and core */
+	if (!wasup)
+		sb_core_disable(sbh, 0);
+	sb_setcoreidx(sbh, origidx);
+
+done:
+	INTR_RESTORE(si, intr_val);
+	return memsize;
+}
--- src/shared.1927/sflash.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/sflash.c	2007-11-19 07:12:47.000000000 +0300
@@ -18,6 +18,7 @@
 #include <sbchipc.h>
 #include <mipsinc.h>
 #include <bcmutils.h>
+#include <bcmdevs.h>
 #include <sflash.h>
 
 /* Private global state */
@@ -27,8 +28,8 @@
 static INLINE void
 sflash_cmd(chipcregs_t *cc, uint opcode)
 {
-	W_REG(&cc->flashcontrol, SFLASH_START | opcode);
-	while (R_REG(&cc->flashcontrol) & SFLASH_BUSY);
+	W_REG(NULL, &cc->flashcontrol, SFLASH_START | opcode);
+	while (R_REG(NULL, &cc->flashcontrol) & SFLASH_BUSY);
 }
 
 /* Initialize serial flash access */
@@ -39,14 +40,14 @@
 
 	bzero(&sflash, sizeof(sflash));
 
-	sflash.type = R_REG(&cc->capabilities) & CAP_FLASH_MASK;
+	sflash.type = R_REG(NULL, &cc->capabilities) & CC_CAP_FLASH_MASK;
 
 	switch (sflash.type) {
 	case SFLASH_ST:
 		/* Probe for ST chips */
 		sflash_cmd(cc, SFLASH_ST_DP);
 		sflash_cmd(cc, SFLASH_ST_RES);
-		id = R_REG(&cc->flashdata);
+		id = R_REG(NULL, &cc->flashdata);
 		switch (id) {
 		case 0x11:
 			/* ST M25P20 2 Mbit Serial Flash */
@@ -73,10 +74,15 @@
 			sflash.blocksize = 64 * 1024;
 			sflash.numblocks = 64;
 			break;
+		case 0x16:
+			/* ST M25P64 64 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 128;
+			break;
 		case 0xbf:
-			W_REG(&cc->flashaddress, 1);
+			W_REG(NULL, &cc->flashaddress, 1);
 			sflash_cmd(cc, SFLASH_ST_RES);
-			id2 = R_REG(&cc->flashdata);
+			id2 = R_REG(NULL, &cc->flashdata);
 			if (id2 == 0x44) {
 				/* SST M25VF80 4 Mbit Serial Flash */
 				sflash.blocksize = 64 * 1024;
@@ -89,7 +95,7 @@
 	case SFLASH_AT:
 		/* Probe for Atmel chips */
 		sflash_cmd(cc, SFLASH_AT_STATUS);
-		id = R_REG(&cc->flashdata) & 0x3c;
+		id = R_REG(NULL, &cc->flashdata) & 0x3c;
 		switch (id) {
 		case 0xc:
 			/* Atmel AT45DB011 1Mbit Serial Flash */
@@ -181,11 +187,11 @@
 	case SFLASH_ST:
 		/* Check for ST Write In Progress bit */
 		sflash_cmd(cc, SFLASH_ST_RDSR);
-		return R_REG(&cc->flashdata) & SFLASH_ST_WIP;
+		return R_REG(NULL, &cc->flashdata) & SFLASH_ST_WIP;
 	case SFLASH_AT:
 		/* Check for Atmel Ready bit */
 		sflash_cmd(cc, SFLASH_AT_STATUS);
-		return !(R_REG(&cc->flashdata) & SFLASH_AT_READY);
+		return !(R_REG(NULL, &cc->flashdata) & SFLASH_AT_READY);
 	}
 
 	return 0;
@@ -199,6 +205,7 @@
 {
 	struct sflash *sfl;
 	int ret = 0;
+	bool is4712b0;
 	uint32 page, byte, mask;
 
 	if (!len)
@@ -210,35 +217,77 @@
 	sfl = &sflash;
 	switch (sfl->type) {
 	case SFLASH_ST:
-		ret = 1;
+		mask = R_REG(NULL, &cc->chipid);
+		is4712b0 = (((mask & CID_ID_MASK) == BCM4712_CHIP_ID) &&
+		            ((mask & CID_REV_MASK) == (3 << CID_REV_SHIFT)));
 		/* Enable writes */
 		sflash_cmd(cc, SFLASH_ST_WREN);
-		W_REG(&cc->flashaddress, offset);
-		W_REG(&cc->flashdata, *buf);
+		if (is4712b0) {
+			mask = 1 << 14;
+			W_REG(NULL, &cc->flashaddress, offset);
+			W_REG(NULL, &cc->flashdata, *buf++);
+			/* Set chip select */
+			OR_REG(NULL, &cc->gpioout, mask);
+			/* Issue a page program with the first byte */
+			sflash_cmd(cc, SFLASH_ST_PP);
+			ret = 1;
+			offset++;
+			len--;
+			while (len > 0) {
+				if ((offset & 255) == 0) {
+					/* Page boundary, drop cs and return */
+					AND_REG(NULL, &cc->gpioout, ~mask);
+					if (!sflash_poll(cc, offset)) {
+						/* Flash rejected command */
+						return -11;
+					}
+					return ret;
+				} else {
+					/* Write single byte */
+					sflash_cmd(cc, *buf++);
+				}
+				ret++;
+				offset++;
+				len--;
+			}
+			/* All done, drop cs if needed */
+			if ((offset & 255) != 1) {
+				/* Drop cs */
+				AND_REG(NULL, &cc->gpioout, ~mask);
+				if (!sflash_poll(cc, offset)) {
+					/* Flash rejected command */
+					return -12;
+				}
+			}
+		} else {
+			ret = 1;
+			W_REG(NULL, &cc->flashaddress, offset);
+			W_REG(NULL, &cc->flashdata, *buf);
 		/* Page program */
 		sflash_cmd(cc, SFLASH_ST_PP);
+		}
 		break;
 	case SFLASH_AT:
 		mask = sfl->blocksize - 1;
 		page = (offset & ~mask) << 1;
 		byte = offset & mask;
 		/* Read main memory page into buffer 1 */
-		if (byte || len < sfl->blocksize) {
-			W_REG(&cc->flashaddress, page);
+		if (byte || (len < sfl->blocksize)) {
+			W_REG(NULL, &cc->flashaddress, page);
 			sflash_cmd(cc, SFLASH_AT_BUF1_LOAD);
 			/* 250 us for AT45DB321B */
 			SPINWAIT(sflash_poll(cc, offset), 1000);
 			ASSERT(!sflash_poll(cc, offset));
 		}
 		/* Write into buffer 1 */
-		for (ret = 0; ret < len && byte < sfl->blocksize; ret++) {
-			W_REG(&cc->flashaddress, byte++);
-			W_REG(&cc->flashdata, *buf++);
+		for (ret = 0; (ret < (int)len) && (byte < sfl->blocksize); ret++) {
+			W_REG(NULL, &cc->flashaddress, byte++);
+			W_REG(NULL, &cc->flashdata, *buf++);
 			sflash_cmd(cc, SFLASH_AT_BUF1_WRITE);
 		}
 		/* Write buffer 1 into main memory page */
-		W_REG(&cc->flashaddress, page);
-		sflash_cmd(cc, SFLASH_AT_BUF1_ERASE_PROGRAM);
+		W_REG(NULL, &cc->flashaddress, page);
+		sflash_cmd(cc, SFLASH_AT_BUF1_PROGRAM);
 		break;
 	}
 
@@ -260,11 +309,11 @@
 	switch (sfl->type) {
 	case SFLASH_ST:
 		sflash_cmd(cc, SFLASH_ST_WREN);
-		W_REG(&cc->flashaddress, offset);
+		W_REG(NULL, &cc->flashaddress, offset);
 		sflash_cmd(cc, SFLASH_ST_SE);
 		return sfl->blocksize;
 	case SFLASH_AT:
-		W_REG(&cc->flashaddress, offset << 1);
+		W_REG(NULL, &cc->flashaddress, offset << 1);
 		sflash_cmd(cc, SFLASH_AT_PAGE_ERASE);
 		return sfl->blocksize;
 	}
@@ -284,7 +333,6 @@
 	uint blocksize = 0, mask, cur_offset, cur_length, cur_retlen, remainder;
 	uint blk_offset, blk_len, copied;
 	int bytes, ret = 0;
-	void *osh;
 
 	/* Check address range */
 	if (len <= 0)
@@ -297,11 +345,8 @@
 	blocksize = sfl->blocksize;
 	mask = blocksize - 1;
 
-	/* get kernel osl handler */
-	osh = osl_attach(NULL);
-
 	/* Allocate a block of mem */
-	if (!(block = MALLOC(osh, blocksize)))
+	if (!(block = MALLOC(NULL, blocksize)))
 		return -1;
 
 	while (len) {
@@ -325,7 +370,7 @@
 				blk_ptr = cur_ptr;
 
 				/* Copy entire block */
-				while(blk_len) {
+				while (blk_len) {
 					copied = sflash_read(cc, blk_offset, blk_len, blk_ptr); 
 					blk_offset += copied;
 					blk_len -= copied;
@@ -372,7 +417,6 @@
 	ret = len;
 done:
 	if (block)
-		MFREE(osh, block, blocksize);
+		MFREE(NULL, block, blocksize);
 	return ret;
 }
-
--- src/shared.1927/sromstubs.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/sromstubs.c	2007-11-19 06:40:26.000000000 +0300
@@ -6,22 +16,24 @@
 
 #include <typedefs.h>
 #include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmsrom.h>
 
 int
-srom_var_init(void *sbh, uint bus, void *curmap, void *osh, char **vars, int *count)
+srom_var_init(sb_t *sbh, uint bus, void *curmap, osl_t *osh, char **vars, uint *count)
 {
 	return 0;
 }
 
 int
-srom_read(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_read(sb_t *sbh, uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
 {
 	return 0;
 }
 
 int
-srom_write(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_write(sb_t *sbh, uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
 {
 	return 0;
 }
--- src/shared.1927/xip.lds.in	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/xip.lds.in	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-OUTPUT_ARCH(mips)
+OUTPUT_ARCH(TARGET_ARCH)
 ENTRY(startup)
 SECTIONS {
 	. = TEXT_START;
@@ -9,8 +9,13 @@
 		*(.text)
 		*(.text.*)
 		*(.fini)
+		*(.glue_7t)
+		*(.glue_7)
+		*(.rdata)
+		*(.rdata.*)
 		*(.rodata)
 		*(.rodata.*)
+		. = ALIGN(16);
 		_etext = .;
 		text_end = .;
 	}
@@ -20,7 +25,6 @@
 	{
 		data_start = .;
 		_fdata = .;
-		*(.rdata)
 		*(.data)
 		*(.data.*)
 		*(.sdata)
@@ -34,6 +38,7 @@
 		*(.sbss)
 		*(.scommon)
 		*(.bss)
+		*(.bss.*)
 		*(COMMON)
 		bss_end = .;
 	}
