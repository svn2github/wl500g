--- src/shared.1927/bcmotp.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/bcmotp.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,1299 @@
+/*
+ * Write-once support for IPX OTP wrapper.
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmdevs.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmendian.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <bcmotp.h>
+
+/* debug/trace */
+#define OTP_MSG(x)
+
+
+#if !defined(CONFIG_BCMHNDOTP)	    /* Newer IPX OTP wrapper */
+
+/* OTP layout */
+/* Subregion word offsets in General Use region */
+#define OTPGU_HSB_OFF		12
+#define OTPGU_SFB_OFF		13
+#define OTPGU_CI_OFF		14
+#define OTPGU_SROM_OFF		16
+
+/* Fixed size subregions sizes in words */
+#define OTPGU_CI_SZ		2
+
+/* Flag bit offsets in General Use region  */
+#define OTPGU_HWP_OFF		252
+#define OTPGU_SWP_OFF		253
+#define OTPGU_CIP_OFF		254
+#define OTPGU_FUSEP_OFF		255
+
+typedef struct {
+	sb_t	*sbh;		/* Saved sb handle */
+	osl_t	*osh;
+	uint16	size;		/* Size of otp in words */
+	uint16	rows;
+	uint16	cols;
+	uint16	hwprot;		/* Hardware protection bits */
+	uint16	prog;		/* Subregion programmed bits */
+	uint16	hwbase;		/* hardware subregion offset */
+	uint16	hwlim;		/* hardware subregion boundary */
+	uint16	swbase;		/* software subregion offset */
+	uint16	swlim;		/* software subregion boundary */
+	uint16	fbase;		/* fuse subregion offset */
+	uint16	flim;		/* fuse subregion boundary */
+} otpinfo_t;
+
+static otpinfo_t otpinfo;
+
+#define OTPP_TRIES	10000000	/* # of tries for OTPP */
+
+static void
+otp_rgn(otpinfo_t *oi, chipcregs_t *cc)
+{
+	/* Read OTP lock bits and subregion programmed indication bits */
+	oi->hwprot = (uint16)(R_REG(oi->osh, &cc->otpstatus) & OTPS_OL_MASK);
+	oi->prog = (uint16)(R_REG(oi->osh, &cc->otpstatus) & OTPS_GUP_MASK);
+	OTP_MSG(("otp_rgn: hwprot %x prog %x\n", oi->hwprot, oi->prog));
+
+	/*
+	 * h/w region base and fuse region limit are fixed to the top and
+	 * the bottom of the general use region. Everything else can be flexible.
+	 */
+	oi->hwbase = OTPGU_SROM_OFF;
+	oi->hwlim = oi->size;
+	if (oi->prog & OTPS_GUP_HW) {
+		oi->hwlim = otpr(oi, cc, OTPGU_HSB_OFF) / 16;
+		oi->swbase = oi->hwlim;
+	}
+	else
+		oi->swbase = oi->hwbase;
+	OTP_MSG(("otp_rgn: hwbase %x hwlim %x\n", oi->hwbase, oi->hwlim));
+	oi->swlim = oi->size;
+	if (oi->prog & OTPS_GUP_SW) {
+		oi->swlim = otpr(oi, cc, OTPGU_SFB_OFF) / 16;
+		oi->fbase = oi->swlim;
+	}
+	else
+		oi->fbase = oi->swbase;
+	OTP_MSG(("otp_rgn: swbase %x swlim %x\n", oi->swbase, oi->swlim));
+	oi->flim = oi->size;
+	OTP_MSG(("otp_rgn: fbase %x flim %x\n", oi->fbase, oi->flim));
+}
+
+void *
+otp_init(sb_t *sbh)
+{
+	uint idx;
+	chipcregs_t *cc;
+	otpinfo_t *oi;
+
+	/* chipc corerev must be >= 21 */
+	if (sbh->ccrev < 21)
+		return NULL;
+
+	oi = &otpinfo;
+	bzero(oi, sizeof(otpinfo_t));
+
+	oi->sbh = sbh;
+	oi->osh = sb_osh(sbh);
+
+	/* Check for otp size */
+	switch ((sbh->cccaps & CC_CAP_OTPSIZE) >> CC_CAP_OTPSIZE_SHIFT) {
+	case 0:
+		/* Nothing there */
+		OTP_MSG(("%s: no OTP\n", __FUNCTION__));
+		return NULL;
+	case 1:	/* 32x64 */
+		oi->rows = 32;
+		oi->cols = 64;
+		oi->size = 128;
+		OTP_MSG(("otp_init: rows %u cols %u\n", oi->rows, oi->cols));
+		break;
+	default:
+		/* Don't know the geometry */
+		OTP_MSG(("%s: unknown OTP geometry\n", __FUNCTION__));
+		return NULL;
+	}
+
+	/* Retrieve OTP region info */
+	idx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		if ((sbh->chipst & CST4325_SPROM_OTP_SEL_MASK) == CST4325_OTP_PWRDN) {
+			OTP_MSG(("%s: OTP is strapped down\n", __FUNCTION__));
+			oi = NULL;
+			goto exit;
+		}
+		if (!(R_REG(oi->osh, &cc->min_res_mask) & PMURES_BIT(RES4325_LNLDO2_PU))) {
+			OTP_MSG(("%s: OTP is powered down\n", __FUNCTION__));
+			oi = NULL;
+			goto exit;
+		}
+		break;
+#endif	/* BCM4325 */
+	default:
+		break;
+	}
+
+	otp_rgn(oi, cc);
+
+	goto exit;
+exit:
+	sb_setcoreidx(sbh, idx);
+
+	return (void *)oi;
+}
+
+uint16
+otpr(void *oh, chipcregs_t *cc, uint wn)
+{
+	otpinfo_t *oi;
+
+	oi = (otpinfo_t *)oh;
+
+	ASSERT(wn < oi->size);
+	ASSERT(cc);
+
+	return R_REG(oi->osh, &cc->otp[wn]);
+}
+
+int
+otp_read_region(void *oh, int region, uint16 *data, uint wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint idx;
+	chipcregs_t *cc;
+	uint base, i, sz;
+
+	/* Validate region selection */
+	switch (region) {
+	case OTP_HW_RGN:
+		if (!(oi->prog & OTPS_GUP_HW)) {
+			OTP_MSG(("%s: h/w region not programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen < (sz = (uint)oi->hwlim - oi->hwbase)) {
+			OTP_MSG(("%s: buffer too small, should be at least %u\n",
+			         __FUNCTION__, oi->hwlim - oi->hwbase));
+			return -1;
+		}
+		base = oi->hwbase;
+		break;
+	case OTP_SW_RGN:
+		if (!(oi->prog & OTPS_GUP_SW)) {
+			OTP_MSG(("%s: s/w region not programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen < (sz = (uint)oi->swlim - oi->swbase)) {
+			OTP_MSG(("%s: buffer too small should be at least %u\n",
+			         __FUNCTION__, oi->swlim - oi->swbase));
+			return -1;
+		}
+		base = oi->swbase;
+		break;
+	case OTP_CI_RGN:
+		if (!(oi->prog & OTPS_GUP_CI)) {
+			OTP_MSG(("%s: chipid region not programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen < (sz = OTPGU_CI_SZ)) {
+			OTP_MSG(("%s: buffer too small, should be at least %u\n",
+			         __FUNCTION__, OTPGU_CI_SZ));
+			return -1;
+		}
+		base = OTPGU_CI_OFF;
+		break;
+	case OTP_FUSE_RGN:
+		if (!(oi->prog & OTPS_GUP_FUSE)) {
+			OTP_MSG(("%s: fuse region not programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen < (sz = (uint)oi->flim - oi->fbase)) {
+			OTP_MSG(("%s: buffer too small, should be at least %u\n",
+			         __FUNCTION__, oi->flim - oi->fbase));
+			return -1;
+		}
+		base = oi->fbase;
+		break;
+	default:
+		OTP_MSG(("%s: reading region %d is not supported\n", __FUNCTION__, region));
+		return -1;
+	}
+
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	/* Read the data */
+	for (i = 0; i < sz; i ++)
+		data[i] = otpr(oh, cc, base + i);
+
+	sb_setcoreidx(oi->sbh, idx);
+	return 0;
+}
+
+int
+otp_status(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	return (int)(oi->hwprot | oi->prog);
+}
+
+int
+otp_size(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	return (int)oi->size * 2;
+}
+
+int
+otp_nvread(void *oh, char *data, uint *len)
+{
+	return -1;
+}
+
+#ifdef BCMNVRAMW
+static int
+otp_write_bit(otpinfo_t *oi, chipcregs_t *cc, uint idx)
+{
+	uint k, row, col;
+	uint32 otpp, st;
+
+	row = idx / oi->cols;
+	col = idx % oi->cols;
+
+	otpp = OTPP_START_BUSY |
+	        ((1 << OTPP_VALUE_SHIFT) & OTPP_VALUE_MASK) |
+	        ((OTPPOC_BIT_PROG << OTPP_OC_SHIFT) & OTPP_OC_MASK) |
+	        ((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) |
+	        ((col << OTPP_COL_SHIFT) & OTPP_COL_MASK);
+	OTP_MSG(("%s: idx = %d, row = %d, col = %d, otpp = 0x%x\n",
+	         __FUNCTION__, idx, row, col, otpp));
+	W_REG(oi->osh, &cc->otpprog, otpp);
+
+	for (k = 0;
+	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY) && (k < OTPP_TRIES);
+	     k ++)
+		;
+	if (k >= OTPP_TRIES) {
+		OTP_MSG(("\n%s: BUSY stuck: st=0x%x, count=%d\n", __FUNCTION__, st, k));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+otpwb16(otpinfo_t *oi, chipcregs_t *cc, int wn, uint16 data)
+{
+	uint base, i;
+	int rc;
+
+	base = wn * 16;
+	for (i = 0; i < 16; i++) {
+		if (data & (1 << i)) {
+			if ((rc = otp_write_bit(oi, cc, base + i)))
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+/* expects the caller to disable interrupts before calling this routine */
+int
+otp_write_region(void *oh, int region, uint16 *data, uint wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint idx;
+	chipcregs_t *cc;
+	uint base, i;
+
+	/* Validate region selection */
+	switch (region) {
+	case OTP_HW_RGN:
+		if (oi->prog & OTPS_GUP_HW) {
+			OTP_MSG(("%s: h/w region has been programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen > (uint)(oi->hwlim - oi->hwbase)) {
+			OTP_MSG(("%s: wlen %u exceeds OTP h/w region limit %u\n",
+			         __FUNCTION__, wlen, oi->hwlim - oi->hwbase));
+			return -1;
+		}
+		base = oi->hwbase;
+		break;
+	case OTP_SW_RGN:
+		if (oi->prog & OTPS_GUP_SW) {
+			OTP_MSG(("%s: s/w region has been programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen > (uint)(oi->swlim - oi->swbase)) {
+			OTP_MSG(("%s: wlen %u exceeds OTP s/w region limit %u\n",
+			         __FUNCTION__, wlen, oi->swlim - oi->swbase));
+			return -1;
+		}
+		base = oi->swbase;
+		break;
+	case OTP_CI_RGN:
+		if (oi->prog & OTPS_GUP_CI) {
+			OTP_MSG(("%s: chipid region has been programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen > OTPGU_CI_SZ) {
+			OTP_MSG(("%s: wlen %u exceeds OTP ci region limit %u\n",
+			         __FUNCTION__, wlen, OTPGU_CI_SZ));
+			return -1;
+		}
+		base = OTPGU_CI_OFF;
+		break;
+	case OTP_FUSE_RGN:
+		if (oi->prog & OTPS_GUP_FUSE) {
+			OTP_MSG(("%s: fuse region has been programmed\n", __FUNCTION__));
+			return -1;
+		}
+		if (wlen > (uint)(oi->flim - oi->fbase)) {
+			OTP_MSG(("%s: wlen %u exceeds OTP ci region limit %u\n",
+			         __FUNCTION__, wlen, oi->flim - oi->fbase));
+			return -1;
+		}
+		base = oi->flim - wlen;
+		break;
+	default:
+		OTP_MSG(("%s: writing region %d is not supported\n", __FUNCTION__, region));
+		return -1;
+	}
+
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	/* Enable Write */
+	OR_REG(oi->osh, &cc->otpcontrol, OTPC_PROGEN);
+
+	/* Write the data */
+	for (i = 0; i < wlen; i ++)
+		otpwb16(oh, cc, base + i, data[i]);
+
+	/* Update boundary/flag in memory and in OTP */
+	switch (region) {
+	case OTP_HW_RGN:
+		otpwb16(oh, cc, OTPGU_HSB_OFF, (base + i) * 16);
+		otp_write_bit(oh, cc, OTPGU_HWP_OFF);
+		break;
+	case OTP_SW_RGN:
+		otpwb16(oh, cc, OTPGU_HSB_OFF, base * 16);
+		otpwb16(oh, cc, OTPGU_SFB_OFF, (base + i) * 16);
+		otp_write_bit(oh, cc, OTPGU_SWP_OFF);
+		break;
+	case OTP_CI_RGN:
+		otp_write_bit(oh, cc, OTPGU_CIP_OFF);
+		break;
+	case OTP_FUSE_RGN:
+		otpwb16(oh, cc, OTPGU_SFB_OFF, base * 16);
+		otp_write_bit(oh, cc, OTPGU_FUSEP_OFF);
+		break;
+	}
+
+	/* Disable Write */
+	AND_REG(oi->osh, &cc->otpcontrol, ~OTPC_PROGEN);
+
+	/* Sync region info by retrieving them again */
+	otp_rgn(oi, cc);
+
+	sb_setcoreidx(oi->sbh, idx);
+	return 0;
+}
+
+/* expects the caller to disable interrupts before calling this routine */
+int
+otp_nvwrite(void *oh, uint16 *data, uint wlen)
+{
+	return -1;
+}
+#endif /* BCMNVRAMW */
+
+#if defined(WLTEST)
+static int
+otp_read_bit(otpinfo_t *oi, chipcregs_t *cc, uint idx)
+{
+	uint k, row, col;
+	uint32 otpp, st;
+
+	row = idx / oi->cols;
+	col = idx % oi->cols;
+
+	otpp = OTPP_START_BUSY |
+	        ((OTPPOC_READ << OTPP_OC_SHIFT) & OTPP_OC_MASK) |
+	        ((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) |
+	        ((col << OTPP_COL_SHIFT) & OTPP_COL_MASK);
+	OTP_MSG(("%s: idx = %d, row = %d, col = %d, otpp = 0x%x",
+	         __FUNCTION__, idx, row, col, otpp));
+	W_REG(oi->osh, &cc->otpprog, otpp);
+
+	for (k = 0;
+	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY) && (k < OTPP_TRIES);
+	     k ++)
+		;
+	if (k >= OTPP_TRIES) {
+		OTP_MSG(("\n%s: BUSY stuck: st=0x%x, count=%d\n", __FUNCTION__, st, k));
+		return -1;
+	}
+	if (st & OTPP_READERR) {
+		OTP_MSG(("\n%s: Could not read OTP bit %d\n", __FUNCTION__, idx));
+		return -1;
+	}
+	st = (st & OTPP_VALUE_MASK) >> OTPP_VALUE_SHIFT;
+
+	OTP_MSG((" => %d\n", st));
+	return (int)st;
+}
+
+static uint16
+otprb16(otpinfo_t *oi, chipcregs_t *cc, uint wn)
+{
+	uint base, i;
+	uint16 val;
+	int bit;
+
+	base = wn * 16;
+
+	val = 0;
+	for (i = 0; i < 16; i++) {
+		if ((bit = otp_read_bit(oi, cc, base + i)) == -1)
+			break;
+		val = val | (bit << i);
+	}
+	if (i < 16)
+		val = 0xffff;
+
+	return val;
+}
+
+int
+otp_dump(void *oh, int arg, char *buf, uint size)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	chipcregs_t *cc;
+	uint idx, i, count;
+	uint16 val;
+	struct bcmstrbuf b;
+
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	count = otp_size(oh);
+
+	bcm_binit(&b, buf, size);
+	for (i = 0; i < count / 2; i++) {
+		if (!(i % 4))
+			bcm_bprintf(&b, "\n0x%04x:", 2 * i);
+		if (arg == 0)
+			val = otpr(oh, cc, i);
+		else
+			val = otprb16(oh, cc, i);
+		bcm_bprintf(&b, " 0x%04x", val);
+	}
+	bcm_bprintf(&b, "\n");
+
+	sb_setcoreidx(oi->sbh, idx);
+
+	return ((int)(b.buf - b.origbuf));
+}
+#endif	
+
+#else	/* BCMHNDOTP - Older HND OTP controller */
+
+/* Fields in otpstatus */
+#define	OTPS_PROGFAIL		0x80000000
+#define	OTPS_PROTECT		0x00000007
+#define	OTPS_HW_PROTECT		0x00000001
+#define	OTPS_SW_PROTECT		0x00000002
+#define	OTPS_CID_PROTECT	0x00000004
+
+/* Fields in the otpcontrol register */
+#define	OTPC_RECWAIT		0xff000000
+#define	OTPC_PROGWAIT		0x00ffff00
+#define	OTPC_PRW_SHIFT		8
+#define	OTPC_MAXFAIL		0x00000038
+#define	OTPC_VSEL		0x00000006
+#define	OTPC_SELVL		0x00000001
+
+/* Fields in otpprog */
+#define	OTPP_COL_MASK		0x000000ff
+#define	OTPP_ROW_MASK		0x0000ff00
+#define	OTPP_ROW_SHIFT		8
+#define	OTPP_READERR		0x10000000
+#define	OTPP_VALUE		0x20000000
+#define	OTPP_VALUE_SHIFT		29
+#define	OTPP_READ		0x40000000
+#define	OTPP_START		0x80000000
+#define	OTPP_BUSY		0x80000000
+
+/* OTP regions (Byte offsets from otp size) */
+#define	OTP_SWLIM_OFF	(-8)
+#define	OTP_CIDBASE_OFF	0
+#define	OTP_CIDLIM_OFF	8
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	OTP_BOUNDARY_OFF (-4)
+#define	OTP_HWSIGN_OFF	(-3)
+#define	OTP_SWSIGN_OFF	(-2)
+#define	OTP_CIDSIGN_OFF	(-1)
+#define	OTP_CID_OFF	0
+#define	OTP_PKG_OFF	1
+#define	OTP_FID_OFF	2
+#define	OTP_RSV_OFF	3
+#define	OTP_LIM_OFF	4
+
+#define	OTP_HW_REGION	OTPS_HW_PROTECT
+#define	OTP_SW_REGION	OTPS_SW_PROTECT
+#define	OTP_CID_REGION	OTPS_CID_PROTECT
+
+#if OTP_HW_REGION != OTP_HW_RGN
+#error "incompatible OTP_HW_RGN"
+#endif
+#if OTP_SW_REGION != OTP_SW_RGN
+#error "incompatible OTP_SW_RGN"
+#endif
+#if OTP_CID_REGION != OTP_CI_RGN
+#error "incompatible OTP_CI_RGN"
+#endif
+
+#define	OTP_SIGNATURE	0x578a
+#define	OTP_MAGIC	0x4e56
+
+#define OTPP_TRIES	10000000	/* # of tries for OTPP */
+
+typedef struct _otpinfo {
+	sb_t	*sbh;		/* Saved sb handle */
+	uint	ccrev;		/* chipc revision */
+	uint	size;		/* Size of otp in bytes */
+	uint	hwprot;		/* Hardware protection bits */
+	uint	signvalid;	/* Signature valid bits */
+	int	boundary;	/* hw/sw boundary */
+} otpinfo_t;
+
+static otpinfo_t otpinfo;
+
+static uint16 otproff(void *oh, chipcregs_t *cc, int woff);
+#ifdef BCMNVRAMW
+static int otp_write_word(void *oh, chipcregs_t *cc, int wn, uint16 data);
+#endif /* BCMNVRAMW */
+
+uint16
+otpr(void *oh, chipcregs_t *cc, uint wn)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	osl_t *osh;
+	uint16 *ptr;
+
+	ASSERT(wn < ((((otpinfo_t *)oh)->size / 2) + OTP_LIM_OFF));
+	ASSERT(cc);
+
+	osh = sb_osh(oi->sbh);
+
+	ptr = (uint16 *)((uchar *)cc + CC_OTP);
+	return (R_REG(osh, &ptr[wn]));
+}
+
+static uint16
+otproff(void *oh, chipcregs_t *cc, int woff)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	osl_t *osh;
+	uint16 *ptr;
+
+	ASSERT(woff >= (-((int)oi->size / 2)));
+	ASSERT(woff < OTP_LIM_OFF);
+	ASSERT(cc);
+
+	osh = sb_osh(oi->sbh);
+
+	ptr = (uint16 *)((uchar *)cc + CC_OTP);
+
+	return (R_REG(osh, &ptr[(oi->size / 2) + woff]));
+}
+
+void *
+otp_init(sb_t *sbh)
+{
+	uint idx;
+	chipcregs_t *cc;
+	otpinfo_t *oi;
+	uint32 cap = 0;
+	void *ret = NULL;
+	osl_t *osh;
+
+	oi = &otpinfo;
+	bzero(oi, sizeof(otpinfo_t));
+
+	idx = sb_coreidx(sbh);
+
+	oi->sbh = sbh;
+	osh = sb_osh(oi->sbh);
+
+	/* Check for otp */
+	if ((cc = sb_setcore(sbh, SB_CC, 0)) != NULL) {
+		cap = R_REG(osh, &cc->capabilities);
+		if ((cap & CC_CAP_OTPSIZE) == 0) {
+			/* Nothing there */
+			goto out;
+		}
+
+		oi->sbh = sbh;
+		oi->ccrev = sb_chipcrev(sbh);
+
+		/* As of right now, support only 4320a2 and 4311a1 */
+		if ((oi->ccrev != 12) && (oi->ccrev != 17)) {
+			goto out;
+		}
+
+		oi->size = 1 << (((cap & CC_CAP_OTPSIZE) >> CC_CAP_OTPSIZE_SHIFT)
+			+ CC_CAP_OTPSIZE_BASE);
+
+		oi->hwprot = (int)(R_REG(osh, &cc->otpstatus) & OTPS_PROTECT);
+		oi->boundary = -1;
+
+		if (oi->ccrev != 17) {
+			if (otproff(oi, cc, OTP_HWSIGN_OFF) == OTP_SIGNATURE) {
+				oi->signvalid |= OTP_HW_REGION;
+				oi->boundary = otproff(oi, cc, OTP_BOUNDARY_OFF);
+			}
+
+			if (otproff(oi, cc, OTP_SWSIGN_OFF) == OTP_SIGNATURE)
+				oi->signvalid |= OTP_SW_REGION;
+
+			if (otproff(oi, cc, OTP_CIDSIGN_OFF) == OTP_SIGNATURE)
+				oi->signvalid |= OTP_CID_REGION;
+		}
+
+		ret = (void *)oi;
+	}
+
+out:	/* All done */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
+int
+otp_read_region(void *oh, int region, uint16 *data, uint wlen)
+{
+	return -1;
+}
+
+int
+otp_status(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	return ((int)(oi->hwprot | oi->signvalid));
+}
+
+int
+otp_size(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	return ((int)(oi->size));
+}
+
+int
+otp_nvread(void *oh, char *data, uint *len)
+{
+	int rc = 0;
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint32 base, bound, lim = 0, st;
+	int i, chunk, gchunks, tsz = 0;
+	uint32 idx;
+	chipcregs_t *cc;
+	uint offset;
+	uint16 *rawotp = NULL;
+
+	/* save the orig core */
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	st = otp_status(oh);
+	if (!(st & (OTP_HW_REGION | OTP_SW_REGION))) {
+		OTP_MSG(("OTP not programmed\n"));
+		rc = -1;
+		goto out;
+	}
+
+	/* Read the whole otp so we can easily manipulate it */
+	lim = otp_size(oh);
+	if ((rawotp = MALLOC(sb_osh(oi->sbh), lim)) == NULL) {
+		OTP_MSG(("Out of memory for rawotp\n"));
+		rc = -2;
+		goto out;
+	}
+	for (i = 0; i < (lim / 2); i++)
+		rawotp[i] = otpr(oh, cc,  i);
+
+	if ((st & OTP_HW_REGION) == 0) {
+		OTP_MSG(("otp: hw region not written (0x%x)\n", st));
+
+		/* This could be a programming failure in the first
+		 * chunk followed by one or more good chunks
+		 */
+		for (i = 0; i < (lim / 2); i++)
+			if (rawotp[i] == OTP_MAGIC)
+				break;
+
+		if (i < (lim / 2)) {
+			base = i;
+			bound = (i * 2) + rawotp[i + 1];
+			OTP_MSG(("otp: trying chunk at 0x%x-0x%x\n", i * 2, bound));
+		} else {
+			OTP_MSG(("otp: unprogrammed\n"));
+			rc = -3;
+			goto out;
+		}
+	} else {
+		bound = rawotp[(lim / 2) + OTP_BOUNDARY_OFF];
+
+		/* There are two cases: 1) The whole otp is used as nvram
+		 * and 2) There is a hardware header followed by nvram.
+		 */
+		if (rawotp[0] == OTP_MAGIC) {
+			base = 0;
+			if (bound != rawotp[1])
+				OTP_MSG(("otp: Bound 0x%x != chunk0 len 0x%x\n", bound,
+				         rawotp[1]));
+		} else
+			base = bound;
+	}
+
+	/* Find and copy the data */
+
+	chunk = 0;
+	gchunks = 0;
+	i = base / 2;
+	offset = 0;
+	while ((i < (lim / 2)) && (rawotp[i] == OTP_MAGIC)) {
+		int dsz, rsz = rawotp[i + 1];
+
+		if (((i * 2) + rsz) >= lim) {
+			OTP_MSG(("  bad chunk size, chunk %d, base 0x%x, size 0x%x\n",
+			         chunk, i * 2, rsz));
+			/* Bad length, try to find another chunk anyway */
+			rsz = 6;
+		}
+		if (hndcrc16((uint8 *)&rawotp[i], rsz,
+		             CRC16_INIT_VALUE) == CRC16_GOOD_VALUE) {
+			/* Good crc, copy the vars */
+			OTP_MSG(("  good chunk %d, base 0x%x, size 0x%x\n",
+			         chunk, i * 2, rsz));
+			gchunks++;
+			dsz = rsz - 6;
+			tsz += dsz;
+			if (offset + dsz >= *len) {
+				OTP_MSG(("Out of memory for otp\n"));
+				goto out;
+			}
+			bcopy((char *)&rawotp[i + 2], &data[offset], dsz);
+			offset += dsz;
+			/* Remove extra null characters at the end */
+			while (offset > 1 &&
+			       data[offset - 1] == 0 && data[offset - 2] == 0)
+				offset --;
+			i += rsz / 2;
+		} else {
+			/* bad length or crc didn't check, try to find the next set */
+			OTP_MSG(("  chunk %d @ 0x%x size 0x%x: bad crc, ",
+			         chunk, i * 2, rsz));
+			if (rawotp[i + (rsz / 2)] == OTP_MAGIC) {
+				/* Assume length is good */
+				i += rsz / 2;
+			} else {
+				while (++i < (lim / 2))
+					if (rawotp[i] == OTP_MAGIC)
+						break;
+			}
+			if (i < (lim / 2))
+				OTP_MSG(("trying next base 0x%x\n", i * 2));
+			else
+				OTP_MSG(("no more chunks\n"));
+		}
+		chunk++;
+	}
+
+	OTP_MSG(("  otp size = %d, boundary = 0x%x, nv base = 0x%x\n",
+	         lim, bound, base));
+	if (tsz != 0)
+		OTP_MSG(("  Found %d bytes in %d good chunks out of %d\n",
+		         tsz, gchunks, chunk));
+	else
+		OTP_MSG(("  No good chunks found out of %d\n", chunk));
+
+	*len = offset;
+
+out:
+	if (rawotp)
+		MFREE(sb_osh(oi->sbh), rawotp, lim);
+	sb_setcoreidx(oi->sbh, idx);
+
+	return rc;
+}
+
+#ifdef BCMNVRAMW
+
+static int
+otp_write_word(void *oh, chipcregs_t *cc, int wn, uint16 data)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint base, row, col, bit, i, j, k;
+	uint32 pwait, init_pwait, otpc, otpp, pst, st;
+
+#ifdef	OTP_FORCEFAIL
+	OTP_MSG(("%s: [0x%x] = 0x%x\n", __FUNCTION__, wn * 2, data));
+#endif /* OTP_FORCEFAIL */
+
+	/* This is bit-at-a-time writing, future cores may do word-at-a-time */
+	base = (wn * 16) + (wn / 4);
+	if (oi->ccrev == 12) {
+		otpc = 0x20000001;
+		init_pwait = 0x00000200;
+	} else {
+		otpc = 0x20000000;
+		init_pwait = 0x00004000;
+	}
+	for (i = 0; i < 16; i++) {
+		pwait = init_pwait;
+		bit = data & 1;
+		row = (base + i) / 65;
+		col = (base + i) % 65;
+		otpp = OTPP_START |
+			((bit << OTPP_VALUE_SHIFT) & OTPP_VALUE) |
+			((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) |
+			(col & OTPP_COL_MASK);
+		OTP_MSG(("row %d, col %d, val %d, otpc 0x%x, otpp 0x%x\n", row, col, bit,
+		         otpc, otpp));
+		j = 0;
+		while (1) {
+			j++;
+			OTP_MSG(("  %d: pwait %d\n", j, (pwait >> 8)));
+			W_REG(osh, &cc->otpcontrol, otpc | pwait);
+			W_REG(osh, &cc->otpprog, otpp);
+			pst = R_REG(osh, &cc->otpprog);
+			for (k = 0; ((pst & OTPP_BUSY) == OTPP_BUSY) && (k < OTPP_TRIES); k++)
+				pst = R_REG(osh, &cc->otpprog);
+			if (k >= OTPP_TRIES) {
+				OTP_MSG(("BUSY stuck: pst=0x%x, count=%d\n", pst, k));
+				st = OTPS_PROGFAIL;
+				break;
+			}
+			st = R_REG(osh, &cc->otpstatus);
+			if (((st & OTPS_PROGFAIL) == 0) || (pwait == OTPC_PROGWAIT)) {
+				break;
+			} else {
+				if ((oi->ccrev == 12) && (pwait >= 0x1000))
+					pwait = (pwait << 3) & OTPC_PROGWAIT;
+				else
+					pwait = (pwait << 1) & OTPC_PROGWAIT;
+				if (pwait == 0)
+					pwait = OTPC_PROGWAIT;
+			}
+		}
+		if (st & OTPS_PROGFAIL) {
+			OTP_MSG(("After %d tries: otpc = 0x%x, otpp = 0x%x/0x%x, otps = 0x%x\n",
+			       j, otpc | pwait, otpp, pst, st));
+			OTP_MSG(("otp prog failed. wn=%d, bit=%d, ppret=%d, ret=%d\n",
+			       wn, i, k, j));
+			return 1;
+		}
+		data >>= 1;
+	}
+	return 0;
+}
+
+/* expects the caller to disable interrupts before calling this routine */
+int
+otp_write_region(void *oh, int region, uint16 *data, uint wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint32 st;
+	uint wn, base = 0, lim;
+	int ret;
+	uint idx;
+	chipcregs_t *cc;
+
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	/* Run bist on chipc to get any unprogrammed bits into a known state */
+	if (sb_corebist(oi->sbh) == 0)
+		OTP_MSG(("%s: bist passed, otp is blank\n", __FUNCTION__));
+
+	if (oi->ccrev != 17) {
+		/* Check valid region */
+		if ((region != OTP_HW_REGION) &&
+		    (region != OTP_SW_REGION) &&
+		    (region != OTP_CID_REGION)) {
+			ret = -2;
+			goto out;
+		}
+
+		/* Region already written? */
+		st = oi->hwprot | oi-> signvalid;
+		if ((st & region) != 0) {
+			ret = -3;
+			goto out;
+		}
+
+		/* HW and CID have to be written before SW */
+		if ((st & OTP_SW_REGION) != 0) {
+			ret = -4;
+			goto out;
+		}
+
+		/* Bounds for the region */
+		lim = (oi->size / 2) + OTP_SWLIM_OFF;
+		if (region == OTP_HW_REGION) {
+			base = 0;
+		} else if (region == OTP_SW_REGION) {
+			base = oi->boundary / 2;
+		} else if (region == OTP_CID_REGION) {
+			base = (oi->size / 2) + OTP_CID_OFF;
+			lim = (oi->size / 2) + OTP_LIM_OFF;
+		}
+	} else {
+		base = 0;
+		lim = oi->size / 4;
+	}
+	if (wlen > (lim - base)) {
+		ret = -5;
+		goto out;
+	}
+	lim = base + wlen;
+
+
+	/* Write the data */
+	ret = -7;
+	for (wn = base; wn < lim; wn++)
+		if (oi->ccrev == 17) {
+			uint werrs, rwn;
+
+			rwn = 4 * wn;
+			werrs = (otp_write_word(oh, cc, rwn++, *data) != 0) ? 1 : 0;
+			werrs += (otp_write_word(oh, cc, rwn++, *data) != 0) ? 1 : 0;
+			werrs += (otp_write_word(oh, cc, rwn, *data++) != 0) ? 1 : 0;
+			if (werrs > 2)
+				goto out;
+		} else
+			if (otp_write_word(oh, cc, wn, *data++) != 0)
+				goto out;
+
+	if (oi->ccrev != 17) {
+		/* Done with the data, write the signature & boundary if needed */
+		if (region == OTP_HW_REGION) {
+			ret = -8;
+			if (otp_write_word(oh, cc, (oi->size / 2) + OTP_BOUNDARY_OFF,
+			                   lim * 2) != 0)
+				goto out;
+			ret = -9;
+			if (otp_write_word(oh, cc, (oi->size / 2) + OTP_HWSIGN_OFF,
+			                   OTP_SIGNATURE) != 0)
+				goto out;
+			oi->boundary = lim * 2;
+			oi->signvalid |= OTP_HW_REGION;
+		} else if (region == OTP_SW_REGION) {
+			ret = -10;
+			if (otp_write_word(oh, cc, (oi->size / 2) + OTP_SWSIGN_OFF,
+			                   OTP_SIGNATURE) != 0)
+				goto out;
+			oi->signvalid |= OTP_SW_REGION;
+		} else if (region == OTP_CID_REGION) {
+			ret = -11;
+			if (otp_write_word(oh, cc, (oi->size / 2) + OTP_CIDSIGN_OFF,
+			                   OTP_SIGNATURE) != 0)
+				goto out;
+			oi->signvalid |= OTP_CID_REGION;
+		}
+	}
+	ret = 0;
+out:
+	OTP_MSG(("bits written: %d, average (%d/%d): %d, max retry: %d, pp max: %d\n",
+		st_n, st_s, st_n, st_n?(st_s / st_n):0, st_hwm, pp_hwm));
+
+	sb_setcoreidx(oi->sbh, idx);
+
+	return ret;
+}
+
+/* expects the caller to disable interrupts before calling this routine */
+int
+otp_nvwrite(void *oh, uint16 *data, uint wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	uint32 st;
+	uint16 crc, clen, *p, hdr[2];
+	uint wn, base = 0, lim;
+	int err, gerr = 0;
+	uint idx;
+	chipcregs_t *cc;
+
+
+	/* Run bist on chipc to get any unprogrammed bits into a known state */
+	if (sb_corebist(oi->sbh) == 0)
+		OTP_MSG(("%s: bist passed, otp is blank\n", __FUNCTION__));
+
+	/* otp already written? */
+	st = oi->hwprot | oi-> signvalid;
+	if ((st & (OTP_HW_REGION | OTP_SW_REGION)) == (OTP_HW_REGION | OTP_SW_REGION))
+		return BCME_EPERM;
+
+	/* save the orig core */
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	/* Bounds for the region */
+	lim = (oi->size / 2) + OTP_SWLIM_OFF;
+	base = 0;
+
+	/* Look for possible chunks from the end down */
+	wn = lim;
+	while (wn > 0) {
+		wn--;
+		if (otpr(oh, cc, wn) == OTP_MAGIC) {
+			base = wn + (otpr(oh, cc, wn + 1) / 2);
+			break;
+		}
+	}
+	if (base == 0) {
+		OTP_MSG(("Unprogrammed otp\n"));
+	} else {
+		OTP_MSG(("Found some chunks, skipping to 0x%x\n", base * 2));
+	}
+	if ((wlen + 3) > (lim - base)) {
+		err =  BCME_NORESOURCE;
+		goto out;
+	}
+
+
+	/* Prepare the header and crc */
+	hdr[0] = OTP_MAGIC;
+	hdr[1] = (wlen + 3) * 2;
+	crc = hndcrc16((uint8 *)hdr, sizeof(hdr), CRC16_INIT_VALUE);
+	crc = hndcrc16((uint8 *)data, wlen * 2, crc);
+	crc = ~crc;
+
+	do {
+		p = data;
+		wn = base + 2;
+		lim = base + wlen + 2;
+
+		OTP_MSG(("writing chunk, 0x%x bytes @ 0x%x-0x%x\n", wlen * 2,
+		         base * 2, (lim + 1) * 2));
+
+		/* Write the header */
+		err = otp_write_word(oh, cc, base, hdr[0]);
+
+		/* Write the data */
+		while (wn < lim) {
+			err += otp_write_word(oh, cc, wn++, *p++);
+
+			/* If there has been an error, close this chunk */
+			if (err != 0) {
+				OTP_MSG(("closing early @ 0x%x\n", wn * 2));
+				break;
+			}
+		}
+
+		/* If we wrote the whole chunk, write the crc */
+		if (wn == lim) {
+			OTP_MSG(("  whole chunk written, crc = 0x%x\n", crc));
+			err += otp_write_word(oh, cc, wn++, crc);
+			clen = hdr[1];
+		} else {
+			/* If there was an error adjust the count to point to
+			 * the word after the error so we can start the next
+			 * chunk there.
+			 */
+			clen = (wn - base) * 2;
+			OTP_MSG(("  partial chunk written, chunk len = 0x%x\n", clen));
+		}
+		/* And now write the chunk length */
+		err += otp_write_word(oh, cc, base + 1, clen);
+
+		if (base == 0) {
+			/* Write the signature and boundary if this is the HW region,
+			 * but don't report failure if either of these 2 writes fail.
+			 */
+			if (otp_write_word(oh, cc, (oi->size / 2) + OTP_BOUNDARY_OFF, wn * 2) == 0)
+				gerr += otp_write_word(oh, cc, (oi->size / 2) + OTP_HWSIGN_OFF,
+				                       OTP_SIGNATURE);
+			else
+				gerr++;
+			oi->boundary = wn * 2;
+			oi->signvalid |= OTP_HW_REGION;
+		}
+
+		if (err != 0) {
+			gerr += err;
+			/* Errors, do it all over again if there is space left */
+			if ((wlen + 3) <= ((oi->size / 2) + OTP_SWLIM_OFF - wn)) {
+				base = wn;
+				lim = base + wlen + 2;
+				OTP_MSG(("Programming errors, retry @ 0x%x\n", wn * 2));
+			} else {
+				OTP_MSG(("Programming errors, no space left ( 0x%x)\n", wn * 2));
+				break;
+			}
+		}
+	} while (err != 0);
+
+	OTP_MSG(("bits written: %d, average (%d/%d): %d, max retry: %d, pp max: %d\n",
+	       st_n, st_s, st_n, st_s / st_n, st_hwm, pp_hwm));
+
+	if (gerr != 0)
+		OTP_MSG(("programming %s after %d errors\n", (err == 0) ? "succedded" : "failed",
+		         gerr));
+out:
+	/* done */
+	sb_setcoreidx(oi->sbh, idx);
+
+	if (err)
+		return BCME_ERROR;
+	else
+		return 0;
+}
+#endif /* BCMNVRAMW */
+
+#if	defined(WLTEST)
+static uint16
+otp_read_bit(void *oh, chipcregs_t *cc, uint idx)
+{
+	uint k, row, col;
+	uint32 otpp, st;
+	osl_t *osh;
+	otpinfo_t *oi = (otpinfo_t *)oh;
+
+	osh = sb_osh(oi->sbh);
+	row = idx / 65;
+	col = idx % 65;
+
+	otpp = OTPP_START | OTPP_READ |
+	        ((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) |
+	        (col & OTPP_COL_MASK);
+
+	OTP_MSG(("%s: idx = %d, row = %d, col = %d, otpp = 0x%x", __FUNCTION__,
+	         idx, row, col, otpp));
+
+	W_REG(osh, &cc->otpprog, otpp);
+	st = R_REG(osh, &cc->otpprog);
+	for (k = 0; ((st & OTPP_BUSY) == OTPP_BUSY) && (k < OTPP_TRIES); k++)
+		st = R_REG(osh, &cc->otpprog);
+
+	if (k >= OTPP_TRIES) {
+		OTP_MSG(("\n%s: BUSY stuck: st=0x%x, count=%d\n", __FUNCTION__, st, k));
+		return 0xffff;
+	}
+	if (st & OTPP_READERR) {
+		OTP_MSG(("\n%s: Could not read OTP bit %d\n", __FUNCTION__, idx));
+		return 0xffff;
+	}
+	st = (st & OTPP_VALUE) >> OTPP_VALUE_SHIFT;
+	OTP_MSG((" => %d\n", st));
+	return (uint16)st;
+}
+
+static uint16
+otprb16(void *oh, chipcregs_t *cc, uint wn)
+{
+	uint base, i;
+	uint16 val, bit;
+
+	base = (wn * 16) + (wn / 4);
+	val = 0;
+	for (i = 0; i < 16; i++) {
+		if ((bit = otp_read_bit(oh, cc, base + i)) == 0xffff)
+			break;
+		val = val | (bit << i);
+	}
+	if (i < 16)
+		val = 0xaaaa;
+	return val;
+}
+
+int
+otp_dump(void *oh, int arg, char *buf, uint size)
+{
+	otpinfo_t *oi = (otpinfo_t *)oh;
+	chipcregs_t *cc;
+	uint idx, i, count, lil;
+	uint16 val;
+	struct bcmstrbuf b;
+
+	idx = sb_coreidx(oi->sbh);
+	cc = sb_setcore(oi->sbh, SB_CC, 0);
+
+	if (arg >= 16) {
+		arg -= 16;
+	} else {
+		/* Run bist on chipc to get any unprogrammed bits into a known state */
+		if (sb_corebist(oi->sbh) == 0)
+			OTP_MSG(("%s: bist passed, otp is blank\n", __FUNCTION__));
+	}
+
+	if (arg == 2) {
+		count = 66 * 4;
+		lil = 3;
+	} else {
+		count = (oi->size / 2) + OTP_LIM_OFF;
+		lil = 7;
+	}
+
+	OTP_MSG(("%s: arg %d, size %d, words %d\n", __FUNCTION__, arg, size, count));
+	bcm_binit(&b, buf, size);
+	for (i = 0; i < count; i++) {
+		if ((i & lil) == 0)
+			bcm_bprintf(&b, "0x%04x:", 2 * i);
+
+		if (arg == 0)
+			val = otpr(oh, cc, i);
+		else
+			val = otprb16(oh, cc, i);
+		bcm_bprintf(&b, " 0x%04x", val);
+		if ((i & lil) == lil) {
+			if (arg == 2) {
+				bcm_bprintf(&b, " %d\n",
+				              otp_read_bit(oh, cc, ((i / 4) * 65) + 64) & 1);
+			} else {
+				bcm_bprintf(&b, "\n");
+			}
+		}
+	}
+	if ((i & lil) != lil)
+		bcm_bprintf(&b, "\n");
+
+	OTP_MSG(("%s: returning %d, left %d, wn %d\n",
+		__FUNCTION__, (int)(b.buf - b.origbuf), b.size, i));
+
+	sb_setcoreidx(oi->sbh, idx);
+
+	return ((int)(b.buf - b.origbuf));
+}
+#endif	
+
+#endif	/* BCMHNDOTP */
--- src/shared.1927/bcmrobo.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/bcmrobo.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,1089 @@
+/*
+ * Broadcom 53xx RoboSwitch device driver.
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <sbconfig.h>
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <bcmparams.h>
+#include <bcmnvram.h>
+#include <bcmdevs.h>
+#include <bcmrobo.h>
+#include <proto/ethernet.h>
+
+#define	ET_ERROR(args)
+#define	ET_MSG(args)
+
+/*
+ * Switch can be programmed through SPI interface, which
+ * has a rreg and a wreg functions to read from and write to
+ * registers.
+ */
+
+/* MII access registers */
+#define PSEUDO_PHYAD	0x1E	/* MII Pseudo PHY address */
+#define REG_MII_PAGE	0x10	/* MII Page register */
+#define REG_MII_ADDR	0x11	/* MII Address register */
+#define REG_MII_DATA0	0x18	/* MII Data register 0 */
+#define REG_MII_DATA1	0x19	/* MII Data register 1 */
+#define REG_MII_DATA2	0x1a	/* MII Data register 2 */
+#define REG_MII_DATA3	0x1b	/* MII Data register 3 */
+
+/* Page numbers */
+#define PAGE_CTRL	0x00	/* Control page */
+#define PAGE_MMR	0x02	/* 5397 Management/Mirroring page */
+#define PAGE_VTBL	0x05	/* ARL/VLAN Table access page */
+#define PAGE_VLAN	0x34	/* VLAN page */
+
+/* Control page registers */
+#define REG_CTRL_PORT0	0x00	/* Port 0 traffic control register */
+#define REG_CTRL_PORT1	0x01	/* Port 1 traffic control register */
+#define REG_CTRL_PORT2	0x02	/* Port 2 traffic control register */
+#define REG_CTRL_PORT3	0x03	/* Port 3 traffic control register */
+#define REG_CTRL_PORT4	0x04	/* Port 4 traffic control register */
+#define REG_CTRL_PORT5	0x05	/* Port 5 traffic control register */
+#define REG_CTRL_PORT6	0x06	/* Port 6 traffic control register */
+#define REG_CTRL_PORT7	0x07	/* Port 7 traffic control register */
+#define REG_CTRL_MODE	0x0B	/* Switch Mode register */
+#define REG_CTRL_MIIPO	0x0E	/* 5325: MII Port Override register */
+#define REG_CTRL_SRST	0x79	/* Software reset control register */
+
+#define REG_DEVICE_ID	0x30	/* 539x Device id: */
+#define	DEVID5325	0x25	/*  5325 (Not really be we fake it) */
+#define	DEVID5395	0x95	/*  5395 */
+#define	DEVID5397	0x97	/*  5397 */
+#define	DEVID5398	0x98	/*  5398 */
+
+/* VLAN page registers */
+#define REG_VLAN_CTRL0	0x00	/* VLAN Control 0 register */
+#define REG_VLAN_CTRL1	0x01	/* VLAN Control 1 register */
+#define REG_VLAN_CTRL4	0x04	/* VLAN Control 4 register */
+#define REG_VLAN_CTRL5	0x05	/* VLAN Control 5 register */
+#define REG_VLAN_ACCESS	0x06	/* VLAN Table Access register */
+#define REG_VLAN_WRITE	0x08	/* VLAN Write register */
+#define REG_VLAN_READ	0x0C	/* VLAN Read register */
+#define REG_VLAN_PTAG0	0x10	/* VLAN Default Port Tag register - port 0 */
+#define REG_VLAN_PTAG1	0x12	/* VLAN Default Port Tag register - port 1 */
+#define REG_VLAN_PTAG2	0x14	/* VLAN Default Port Tag register - port 2 */
+#define REG_VLAN_PTAG3	0x16	/* VLAN Default Port Tag register - port 3 */
+#define REG_VLAN_PTAG4	0x18	/* VLAN Default Port Tag register - port 4 */
+#define REG_VLAN_PTAG5	0x1a	/* VLAN Default Port Tag register - port 5 */
+#define REG_VLAN_PTAG6	0x1c	/* VLAN Default Port Tag register - port 6 */
+#define REG_VLAN_PTAG7	0x1e	/* VLAN Default Port Tag register - port 7 */
+#define REG_VLAN_PTAG8	0x20	/* 539x: VLAN Default Port Tag register - IMP port */
+#define REG_VLAN_PMAP	0x20	/* 5325: VLAN Priority Re-map register */
+
+#define VLAN_NUMVLANS	16	/* # of VLANs */
+
+
+/* ARL/VLAN Table Access page registers */
+#define REG_VTBL_CTRL		0x00	/* ARL Read/Write Control */
+#define REG_VTBL_MINDX		0x02	/* MAC Address Index */
+#define REG_VTBL_VINDX		0x08	/* VID Table Index */
+#define REG_VTBL_ARL_E0		0x10	/* ARL Entry 0 */
+#define REG_VTBL_ARL_E1		0x18	/* ARL Entry 1 */
+#define REG_VTBL_DAT_E0		0x18	/* ARL Table Data Entry 0 */
+#define REG_VTBL_SCTRL		0x20	/* ARL Search Control */
+#define REG_VTBL_SADDR		0x22	/* ARL Search Address */
+#define REG_VTBL_SRES		0x24	/* ARL Search Result */
+#define REG_VTBL_SREXT		0x2c	/* ARL Search Result */
+#define REG_VTBL_VID_E0		0x30	/* VID Entry 0 */
+#define REG_VTBL_VID_E1		0x32	/* VID Entry 1 */
+#define REG_VTBL_PREG		0xFF	/* Page Register */
+#define REG_VTBL_ACCESS		0x60	/* VLAN table access register */
+#define REG_VTBL_INDX		0x61	/* VLAN table address index register */
+#define REG_VTBL_ENTRY		0x63	/* VLAN table entry register */
+#define REG_VTBL_ACCESS_5395	0x80	/* VLAN table access register */
+#define REG_VTBL_INDX_5395	0x81	/* VLAN table address index register */
+#define REG_VTBL_ENTRY_5395	0x83	/* VLAN table entry register */
+
+/* SPI registers */
+#define REG_SPI_PAGE	0xff	/* SPI Page register */
+
+/* Access switch registers through GPIO/SPI */
+
+/* Minimum timing constants */
+#define SCK_EDGE_TIME	2	/* clock edge duration - 2us */
+#define MOSI_SETUP_TIME	1	/* input setup duration - 1us */
+#define SS_SETUP_TIME	1 	/* select setup duration - 1us */
+
+/* misc. constants */
+#define SPI_MAX_RETRY	100
+
+/* Enable GPIO access to the chip */
+static void
+gpio_enable(robo_info_t *robo)
+{
+	/* Enable GPIO outputs with SCK and MOSI low, SS high */
+	sb_gpioout(robo->sbh, robo->ss | robo->sck | robo->mosi, robo->ss, GPIO_DRV_PRIORITY);
+	sb_gpioouten(robo->sbh, robo->ss | robo->sck | robo->mosi,
+	             robo->ss | robo->sck | robo->mosi, GPIO_DRV_PRIORITY);
+}
+
+/* Disable GPIO access to the chip */
+static void
+gpio_disable(robo_info_t *robo)
+{
+	/* Disable GPIO outputs with all their current values */
+	sb_gpioouten(robo->sbh, robo->ss | robo->sck | robo->mosi, 0, GPIO_DRV_PRIORITY);
+}
+
+/* Write a byte stream to the chip thru SPI */
+static int
+spi_write(robo_info_t *robo, uint8 *buf, uint len)
+{
+	uint i;
+	uint8 mask;
+
+	/* Byte bang from LSB to MSB */
+	for (i = 0; i < len; i++) {
+		/* Bit bang from MSB to LSB */
+		for (mask = 0x80; mask; mask >>= 1) {
+			/* Clock low */
+			sb_gpioout(robo->sbh, robo->sck, 0, GPIO_DRV_PRIORITY);
+			OSL_DELAY(SCK_EDGE_TIME);
+
+			/* Sample on rising edge */
+			if (mask & buf[i])
+				sb_gpioout(robo->sbh, robo->mosi, robo->mosi, GPIO_DRV_PRIORITY);
+			else
+				sb_gpioout(robo->sbh, robo->mosi, 0, GPIO_DRV_PRIORITY);
+			OSL_DELAY(MOSI_SETUP_TIME);
+
+			/* Clock high */
+			sb_gpioout(robo->sbh, robo->sck, robo->sck, GPIO_DRV_PRIORITY);
+			OSL_DELAY(SCK_EDGE_TIME);
+		}
+	}
+
+	return 0;
+}
+
+/* Read a byte stream from the chip thru SPI */
+static int
+spi_read(robo_info_t *robo, uint8 *buf, uint len)
+{
+	uint i, timeout;
+	uint8 rack, mask, byte;
+
+	/* Timeout after 100 tries without RACK */
+	for (i = 0, rack = 0, timeout = SPI_MAX_RETRY; i < len && timeout;) {
+		/* Bit bang from MSB to LSB */
+		for (mask = 0x80, byte = 0; mask; mask >>= 1) {
+			/* Clock low */
+			sb_gpioout(robo->sbh, robo->sck, 0, GPIO_DRV_PRIORITY);
+			OSL_DELAY(SCK_EDGE_TIME);
+
+			/* Sample on falling edge */
+			if (sb_gpioin(robo->sbh) & robo->miso)
+				byte |= mask;
+
+			/* Clock high */
+			sb_gpioout(robo->sbh, robo->sck, robo->sck, GPIO_DRV_PRIORITY);
+			OSL_DELAY(SCK_EDGE_TIME);
+		}
+		/* RACK when bit 0 is high */
+		if (!rack) {
+			rack = (byte & 1);
+			timeout--;
+			continue;
+		}
+		/* Byte bang from LSB to MSB */
+		buf[i] = byte;
+		i++;
+	}
+
+	if (timeout == 0) {
+		ET_ERROR(("spi_read: timeout"));
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Enable/disable SPI access */
+static void
+spi_select(robo_info_t *robo, uint8 spi)
+{
+	if (spi) {
+		/* Enable SPI access */
+		sb_gpioout(robo->sbh, robo->ss, 0, GPIO_DRV_PRIORITY);
+	} else {
+		/* Disable SPI access */
+		sb_gpioout(robo->sbh, robo->ss, robo->ss, GPIO_DRV_PRIORITY);
+	}
+	OSL_DELAY(SS_SETUP_TIME);
+}
+
+
+/* Select chip and page */
+static void
+spi_goto(robo_info_t *robo, uint8 page)
+{
+	uint8 reg8 = REG_SPI_PAGE;	/* page select register */
+	uint8 cmd8;
+
+	/* Issue the command only when we are on a different page */
+	if (robo->page == page)
+		return;
+
+	robo->page = page;
+
+	/* Enable SPI access */
+	spi_select(robo, 1);
+
+	/* Select new page with CID 0 */
+	cmd8 = ((6 << 4) |		/* normal SPI */
+	        1);			/* write */
+	spi_write(robo, &cmd8, 1);
+	spi_write(robo, &reg8, 1);
+	spi_write(robo, &page, 1);
+
+	/* Disable SPI access */
+	spi_select(robo, 0);
+}
+
+/* Write register thru SPI */
+static int
+spi_wreg(robo_info_t *robo, uint8 page, uint8 addr, void *val, int len)
+{
+	int status = 0;
+	uint8 cmd8;
+	union {
+		uint8 val8;
+		uint16 val16;
+		uint32 val32;
+	} bytes;
+
+	/* validate value length and buffer address */
+	ASSERT(len == 1 || (len == 2 && !((int)val & 1)) ||
+	       (len == 4 && !((int)val & 3)));
+
+	/* Select chip and page */
+	spi_goto(robo, page);
+
+	/* Enable SPI access */
+	spi_select(robo, 1);
+
+	/* Write with CID 0 */
+	cmd8 = ((6 << 4) |		/* normal SPI */
+	        1);			/* write */
+	spi_write(robo, &cmd8, 1);
+	spi_write(robo, &addr, 1);
+	switch (len) {
+	case 1:
+		bytes.val8 = *(uint8 *)val;
+		break;
+	case 2:
+		bytes.val16 = htol16(*(uint16 *)val);
+		break;
+	case 4:
+		bytes.val32 = htol32(*(uint32 *)val);
+		break;
+	}
+	spi_write(robo, (uint8 *)val, len);
+
+	ET_MSG(("%s: [0x%x-0x%x] := 0x%x (len %d)\n", __FUNCTION__, page, addr,
+	        *(uint16 *)val, len));
+	/* Disable SPI access */
+	spi_select(robo, 0);
+	return status;
+}
+
+/* Read register thru SPI in fast SPI mode */
+static int
+spi_rreg(robo_info_t *robo, uint8 page, uint8 addr, void *val, int len)
+{
+	int status = 0;
+	uint8 cmd8;
+	union {
+		uint8 val8;
+		uint16 val16;
+		uint32 val32;
+	} bytes;
+
+	/* validate value length and buffer address */
+	ASSERT(len == 1 || (len == 2 && !((int)val & 1)) ||
+	       (len == 4 && !((int)val & 3)));
+
+	/* Select chip and page */
+	spi_goto(robo, page);
+
+	/* Enable SPI access */
+	spi_select(robo, 1);
+
+	/* Fast SPI read with CID 0 and byte offset 0 */
+	cmd8 = (1 << 4);		/* fast SPI */
+	spi_write(robo, &cmd8, 1);
+	spi_write(robo, &addr, 1);
+	status = spi_read(robo, (uint8 *)&bytes, len);
+	switch (len) {
+	case 1:
+		*(uint8 *)val = bytes.val8;
+		break;
+	case 2:
+		*(uint16 *)val = ltoh16(bytes.val16);
+		break;
+	case 4:
+		*(uint32 *)val = ltoh32(bytes.val32);
+		break;
+	}
+
+	ET_MSG(("%s: [0x%x-0x%x] => 0x%x (len %d)\n", __FUNCTION__, page, addr,
+	        *(uint16 *)val, len));
+
+	/* Disable SPI access */
+	spi_select(robo, 0);
+	return status;
+}
+
+/* SPI/gpio interface functions */
+static dev_ops_t spigpio = {
+	gpio_enable,
+	gpio_disable,
+	spi_wreg,
+	spi_rreg,
+	"SPI (GPIO)"
+};
+
+
+/* Access switch registers through MII (MDC/MDIO) */
+
+#define MII_MAX_RETRY	100
+
+/* Write register thru MDC/MDIO */
+static int
+mii_wreg(robo_info_t *robo, uint8 page, uint8 reg, void *val, int len)
+{
+	uint16 cmd16, val16;
+	void *h = robo->h;
+	int i;
+	uint8 *ptr = (uint8 *)val;
+
+	/* validate value length and buffer address */
+	ASSERT(len == 1 || len == 6 || len == 8 ||
+	       ((len == 2) && !((int)val & 1)) || ((len == 4) && !((int)val & 3)));
+
+	ET_MSG(("%s: [0x%x-0x%x] := 0x%x (len %d)\n", __FUNCTION__, page, reg,
+	          *(uint16 *)val, len));
+
+	/* set page number - MII register 0x10 */
+	if (robo->page != page) {
+		cmd16 = ((page << 8) |		/* page number */
+		         1);			/* mdc/mdio access enable */
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_PAGE, cmd16);
+		robo->page = page;
+	}
+
+	switch (len) {
+	case 8:
+		val16 = ptr[7];
+		val16 = ((val16 << 8) | ptr[6]);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA3, val16);
+		/* FALLTHRU */
+
+	case 6:
+		val16 = ptr[5];
+		val16 = ((val16 << 8) | ptr[4]);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA2, val16);
+		val16 = ptr[3];
+		val16 = ((val16 << 8) | ptr[2]);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA1, val16);
+		val16 = ptr[1];
+		val16 = ((val16 << 8) | ptr[0]);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+
+	case 4:
+		val16 = (uint16)((*(uint32 *)val) >> 16);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA1, val16);
+		val16 = (uint16)(*(uint32 *)val);
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+
+	case 2:
+		val16 = *(uint16 *)val;
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+
+	case 1:
+		val16 = *(uint8 *)val;
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+	}
+
+	/* set register address - MII register 0x11 */
+	cmd16 = ((reg << 8) |		/* register address */
+	         1);		/* opcode write */
+	robo->miiwr(h, PSEUDO_PHYAD, REG_MII_ADDR, cmd16);
+
+	/* is operation finished? */
+	for (i = MII_MAX_RETRY; i > 0; i --) {
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_ADDR);
+		if ((val16 & 3) == 0)
+			break;
+	}
+
+	/* timed out */
+	if (!i) {
+		ET_ERROR(("mii_wreg: timeout"));
+		return -1;
+	}
+	return 0;
+}
+
+/* Read register thru MDC/MDIO */
+static int
+mii_rreg(robo_info_t *robo, uint8 page, uint8 reg, void *val, int len)
+{
+	uint16 cmd16, val16;
+	void *h = robo->h;
+	int i;
+	uint8 *ptr = (uint8 *)val;
+
+	/* validate value length and buffer address */
+	ASSERT(len == 1 || len == 6 || len == 8 ||
+	       ((len == 2) && !((int)val & 1)) || ((len == 4) && !((int)val & 3)));
+
+	/* set page number - MII register 0x10 */
+	if (robo->page != page) {
+		cmd16 = ((page << 8) |		/* page number */
+		         1);			/* mdc/mdio access enable */
+		robo->miiwr(h, PSEUDO_PHYAD, REG_MII_PAGE, cmd16);
+		robo->page = page;
+	}
+
+	/* set register address - MII register 0x11 */
+	cmd16 = ((reg << 8) |		/* register address */
+	         2);			/* opcode read */
+	robo->miiwr(h, PSEUDO_PHYAD, REG_MII_ADDR, cmd16);
+
+	/* is operation finished? */
+	for (i = MII_MAX_RETRY; i > 0; i --) {
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_ADDR);
+		if ((val16 & 3) == 0)
+			break;
+	}
+	/* timed out */
+	if (!i) {
+		ET_ERROR(("mii_rreg: timeout"));
+		return -1;
+	}
+
+	ET_MSG(("%s: [0x%x-0x%x] => 0x%x (len %d)\n", __FUNCTION__, page, reg, val16, len));
+
+	switch (len) {
+	case 8:
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA3);
+		ptr[7] = (val16 >> 8);
+		ptr[6] = (val16 & 0xff);
+		/* FALLTHRU */
+
+	case 6:
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA2);
+		ptr[5] = (val16 >> 8);
+		ptr[4] = (val16 & 0xff);
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA1);
+		ptr[3] = (val16 >> 8);
+		ptr[2] = (val16 & 0xff);
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA0);
+		ptr[1] = (val16 >> 8);
+		ptr[0] = (val16 & 0xff);
+		break;
+
+	case 4:
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA1);
+		*(uint32 *)val = (((uint32)val16) << 16);
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(uint32 *)val |= val16;
+		break;
+
+	case 2:
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(uint16 *)val = val16;
+		break;
+
+	case 1:
+		val16 = robo->miird(h, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(uint8 *)val = (uint8)(val16 & 0xff);
+		break;
+	}
+
+	return 0;
+}
+
+/* MII interface functions */
+static dev_ops_t mdcmdio = {
+	NULL,
+	NULL,
+	mii_wreg,
+	mii_rreg,
+	"MII (MDC/MDIO)"
+};
+
+/* High level switch configuration functions. */
+
+/* Get access to the RoboSwitch */
+robo_info_t *
+bcm_robo_attach(sb_t *sbh, void *h, char *vars, miird_f miird, miiwr_f miiwr)
+{
+	robo_info_t *robo;
+	uint32 reset, idx;
+
+	/* Allocate and init private state */
+	if (!(robo = MALLOC(sb_osh(sbh), sizeof(robo_info_t)))) {
+		ET_ERROR(("robo_attach: out of memory, malloced %d bytes", MALLOCED(sb_osh(sbh))));
+		return NULL;
+	}
+	bzero(robo, sizeof(robo_info_t));
+
+	robo->h = h;
+	robo->sbh = sbh;
+	robo->vars = vars;
+	robo->miird = miird;
+	robo->miiwr = miiwr;
+	robo->page = -1;
+
+	/* Trigger external reset by nvram variable existance */
+	if ((reset = getgpiopin(robo->vars, "robo_reset", GPIO_PIN_NOTDEFINED)) !=
+	    GPIO_PIN_NOTDEFINED) {
+		/*
+		 * Reset sequence: RESET low(50ms)->high(20ms)
+		 *
+		 * We have to perform a full sequence for we don't know how long
+		 * it has been from power on till now.
+		 */
+		ET_MSG(("%s: Using external reset in gpio pin %d\n", __FUNCTION__, reset));
+		reset = 1 << reset;
+
+		/* Keep RESET low for 50 ms */
+		sb_gpioout(robo->sbh, reset, 0, GPIO_DRV_PRIORITY);
+		sb_gpioouten(robo->sbh, reset, reset, GPIO_DRV_PRIORITY);
+		bcm_mdelay(50);
+
+		/* Keep RESET high for at least 20 ms */
+		sb_gpioout(robo->sbh, reset, reset, GPIO_DRV_PRIORITY);
+		bcm_mdelay(20);
+	} else {
+		/* In case we need it */
+		idx = sb_coreidx(robo->sbh);
+
+		if (sb_setcore(robo->sbh, SB_ROBO, 0)) {
+			/* If we have an internal robo core, reset it using sb_core_reset */
+			ET_MSG(("%s: Resetting internal robo core\n", __FUNCTION__));
+			sb_core_reset(robo->sbh, 0, 0);
+		}
+
+		sb_setcoreidx(robo->sbh, idx);
+	}
+
+	if (miird && miiwr) {
+		uint16 tmp;
+		int rc, retry_count = 0;
+
+		/* Read the PHY ID */
+		tmp = miird(h, PSEUDO_PHYAD, 2);
+		if (tmp != 0xffff) {
+			do {
+				rc = mii_rreg(robo, PAGE_MMR, REG_DEVICE_ID, \
+							  &robo->devid, sizeof(uint16));
+				if (rc != 0)
+					break;
+				retry_count++;
+			} while ((robo->devid == 0) && (retry_count < 10));
+
+			ET_MSG(("%s: devid read %ssuccesfully via mii: 0x%x\n", __FUNCTION__, \
+			        rc ? "un" : "", robo->devid));
+			ET_MSG(("%s: mii access to switch works\n", __FUNCTION__));
+			robo->ops = &mdcmdio;
+			if ((rc != 0) || (robo->devid == 0)) {
+				ET_MSG(("%s: error reading devid, assuming 5325e\n", __FUNCTION__));
+				robo->devid = DEVID5325;
+			}
+			ET_MSG(("%s: devid: 0x%x\n", __FUNCTION__, robo->devid));
+		}
+	}
+
+	if ((robo->devid == DEVID5395) ||
+	    (robo->devid == DEVID5397) ||
+	    (robo->devid == DEVID5398)) {
+		uint8 srst_ctrl;
+
+		/* If it is a 539x switch, use the soft reset register */
+		ET_MSG(("%s: Resetting 539x robo switch\n", __FUNCTION__));
+
+		/* Reset the 539x switch core and register file */
+		srst_ctrl = 0x83;
+		mii_wreg(robo, PAGE_CTRL, REG_CTRL_SRST, &srst_ctrl, sizeof(uint8));
+		srst_ctrl = 0x00;
+		mii_wreg(robo, PAGE_CTRL, REG_CTRL_SRST, &srst_ctrl, sizeof(uint8));
+	}
+
+	if (!robo->ops) {
+		int mosi, miso, ss, sck;
+
+		robo->ops = &spigpio;
+		robo->devid = DEVID5325;
+
+		/* Init GPIO mapping. Default 2, 3, 4, 5 */
+		ss = getgpiopin(vars, "robo_ss", 2);
+		if (ss == GPIO_PIN_NOTDEFINED) {
+			ET_ERROR(("robo_attach: robo_ss gpio fail: GPIO 2 in use"));
+			goto error;
+		}
+		robo->ss = 1 << ss;
+		sck = getgpiopin(vars, "robo_sck", 3);
+		if (sck == GPIO_PIN_NOTDEFINED) {
+			ET_ERROR(("robo_attach: robo_sck gpio fail: GPIO 3 in use"));
+			goto error;
+		}
+		robo->sck = 1 << sck;
+		mosi = getgpiopin(vars, "robo_mosi", 4);
+		if (mosi == GPIO_PIN_NOTDEFINED) {
+			ET_ERROR(("robo_attach: robo_mosi gpio fail: GPIO 4 in use"));
+			goto error;
+		}
+		robo->mosi = 1 << mosi;
+		miso = getgpiopin(vars, "robo_miso", 5);
+		if (miso == GPIO_PIN_NOTDEFINED) {
+			ET_ERROR(("robo_attach: robo_miso gpio fail: GPIO 5 in use"));
+			goto error;
+		}
+		robo->miso = 1 << miso;
+		ET_MSG(("%s: ss %d sck %d mosi %d miso %d\n", __FUNCTION__,
+		        ss, sck, mosi, miso));
+	}
+
+	/* sanity check */
+	ASSERT(robo->ops);
+	ASSERT(robo->ops->write_reg);
+	ASSERT(robo->ops->read_reg);
+	ASSERT((robo->devid == DEVID5325) ||
+	       (robo->devid == DEVID5395) ||
+	       (robo->devid == DEVID5397) ||
+	       (robo->devid == DEVID5398));
+
+	return robo;
+
+error:
+	bcm_robo_detach(robo);
+	return NULL;
+}
+
+/* Release access to the RoboSwitch */
+void
+bcm_robo_detach(robo_info_t *robo)
+{
+	MFREE(sb_osh(robo->sbh), robo, sizeof(robo_info_t));
+}
+
+/* Enable the device and set it to a known good state */
+int
+bcm_robo_enable_device(robo_info_t *robo)
+{
+	uint8 reg_offset, reg_val;
+	int ret = 0;
+
+	/* Enable management interface access */
+	if (robo->ops->enable_mgmtif)
+		robo->ops->enable_mgmtif(robo);
+
+	if (robo->devid == DEVID5398) {
+		/* Disable unused ports: port 6 and 7 */
+		for (reg_offset = REG_CTRL_PORT6; reg_offset <= REG_CTRL_PORT7; reg_offset ++) {
+			/* Set bits [1:0] to disable RX and TX */
+			reg_val = 0x03;
+			robo->ops->write_reg(robo, PAGE_CTRL, reg_offset, &reg_val,
+			                     sizeof(reg_val));
+		}
+	}
+
+	if (robo->devid == DEVID5325) {
+		/* Must put the switch into Reverse MII mode! */
+
+		/* MII port state override (page 0 register 14) */
+		robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MIIPO, &reg_val, sizeof(reg_val));
+
+		/* Bit 4 enables reverse MII mode */
+		if (!(reg_val & (1 << 4))) {
+			/* Enable RvMII */
+			reg_val |= (1 << 4);
+			robo->ops->write_reg(robo, PAGE_CTRL, REG_CTRL_MIIPO, &reg_val,
+			                     sizeof(reg_val));
+
+			/* Read back */
+			robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MIIPO, &reg_val,
+			                    sizeof(reg_val));
+			if (!(reg_val & (1 << 4))) {
+				ET_ERROR(("robo_enable_device: enabling RvMII mode failed\n"));
+				ret = -1;
+			}
+		}
+	}
+
+	/* Disable management interface access */
+	if (robo->ops->disable_mgmtif)
+		robo->ops->disable_mgmtif(robo);
+
+	return ret;
+}
+
+/* Port flags */
+#define FLAG_TAGGED	't'	/* output tagged (external ports only) */
+#define FLAG_UNTAG	'u'	/* input & output untagged (CPU port only, for OS (linux, ...) */
+#define FLAG_LAN	'*'	/* input & output untagged (CPU port only, for CFE */
+
+/* port descriptor */
+typedef	struct {
+	uint32 untag;	/* untag enable bit (Page 0x05 Address 0x63-0x66 Bit[17:9]) */
+	uint32 member;	/* vlan member bit (Page 0x05 Address 0x63-0x66 Bit[7:0]) */
+	uint8 ptagr;	/* port tag register address (Page 0x34 Address 0x10-0x1F) */
+	uint8 cpu;	/* is this cpu port? */
+} pdesc_t;
+
+pdesc_t pdesc97[] = {
+	/* 5395/5397/5398 is 0 ~ 7.  port 8 is IMP port. */
+	/* port 0 */ {1 << 9, 1 << 0, REG_VLAN_PTAG0, 0},
+	/* port 1 */ {1 << 10, 1 << 1, REG_VLAN_PTAG1, 0},
+	/* port 2 */ {1 << 11, 1 << 2, REG_VLAN_PTAG2, 0},
+	/* port 3 */ {1 << 12, 1 << 3, REG_VLAN_PTAG3, 0},
+	/* port 4 */ {1 << 13, 1 << 4, REG_VLAN_PTAG4, 0},
+	/* port 5 */ {1 << 14, 1 << 5, REG_VLAN_PTAG5, 0},
+	/* port 6 */ {1 << 15, 1 << 6, REG_VLAN_PTAG6, 0},
+	/* port 7 */ {1 << 16, 1 << 7, REG_VLAN_PTAG7, 0},
+	/* mii port */ {1 << 17, 1 << 8, REG_VLAN_PTAG8, 1},
+};
+
+pdesc_t pdesc25[] = {
+	/* port 0 */ {1 << 6, 1 << 0, REG_VLAN_PTAG0, 0},
+	/* port 1 */ {1 << 7, 1 << 1, REG_VLAN_PTAG1, 0},
+	/* port 2 */ {1 << 8, 1 << 2, REG_VLAN_PTAG2, 0},
+	/* port 3 */ {1 << 9, 1 << 3, REG_VLAN_PTAG3, 0},
+	/* port 4 */ {1 << 10, 1 << 4, REG_VLAN_PTAG4, 0},
+	/* mii port */ {1 << 11, 1 << 5, REG_VLAN_PTAG5, 1},
+};
+
+/* Configure the VLANs */
+int
+bcm_robo_config_vlan(robo_info_t *robo, uint8 *mac_addr)
+{
+	uint8 val8;
+	uint16 val16;
+	uint32 val32;
+	pdesc_t *pdesc;
+	int pdescsz;
+	uint16 vid;
+	uint8 arl_entry[8] = { 0 }, arl_entry1[8] = { 0 };
+
+	/* Enable management interface access */
+	if (robo->ops->enable_mgmtif)
+		robo->ops->enable_mgmtif(robo);
+
+	/* setup global vlan configuration */
+	/* VLAN Control 0 Register (Page 0x34, Address 0) */
+	val8 = ((1 << 7) |		/* enable 802.1Q VLAN */
+	        (3 << 5));		/* individual VLAN learning mode */
+	robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_CTRL0, &val8, sizeof(val8));
+
+	/* VLAN Control 1 Register (Page 0x34, Address 1) */
+	val8 = ((1 << 2) |		/* enable RSV multicast V Fwdmap */
+		(1 << 3));		/* enable RSV multicast V Untagmap */
+	if (robo->devid == DEVID5325)
+		val8 |= (1 << 1);	/* enable RSV multicast V Tagging */
+	robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_CTRL1, &val8, sizeof(val8));
+
+	arl_entry[0] = mac_addr[5];
+	arl_entry[1] = mac_addr[4];
+	arl_entry[2] = mac_addr[3];
+	arl_entry[3] = mac_addr[2];
+	arl_entry[4] = mac_addr[1];
+	arl_entry[5] = mac_addr[0];
+
+	if (robo->devid == DEVID5325) {
+		/* Init the entry 1 of the bin */
+		robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_ARL_E1, \
+				     arl_entry1, sizeof(arl_entry1));
+		robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_VID_E1, \
+				     arl_entry1, 1);
+
+		/* Init the entry 0 of the bin */
+		arl_entry[6] = 0x8;		/* Port Id: MII */
+		arl_entry[7] = 0xc0;	/* Static Entry, Valid */
+
+		robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_ARL_E0, \
+				     arl_entry, sizeof(arl_entry));
+		robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_MINDX, \
+				     arl_entry, ETHER_ADDR_LEN);
+
+		/* VLAN Control 4 Register (Page 0x34, Address 4) */
+		val8 = (1 << 6);		/* drop frame with VID violation */
+		robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_CTRL4, &val8, sizeof(val8));
+
+		/* VLAN Control 5 Register (Page 0x34, Address 5) */
+		val8 = (1 << 3);		/* drop frame when miss V table */
+		robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_CTRL5, &val8, sizeof(val8));
+
+		pdesc = pdesc25;
+		pdescsz = sizeof(pdesc25) / sizeof(pdesc_t);
+	} else {
+		/* Initialize the MAC Addr Index Register */
+		robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_MINDX, \
+				     arl_entry, ETHER_ADDR_LEN);
+
+		pdesc = pdesc97;
+		pdescsz = sizeof(pdesc97) / sizeof(pdesc_t);
+	}
+
+	/* setup each vlan. max. 16 vlans. */
+	/* force vlan id to be equal to vlan number */
+	for (vid = 0; vid < VLAN_NUMVLANS; vid ++) {
+		char vlanports[] = "vlanXXXXports";
+		char port[] = "XXXX", *ports, *next, *cur;
+		uint32 untag = 0;
+		uint32 member = 0;
+		int pid, len;
+
+		/* no members if VLAN id is out of limitation */
+		if (vid > VLAN_MAXVID)
+			goto vlan_setup;
+
+		/* get vlan member ports from nvram */
+		sprintf(vlanports, "vlan%dports", vid);
+		ports = getvar(robo->vars, vlanports);
+
+		/* In 539x vid == 0 us invalid?? */
+		if ((robo->devid != DEVID5325) && (vid == 0)) {
+			if (ports)
+				ET_ERROR(("VID 0 is set in nvram, Ignoring\n"));
+			continue;
+		}
+
+		/* disable this vlan if not defined */
+		if (!ports)
+			goto vlan_setup;
+
+		/*
+		 * setup each port in the vlan. cpu port needs special handing
+		 * (with or without output tagging) to support linux/pmon/cfe.
+		 */
+		for (cur = ports; cur; cur = next) {
+			/* tokenize the port list */
+			while (*cur == ' ')
+				cur ++;
+			next = bcmstrstr(cur, " ");
+			len = next ? next - cur : strlen(cur);
+			if (!len)
+				break;
+			if (len > sizeof(port) - 1)
+				len = sizeof(port) - 1;
+			strncpy(port, cur, len);
+			port[len] = 0;
+
+			/* make sure port # is within the range */
+			pid = bcm_atoi(port);
+			if (pid >= pdescsz) {
+				ET_ERROR(("robo_config_vlan: port %d in vlan%dports is out "
+				          "of range[0-%d]\n", pid, vid, pdescsz));
+				continue;
+			}
+
+			/* build VLAN registers values */
+#ifndef	_CFE_
+			if ((!pdesc[pid].cpu && !strchr(port, FLAG_TAGGED)) ||
+			    (pdesc[pid].cpu && strchr(port, FLAG_UNTAG)))
+#endif
+				untag |= pdesc[pid].untag;
+
+			member |= pdesc[pid].member;
+
+			/* set port tag - applies to untagged ingress frames */
+			/* Default Port Tag Register (Page 0x34, Address 0x10-0x1D) */
+#ifdef	_CFE_
+#define	FL	FLAG_LAN
+#else
+#define	FL	FLAG_UNTAG
+#endif /* _CFE_ */
+			if (!pdesc[pid].cpu || strchr(port, FL)) {
+				val16 = ((0 << 13) |		/* priority - always 0 */
+				         vid);			/* vlan id */
+				robo->ops->write_reg(robo, PAGE_VLAN, pdesc[pid].ptagr,
+				                     &val16, sizeof(val16));
+			}
+		}
+
+		/* Add static ARL entries */
+		if (robo->devid == DEVID5325) {
+			val8 = vid;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_VID_E0, \
+					     &val8, sizeof(val8));
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_VINDX, \
+					     &val8, sizeof(val8));
+
+			/* Write the entry */
+			val8 = 0x80;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_CTRL, \
+					     &val8, sizeof(val8));
+			/* Wait for write to complete */
+			SPINWAIT((robo->ops->read_reg(robo, PAGE_VTBL, REG_VTBL_CTRL, \
+				 &val8, sizeof(val8)), ((val8 & 0x80) != 0)),
+				 100 /* usec */);
+		} else {
+			/* Set the VLAN Id in VLAN ID Index Register */
+			val8 = vid;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_VINDX, \
+					     &val8, sizeof(val8));
+
+			/* Set the MAC addr and VLAN Id in ARL Table MAC/VID Entry 0
+			 * Register.
+			 */
+			arl_entry[6] = vid;
+			arl_entry[7] = 0x0;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_ARL_E0, \
+					     arl_entry, sizeof(arl_entry));
+
+			/* Set the Static bit , Valid bit and Port ID fields in
+			 * ARL Table Data Entry 0 Register
+			 */
+			val16 = 0xc008;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_DAT_E0, \
+					     &val16, sizeof(val16));
+
+			/* Clear the ARL_R/W bit and set the START/DONE bit in
+			 * the ARL Read/Write Control Register.
+			 */
+			val8 = 0x80;
+			robo->ops->write_reg(robo, PAGE_VTBL, REG_VTBL_CTRL, \
+					     &val8, sizeof(val8));
+			/* Wait for write to complete */
+			SPINWAIT((robo->ops->read_reg(robo, PAGE_VTBL, REG_VTBL_CTRL, \
+				 &val8, sizeof(val8)), ((val8 & 0x80) != 0)),
+				 100 /* usec */);
+		}
+
+vlan_setup:
+		/* setup VLAN ID and VLAN memberships */
+
+		val32 = (untag |			/* untag enable */
+		         member);			/* vlan members */
+		if (robo->devid == DEVID5325) {
+			val32 |= ((1 << 20) |		/* valid write */
+			          ((vid >> 4) << 12));	/* vlan id bit[11:4] */
+			/* VLAN Write Register (Page 0x34, Address 0x08-0x0B) */
+			robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_WRITE, &val32,
+			                     sizeof(val32));
+			/* VLAN Table Access Register (Page 0x34, Address 0x06-0x07) */
+			val16 = ((1 << 13) |	/* start command */
+			         (1 << 12) |	/* write state */
+			         vid);		/* vlan id */
+			robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_ACCESS, &val16,
+			                     sizeof(val16));
+		} else {
+			uint8 vtble, vtbli, vtbla;
+
+			if (robo->devid == DEVID5395) {
+				vtble = REG_VTBL_ENTRY_5395;
+				vtbli = REG_VTBL_INDX_5395;
+				vtbla = REG_VTBL_ACCESS_5395;
+			} else {
+				vtble = REG_VTBL_ENTRY;
+				vtbli = REG_VTBL_INDX;
+				vtbla = REG_VTBL_ACCESS;
+			}
+
+			/* VLAN Table Entry Register (Page 0x05, Address 0x63-0x66/0x83-0x86) */
+			robo->ops->write_reg(robo, PAGE_VTBL, vtble, &val32,
+			                     sizeof(val32));
+			/* VLAN Table Address Index Reg (Page 0x05, Address 0x61-0x62/0x81-0x82) */
+			val16 = vid;        /* vlan id */
+			robo->ops->write_reg(robo, PAGE_VTBL, vtbli, &val16,
+			                     sizeof(val16));
+
+			/* VLAN Table Access Register (Page 0x34, Address 0x60/0x80) */
+			val8 = ((1 << 7) | 	/* start command */
+			        0);	        /* write */
+			robo->ops->write_reg(robo, PAGE_VTBL, vtbla, &val8,
+			                     sizeof(val8));
+		}
+	}
+
+	if (robo->devid == DEVID5325) {
+		/* setup priority mapping - applies to tagged ingress frames */
+		/* Priority Re-map Register (Page 0x34, Address 0x20-0x23) */
+		val32 = ((0 << 0) |	/* 0 -> 0 */
+		         (1 << 3) |	/* 1 -> 1 */
+		         (2 << 6) |	/* 2 -> 2 */
+		         (3 << 9) |	/* 3 -> 3 */
+		         (4 << 12) |	/* 4 -> 4 */
+		         (5 << 15) |	/* 5 -> 5 */
+		         (6 << 18) |	/* 6 -> 6 */
+		         (7 << 21));	/* 7 -> 7 */
+		robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_PMAP, &val32, sizeof(val32));
+	}
+
+	/* Disable management interface access */
+	if (robo->ops->disable_mgmtif)
+		robo->ops->disable_mgmtif(robo);
+
+	return 0;
+}
+
+/* Enable switching/forwarding */
+int
+bcm_robo_enable_switch(robo_info_t *robo)
+{
+	int i, max_port_ind, ret = 0;
+	uint8 val8;
+
+	/* Enable management interface access */
+	if (robo->ops->enable_mgmtif)
+		robo->ops->enable_mgmtif(robo);
+
+	/* Switch Mode register (Page 0, Address 0x0B) */
+	robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
+
+	/* Bit 1 enables switching/forwarding */
+	if (!(val8 & (1 << 1))) {
+		/* Set unmanaged mode */
+		val8 &= (~(1 << 0));
+
+		/* Enable forwarding */
+		val8 |= (1 << 1);
+		robo->ops->write_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
+
+		/* Read back */
+		robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
+		if (!(val8 & (1 << 1))) {
+			ET_ERROR(("robo_enable_switch: enabling forwarding failed\n"));
+			ret = -1;
+		}
+
+		/* No spanning tree for unmanaged mode */
+		val8 = 0;
+		max_port_ind = ((robo->devid == DEVID5398) ? REG_CTRL_PORT7 : REG_CTRL_PORT4);
+		for (i = REG_CTRL_PORT0; i <= max_port_ind; i++) {
+			robo->ops->write_reg(robo, PAGE_CTRL, i, &val8, sizeof(val8));
+		}
+	}
+
+	/* Disable management interface access */
+	if (robo->ops->disable_mgmtif)
+		robo->ops->disable_mgmtif(robo);
+
+	return ret;
+}
+
--- src/shared.1927/bcmsrom.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmsrom.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,54 +12,140 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <stdarg.h>
 #include <bcmutils.h>
-#include <bcmsrom.h>
+#include <sbchipc.h>
 #include <bcmdevs.h>
 #include <bcmendian.h>
 #include <sbpcmcia.h>
 #include <pcicfg.h>
+#include <sbconfig.h>
 #include <sbutils.h>
+#include <bcmsrom.h>
 
+#include <bcmnvram.h>
+#include <bcmotp.h>
+
+#if defined(CONFIG_BCMUSBDEV)
+#include <sbsdio.h>
+#include <sbhnddma.h>
+#include <sbsdpcmdev.h>
+#endif 
+
+#ifdef WLTEST
+#include <sbsprom.h>
+#endif /* WLTEST */
 #include <proto/ethernet.h>	/* for sprom content groking */
 
-#define	VARS_MAX	4096	/* should be reduced */
+/* debug/trace */
+#if defined(WLTEST)
+#define	BS_ERROR(args)	printf args
+#else
+#define	BS_ERROR(args)
+#endif	
 
 #define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
 #define WRITE_WORD_DELAY	20	/* 20 ms between each word write */
 
-static int initvars_srom_pci(void *osh, void *curmap, char **vars, int *count);
-static int initvars_cis_pcmcia(void *sbh, void *curmap, void *osh, char **vars, int *count);
-static int srom_parsecis(void *osh, uint8 *cis, char **vars, int *count);
-static int sprom_cmd_pcmcia(void *osh, uint8 cmd);
-static int sprom_read_pcmcia(void *osh, uint16 addr, uint16 *data);
-static int sprom_write_pcmcia(void *osh, uint16 addr, uint16 data);
-static int sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc);
+typedef struct varbuf {
+	char *buf;		/* pointer to current position */
+	unsigned int size;	/* current (residual) size in bytes */
+} varbuf_t;
+
+static int initvars_srom_sb(sb_t *sbh, osl_t *osh, void *curmap, char **vars, uint *count);
+static void _initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off, varbuf_t *b);
+static int initvars_srom_pci(sb_t *sbh, void *curmap, char **vars, uint *count);
+static int initvars_cis_pcmcia(sb_t *sbh, osl_t *osh, char **vars, uint *count);
+#if !defined(CONFIG_BCMUSBDEV) && !defined(CONFIG_BCMSDIODEV)
+static int initvars_flash_sb(sb_t *sbh, char **vars, uint *count);
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+static int sprom_cmd_pcmcia(osl_t *osh, uint8 cmd);
+static int sprom_read_pcmcia(osl_t *osh, uint16 addr, uint16 *data);
+static int sprom_write_pcmcia(osl_t *osh, uint16 addr, uint16 data);
+static int sprom_read_pci(osl_t *osh, uint16 *sprom, uint wordoff, uint16 *buf, uint nwords,
+                          bool check_crc);
+
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars, uint *count);
+static int initvars_flash(sb_t *sbh, osl_t *osh, char **vp, uint len);
+
+#ifdef BCMUSBDEV
+static int get_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                              uint boff, uint16 *srom, uint bsz);
+static int set_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                              uint boff, uint16 *srom, uint bsz);
+static uint srom_size(sb_t *sbh, osl_t *osh);
+#endif /* def BCMUSBDEV */
+
+/* Initialization of varbuf structure */
+static void
+varbuf_init(varbuf_t *b, char *buf, uint size)
+{
+	b->size = size;
+	b->buf = buf;
+}
+
+/* append a null terminated var=value string */
+static int
+varbuf_append(varbuf_t *b, const char *fmt, ...)
+{
+	va_list ap;
+	int r;
+
+	if (b->size < 2)
+	  return 0;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+	va_end(ap);
+
+	/* C99 snprintf behavior returns r >= size on overflow,
+	 * others return -1 on overflow.
+	 * All return -1 on format error.
+	 * We need to leave room for 2 null terminations, one for the current var
+	 * string, and one for final null of the var table. So check that the
+	 * strlen written, r, leaves room for 2 chars.
+	 */
+	if ((r == -1) || (r > (int)(b->size - 2))) {
+		b->size = 0;
+		return 0;
+	}
+
+	/* skip over this string's null termination */
+	r++;
+	b->size -= r;
+	b->buf += r;
+
+	return r;
+}
 
 /*
  * Initialize local vars from the right source for this platform.
  * Return 0 on success, nonzero on error.
  */
 int
-srom_var_init(void *sbh, uint bustype, void *curmap, void *osh, char **vars, int *count)
+BCMINITFN(srom_var_init)(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+	char **vars, uint *count)
 {
 	ASSERT(bustype == BUSTYPE(bustype));
-	if (vars == NULL)
+	if (vars == NULL || count == NULL)
 		return (0);
 
-	switch (BUSTYPE(bustype)) {
-	case SB_BUS:
-		/* These two could be asserts ... */
 		*vars = NULL;
 		*count = 0;
-		return(0);
+
+	switch (BUSTYPE(bustype)) {
+	case SB_BUS:
+	case JTAG_BUS:
+		return initvars_srom_sb(sbh, osh, curmap, vars, count);
 
 	case PCI_BUS:
 		ASSERT(curmap);	/* can not be NULL */
-		return(initvars_srom_pci(osh, curmap, vars, count));
+		return initvars_srom_pci(sbh, curmap, vars, count);
 
 	case PCMCIA_BUS:
-		return(initvars_cis_pcmcia(sbh, curmap, osh, vars, count));
+		return initvars_cis_pcmcia(sbh, osh, vars, count);
 
 
 	default:
@@ -70,7 +156,8 @@
 
 /* support only 16-bit word read from srom */
 int
-srom_read(uint bustype, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_read(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+          uint byteoff, uint nbytes, uint16 *buf)
 {
 	void *srom;
 	uint i, off, nw;
@@ -88,13 +175,39 @@
 		if (!curmap)
 			return 1;
 		srom = (uchar*)curmap + PCI_BAR0_SPROM_OFFSET;
-		if (sprom_read_pci(srom, off, buf, nw, FALSE))
+		if (sprom_read_pci(osh, srom, off, buf, nw, FALSE))
 			return 1;
 	} else if (BUSTYPE(bustype) == PCMCIA_BUS) {
 		for (i = 0; i < nw; i++) {
-			if (sprom_read_pcmcia(osh, (uint16)(off + i), (uint16*)(buf + i)))
+			if (sprom_read_pcmcia(osh, (uint16)(off + i), (uint16 *)(buf + i)))
 				return 1;
 		}
+	} else if (BUSTYPE(bustype) == SB_BUS) {
+#ifdef BCMUSBDEV
+		if (SPROMBUS == PCMCIA_BUS) {
+			uint origidx;
+			void *regs;
+			int rc;
+			bool wasup;
+
+			origidx = sb_coreidx(sbh);
+			regs = sb_setcore(sbh, SB_PCMCIA, 0);
+			ASSERT(regs != NULL);
+
+			if (!(wasup = sb_iscoreup(sbh)))
+				sb_core_reset(sbh, 0, 0);
+
+			rc = get_sb_pcmcia_srom(sbh, osh, regs, byteoff, buf, nbytes);
+
+			if (!wasup)
+				sb_core_disable(sbh, 0);
+
+			sb_setcoreidx(sbh, origidx);
+			return rc;
+		}
+#endif /* def BCMUSBDEV */
+
+		return 1;
 	} else {
 		return 1;
 	}
@@ -104,45 +217,69 @@
 
 /* support only 16-bit word write into srom */
 int
-srom_write(uint bustype, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_write(sb_t *sbh, uint bustype, void *curmap, osl_t *osh,
+           uint byteoff, uint nbytes, uint16 *buf)
 {
 	uint16 *srom;
-	uint i, off, nw, crc_range;
-	uint16 image[SPROM_SIZE], *p;
+	uint i, nw, crc_range;
+	uint16 image[SPROM_SIZE];
 	uint8 crc;
 	volatile uint32 val32;
 
 	ASSERT(bustype == BUSTYPE(bustype));
 
 	/* check input - 16-bit access only */
-	if (byteoff & 1 || nbytes & 1 || (byteoff + nbytes) > (SPROM_SIZE * 2))
+	if ((byteoff & 1) || (nbytes & 1))
 		return 1;
 
-	crc_range = (((BUSTYPE(bustype) == PCMCIA_BUS) || (BUSTYPE(bustype) == SDIO_BUS)) ? SPROM_SIZE : SPROM_CRC_RANGE) * 2;
+	if (byteoff == 0x55aa) {
+		/* Erase request */
+		crc_range = 0;
+		memset((void *)image, 0xff, nbytes);
+		nw = nbytes / 2;
+	} else if ((byteoff == 0) &&
+	           ((nbytes == SPROM_SIZE * 2) ||
+	            (nbytes == (SPROM_CRC_RANGE * 2)) ||
+	            (nbytes == (SROM4_WORDS * 2)))) {
+		/* Are we writing the whole thing at once? */
+		crc_range = nbytes;
+		bcopy((void *)buf, (void *)image, nbytes);
+		nw = nbytes / 2;
+	} else {
+		if ((byteoff + nbytes) > (SPROM_SIZE * 2))
+			return 1;
 
-	/* if changes made inside crc cover range */
-	if (byteoff < crc_range) {
-		nw = (((byteoff + nbytes) > crc_range) ? byteoff + nbytes : crc_range) / 2;
-		/* read data including entire first 64 words from srom */
-		if (srom_read(bustype, curmap, osh, 0, nw * 2, image))
+		if (BUSTYPE(bustype) == PCMCIA_BUS) {
+			crc_range = SPROM_SIZE * 2;
+		}
+		else {
+			crc_range = SPROM_CRC_RANGE * 2;	/* Tentative */
+		}
+
+		nw = crc_range / 2;
+		/* read first 64 words from srom */
+		if (srom_read(sbh, bustype, curmap, osh, 0, crc_range, image))
+			return 1;
+		if (image[SROM4_SIGN] == SROM4_SIGNATURE) {
+			nw = SROM4_WORDS;
+			crc_range = nw * 2;
+			if (srom_read(sbh, bustype, curmap, osh, 0, crc_range, image))
 			return 1;
+		}
 		/* make changes */
-		bcopy((void*)buf, (void*)&image[byteoff / 2], nbytes);
+		bcopy((void *)buf, (void *)&image[byteoff / 2], nbytes);
+	}
+
+	if (crc_range) {
 		/* calculate crc */
 		htol16_buf(image, crc_range);
 		crc = ~hndcrc8((uint8 *)image, crc_range - 1, CRC8_INIT_VALUE);
 		ltoh16_buf(image, crc_range);
-		image[(crc_range / 2) - 1] = (crc << 8) | (image[(crc_range / 2) - 1] & 0xff);
-		p = image;
-		off = 0;
-	} else {
-		p = buf;
-		off = byteoff / 2;
-		nw = nbytes / 2;
+		image[nw - 1] = (crc << 8) | (image[nw - 1] & 0xff);
 	}
 
 	if (BUSTYPE(bustype) == PCI_BUS) {
-		srom = (uint16*)((uchar*)curmap + PCI_BAR0_SPROM_OFFSET);
+		srom = (uint16 *)((uchar*)curmap + PCI_BAR0_SPROM_OFFSET);
 		/* enable writes to the SPROM */
 		val32 = OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32));
 		val32 |= SPROM_WRITEEN;
@@ -150,11 +287,12 @@
 		bcm_mdelay(WRITE_ENABLE_DELAY);
 		/* write srom */
 		for (i = 0; i < nw; i++) {
-			W_REG(&srom[off + i], p[i]);
+			W_REG(osh, &srom[i], image[i]);
 			bcm_mdelay(WRITE_WORD_DELAY);
 		}
 		/* disable writes to the SPROM */
-		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32 & ~SPROM_WRITEEN);
+		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32 &
+		                     ~SPROM_WRITEEN);
 	} else if (BUSTYPE(bustype) == PCMCIA_BUS) {
 		/* enable writes to the SPROM */
 		if (sprom_cmd_pcmcia(osh, SROM_WEN))
@@ -162,12 +300,37 @@
 		bcm_mdelay(WRITE_ENABLE_DELAY);
 		/* write srom */
 		for (i = 0; i < nw; i++) {
-			sprom_write_pcmcia(osh, (uint16)(off + i), p[i]);
+			sprom_write_pcmcia(osh, (uint16)(i), image[i]);
 			bcm_mdelay(WRITE_WORD_DELAY);
 		}
 		/* disable writes to the SPROM */
 		if (sprom_cmd_pcmcia(osh, SROM_WDS))
 			return 1;
+	} else if (BUSTYPE(bustype) == SB_BUS) {
+#ifdef BCMUSBDEV
+		if (SPROMBUS == PCMCIA_BUS) {
+			uint origidx;
+			void *regs;
+			int rc;
+			bool wasup;
+
+			origidx = sb_coreidx(sbh);
+			regs = sb_setcore(sbh, SB_PCMCIA, 0);
+			ASSERT(regs != NULL);
+
+			if (!(wasup = sb_iscoreup(sbh)))
+				sb_core_reset(sbh, 0, 0);
+
+			rc = set_sb_pcmcia_srom(sbh, osh, regs, byteoff, buf, nbytes);
+
+			if (!wasup)
+				sb_core_disable(sbh, 0);
+
+			sb_setcoreidx(sbh, origidx);
+			return rc;
+		}
+#endif /* def BCMUSBDEV */
+		return 1;
 	} else {
 		return 1;
 	}
@@ -176,25 +339,231 @@
 	return 0;
 }
 
+#ifdef BCMUSBDEV
+#define SB_PCMCIA_READ(osh, regs, fcr) \
+		R_REG(osh, (volatile uint8 *)(regs) + 0x600 + (fcr) - 0x700 / 2)
+#define SB_PCMCIA_WRITE(osh, regs, fcr, v) \
+		W_REG(osh, (volatile uint8 *)(regs) + 0x600 + (fcr) - 0x700 / 2, v)
+
+/* set PCMCIA srom command register */
+static int
+srom_cmd_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint8 cmd)
+{
+	uint8 status = 0;
+	uint wait_cnt = 0;
+
+	/* write srom command register */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_CS, cmd);
+
+	/* wait status */
+	while (++wait_cnt < 1000000) {
+		status = SB_PCMCIA_READ(osh, pcmregs, SROM_CS);
+		if (status & SROM_DONE)
+			return 0;
+		OSL_DELAY(1);
+	}
+
+	BS_ERROR(("sr_cmd: Give up after %d tries, stat = 0x%x\n", wait_cnt, status));
+	return 1;
+}
+
+/* read a word from the PCMCIA srom over SB */
+static int
+srom_read_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint16 addr, uint16 *data)
+{
+	uint8 addr_l, addr_h,  data_l, data_h;
+
+	addr_l = (uint8)((addr * 2) & 0xff);
+	addr_h = (uint8)(((addr * 2) >> 8) & 0xff);
+
+	/* set address */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRH, addr_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRL, addr_l);
+
+	/* do read */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_READ))
+		return 1;
 
+	/* read data */
+	data_h = SB_PCMCIA_READ(osh, pcmregs, SROM_DATAH);
+	data_l = SB_PCMCIA_READ(osh, pcmregs, SROM_DATAL);
+	*data = ((uint16)data_h << 8) | data_l;
+
+	return 0;
+}
+
+/* write a word to the PCMCIA srom over SB */
 static int
-srom_parsecis(void *osh, uint8 *cis, char **vars, int *count)
+srom_write_sb_pcmcia(osl_t *osh, uint8 *pcmregs, uint16 addr, uint16 data)
+{
+	uint8 addr_l, addr_h, data_l, data_h;
+	int rc;
+
+	addr_l = (uint8)((addr * 2) & 0xff);
+	addr_h = (uint8)(((addr * 2) >> 8) & 0xff);
+
+	/* set address */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRH, addr_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_ADDRL, addr_l);
+
+	data_l = (uint8)(data & 0xff);
+	data_h = (uint8)((data >> 8) & 0xff);
+
+	/* write data */
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_DATAH, data_h);
+	SB_PCMCIA_WRITE(osh, pcmregs, SROM_DATAL, data_l);
+
+	/* do write */
+	rc = srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WRITE);
+	OSL_DELAY(20000);
+	return rc;
+}
+
+/*
+ * Read the srom for the pcmcia-srom over sb case.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+get_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                   uint boff, uint16 *srom, uint bsz)
+{
+	uint i, nw, woff, wsz;
+	int err = 0;
+
+	/* read must be at word boundary */
+	ASSERT((boff & 1) == 0 && (bsz & 1) == 0);
+
+	/* read sprom size and validate the parms */
+	if ((nw = srom_size(sbh, osh)) == 0) {
+		BS_ERROR(("get_sb_pcmcia_srom: sprom size unknown\n"));
+		err = -1;
+		goto out;
+	}
+	if (boff + bsz > 2 * nw) {
+		BS_ERROR(("get_sb_pcmcia_srom: sprom size exceeded\n"));
+		err = -2;
+		goto out;
+	}
+
+	/* read in sprom contents */
+	for (woff = boff / 2, wsz = bsz / 2, i = 0;
+	     woff < nw && i < wsz; woff ++, i ++) {
+		if (srom_read_sb_pcmcia(osh, pcmregs, (uint16)woff, &srom[i])) {
+			BS_ERROR(("get_sb_pcmcia_srom: sprom read failed\n"));
+			err = -3;
+			goto out;
+		}
+	}
+
+out:
+	return err;
+}
+
+/*
+ * Write the srom for the pcmcia-srom over sb case.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+set_sb_pcmcia_srom(sb_t *sbh, osl_t *osh, uint8 *pcmregs,
+                   uint boff, uint16 *srom, uint bsz)
+{
+	uint i, nw, woff, wsz;
+	uint16 word;
+	uint8 crc;
+	int err = 0;
+
+	/* write must be at word boundary */
+	ASSERT((boff & 1) == 0 && (bsz & 1) == 0);
+
+	/* read sprom size and validate the parms */
+	if ((nw = srom_size(sbh, osh)) == 0) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom size unknown\n"));
+		err = -1;
+		goto out;
+	}
+	if (boff + bsz > 2 * nw) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom size exceeded\n"));
+		err = -2;
+		goto out;
+	}
+
+	/* enable write */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WEN)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom wen failed\n"));
+		err = -3;
+		goto out;
+	}
+
+	/* write buffer to sprom */
+	for (woff = boff / 2, wsz = bsz / 2, i = 0;
+	     woff < nw && i < wsz; woff ++, i ++) {
+		if (srom_write_sb_pcmcia(osh, pcmregs, (uint16)woff, srom[i])) {
+			BS_ERROR(("set_sb_pcmcia_srom: sprom write failed\n"));
+			err = -4;
+			goto out;
+		}
+	}
+
+	/* fix crc */
+	crc = CRC8_INIT_VALUE;
+	for (woff = 0; woff < nw; woff ++) {
+		if (srom_read_sb_pcmcia(osh, pcmregs, (uint16)woff, &word)) {
+			BS_ERROR(("set_sb_pcmcia_srom: sprom fix crc read failed\n"));
+			err = -5;
+			goto out;
+		}
+		word = htol16(word);
+		crc = hndcrc8((uint8 *)&word, woff != nw - 1 ? 2 : 1, crc);
+	}
+	word = (~crc << 8) + (ltoh16(word) & 0xff);
+	if (srom_write_sb_pcmcia(osh, pcmregs, (uint16)(woff - 1), word)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom fix crc write failed\n"));
+		err = -6;
+		goto out;
+	}
+
+	/* disable write */
+	if (srom_cmd_sb_pcmcia(osh, pcmregs, SROM_WDS)) {
+		BS_ERROR(("set_sb_pcmcia_srom: sprom wds failed\n"));
+		err = -7;
+		goto out;
+	}
+
+out:
+	return err;
+}
+#endif /* def BCMUSBDEV */
+
+int
+srom_parsecis(osl_t *osh, uint8 *pcis[], uint ciscnt, char **vars, uint *count)
 {
 	char eabuf[32];
-	char *vp, *base;
-	uint8 tup, tlen, sromrev = 1;
+	char *base;
+	varbuf_t b;
+	uint8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
 	uint varsize;
 	bool ag_init = FALSE;
-	uint16 w;
+	uint32 w32;
+	uint funcid;
+	uint cisnum;
+	int32 boardnum = -1;
 
 	ASSERT(vars);
 	ASSERT(count);
 
-	base = vp = MALLOC(osh, VARS_MAX);
-	ASSERT(vp);
-
+	base = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	ASSERT(base);
+	if (!base)
+		return -2;
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+
+	eabuf[0] = '\0';
+	for (cisnum = 0; cisnum < ciscnt; cisnum++) {
+		cis = *pcis++;
 	i = 0;
+		funcid = 0;
 	do {
 		tup = cis[i++];
 		tlen = cis[i++];
@@ -202,142 +571,335 @@
 			break;
 
 		switch (tup) {
+			case CISTPL_VERS_1:
+				/* assume the strings are good if the version field checks out */
+				if (((cis[i + 1] << 8) + cis[i]) >= 0x0008) {
+					varbuf_append(&b, "manf=%s", &cis[i + 2]);
+					varbuf_append(&b, "productname=%s",
+					              &cis[i + 3 + strlen((char *)&cis[i + 2])]);
+					break;
+				}
+
 		case CISTPL_MANFID:
-			vp += sprintf(vp, "manfid=%d", (cis[i + 1] << 8) + cis[i]);
-			vp++;
-			vp += sprintf(vp, "prodid=%d", (cis[i + 3] << 8) + cis[i + 2]);
-			vp++;
+				varbuf_append(&b, "manfid=0x%x", (cis[i + 1] << 8) + cis[i]);
+				varbuf_append(&b, "prodid=0x%x", (cis[i + 3] << 8) + cis[i + 2]);
+				break;
+
+			case CISTPL_FUNCID:
+				funcid = cis[i];
 			break;
 
 		case CISTPL_FUNCE:
-			if (cis[i] == LAN_NID) {
+				switch (funcid) {
+				default:
+					/* set macaddr if HNBU_MACADDR not seen yet */
+					if (eabuf[0] == '\0' && cis[i] == LAN_NID) {
 				ASSERT(cis[i + 1] == ETHER_ADDR_LEN);
-				bcm_ether_ntoa((uchar*)&cis[i + 2], eabuf);
-				vp += sprintf(vp, "il0macaddr=%s", eabuf);
-				vp++;
+						bcm_ether_ntoa((struct ether_addr *)&cis[i + 2],
+						               eabuf);
+					}
+					/* set boardnum if HNBU_BOARDNUM not seen yet */
+					if (boardnum == -1)
+						boardnum = (cis[i + 6] << 8) + cis[i + 7];
+					break;
 			}
 			break;
 
 		case CISTPL_CFTABLE:
-			vp += sprintf(vp, "regwindowsz=%d", (cis[i + 7] << 8) | cis[i + 6]);
-			vp++;
+				varbuf_append(&b, "regwindowsz=%d", (cis[i + 7] << 8) | cis[i + 6]);
 			break;
 
 		case CISTPL_BRCM_HNBU:
 			switch (cis[i]) {
+				case HNBU_SROMREV:
+					sromrev = cis[i + 1];
+					varbuf_append(&b, "sromrev=%d", sromrev);
+					break;
+
 			case HNBU_CHIPID:
-				vp += sprintf(vp, "vendid=%d", (cis[i + 2] << 8) + cis[i + 1]);
-				vp++;
-				vp += sprintf(vp, "devid=%d", (cis[i + 4] << 8) + cis[i + 3]);
-				vp++;
-				if (tlen == 7) {
-					vp += sprintf(vp, "chiprev=%d", (cis[i + 6] << 8) + cis[i + 5]);
-					vp++;
+					varbuf_append(&b, "vendid=0x%x", (cis[i + 2] << 8) +
+					              cis[i + 1]);
+					varbuf_append(&b, "devid=0x%x", (cis[i + 4] << 8) +
+					              cis[i + 3]);
+					if (tlen >= 7) {
+						varbuf_append(&b, "chiprev=%d",
+						              (cis[i + 6] << 8) + cis[i + 5]);
+					}
+					if (tlen >= 9) {
+						varbuf_append(&b, "subvendid=0x%x",
+						              (cis[i + 8] << 8) + cis[i + 7]);
+					}
+					if (tlen >= 11) {
+						varbuf_append(&b, "subdevid=0x%x",
+						              (cis[i + 10] << 8) + cis[i + 9]);
+						/* subdevid doubles for boardtype */
+						varbuf_append(&b, "boardtype=0x%x",
+						              (cis[i + 10] << 8) + cis[i + 9]);
 				}
 				break;
 
 			case HNBU_BOARDREV:
-				vp += sprintf(vp, "boardrev=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "boardrev=0x%x", cis[i + 1]);
 				break;
 
 			case HNBU_AA:
-				vp += sprintf(vp, "aa0=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "aa2g=%d", cis[i + 1]);
 				break;
 
 			case HNBU_AG:
-				vp += sprintf(vp, "ag0=%d", cis[i + 1]);
-				vp++;
+					varbuf_append(&b, "ag0=%d", cis[i + 1]);
 				ag_init = TRUE;
 				break;
 
+				case HNBU_ANT5G:
+					varbuf_append(&b, "aa5g=%d", cis[i + 1]);
+					varbuf_append(&b, "ag1=%d", cis[i + 2]);
+					break;
+
 			case HNBU_CC:
-				vp += sprintf(vp, "cc=%d", cis[i + 1]);
-				vp++;
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, "cc=%d", cis[i + 1]);
 				break;
 
 			case HNBU_PAPARMS:
-				vp += sprintf(vp, "pa0maxpwr=%d", cis[i + tlen - 1]);
-				vp++;
-				if (tlen == 9) {
-					/* New version */
+					if (tlen == 2) {
+						ASSERT(sromrev == 1);
+						varbuf_append(&b, "pa0maxpwr=%d", cis[i + 1]);
+					} else if (tlen >= 9) {
+						if (tlen == 10) {
+							ASSERT(sromrev >= 2);
+							varbuf_append(&b, "opo=%d", cis[i + 9]);
+						} else
+							ASSERT(tlen == 9);
+
 					for (j = 0; j < 3; j++) {
-						vp += sprintf(vp, "pa0b%d=%d", j,
-							      (cis[i + (j * 2) + 2] << 8) + cis[i + (j * 2) + 1]);
-						vp++;
-					}
-					vp += sprintf(vp, "pa0itssit=%d", cis[i + 7]);
-					vp++;
+							varbuf_append(&b, "pa0b%d=%d", j,
+							              (cis[i + (j * 2) + 2] << 8) +
+							              cis[i + (j * 2) + 1]);
 				}
+						varbuf_append(&b, "pa0itssit=%d", cis[i + 7]);
+						varbuf_append(&b, "pa0maxpwr=%d", cis[i + 8]);
+					} else
+						ASSERT(tlen >= 9);
+					break;
+
+				case HNBU_PAPARMS5G:
+					ASSERT((sromrev == 2) || (sromrev == 3));
+					for (j = 0; j < 3; j++) {
+						varbuf_append(&b, "pa1b%d=%d", j,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					for (j = 3; j < 6; j++) {
+						varbuf_append(&b, "pa1lob%d=%d", j - 3,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					for (j = 6; j < 9; j++) {
+						varbuf_append(&b, "pa1hib%d=%d", j - 6,
+							(cis[i + (j * 2) + 2] << 8) +
+							cis[i + (j * 2) + 1]);
+					}
+					varbuf_append(&b, "pa1itssit=%d", cis[i + 19]);
+					varbuf_append(&b, "pa1maxpwr=%d", cis[i + 20]);
+					varbuf_append(&b, "pa1lomaxpwr=%d", cis[i + 21]);
+					varbuf_append(&b, "pa1himaxpwr=%d", cis[i + 22]);
 				break;
 
 			case HNBU_OEM:
-				vp += sprintf(vp, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
-					cis[i + 1], cis[i + 2], cis[i + 3], cis[i + 4],
-					cis[i + 5], cis[i + 6], cis[i + 7], cis[i + 8]);
-				vp++;
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
+					              cis[i + 1], cis[i + 2],
+					              cis[i + 3], cis[i + 4],
+					              cis[i + 5], cis[i + 6],
+					              cis[i + 7], cis[i + 8]);
 				break;
+
 			case HNBU_BOARDFLAGS:
-				w = (cis[i + 2] << 8) + cis[i + 1];
-				if (w == 0xffff) w = 0;
-				vp += sprintf(vp, "boardflags=%d", w);
-				vp++;
+					w32 = (cis[i + 2] << 8) + cis[i + 1];
+					if (tlen == 5)
+						w32 |= (cis[i + 4] << 24) + (cis[i + 3] << 16);
+					varbuf_append(&b, "boardflags=0x%x", w32);
 				break;
-			case HNBU_LED:
+
+				case HNBU_LEDS:
 				if (cis[i + 1] != 0xff) {
-					vp += sprintf(vp, "wl0gpio0=%d", cis[i + 1]);
-					vp++;
+						varbuf_append(&b, "ledbh0=%d", cis[i + 1]);
 				}
 				if (cis[i + 2] != 0xff) {
-					vp += sprintf(vp, "wl0gpio1=%d", cis[i + 2]);
-					vp++;
+						varbuf_append(&b, "ledbh1=%d", cis[i + 2]);
 				}
 				if (cis[i + 3] != 0xff) {
-					vp += sprintf(vp, "wl0gpio2=%d", cis[i + 3]);
-					vp++;
+						varbuf_append(&b, "ledbh2=%d", cis[i + 3]);
 				}
 				if (cis[i + 4] != 0xff) {
-					vp += sprintf(vp, "wl0gpio3=%d", cis[i + 4]);
-					vp++;
+						varbuf_append(&b, "ledbh3=%d", cis[i + 4]);
 				}
 				break;
-			}
+
+				case HNBU_CCODE:
+					ASSERT(sromrev > 1);
+					if ((cis[i + 1] == 0) || (cis[i + 2] == 0))
+						varbuf_append(&b, "ccode=");
+					else
+						varbuf_append(&b, "ccode=%c%c",
+						              cis[i + 1], cis[i + 2]);
+					varbuf_append(&b, "cctl=0x%x", cis[i + 3]);
+					break;
+
+				case HNBU_CCKPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, "cckpo=0x%x",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_OFDMPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, "ofdmpo=0x%x",
+					              (cis[i + 4] << 24) |
+					              (cis[i + 3] << 16) |
+					              (cis[i + 2] << 8) |
+					              cis[i + 1]);
+					break;
+
+				case HNBU_RDLID:
+					varbuf_append(&b, "rdlid=0x%x",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_RDLRNDIS:
+					varbuf_append(&b, "rdlrndis=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RDLRWU:
+					varbuf_append(&b, "rdlrwu=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RDLSN:
+					varbuf_append(&b, "rdlsn=%d",
+					              (cis[i + 2] << 8) | cis[i + 1]);
+					break;
+
+				case HNBU_XTALFREQ:
+					varbuf_append(&b, "xtalfreq=%d",
+					              (cis[i + 4] << 24) |
+					              (cis[i + 3] << 16) |
+					              (cis[i + 2] << 8) |
+					              cis[i + 1]);
+					break;
+
+				case HNBU_RSSISMBXA2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rssismf2g=%d", cis[i + 1] & 0xf);
+					varbuf_append(&b, "rssismc2g=%d", (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, "rssisav2g=%d", cis[i + 2] & 0x7);
+					varbuf_append(&b, "bxa2g=%d", (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_RSSISMBXA5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rssismf5g=%d", cis[i + 1] & 0xf);
+					varbuf_append(&b, "rssismc5g=%d", (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, "rssisav5g=%d", cis[i + 2] & 0x7);
+					varbuf_append(&b, "bxa5g=%d", (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_TRI2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "tri2g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_TRI5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "tri5gl=%d", cis[i + 1]);
+					varbuf_append(&b, "tri5g=%d", cis[i + 2]);
+					varbuf_append(&b, "tri5gh=%d", cis[i + 3]);
+					break;
+
+				case HNBU_RXPO2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rxpo2g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_RXPO5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, "rxpo5g=%d", cis[i + 1]);
+					break;
+
+				case HNBU_BOARDNUM:
+					boardnum = (cis[i + 2] << 8) + cis[i + 1];
+					break;
+
+				case HNBU_MACADDR:
+					bcm_ether_ntoa((struct ether_addr *)&cis[i + 1],
+					               eabuf);
 			break;
 
+				case HNBU_BOARDTYPE:
+					varbuf_append(&b, "boardtype=0x%x",
+					              (cis[i + 2] << 8) + cis[i + 1]);
+					break;
+
+#if defined(CONFIG_BCMCCISSR3)
+				case HNBU_SROM3SWRGN: {
+					uint16 srom[35];
+					uint8 srev = cis[i + 1 + 70];
+					ASSERT(srev == 3);
+					/* make tuple value 16-bit aligned and parse it */
+					bcopy(&cis[i + 1], srom, sizeof(srom));
+					_initvars_srom_pci(srev, srom, SROM3_SWRGN_OFF, &b);
+					/* create extra variables */
+					varbuf_append(&b, "vendid=0x%x",
+					              (cis[i + 1 + 73] << 8) + cis[i + 1 + 72]);
+					varbuf_append(&b, "devid=0x%x",
+					              (cis[i + 1 + 75] << 8) + cis[i + 1 + 74]);
+					varbuf_append(&b, "xtalfreq=%d",
+					              (cis[i + 1 + 77] << 8) + cis[i + 1 + 76]);
+					/* 2.4G antenna gain is included in SROM */
+					ag_init = TRUE;
+					/* Ethernet MAC address is included in SROM */
+					eabuf[0] = 0;
+					boardnum = -1;
+					break;
+				}
+#endif	
+				}
+				break;
 		}
 		i += tlen;
-	} while (tup != 0xff);
+		} while (tup != CISTPL_END);
+	}
+
+	if (boardnum != -1) {
+		varbuf_append(&b, "boardnum=%d", boardnum);
+	}
 
-	/* Set the srom version */
-	vp += sprintf(vp, "sromrev=%d", sromrev);
-	vp++;
-
-	/* For now just set boardflags2 to zero */
-	vp += sprintf(vp, "boardflags2=0");
-	vp++;
+	if (eabuf[0]) {
+		varbuf_append(&b, "macaddr=%s", eabuf);
+	}
 
 	/* if there is no antenna gain field, set default */
 	if (ag_init == FALSE) {
-		vp += sprintf(vp, "ag0=%d", 0xff);
-		vp++;
+		varbuf_append(&b, "ag0=%d", 0xff);
 	}
 
 	/* final nullbyte terminator */
-	*vp++ = '\0';
-	varsize = (uint)(vp - base);
-
-	ASSERT((vp - base) < VARS_MAX);
+	ASSERT(b.size >= 1);
+	*b.buf++ = '\0';
+	varsize = (uint)(b.buf - base);
+	ASSERT(varsize < MAXSZ_NVRAM_VARS);
+	if (varsize < MAXSZ_NVRAM_VARS) {
+		char* new_buf;
+		new_buf = (char*)MALLOC(osh, varsize);
+		ASSERT(new_buf);
+		if (new_buf) {
+			bcopy(base, new_buf, varsize);
+			MFREE(osh, base, MAXSZ_NVRAM_VARS);
+			base = new_buf;
+		}
+	}
 
-	if (varsize == VARS_MAX) {
 		*vars = base;
-	} else {
-		vp = MALLOC(osh, varsize);
-		ASSERT(vp);
-		bcopy(base, vp, varsize);
-		MFREE(osh, base, VARS_MAX);
-		*vars = vp;
-	}
 	*count = varsize;
 
 	return (0);
@@ -346,7 +908,7 @@
 
 /* set PCMCIA sprom command register */
 static int
-sprom_cmd_pcmcia(void *osh, uint8 cmd)
+sprom_cmd_pcmcia(osl_t *osh, uint8 cmd)
 {
 	uint8 status = 0;
 	uint wait_cnt = 1000;
@@ -366,7 +928,7 @@
 
 /* read a word from the PCMCIA srom */
 static int
-sprom_read_pcmcia(void *osh, uint16 addr, uint16 *data)
+sprom_read_pcmcia(osl_t *osh, uint16 addr, uint16 *data)
 {
 	uint8 addr_l, addr_h, data_l, data_h;
 
@@ -392,7 +954,7 @@
 
 /* write a word to the PCMCIA srom */
 static int
-sprom_write_pcmcia(void *osh, uint16 addr, uint16 data)
+sprom_write_pcmcia(osl_t *osh, uint16 addr, uint16 data)
 {
 	uint8 addr_l, addr_h, data_l, data_h;
 
@@ -418,265 +980,800 @@
  * Return 0 on success, nonzero on error.
  */
 static int
-sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc)
+sprom_read_pci(osl_t *osh, uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc)
 {
-	uint8 chk8;
+	int err = 0;
 	uint i;
 
 	/* read the sprom */
-	for (i = 0; i < nwords; i++)
-		buf[i] = R_REG(&sprom[wordoff + i]);
+	for (i = 0; i < nwords; i++) {
+#ifdef BCMQT
+		buf[i] = R_REG(osh, &sprom[wordoff + i]);
+#endif
+		buf[i] = R_REG(osh, &sprom[wordoff + i]);
+	}
 
 	if (check_crc) {
+		if (buf[0] == 0xffff) {
+			/* The hardware thinks that an srom that starts with 0xffff
+			 * is blank, regardless of the rest of the content, so declare
+			 * it bad.
+			 */
+			BS_ERROR(("%s: buf[0] = 0x%x, returning bad-crc\n", __FUNCTION__, buf[0]));
+			return 1;
+		}
+
 		/* fixup the endianness so crc8 will pass */
 		htol16_buf(buf, nwords * 2);
-		if ((chk8 = hndcrc8((uchar*)buf, nwords * 2, CRC8_INIT_VALUE)) != CRC8_GOOD_VALUE)
-			return (1);
+		if (hndcrc8((uint8 *)buf, nwords * 2, CRC8_INIT_VALUE) != CRC8_GOOD_VALUE)
+			err = 1;
 		/* now correct the endianness of the byte array */
 		ltoh16_buf(buf, nwords * 2);
 	}
 
-	return (0);
+	return err;
 }
 
 /*
- * Initialize nonvolatile variable table from sprom.
+* Create variable table from memory.
+* Return 0 on success, nonzero on error.
+*/
+static int
+BCMINITFN(initvars_table)(osl_t *osh, char *start, char *end, char **vars, uint *count)
+{
+	int c = (int)(end - start);
+
+	/* do it only when there is more than just the null string */
+	if (c > 1) {
+		char *vp = MALLOC(osh, c);
+		ASSERT(vp);
+		if (!vp)
+			return BCME_NOMEM;
+		bcopy(start, vp, c);
+		*vars = vp;
+		*count = c;
+	}
+	else {
+		*vars = NULL;
+		*count = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Find variables with <devpath> from flash. 'base' points to the beginning
+ * of the table upon enter and to the end of the table upon exit when success.
  * Return 0 on success, nonzero on error.
  */
-
 static int
-initvars_srom_pci(void *osh, void *curmap, char **vars, int *count)
+initvars_flash(sb_t *sbh, osl_t *osh, char **base, uint len)
 {
-	uint16 w, b[64];
-	uint8 sromrev;
-	struct ether_addr ea;
-	char eabuf[32];		     
-	uint32 bfl;
-	int c, woff, i;
-	char *vp, *base;
+	char *vp = *base;
+	char *flash;
+	int err;
+	char *s;
+	uint l, dl, copy_len;
+	char devpath[SB_DEVPATH_BUFSZ];
+
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE)))
+		return BCME_NOMEM;
+	if ((err = nvram_getall(flash, NVRAM_SPACE)))
+		goto exit;
+
+	sb_devpath(sbh, devpath, sizeof(devpath));
+
+	/* grab vars with the <devpath> prefix in name */
+	dl = strlen(devpath);
+	for (s = flash; s && *s; s += l + 1) {
+		l = strlen(s);
+
+		/* skip non-matching variable */
+		if (strncmp(s, devpath, dl))
+			continue;
+
+		/* is there enough room to copy? */
+		copy_len = l - dl + 1;
+		if (len < copy_len) {
+			err = BCME_BUFTOOSHORT;
+			goto exit;
+		}
+
+		/* no prefix, just the name=value */
+		strncpy(vp, &s[dl], copy_len);
+		vp += copy_len;
+		len -= copy_len;
+	}
+
+	/* add null string as terminator */
+	if (len < 1) {
+		err = BCME_BUFTOOSHORT;
+		goto exit;
+	}
+	*vp++ = '\0';
 
-	if (sprom_read_pci((void*)((int8*)curmap + PCI_BAR0_SPROM_OFFSET), 0, b, sizeof(b)/sizeof(b[0]), TRUE))
-		return (-1);
+	*base = vp;
 
-	/* top word of sprom contains version and crc8 */
-	sromrev = b[63] & 0xff;
-	/* bcm4401 sroms misprogrammed */
-	if (sromrev == 0x10)
-		sromrev = 1;
-	if ((sromrev != 1) && (sromrev != 2))
-		return (-2);
+exit:	MFREE(osh, flash, NVRAM_SPACE);
+	return err;
+}
+
+#if !defined(CONFIG_BCMUSBDEV) && !defined(CONFIG_BCMSDIODEV)
+/*
+ * Initialize nonvolatile variable table from flash.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+initvars_flash_sb(sb_t *sbh, char **vars, uint *count)
+{
+	osl_t *osh = sb_osh(sbh);
+	char *vp, *base;
+	int err;
 
 	ASSERT(vars);
 	ASSERT(count);
 
-	base = vp = MALLOC(osh, VARS_MAX);
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
 	ASSERT(vp);
+	if (!vp)
+		return BCME_NOMEM;
 
-	vp += sprintf(vp, "sromrev=%d", sromrev);
-	vp++;
+	if ((err = initvars_flash(sbh, osh, &vp, MAXSZ_NVRAM_VARS)) == 0)
+		err = initvars_table(osh, base, vp, vars, count);
 
-	if (sromrev >= 2) {
-		/* New section takes over the 4th hardware function space */
+	MFREE(osh, base, MAXSZ_NVRAM_VARS);
 
-		/* Word 29 is max power 11a high/low */
-		w = b[29];
-		vp += sprintf(vp, "pa1himaxpwr=%d", w & 0xff);
-		vp++;
-		vp += sprintf(vp, "pa1lomaxpwr=%d", (w >> 8) & 0xff);
-		vp++;
-
-		/* Words 30-32 set the 11alow pa settings,
-		 * 33-35 are the 11ahigh ones.
-		 */
-		for (i = 0; i < 3; i++) {
-			vp += sprintf(vp, "pa1lob%d=%d", i, b[30 + i]);
-			vp++;
-			vp += sprintf(vp, "pa1hib%d=%d", i, b[33 + i]);
-			vp++;
-		}
-		w = b[59];
-		if (w == 0)
-			vp += sprintf(vp, "ccode=");
-		else
-			vp += sprintf(vp, "ccode=%c%c", (w >> 8), (w & 0xff));
-		vp++;
+	return err;
+}
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+
+#ifdef WLTEST
+char mfgsromvars[256];
+char *defaultsromvars = "il0macaddr=00:11:22:33:44:51\0"
+		"et0macaddr=00:11:22:33:44:52\0"
+		"et1macaddr=00:11:22:33:44:53\0"
+		"boardtype=0xffff\0"
+		"boardrev=0x10\0"
+		"boardflags=8\0"
+		"sromrev=2\0"
+		"aa2g=3\0"
+		"\0";
+#define	MFGSROM_DEFVARSLEN	149 /* default srom len */
+#endif /* WL_TEST */
+
+/*
+ * Initialize nonvolatile variable table from sprom.
+ * Return 0 on success, nonzero on error.
+ */
+
+typedef struct {
+	const char *name;
+	uint32	revmask;
+	uint32	flags;
+	uint16	off;
+	uint16	mask;
+} sromvar_t;
+
+#define SRFL_MORE	1		/* value continues as described by the next entry */
+#define	SRFL_NOFFS	2		/* value bits can't be all one's */
+#define	SRFL_PRHEX	4		/* value is in hexdecimal format */
+#define	SRFL_PRSIGN	8		/* value is in signed decimal format */
+#define	SRFL_CCODE	0x10		/* value is in country code format */
+#define	SRFL_ETHADDR	0x20		/* value is an Ethernet address */
+#define SRFL_LEDDC	0x40		/* value is an LED duty cycle */
+
+/* Assumptions:
+ * - Ethernet address spins across 3 consective words
+ *
+ * Table rules:
+ * - Add multiple entries next to each other if a value spins across multiple words
+ *   (even multiple fields in the same word) with each entry except the last having
+ *   it's SRFL_MORE bit set.
+ * - Ethernet address entry does not follow above rule and must not have SRFL_MORE
+ *   bit set. Its SRFL_ETHADDR bit implies it takes multiple words.
+ * - The last entry's name field must be NULL to indicate the end of the table. Other
+ *   entries must have non-NULL name.
+ */
+
+static const sromvar_t pci_sromvars[] = {
+	{"boardrev",	0x0000000e,	SRFL_PRHEX,	SROM_AABREV, SROM_BR_MASK},
+	{"boardrev",	0x000000f0,	SRFL_PRHEX,	SROM4_BREV, 0xffff},
+	{"boardrev",	0xffffff00,	SRFL_PRHEX,	SROM8_BREV, 0xffff},
+	{"boardflags",	0x00000002,	SRFL_PRHEX,	SROM_BFL, 0xffff},
+	{"boardflags",	0x00000004,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL, 0xffff},
+	{"",		0,		0,			SROM_BFL2, 0xffff},
+	{"boardflags",	0x00000008,	SRFL_PRHEX|SRFL_MORE,	SROM_BFL, 0xffff},
+	{"",		0,		0,			SROM3_BFL2, 0xffff},
+	{"boardflags",	0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL0, 0xffff},
+	{"",		0,		0,			SROM4_BFL1, 0xffff},
+	{"boardflags",	0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL0, 0xffff},
+	{"",		0,		0,			SROM5_BFL1, 0xffff},
+	{"boardflags",	0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL0, 0xffff},
+	{"",		0,		0,			SROM8_BFL1, 0xffff},
+	{"boardflags2", 0x00000010,	SRFL_PRHEX|SRFL_MORE,	SROM4_BFL2, 0xffff},
+	{"",		0,		0,			SROM4_BFL3, 0xffff},
+	{"boardflags2", 0x000000e0,	SRFL_PRHEX|SRFL_MORE,	SROM5_BFL2, 0xffff},
+	{"",		0,		0,			SROM5_BFL3, 0xffff},
+	{"boardflags2", 0xffffff00,	SRFL_PRHEX|SRFL_MORE,	SROM8_BFL2, 0xffff},
+	{"",		0,		0,			SROM8_BFL3, 0xffff},
+	{"boardtype",	0xfffffffc,	SRFL_PRHEX,	SROM_SSID, 0xffff},
+	{"boardnum",	0x00000006,	0,		SROM_MACLO_IL0, 0xffff},
+	{"boardnum",	0x00000008,	0,		SROM3_MACLO, 0xffff},
+	{"boardnum",	0x00000010,	0,		SROM4_MACLO, 0xffff},
+	{"boardnum",	0x000000e0,	0,		SROM5_MACLO, 0xffff},
+	{"boardnum",	0xffffff00,	0,		SROM8_MACLO, 0xffff},
+	{"cc",		0x00000002,	0,		SROM_AABREV, SROM_CC_MASK},
+	{"regrev",	0x00000008,	0,		SROM_OPO, 0xff00},
+	{"regrev",	0x00000010,	0,		SROM4_REGREV, 0xff},
+	{"regrev",	0x000000e0,	0,		SROM5_REGREV, 0xff},
+	{"regrev",	0xffffff00,	0,		SROM8_REGREV, 0xff},
+	{"ledbh0",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10, 0xff},
+	{"ledbh1",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH10, 0xff00},
+	{"ledbh2",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32, 0xff},
+	{"ledbh3",	0x0000000e,	SRFL_NOFFS,	SROM_LEDBH32, 0xff00},
+	{"ledbh0",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10, 0xff},
+	{"ledbh1",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH10, 0xff00},
+	{"ledbh2",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32, 0xff},
+	{"ledbh3",	0x00000010,	SRFL_NOFFS,	SROM4_LEDBH32, 0xff00},
+	{"ledbh0",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10, 0xff},
+	{"ledbh1",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH10, 0xff00},
+	{"ledbh2",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32, 0xff},
+	{"ledbh3",	0x000000e0,	SRFL_NOFFS,	SROM5_LEDBH32, 0xff00},
+	{"ledbh0",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH10, 0xff},
+	{"ledbh1",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH10, 0xff00},
+	{"ledbh2",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH32, 0xff},
+	{"ledbh3",	0xffffff00,	SRFL_NOFFS,	SROM8_LEDBH32, 0xff00},
+	{"pa0b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB0, 0xffff},
+	{"pa0b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB1, 0xffff},
+	{"pa0b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL0PAB2, 0xffff},
+	{"pa0itssit",	0x0000000e,	0,		SROM_ITT, 0xff},
+	{"pa0maxpwr",	0x0000000e,	0,		SROM_WL10MAXP, 0xff},
+	{"pa0b0",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB0, 0xffff},
+	{"pa0b1",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB1, 0xffff},
+	{"pa0b2",	0xffffff00,	SRFL_PRHEX,	SROM8_W0_PAB2, 0xffff},
+	{"pa0itssit",	0xffffff00,	0,		SROM8_W0_ITTMAXP, 0xff00},
+	{"pa0maxpwr",	0xffffff00,	0,		SROM8_W0_ITTMAXP, 0xff},
+	{"opo",		0x0000000c,	0,		SROM_OPO, 0xff},
+	{"opo",		0xffffff00,	0,		SROM8_2G_OFDMPO, 0xff},
+	{"aa2g",	0x0000000e,	0,		SROM_AABREV, SROM_AA0_MASK},
+	{"aa2g",	0x000000f0,	0,		SROM4_AA, 0xff},
+	{"aa2g",	0xffffff00,	0,		SROM8_AA, 0xff},
+	{"aa5g",	0x0000000e,	0,		SROM_AABREV, SROM_AA1_MASK},
+	{"aa5g",	0x000000f0,	0,		SROM4_AA, 0xff00},
+	{"aa5g",	0xffffff00,	0,		SROM8_AA, 0xff00},
+	{"ag0",		0x0000000e,	0,		SROM_AG10, 0xff},
+	{"ag1",		0x0000000e,	0,		SROM_AG10, 0xff00},
+	{"ag0",		0x000000f0,	0,		SROM4_AG10, 0xff},
+	{"ag1",		0x000000f0,	0,		SROM4_AG10, 0xff00},
+	{"ag2",		0x000000f0,	0,		SROM4_AG32, 0xff},
+	{"ag3",		0x000000f0,	0,		SROM4_AG32, 0xff00},
+	{"ag0",		0xffffff00,	0,		SROM8_AG10, 0xff},
+	{"ag1",		0xffffff00,	0,		SROM8_AG10, 0xff00},
+	{"ag2",		0xffffff00,	0,		SROM8_AG32, 0xff},
+	{"ag3",		0xffffff00,	0,		SROM8_AG32, 0xff00},
+	{"pa1b0",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB0, 0xffff},
+	{"pa1b1",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB1, 0xffff},
+	{"pa1b2",	0x0000000e,	SRFL_PRHEX,	SROM_WL1PAB2, 0xffff},
+	{"pa1lob0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB0, 0xffff},
+	{"pa1lob1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB1, 0xffff},
+	{"pa1lob2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1LPAB2, 0xffff},
+	{"pa1hib0",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB0, 0xffff},
+	{"pa1hib1",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB1, 0xffff},
+	{"pa1hib2",	0x0000000c,	SRFL_PRHEX,	SROM_WL1HPAB2, 0xffff},
+	{"pa1itssit",	0x0000000e,	0,		SROM_ITT, 0xff00},
+	{"pa1maxpwr",	0x0000000e,	0,		SROM_WL10MAXP, 0xff00},
+	{"pa1lomaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP, 0xff00},
+	{"pa1himaxpwr",	0x0000000c,	0,		SROM_WL1LHMAXP, 0xff},
+	{"pa1b0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0, 0xffff},
+	{"pa1b1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1, 0xffff},
+	{"pa1b2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2, 0xffff},
+	{"pa1lob0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0_LC, 0xffff},
+	{"pa1lob1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1_LC, 0xffff},
+	{"pa1lob2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2_LC, 0xffff},
+	{"pa1hib0",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB0_HC, 0xffff},
+	{"pa1hib1",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB1_HC, 0xffff},
+	{"pa1hib2",	0xffffff00,	SRFL_PRHEX,	SROM8_W1_PAB2_HC, 0xffff},
+	{"pa1itssit",	0xffffff00,	0,		SROM8_W1_ITTMAXP, 0xff00},
+	{"pa1maxpwr",	0xffffff00,	0,		SROM8_W1_ITTMAXP, 0xff},
+	{"pa1lomaxpwr",	0xffffff00,	0,		SROM8_W1_MAXP_LCHC, 0xff00},
+	{"pa1himaxpwr",	0xffffff00,	0,		SROM8_W1_MAXP_LCHC, 0xff},
+	{"bxa2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x1800},
+	{"rssisav2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x0700},
+	{"rssismc2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x00f0},
+	{"rssismf2g",	0x00000008,	0,		SROM_BXARSSI2G, 0x000f},
+	{"bxa2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x1800},
+	{"rssisav2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x0700},
+	{"rssismc2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x00f0},
+	{"rssismf2g",	0xffffff00,	0,		SROM8_BXARSSI2G, 0x000f},
+	{"bxa5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x1800},
+	{"rssisav5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x0700},
+	{"rssismc5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x00f0},
+	{"rssismf5g",	0x00000008,	0,		SROM_BXARSSI5G, 0x000f},
+	{"bxa5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x1800},
+	{"rssisav5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x0700},
+	{"rssismc5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x00f0},
+	{"rssismf5g",	0xffffff00,	0,		SROM8_BXARSSI5G, 0x000f},
+	{"tri2g",	0x00000008,	0,		SROM_TRI52G, 0xff},
+	{"tri5g",	0x00000008,	0,		SROM_TRI52G, 0xff00},
+	{"tri5gl",	0x00000008,	0,		SROM_TRI5GHL, 0xff},
+	{"tri5gh",	0x00000008,	0,		SROM_TRI5GHL, 0xff00},
+	{"tri2g",	0xffffff00,	0,		SROM8_TRI52G, 0xff},
+	{"tri5g",	0xffffff00,	0,		SROM8_TRI52G, 0xff00},
+	{"tri5gl",	0xffffff00,	0,		SROM8_TRI5GHL, 0xff},
+	{"tri5gh",	0xffffff00,	0,		SROM8_TRI5GHL, 0xff00},
+	{"rxpo2g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G, 0xff},
+	{"rxpo5g",	0x00000008,	SRFL_PRSIGN,	SROM_RXPO52G, 0xff00},
+	{"rxpo2g",	0xffffff00,	SRFL_PRSIGN,	SROM8_RXPO52G, 0xff},
+	{"rxpo5g",	0xffffff00,	SRFL_PRSIGN,	SROM8_RXPO52G, 0xff00},
+	{"txchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch",	0x000000f0,	SRFL_NOFFS,	SROM4_TXRXC, SROM4_SWITCH_MASK},
+	{"txchain",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch",	0xffffff00,	SRFL_NOFFS,	SROM8_TXRXC, SROM4_SWITCH_MASK},
+	{"txpid2ga0",	0x000000f0,	0,		SROM4_TXPID2G, 0xff},
+	{"txpid2ga1",	0x000000f0,	0,		SROM4_TXPID2G, 0xff00},
+	{"txpid2ga2",	0x000000f0,	0,		SROM4_TXPID2G + 1, 0xff},
+	{"txpid2ga3",	0x000000f0,	0,		SROM4_TXPID2G + 1, 0xff00},
+	{"txpid5ga0",	0x000000f0,	0,		SROM4_TXPID5G, 0xff},
+	{"txpid5ga1",	0x000000f0,	0,		SROM4_TXPID5G, 0xff00},
+	{"txpid5ga2",	0x000000f0,	0,		SROM4_TXPID5G + 1, 0xff},
+	{"txpid5ga3",	0x000000f0,	0,		SROM4_TXPID5G + 1, 0xff00},
+	{"txpid5gla0",	0x000000f0,	0,		SROM4_TXPID5GL, 0xff},
+	{"txpid5gla1",	0x000000f0,	0,		SROM4_TXPID5GL, 0xff00},
+	{"txpid5gla2",	0x000000f0,	0,		SROM4_TXPID5GL + 1, 0xff},
+	{"txpid5gla3",	0x000000f0,	0,		SROM4_TXPID5GL + 1, 0xff00},
+	{"txpid5gha0",	0x000000f0,	0,		SROM4_TXPID5GH, 0xff},
+	{"txpid5gha1",	0x000000f0,	0,		SROM4_TXPID5GH, 0xff00},
+	{"txpid5gha2",	0x000000f0,	0,		SROM4_TXPID5GH + 1, 0xff},
+	{"txpid5gha3",	0x000000f0,	0,		SROM4_TXPID5GH + 1, 0xff00},
+	{"cck2gpo",	0x000000f0,	0,		SROM4_2G_CCKPO, 0xffff},
+	{"cck2gpo",	0xffffff00,	0,		SROM8_2G_CCKPO, 0xffff},
+	{"ofdm2gpo",	0x000000f0,	SRFL_MORE,	SROM4_2G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo",	0x000000f0,	SRFL_MORE,	SROM4_5G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo",	0x000000f0,	SRFL_MORE,	SROM4_5GL_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo",	0x000000f0,	SRFL_MORE,	SROM4_5GH_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM4_5GH_OFDMPO + 1, 0xffff},
+	{"ofdm2gpo",	0xffffff00,	SRFL_MORE,	SROM8_2G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo",	0xffffff00,	SRFL_MORE,	SROM8_5G_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo",	0xffffff00,	SRFL_MORE,	SROM8_5GL_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo",	0xffffff00,	SRFL_MORE,	SROM8_5GH_OFDMPO, 0xffff},
+	{"",		0,		0,		SROM8_5GH_OFDMPO + 1, 0xffff},
+	{"mcs2gpo0",	0x000000f0,	0,		SROM4_2G_MCSPO, 0xffff},
+	{"mcs2gpo1",	0x000000f0,	0,		SROM4_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2",	0x000000f0,	0,		SROM4_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3",	0x000000f0,	0,		SROM4_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4",	0x000000f0,	0,		SROM4_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5",	0x000000f0,	0,		SROM4_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6",	0x000000f0,	0,		SROM4_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7",	0x000000f0,	0,		SROM4_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0",	0x000000f0,	0,		SROM4_5G_MCSPO, 0xffff},
+	{"mcs5gpo1",	0x000000f0,	0,		SROM4_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2",	0x000000f0,	0,		SROM4_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3",	0x000000f0,	0,		SROM4_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4",	0x000000f0,	0,		SROM4_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5",	0x000000f0,	0,		SROM4_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6",	0x000000f0,	0,		SROM4_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7",	0x000000f0,	0,		SROM4_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0",	0x000000f0,	0,		SROM4_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1",	0x000000f0,	0,		SROM4_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2",	0x000000f0,	0,		SROM4_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3",	0x000000f0,	0,		SROM4_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4",	0x000000f0,	0,		SROM4_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5",	0x000000f0,	0,		SROM4_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6",	0x000000f0,	0,		SROM4_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7",	0x000000f0,	0,		SROM4_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0",	0x000000f0,	0,		SROM4_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1",	0x000000f0,	0,		SROM4_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2",	0x000000f0,	0,		SROM4_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3",	0x000000f0,	0,		SROM4_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4",	0x000000f0,	0,		SROM4_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5",	0x000000f0,	0,		SROM4_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6",	0x000000f0,	0,		SROM4_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7",	0x000000f0,	0,		SROM4_5GH_MCSPO + 7, 0xffff},
+	{"mcs2gpo0",	0xffffff00,	0,		SROM8_2G_MCSPO, 0xffff},
+	{"mcs2gpo1",	0xffffff00,	0,		SROM8_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2",	0xffffff00,	0,		SROM8_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3",	0xffffff00,	0,		SROM8_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4",	0xffffff00,	0,		SROM8_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5",	0xffffff00,	0,		SROM8_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6",	0xffffff00,	0,		SROM8_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7",	0xffffff00,	0,		SROM8_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0",	0xffffff00,	0,		SROM8_5G_MCSPO, 0xffff},
+	{"mcs5gpo1",	0xffffff00,	0,		SROM8_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2",	0xffffff00,	0,		SROM8_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3",	0xffffff00,	0,		SROM8_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4",	0xffffff00,	0,		SROM8_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5",	0xffffff00,	0,		SROM8_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6",	0xffffff00,	0,		SROM8_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7",	0xffffff00,	0,		SROM8_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0",	0xffffff00,	0,		SROM8_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1",	0xffffff00,	0,		SROM8_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2",	0xffffff00,	0,		SROM8_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3",	0xffffff00,	0,		SROM8_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4",	0xffffff00,	0,		SROM8_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5",	0xffffff00,	0,		SROM8_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6",	0xffffff00,	0,		SROM8_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7",	0xffffff00,	0,		SROM8_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0",	0xffffff00,	0,		SROM8_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1",	0xffffff00,	0,		SROM8_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2",	0xffffff00,	0,		SROM8_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3",	0xffffff00,	0,		SROM8_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4",	0xffffff00,	0,		SROM8_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5",	0xffffff00,	0,		SROM8_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6",	0xffffff00,	0,		SROM8_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7",	0xffffff00,	0,		SROM8_5GH_MCSPO + 7, 0xffff},
+	{"cddpo",	0x000000f0,	0,		SROM4_CDDPO, 0xffff},
+	{"stbcpo",	0x000000f0,	0,		SROM4_STBCPO, 0xffff},
+	{"bw40po",	0x000000f0,	0,		SROM4_BW40PO, 0xffff},
+	{"bwduppo",	0x000000f0,	0,		SROM4_BWDUPPO, 0xffff},
+	{"cddpo",	0xffffff00,	0,		SROM8_CDDPO, 0xffff},
+	{"stbcpo",	0xffffff00,	0,		SROM8_STBCPO, 0xffff},
+	{"bw40po",	0xffffff00,	0,		SROM8_BW40PO, 0xffff},
+	{"bwduppo",	0xffffff00,	0,		SROM8_BWDUPPO, 0xffff},
+	{"ccode",	0x0000000f,	SRFL_CCODE,	SROM_CCODE, 0xffff},
+	{"ccode",	0x00000010,	SRFL_CCODE,	SROM4_CCODE, 0xffff},
+	{"ccode",	0x000000e0,	SRFL_CCODE,	SROM5_CCODE, 0xffff},
+	{"ccode",	0xffffff00,	SRFL_CCODE,	SROM8_CCODE, 0xffff},
+	{"macaddr",	0xffffff00,	SRFL_ETHADDR,	SROM8_MACHI, 0xffff},
+	{"macaddr",	0x000000e0,	SRFL_ETHADDR,	SROM5_MACHI, 0xffff},
+	{"macaddr",	0x00000010,	SRFL_ETHADDR,	SROM4_MACHI, 0xffff},
+	{"macaddr",	0x00000008,	SRFL_ETHADDR,	SROM3_MACHI, 0xffff},
+	{"il0macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_IL0, 0xffff},
+	{"et1macaddr",	0x00000007,	SRFL_ETHADDR,	SROM_MACHI_ET1, 0xffff},
+	{"leddc",	0xffffff00,	SRFL_NOFFS|SRFL_LEDDC,	SROM8_LEDDC, 0xffff},
+	{"leddc",	0x000000e0,	SRFL_NOFFS|SRFL_LEDDC,	SROM5_LEDDC, 0xffff},
+	{"leddc",	0x00000010,	SRFL_NOFFS|SRFL_LEDDC,	SROM4_LEDDC, 0xffff},
+	{"leddc",	0x00000008,	SRFL_NOFFS|SRFL_LEDDC,	SROM3_LEDDC, 0xffff},
+	{NULL,		0,		0,		0, 0}
+};
+
+static const sromvar_t perpath_pci_sromvars[] = {
+	{"maxp2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP, 0xff},
+	{"itt2ga",	0x000000f0,	0,		SROM4_2G_ITT_MAXP, 0xff00},
+	{"itt5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA, 0xffff},
+	{"pa2gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 1, 0xffff},
+	{"pa2gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 2, 0xffff},
+	{"pa2gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_2G_PA + 3, 0xffff},
+	{"maxp5ga",	0x000000f0,	0,		SROM4_5G_ITT_MAXP, 0xff},
+	{"maxp5gha",	0x000000f0,	0,		SROM4_5GLH_MAXP, 0xff},
+	{"maxp5gla",	0x000000f0,	0,		SROM4_5GLH_MAXP, 0xff00},
+	{"pa5gw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA, 0xffff},
+	{"pa5gw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 1, 0xffff},
+	{"pa5gw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 2, 0xffff},
+	{"pa5gw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5G_PA + 3, 0xffff},
+	{"pa5glw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA, 0xffff},
+	{"pa5glw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 1, 0xffff},
+	{"pa5glw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 2, 0xffff},
+	{"pa5glw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GL_PA + 3, 0xffff},
+	{"pa5ghw0a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA, 0xffff},
+	{"pa5ghw1a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 2, 0xffff},
+	{"pa5ghw3a",	0x000000f0,	SRFL_PRHEX,	SROM4_5GH_PA + 3, 0xffff},
+	{"maxp2ga",	0xffffff00,	0,		SROM8_2G_ITT_MAXP, 0xff},
+	{"itt2ga",	0xffffff00,	0,		SROM8_2G_ITT_MAXP, 0xff00},
+	{"itt5ga",	0xffffff00,	0,		SROM8_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA, 0xffff},
+	{"pa2gw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA + 1, 0xffff},
+	{"pa2gw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_2G_PA + 2, 0xffff},
+	{"maxp5ga",	0xffffff00,	0,		SROM8_5G_ITT_MAXP, 0xff},
+	{"maxp5gha",	0xffffff00,	0,		SROM8_5GLH_MAXP, 0xff},
+	{"maxp5gla",	0xffffff00,	0,		SROM8_5GLH_MAXP, 0xff00},
+	{"pa5gw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA, 0xffff},
+	{"pa5gw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA + 1, 0xffff},
+	{"pa5gw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5G_PA + 2, 0xffff},
+	{"pa5glw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA, 0xffff},
+	{"pa5glw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA + 1, 0xffff},
+	{"pa5glw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GL_PA + 2, 0xffff},
+	{"pa5ghw0a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA, 0xffff},
+	{"pa5ghw1a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a",	0xffffff00,	SRFL_PRHEX,	SROM8_5GH_PA + 2, 0xffff},
+	{NULL,		0,		0,		0, 0}
+};
+
+/* Parse SROM and create name=value pairs. 'srom' points to
+ * the SROM word array. 'off' specifies the offset of the
+ * first word 'srom' points to, which should be either 0 or
+ * SROM3_SWRG_OFF (full SROM or software region).
+ */
 
+static uint
+mask_shift(uint16 mask)
+{
+	uint i;
+	for (i = 0; i < (sizeof(mask) << 3); i ++) {
+		if (mask & (1 << i))
+			return i;
 	}
+	ASSERT(mask);
+	return 0;
+}
 
-	/* parameter section of sprom starts at byte offset 72 */
-	woff = 72/2;
+static uint
+mask_width(uint16 mask)
+{
+	int i;
+	for (i = (sizeof(mask) << 3) - 1; i >= 0; i --) {
+		if (mask & (1 << i))
+			return (uint)(i - mask_shift(mask) + 1);
+	}
+	ASSERT(mask);
+	return 0;
+}
 
-	/* first 6 bytes are il0macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "il0macaddr=%s", eabuf);
-	vp++;
-
-	/* next 6 bytes are et0macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "et0macaddr=%s", eabuf);
-	vp++;
-
-	/* next 6 bytes are et1macaddr */
-	ea.octet[0] = (b[woff] >> 8) & 0xff;
-	ea.octet[1] = b[woff] & 0xff;
-	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
-	ea.octet[3] = b[woff+1] & 0xff;
-	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
-	ea.octet[5] = b[woff+2] & 0xff;
-	woff += ETHER_ADDR_LEN/2 ;
-	bcm_ether_ntoa((uchar*)&ea, eabuf);
-	vp += sprintf(vp, "et1macaddr=%s", eabuf);
-	vp++;
+#ifdef BCMDBG_ASSERT
+static bool
+mask_valid(uint16 mask)
+{
+	uint shift = mask_shift(mask);
+	uint width = mask_width(mask);
+	return mask == ((~0 << shift) & ~(~0 << (shift + width)));
+}
+#endif
 
-	/*
-	 * Enet phy settings one or two singles or a dual
-	 * Bits 4-0 : MII address for enet0 (0x1f for not there)
-	 * Bits 9-5 : MII address for enet1 (0x1f for not there)
-	 * Bit 14   : Mdio for enet0
-	 * Bit 15   : Mdio for enet1
-	 */
-	w = b[woff];
-	vp += sprintf(vp, "et0phyaddr=%d", (w & 0x1f));
-	vp++;
-	vp += sprintf(vp, "et1phyaddr=%d", ((w >> 5) & 0x1f));
-	vp++;
-	vp += sprintf(vp, "et0mdcport=%d", ((w >> 14) & 0x1));
-	vp++;
-	vp += sprintf(vp, "et1mdcport=%d", ((w >> 15) & 0x1));
-	vp++;
-
-	/* Word 46 has board rev, antennas 0/1 & Country code/control */
-	w = b[46];
-	vp += sprintf(vp, "boardrev=%d", w & 0xff);
-	vp++;
+static void
+_initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off, varbuf_t *b)
+{
+	uint16 w;
+	uint32 val;
+	const sromvar_t *srv;
+	uint width;
+	uint flags;
+	uint32 sr = (1 << sromrev);
+
+	varbuf_append(b, "sromrev=%d", sromrev);
+
+	for (srv = pci_sromvars; srv->name != NULL; srv ++) {
+		const char *name;
+
+		if ((srv->revmask & sr) == 0)
+			continue;
+
+		if (srv->off < off)
+			continue;
+
+		flags = srv->flags;
+		name = srv->name;
+
+		if (flags & SRFL_ETHADDR) {
+			char eabuf[ETHER_ADDR_STR_LEN];
+			struct ether_addr ea;
+
+			ea.octet[0] = (srom[srv->off - off] >> 8) & 0xff;
+			ea.octet[1] = srom[srv->off - off] & 0xff;
+			ea.octet[2] = (srom[srv->off + 1 - off] >> 8) & 0xff;
+			ea.octet[3] = srom[srv->off + 1 - off] & 0xff;
+			ea.octet[4] = (srom[srv->off + 2 - off] >> 8) & 0xff;
+			ea.octet[5] = srom[srv->off + 2 - off] & 0xff;
+			bcm_ether_ntoa(&ea, eabuf);
+
+			varbuf_append(b, "%s=%s", name, eabuf);
+		}
+		else {
+			ASSERT(mask_valid(srv->mask));
+			ASSERT(mask_width(srv->mask));
+
+			w = srom[srv->off - off];
+			val = (w & srv->mask) >> mask_shift(srv->mask);
+			width = mask_width(srv->mask);
+
+			while (srv->flags & SRFL_MORE) {
+				srv ++;
+				ASSERT(srv->name);
 
-	if (sromrev > 1)
-		vp += sprintf(vp, "cctl=%d", (w >> 8) & 0xf);
+				if (srv->off == 0 || srv->off < off)
+					continue;
+
+				ASSERT(mask_valid(srv->mask));
+				ASSERT(mask_width(srv->mask));
+
+				w = srom[srv->off - off];
+				val += ((w & srv->mask) >> mask_shift(srv->mask)) << width;
+				width += mask_width(srv->mask);
+			}
+
+			if ((flags & SRFL_NOFFS) && ((int)val == (1 << width) - 1))
+				continue;
+
+			if (flags & SRFL_CCODE) {
+				if (val == 0)
+					varbuf_append(b, "ccode=");
 	else
-		vp += sprintf(vp, "cc=%d", (w >> 8) & 0xf);
-	vp++;
+					varbuf_append(b, "ccode=%c%c", (val >> 8), (val & 0xff));
+			}
+			/* LED Powersave duty cycle has to be scaled:
+			 *(oncount >> 24) (offcount >> 8)
+			 */
+			else if (flags & SRFL_LEDDC) {
+				uint32 w32 = (((val >> 8) & 0xff) << 24) | /* oncount */
+					     (((val & 0xff)) << 8); /* offcount */
+				varbuf_append(b, "leddc=%d", w32);
+			}
+			else if (flags & SRFL_PRHEX)
+				varbuf_append(b, "%s=0x%x", name, val);
+			else if ((flags & SRFL_PRSIGN) && (val & (1 << (width - 1))))
+				varbuf_append(b, "%s=%d", name, (int)(val | (~0 << width)));
+			else
+				varbuf_append(b, "%s=%u", name, val);
+		}
+	}
 
-	vp += sprintf(vp, "aa0=%d", (w >> 12) & 0x3);
-	vp++;
+	if (sromrev >= 4) {
+		/* Do per-path variables */
+		uint p, pb, psz;
+
+		if (sromrev >= 8) {
+			pb = SROM8_PATH0;
+			psz = SROM8_PATH1 - SROM8_PATH0;
+		} else {
+			pb = SROM4_PATH0;
+			psz = SROM4_PATH1 - SROM4_PATH0;
+		}
 
-	vp += sprintf(vp, "aa1=%d", (w >> 14) & 0x3);
-	vp++;
+		for (p = 0; p < MAX_PATH; p++) {
+			for (srv = perpath_pci_sromvars; srv->name != NULL; srv ++) {
+				if ((srv->revmask & sr) == 0)
+					continue;
 
-	/* Words 47-49 set the (wl) pa settings */
-	woff = 47;
-
-	for (i = 0; i < 3; i++) {
-		vp += sprintf(vp, "pa0b%d=%d", i, b[woff+i]);
-		vp++;
-		vp += sprintf(vp, "pa1b%d=%d", i, b[woff+i+6]);
-		vp++;
+				if (pb + srv->off < off)
+					continue;
+
+				w = srom[pb + srv->off - off];
+				ASSERT(mask_valid(srv->mask));
+				val = (w & srv->mask) >> mask_shift(srv->mask);
+				width = mask_width(srv->mask);
+
+				/* Cheating: no per-path var is more than 1 word */
+
+				if ((srv->flags & SRFL_NOFFS) && ((int)val == (1 << width) - 1))
+					continue;
+
+				if (srv->flags & SRFL_PRHEX)
+					varbuf_append(b, "%s%d=0x%x", srv->name, p, val);
+				else
+					varbuf_append(b, "%s%d=%d", srv->name, p, val);
+			}
+			pb += psz;
 	}
+	}
+}
+
+static int
+initvars_srom_pci(sb_t *sbh, void *curmap, char **vars, uint *count)
+{
+	uint16 *srom;
+	uint8 sromrev = 0;
+	uint32 sr;
+	varbuf_t b;
+	char *vp, *base = NULL;
+	osl_t *osh = sb_osh(sbh);
+	bool flash = FALSE;
+	char *value;
+	int err;
 
 	/*
-	 * Words 50-51 set the customer-configured wl led behavior.
-	 * 8 bits/gpio pin.  High bit:  activehi=0, activelo=1;
-	 * LED behavior values defined in wlioctl.h .
-	 */
-	w = b[50];
-	if ((w != 0) && (w != 0xffff)) {
-		/* gpio0 */
-		vp += sprintf(vp, "wl0gpio0=%d", (w & 0xff));
-		vp++;
-
-		/* gpio1 */
-		vp += sprintf(vp, "wl0gpio1=%d", (w >> 8) & 0xff);
-		vp++;
-	}
-	w = b[51];
-	if ((w != 0) && (w != 0xffff)) {
-		/* gpio2 */
-		vp += sprintf(vp, "wl0gpio2=%d", w & 0xff);
-		vp++;
-
-		/* gpio3 */
-		vp += sprintf(vp, "wl0gpio3=%d", (w >> 8) & 0xff);
-		vp++;
-	}
-	
-	/* Word 52 is max power 0/1 */
-	w = b[52];
-	vp += sprintf(vp, "pa0maxpwr=%d", w & 0xff);
-	vp++;
-	vp += sprintf(vp, "pa1maxpwr=%d", (w >> 8) & 0xff);
-	vp++;
-
-	/* Word 56 is idle tssi target 0/1 */
-	w = b[56];
-	vp += sprintf(vp, "pa0itssit=%d", w & 0xff);
-	vp++;
-	vp += sprintf(vp, "pa1itssit=%d", (w >> 8) & 0xff);
-	vp++;
-
-	/* Word 57 is boardflags, if not programmed make it zero */
-	bfl = (uint32)b[57];
-	if (bfl == 0xffff) bfl = 0;
-	if (sromrev > 1) {
-		/* Word 28 is boardflags2 */
-		bfl |= (uint32)b[28] << 16;
-	}
-	vp += sprintf(vp, "boardflags=%d", bfl);
-	vp++;
-
-	/* Word 58 is antenna gain 0/1 */
-	w = b[58];
-	vp += sprintf(vp, "ag0=%d", w & 0xff);
-	vp++;
-
-	vp += sprintf(vp, "ag1=%d", (w >> 8) & 0xff);
-	vp++;
-
-	if (sromrev == 1) {
-		/* set the oem string */
-		vp += sprintf(vp, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
-			      ((b[59] >> 8) & 0xff), (b[59] & 0xff),
-			      ((b[60] >> 8) & 0xff), (b[60] & 0xff),
-			      ((b[61] >> 8) & 0xff), (b[61] & 0xff),
-			      ((b[62] >> 8) & 0xff), (b[62] & 0xff));
-		vp++;
+	 * Apply CRC over SROM content regardless SROM is present or not,
+	 * and use variable <devpath>sromrev's existance in flash to decide
+	 * if we should return an error when CRC fails or read SROM variables
+	 * from flash.
+	 */
+	srom = MALLOC(osh, SROM_MAX);
+	ASSERT(srom);
+	if (!srom)
+		return -2;
+
+	err = sprom_read_pci(osh, (void *)((int8 *)curmap + PCI_BAR0_SPROM_OFFSET), 0, srom,
+	                     SROM_WORDS, TRUE);
+
+	if ((srom[SROM4_SIGN] == SROM4_SIGNATURE) ||
+	    ((sbh->buscoretype == SB_PCIE) && (sbh->buscorerev >= 6))) {
+		/* sromrev >= 4, read more */
+		err = sprom_read_pci(osh, (void *)((int8 *)curmap + PCI_BAR0_SPROM_OFFSET), 0,
+		                     srom, SROM4_WORDS, TRUE);
+		sromrev = srom[SROM4_CRCREV] & 0xff;
+	} else if (err == 0) {
+		/* srom is good and is rev < 4 */
+		/* top word of sprom contains version and crc8 */
+		sromrev = srom[SROM_CRCREV] & 0xff;
+		/* bcm4401 sroms misprogrammed */
+		if (sromrev == 0x10)
+			sromrev = 1;
+	}
+
+	if (err) {
+#ifdef WLTEST
+		uint32 val;
+
+		BS_ERROR(("SROM Crc Error, so see if we could use a default\n"));
+		val = OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32));
+		if (val & SPROM_OTPIN_USE) {
+			BS_ERROR(("srom crc failed with OTP, use default vars....\n"));
+			vp = base = mfgsromvars;
+			if (sb_chip(sbh) == BCM4311_CHIP_ID) {
+				const char *devid = "devid=0x4311";
+				const size_t devid_strlen = strlen(devid);
+				BS_ERROR(("setting the devid to be 4311\n"));
+				bcopy(devid, vp, devid_strlen + 1);
+				vp += devid_strlen + 1;
+			}
+			bcopy(defaultsromvars, vp, MFGSROM_DEFVARSLEN);
+			vp += MFGSROM_DEFVARSLEN;
+			goto varsdone;
 	} else {
-		/* Word 60 OFDM tx power offset from CCK level */
-		/* OFDM Power Offset - opo */
-		vp += sprintf(vp, "opo=%d", b[60] & 0xff);
-		vp++;
+#endif /* WLTEST */
+			BS_ERROR(("srom crc failed with SPROM....\n"));
+			if (!(value = sb_getdevpathvar(sbh, "sromrev"))) {
+				err = -1;
+				goto errout;
+			}
+			sromrev = (uint8)bcm_strtoul(value, NULL, 0);
+			flash = TRUE;
+#ifdef WLTEST
+		}
+#endif /* WLTEST */
 	}
 
-	/* final nullbyte terminator */
-	*vp++ = '\0';
+	/* Bitmask for the sromrev */
+	sr = 1 << sromrev;
 
-	c = (int)(vp - base);
-	ASSERT((vp - base) <= VARS_MAX);
+	/* srom version check
+	 * Current valid versions: 1, 2, 3, 4, 5, 8
+	 */
+	if ((sr & 0x13e) == 0) {
+		err = -2;
+		goto errout;
+	}
 
-	if (c == VARS_MAX) {
-		*vars = base;
-	} else {
-		vp = MALLOC(osh, c);
+	ASSERT(vars);
+	ASSERT(count);
+
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
 		ASSERT(vp);
-		bcopy(base, vp, c);
-		MFREE(osh, base, VARS_MAX);
-		*vars = vp;
+	if (!vp) {
+		err = -2;
+		goto errout;
 	}
-	*count = c;
 
-	return (0);
+	/* read variables from flash */
+	if (flash) {
+		if ((err = initvars_flash(sbh, osh, &vp, MAXSZ_NVRAM_VARS)))
+			goto errout;
+		goto varsdone;
+	}
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+
+	/* parse SROM into name=value pairs. */
+	_initvars_srom_pci(sromrev, srom, 0, &b);
+
+	/* final nullbyte terminator */
+	ASSERT(b.size >= 1);
+	vp = b.buf;
+	*vp++ = '\0';
+
+	ASSERT((vp - base) <= MAXSZ_NVRAM_VARS);
+
+varsdone:
+	err = initvars_table(osh, base, vp, vars, count);
+
+errout:
+#ifdef WLTEST
+	if (base && (base != mfgsromvars))
+#else
+	if (base)
+#endif
+		MFREE(osh, base, MAXSZ_NVRAM_VARS);
+
+	MFREE(osh, srom, SROM_MAX);
+	return err;
 }
 
 /*
@@ -684,7 +1781,7 @@
  * Return 0 on success, nonzero on error.
  */
 static int
-initvars_cis_pcmcia(void *sbh, void *curmap, void *osh, char **vars, int *count)
+initvars_cis_pcmcia(sb_t *sbh, osl_t *osh, char **vars, uint *count)
 {
 	uint8 *cis = NULL;
 	int rc;
@@ -696,19 +1793,187 @@
 		return (-2);
 
 	if (sb_pcmciarev(sbh) == 1) {
-		if (srom_read(PCMCIA_BUS, (void *)NULL, osh, 0, data_sz, (uint16 *)cis)) {
+		if (srom_read(sbh, PCMCIA_BUS, (void *)NULL, osh, 0, data_sz, (uint16 *)cis)) {
 			MFREE(osh, cis, data_sz);
 			return (-1);
 		}
 		/* fix up endianess for 16-bit data vs 8-bit parsing */
-		ltoh16_buf((uint16 *)cis, data_sz);
+		htol16_buf((uint16 *)cis, data_sz);
 	} else
 		OSL_PCMCIA_READ_ATTR(osh, 0, cis, data_sz);
 
-	rc = srom_parsecis(osh, cis, vars, count);
+	rc = srom_parsecis(osh, &cis, 1, vars, count);
 
 	MFREE(osh, cis, data_sz);
 
 	return (rc);
 }
 
+
+static int
+BCMINITFN(initvars_srom_sb)(sb_t *sbh, osl_t *osh, void *curmap, char **vars, uint *varsz)
+{
+#if defined(CONFIG_BCMSDIODEV)
+	/* CIS is read and supplied by the host */
+	return BCME_OK;
+#elif defined(CONFIG_BCMUSBDEV)
+	static bool srvars = FALSE;	/* Use OTP/SPROM as global variables */
+
+	int sel = 0;	/* where to read the srom. 0 - nowhere, 1 - otp, 2 - sprom */
+	uint sz = 0;	/* srom size in bytes */
+	void *oh = NULL;
+	int rc = BCME_OK;
+
+	/* Bail out if we've dealt with OTP/SPROM before! */
+	if (srvars)
+		return 0;
+
+#if defined(CONFIG_BCM4328)
+	if (sbh->chip == BCM4328_CHIP_ID) {
+		/* Access the SPROM if it is present */
+		if ((sz = srom_size(sbh, osh)) != 0) {
+			sz <<= 1;
+			sel = 2;
+		}
+	}
+#endif
+#if defined(CONFIG_BCM4325)
+	if (sbh->chip == BCM4325_CHIP_ID) {
+		uint32 cst = sbh->chipst & CST4325_SPROM_OTP_SEL_MASK;
+
+		/* Access OTP if it is present, powered on, and programmed */
+		if ((oh = otp_init(sbh)) != NULL && (otp_status(oh) & OTPS_GUP_SW)) {
+			sz = otp_size(oh);
+			sel = 1;
+		}
+		/* Access the SPROM if it is present and allow to be accessed */
+		else if ((cst == CST4325_OTP_PWRDN || cst == CST4325_SPROM_SEL) &&
+		         (sz = srom_size(sbh, osh)) != 0) {
+			sz <<= 1;
+			sel = 2;
+		}
+	}
+#endif	/* BCM4325 */
+
+	/* Read CIS in OTP/SPROM */
+	if (sel != 0) {
+		uint16 *srom;
+		uint8 *body = NULL;
+
+		ASSERT(sz);
+
+		/* Allocate memory */
+		if ((srom = (uint16 *)MALLOC(osh, sz)) == NULL)
+			return BCME_NOMEM;
+
+		/* Read CIS */
+		switch (sel) {
+		case 1:
+			rc = otp_read_region(oh, OTP_SW_RGN, srom, sz);
+			body = (uint8 *)srom;
+			break;
+		case 2:
+			rc = srom_read(sbh, SB_BUS, curmap, osh, 0, sz, srom);
+			/* sprom has 8 byte h/w header */
+			body = (uint8 *)srom + SBSDIO_SPROM_CIS_OFFSET;
+			break;
+		default:
+			/* impossible to come here */
+			ASSERT(0);
+			break;
+		}
+
+		/* Parse CIS */
+		if (rc == BCME_OK) {
+			uint i, tpls = 0xffffffff;
+			/* # sdiod fns + common + extra */
+			uint8 *cis[SBSDIO_NUM_FUNCTION + 2];
+			uint ciss = 0;
+
+			/* each word is in host endian */
+			htol16_buf((uint8 *)srom, sz);
+
+			ASSERT(body);
+
+			/* count cis tuple chains */
+			for (i = 0; i < sz && ciss < ARRAYSIZE(cis) && tpls != 0; i ++) {
+				cis[ciss++] = &body[i];
+				for (tpls = 0; i < sz - 1; tpls ++) {
+					if (body[i++] == CISTPL_END)
+						break;
+					i += body[i] + 1;
+				}
+			}
+
+			/* call parser routine only when there are tuple chains */
+			if (ciss > 1)
+				rc = srom_parsecis(osh, cis, ciss, vars, varsz);
+		}
+
+		/* Clean up */
+		MFREE(osh, srom, sz);
+
+		/* Make SROM variables global */
+		if (rc == BCME_OK) {
+			rc = nvram_append((void *)sbh, *vars, *varsz);
+			srvars = TRUE;
+
+			/* Tell the caller there is no individual SROM variables */
+			*vars = NULL;
+			*varsz = 0;
+		}
+	}
+
+	return rc;
+#else	/* !BCMUSBDEV && !BCMSDIODEV */
+	/* Search flash nvram section for srom variables */
+	return initvars_flash_sb(sbh, vars, varsz);
+#endif	/* !BCMUSBDEV && !BCMSDIODEV */
+}
+
+#ifdef BCMUSBDEV
+/* Return sprom size in 16-bit words */
+static uint
+srom_size(sb_t *sbh, osl_t *osh)
+{
+	uint size = 0;
+	if (SPROMBUS == PCMCIA_BUS) {
+		uint32 origidx;
+		sdpcmd_regs_t *pcmregs;
+		bool wasup;
+
+		origidx = sb_coreidx(sbh);
+		pcmregs = sb_setcore(sbh, SB_PCMCIA, 0);
+		ASSERT(pcmregs);
+
+		if (!(wasup = sb_iscoreup(sbh)))
+			sb_core_reset(sbh, 0, 0);
+
+		/* not worry about earlier core revs */
+		if (sb_corerev(sbh) < 8)
+			goto done;
+
+		/* SPROM is accessible only in PCMCIA mode unless there is SDIO clock */
+		if (!(R_REG(osh, &pcmregs->corestatus) & CS_PCMCIAMODE))
+			goto done;
+
+		switch (SB_PCMCIA_READ(osh, pcmregs, SROM_INFO) & SRI_SZ_MASK) {
+		case 1:
+			size = 256;	/* SROM_INFO == 1 means 4kbit */
+			break;
+		case 2:
+			size = 1024;	/* SROM_INFO == 2 means 16kbit */
+			break;
+		default:
+			break;
+		}
+
+	done:
+		if (!wasup)
+			sb_core_disable(sbh, 0);
+
+		sb_setcoreidx(sbh, origidx);
+	}
+	return size;
+}
+#endif /* def BCMUSBDEV */
--- src/shared.1927/bcmstdlib.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmstdlib.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,16 +10,85 @@
  * $Id$
  */
 
+/*
+ * bcmstdlib.c file should be used only to construct an OSL or alone without any OSL
+ * It should not be used with any orbitarary OSL's as there could be a conflict
+ * with some of the routines defined here.
+*/
+
 #include <typedefs.h>
-#include <stdarg.h>
+#if defined(NDIS) || defined(_MINOSL_) || defined(__vxworks) || \
+	defined(PCBIOS) || defined(LINUXSIM) || defined(EFI)
+/* debatable */
 #include <osl.h>
+#elif !defined(__IOPOS__)
+#include <stdio.h>
+#endif 
+
+/*
+ * Define BCMSTDLIB_WIN32_APP if this is a Win32 Application compile
+ */
+#if defined(_WIN32) && !defined(NDIS) && !defined(EFI)
+#define BCMSTDLIB_WIN32_APP 1
+#endif /* _WIN32 && !NDIS */
+
+/*
+ * Define BCMSTDLIB_SNPRINTF_ONLY if we only want snprintf & vsnprintf implementations
+ */
+#if (defined(_WIN32) && !defined(EFI)) || defined(__vxworks) || defined(_CFE_)
+#define BCMSTDLIB_SNPRINTF_ONLY 1
+#endif 
+
+#include <stdarg.h>
+#include <bcmstdlib.h>
+#ifndef BCMSTDLIB_WIN32_APP
 #include <bcmutils.h>
+#endif
+
+#ifdef BCMSTDLIB_WIN32_APP
+
+/* for a WIN32 application, use _vsnprintf as basis of vsnprintf/snprintf to 
+ * support full set of format specifications.
+ */
+
+int
+vsnprintf(char *buf, size_t bufsize, const char *fmt, va_list ap)
+{
+	int r;
+
+	r = _vsnprintf(buf, bufsize, fmt, ap);
+
+	/* Microsoft _vsnprintf() will not null terminate on overflow,
+	 * so null terminate at buffer end on error
+	 */
+	if (r < 0 && bufsize > 0)
+		buf[bufsize - 1] = '\0';
+
+	return r;
+}
+
+int
+snprintf(char *buf, size_t bufsize, const char *fmt, ...)
+{
+	va_list	ap;
+	int	r;
+
+	va_start(ap, fmt);
+	r = vsnprintf(buf, bufsize, fmt, ap);
+	va_end(ap);
+
+	return r;
+}
+
+#else /* BCMSTDLIB_WIN32_APP */
+
+#ifndef	BCMROMOFFLOAD
 
 static const char digits[17] = "0123456789ABCDEF";
 static const char ldigits[17] = "0123456789abcdef";
 
 static int
-__atox(char *buf, unsigned int num, unsigned int radix, int width,
+__atox(char *buf, char * end, unsigned int num, unsigned int radix, int width,
        const char *digits)
 {
 	char buffer[16];
@@ -49,20 +115,19 @@
 
 	while (op != buffer) {
 		op--;
-		*buf++ = *op;
+		if (buf <= end)
+			*buf = *op;
+		buf++;
 	}
 
 	return retval;
 }
 
-#define isdigit(x) (((x) >= '0') && ((x) <= '9'))
-
-extern int vsprintf(char *buf, const char *fmt, va_list ap);
-
 int
-vsprintf(char *buf, const char *fmt, va_list ap)
+BCMROMFN(vsnprintf)(char *buf, size_t size, const char *fmt, va_list ap)
 {
 	char *optr;
+	char *end;
 	const char *iptr;
 	unsigned char *tmpptr;
 	unsigned int x;
@@ -75,11 +140,20 @@
 	int hashash = 0;
 
 	optr = buf;
+	end = buf + size - 1;
 	iptr = fmt;
 
+	if (end < buf - 1) {
+		end = ((void *) -1);
+		size = end - buf + 1;
+	}
+
 	while (*iptr) {
 		if (*iptr != '%') {
-			*optr++ = *iptr++;
+			if (optr <= end)
+				*optr = *iptr;
+			++optr;
+			++iptr;
 			continue;
 		}
 
@@ -101,19 +175,19 @@
 			leadingzero = 0;
 
 		width = 0;
-		while (*iptr && isdigit(*iptr)) {
+		while (*iptr && bcm_isdigit(*iptr)) {
 			width += (*iptr - '0');
 			iptr++;
-			if (isdigit(*iptr))
+			if (bcm_isdigit(*iptr))
 				width *= 10;
 		}
 		if (*iptr == '.') {
 			iptr++;
 			width2 = 0;
-			while (*iptr && isdigit(*iptr)) {
+			while (*iptr && bcm_isdigit(*iptr)) {
 				width2 += (*iptr - '0');
 				iptr++;
-				if (isdigit(*iptr)) width2 *= 10;
+				if (bcm_isdigit(*iptr)) width2 *= 10;
 			}
 		}
 
@@ -128,121 +202,147 @@
 			tmpptr = (unsigned char *) va_arg(ap, unsigned char *);
 			if (!tmpptr) tmpptr = (unsigned char *) "(null)";
 			if ((width == 0) & (width2 == 0)) {
-				while (*tmpptr) *optr++ = *tmpptr++;
+				while (*tmpptr) {
+					if (optr <= end)
+						*optr = *tmpptr;
+					++optr;
+					++tmpptr;
+				}
 				break;
 			}
 			while (width && *tmpptr) {
-				*optr++ = *tmpptr++;
+				if (optr <= end)
+					*optr = *tmpptr;
+				++optr;
+				++tmpptr;
 				width--;
 			}
 			while (width) {
-				*optr++ = ' ';
+				if (optr <= end)
+					*optr = ' ';
+				++optr;
 				width--;
 			}
 			break;
 		case 'd':
+		case 'i':
 			i = va_arg(ap, int);
-			if (i < 0) { *optr++='-'; i = -i;}
-			optr += __atox(optr, i, 10, width, digits);
+			if (i < 0) {
+				if (optr <= end)
+					*optr = '-';
+				++optr;
+				i = -i;
+			}
+			optr += __atox(optr, end, i, 10, width, digits);
 			break;
 		case 'u':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 10, width, digits);
+			optr += __atox(optr, end, x, 10, width, digits);
 			break;
 		case 'X':
 		case 'x':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 16, width,
+			optr += __atox(optr, end, x, 16, width,
 				       (*iptr == 'X') ? digits : ldigits);
 			break;
 		case 'p':
 		case 'P':
 			x = va_arg(ap, unsigned int);
-			optr += __atox(optr, x, 16, 8,
+			optr += __atox(optr, end, x, 16, 8,
 				       (*iptr == 'P') ? digits : ldigits);
 			break;
 		case 'c':
 			x = va_arg(ap, int);
-			*optr++ = x & 0xff;
+			if (optr <= end)
+				*optr = x & 0xff;
+			optr++;
 			break;
 
 		default:
-			*optr++ = *iptr;
+			if (optr <= end)
+				*optr = *iptr;
+			optr++;
 			break;
 		}
 		iptr++;
 	}
 
+	if (optr <= end) {
 	*optr = '\0';
-
-	return (optr - buf);
+		return (int)(optr - buf);
+	} else {
+		*end = '\0';
+		return (int)(end - buf);
+	}
 }
 
+
 int
-sprintf(char *buf, const char *fmt, ...)
+BCMROMFN(snprintf)(char *buf, size_t bufsize, const char *fmt, ...)
 {
 	va_list ap;
-	int count;
+	int			r;
 
 	va_start(ap, fmt);
-	count = vsprintf(buf, fmt, ap);
+	r = vsnprintf(buf, bufsize, fmt, ap);
 	va_end(ap);
 
-	return count;
+	return r;
 }
+#endif	/* !BCMROMOFFLOAD */
+
+#endif /* BCMSTDLIB_WIN32_APP */
+
+#ifndef BCMSTDLIB_SNPRINTF_ONLY
+
+#ifndef	BCMROMOFFLOAD
 
 int
-printf(const char *fmt, ...)
+BCMROMFN(vsprintf)(char *buf, const char *fmt, va_list ap)
+{
+	return (vsnprintf(buf, INT_MAX, fmt, ap));
+}
+
+
+int
+BCMROMFN(sprintf)(char *buf, const char *fmt, ...)
 {
 	va_list ap;
-	int count, i;
-	char buffer[512];
+	int count;
 
 	va_start(ap, fmt);
-	count = vsprintf(buffer, fmt, ap);
+	count = vsprintf(buf, fmt, ap);
 	va_end(ap);
 
-	for (i = 0; i < count; i++) {
-		putc(buffer[i]);
-	}
-
 	return count;
 }
 
-void *
-memset(void *dest, int c, uint n)
-{
-	unsigned char *d;
-
-	d = (unsigned char *)dest;
-
-	while (n) {
-		*d++ = (unsigned char) c;
-		n--;
-	}
-
-	return d;
-}
 
 void *
-memcpy(void *dest, const void *src, uint n)
+BCMROMFN(memmove)(void *dest, const void *src, size_t n)
 {
 	unsigned char *d;
 	const unsigned char *s;
 
-	d = (unsigned char *)dest;
-	s = (const unsigned char *)src;
+	/* only use memmove if dest is after source, otherwise use memcopy */
+	if (src < dest)
+		return memcpy(dest, src, n);
+
+	/* do what memcpy does, but starting at the end and work backwords */
+	d = (unsigned char *)dest + (n-1);
+	s = (const unsigned char *)src + (n-1);
 
 	while (n) {
-		*d++ = *s++;
+		*d-- = *s--;
 		n--;
 	}
 
 	return dest;
 }
 
+#ifndef EFI
 int
-memcmp(const void *s1, const void *s2, uint n)
+BCMROMFN(memcmp)(const void *s1, const void *s2, size_t n)
 {
 	const unsigned char *ss1;
 	const unsigned char *ss2;
@@ -263,37 +363,41 @@
 	return 0;
 }
 
+/* Skip over functions that are being used from DriverLibrary to save space */
 char *
-strcpy(char *dest, const char *src)
+BCMROMFN(strcpy)(char *dest, const char *src)
 {
 	char *ptr = dest;
 
-	while (*src)
-		*ptr++ = *src++;
-	*ptr = '\0';
+	while ((*ptr++ = *src++) != '\0')
+		;
 
 	return dest;
 }
 
 char *
-strncpy(char *dest, const char *src, uint n)
+BCMROMFN(strncpy)(char *dest, const char *src, size_t n)
 {
-	char *ptr = dest;
+	char *endp;
+	char *p;
 
-	while (*src && (n > 0)) {
-		*ptr++ = *src++;
-		n--;
-	}
-	if (n > 0)
-		*ptr = '\0';
+	p = dest;
+	endp = p + n;
+
+	while (p != endp && (*p++ = *src++) != '\0')
+		;
+
+	/* zero fill remainder */
+	while (p != endp)
+		*p++ = '\0';
 
 	return dest;
 }
 
-uint
-strlen(const char *s)
+size_t
+BCMROMFN(strlen)(const char *s)
 {
-	uint n = 0;
+	size_t n = 0;
 
 	while (*s) {
 		s++;
@@ -304,7 +408,7 @@
 }
 
 int
-strcmp(const char *s1, const char *s2)
+BCMROMFN(strcmp)(const char *s1, const char *s2)
 {
 	while (*s2 && *s1) {
 		if (*s1 < *s2)
@@ -321,9 +425,10 @@
 		return -1;
 	return 0;
 }
+#endif /* EFI */
 
 int
-strncmp(const char *s1, const char *s2, uint n)
+BCMROMFN(strncmp)(const char *s1, const char *s2, size_t n)
 {
 	while (*s2 && *s1 && n) {
 		if (*s1 < *s2)
@@ -345,7 +450,7 @@
 }
 
 char *
-strchr(const char *str,int c)
+BCMROMFN(strchr)(const char *str, int c)
 {
 	char *x = (char *)str; 
 
@@ -357,7 +462,7 @@
 }
 
 char * 
-strrchr(const char *str,int c)
+BCMROMFN(strrchr)(const char *str, int c)
 {
     char *save = NULL;
 
@@ -369,14 +474,265 @@
     return (save);
 }
 
+/* Skip over functions that are being used from DriverLibrary to save space */
+#ifndef EFI
 char *
-strcat(char *d, const char *s)
+BCMROMFN(strcat)(char *d, const char *s)
 {
-	char *x, *ss = (char *)s;
+	strcpy(&d[strlen(d)], s);
+	return (d);
+}
+#endif /* EFI */
 
-	x = &d[strlen(d)];
-	while ((*x++ = *ss++))
-		;
+char *
+BCMROMFN(index)(const char *s, int c)
+{
+	/* Terminating NUL is considered part of string */
 
-	return (d);
+	for (; *s != c; s++)
+		if (!*s)
+			return NULL;
+
+	return (char *)s;
+}
+
+/* Skip over functions that are being used from DriverLibrary to save space */
+#ifndef EFI
+char *
+BCMROMFN(strstr)(const char *s, const char *substr)
+{
+	int substr_len = strlen(substr);
+
+	for (; *s; s++)
+		if (strncmp(s, substr, substr_len) == 0)
+			return (char *)s;
+
+	return NULL;
+}
+#endif /* EFI */
+
+size_t
+BCMROMFN(strspn)(const char *s, const char *accept)
+{
+	uint count = 0;
+
+	while (s[count] && index(accept, s[count]))
+		count++;
+
+	return count;
+}
+
+size_t
+BCMROMFN(strcspn)(const char *s, const char *reject)
+{
+	uint count = 0;
+
+	while (s[count] && !index(reject, s[count]))
+		count++;
+
+	return count;
+}
+
+void *
+BCMROMFN(memchr)(const void *s, int c, size_t n)
+{
+	if (n != 0) {
+		const unsigned char *ptr = s;
+
+		do {
+			if (*ptr == (unsigned char)c)
+				return (void *)ptr;
+			ptr++;
+			n--;
+		} while (n != 0);
+	}
+	return NULL;
+}
+
+unsigned long
+BCMROMFN(strtoul)(const char *cp, char **endp, int base)
+{
+	ulong result, value;
+	bool minus;
+
+	minus = FALSE;
+
+	while (bcm_isspace(*cp))
+		cp++;
+
+	if (cp[0] == '+')
+		cp++;
+	else if (cp[0] == '-') {
+		minus = TRUE;
+		cp++;
+	}
+
+	if (base == 0) {
+		if (cp[0] == '0') {
+			if ((cp[1] == 'x') || (cp[1] == 'X')) {
+				base = 16;
+				cp = &cp[2];
+			} else {
+				base = 8;
+				cp = &cp[1];
+			}
+		} else
+			base = 10;
+	} else if (base == 16 && (cp[0] == '0') && ((cp[1] == 'x') || (cp[1] == 'X'))) {
+		cp = &cp[2];
+	}
+
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value = bcm_isdigit(*cp) ? *cp - '0' : bcm_toupper(*cp) - 'A' + 10) <
+	       (ulong) base) {
+		result = result * base + value;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong)(result * -1);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+#endif	/* !BCMROMOFFLOAD */
+
+#ifndef EFI
+/* memset is not in ROM offload because it is used directly by the compiler in
+ * structure assignments/character array initialization with "".
+ */
+void *
+memset(void *dest, int c, size_t n)
+{
+	uint32 w, *dw;
+	unsigned char *d;
+
+
+	dw = (uint32 *)dest;
+
+	/* 8 min because we have to create w */
+	if ((n >= 8) && (((uint)dest & 3) == 0)) {
+		if (c == 0)
+			w = 0;
+		else {
+			unsigned char ch;
+
+			ch = (unsigned char)(c & 0xff);
+			w = (ch << 8) | ch;
+			w |= w << 16;
+		}
+		while (n >= 4) {
+			*dw++ = w;
+			n -= 4;
+		}
+	}
+	d = (unsigned char *)dw;
+
+	while (n) {
+		*d++ = (unsigned char)c;
+		n--;
+	}
+
+	return d;
+}
+
+/* memcpy is not in ROM offload because it is used directly by the compiler in
+ * structure assignments.
+ */
+void *
+memcpy(void *dest, const void *src, size_t n)
+{
+	uint32 *dw;
+	const uint32 *sw;
+	unsigned char *d;
+	const unsigned char *s;
+
+	sw = (const uint32 *)src;
+	dw = (uint32 *)dest;
+	if ((n >= 4) && (((uint)src & 3) == 0) && (((uint)dest & 3) == 0)) {
+		while (n >= 4) {
+			*dw++ = *sw++;
+			n -= 4;
+		}
+	}
+	d = (unsigned char *)dw;
+	s = (const unsigned char *)sw;
+	while (n) {
+		*d++ = *s++;
+		n--;
+	}
+
+	return dest;
+}
+#endif /* EFI */
+
+/* Include printf if it has already not been defined as NULL */
+#ifndef printf
+int
+printf(const char *fmt, ...)
+{
+	va_list ap;
+	int count, i;
+	char buffer[PRINTF_BUFLEN + 1];
+
+	va_start(ap, fmt);
+	count = vsnprintf(buffer, sizeof(buffer), fmt, ap);
+	va_end(ap);
+
+	for (i = 0; i < count; i++) {
+		putc(buffer[i]);
+
+#ifdef EFI
+		if (buffer[i] == '\n')
+			putc('\r');
+#endif
+	}
+
+	return count;
+}
+#endif /* printf */
+
+int
+fputs(const char *s, FILE *stream /* UNUSED */)
+{
+	char c;
+	while ((c = *s++))
+		putchar(c);
+	return 0;
+}
+
+int
+puts(const char *s)
+{
+	fputs(s, stdout);
+	putchar('\n');
+	return 0;
+}
+
+int
+fputc(int c, FILE *stream /* UNUSED */)
+{
+	putc(c);
+	return (int)(unsigned char)c;
+}
+
+
+unsigned long
+rand(void)
+{
+	static unsigned long seed = 1;
+	long x, hi, lo, t;
+
+	x = seed;
+	hi = x / 127773;
+	lo = x % 127773;
+	t = 16807 * lo - 2836 * hi;
+	if (t <= 0) t += 0x7fffffff;
+	seed = t;
+	return t;
 }
+#endif /* BCMSTDLIB_SNPRINTF_ONLY */
--- src/shared.1927/bcmutils.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bcmutils.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,21 +12,42 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
+#include <stdarg.h>
+#include <bcmutils.h>
 #ifdef BCMDRIVER
 #include <osl.h>
+#include <sbutils.h>
 #include <bcmnvram.h>
 #else
 #include <stdio.h>
 #include <string.h>
+#endif /* BCMDRIVER */
+#if defined(_WIN32) || defined(NDIS) || defined(__vxworks) || \
+	defined(_CFE_) || defined(EFI)
+/* debatable */
+#include <bcmstdlib.h>
 #endif
-#include <bcmutils.h>
 #include <bcmendian.h>
 #include <bcmdevs.h>
+#include <proto/ethernet.h>
+#include <proto/vlan.h>
+#include <proto/bcmip.h>
+#include <proto/bcmtcp.h>
+#include <proto/802.1d.h>
+
+#ifdef BCMPERFSTATS
+#include <bcmperf.h>
+#endif
 
 #ifdef BCMDRIVER
+/* nvram vars cache */
+static char *nvram_vars = NULL;
+static int vars_len = -1;
+
 /* copy a pkt buffer chain into a buffer */
 uint
-pktcopy(void *drv, void *p, uint offset, int len, uchar *buf)
+pktcopy(osl_t *osh, void *p, uint offset, int len, uchar *buf)
 {
 	uint n, ret = 0;
 
@@ -34,19 +55,19 @@
 		len = 4096;	/* "infinite" */
 
 	/* skip 'offset' bytes */
-	for (; p && offset; p = PKTNEXT(drv, p)) {
-		if (offset < (uint)PKTLEN(drv, p))
+	for (; p && offset; p = PKTNEXT(osh, p)) {
+		if (offset < (uint)PKTLEN(osh, p))
 			break;
-		offset -= PKTLEN(drv, p);
+		offset -= PKTLEN(osh, p);
 	}
 
 	if (!p)
 		return 0;
 
 	/* copy the data */
-	for (; p && len; p = PKTNEXT(drv, p)) {
-		n = MIN((uint)PKTLEN(drv, p) - offset, (uint)len);
-		bcopy(PKTDATA(drv, p) + offset, buf, n);
+	for (; p && len; p = PKTNEXT(osh, p)) {
+		n = MIN((uint)PKTLEN(osh, p) - offset, (uint)len);
+		bcopy(PKTDATA(osh, p) + offset, buf, n);
 		buf += n;
 		len -= n;
 		ret += n;
@@ -58,215 +79,439 @@
 
 /* return total length of buffer chain */
 uint
-pkttotlen(void *drv, void *p)
+pkttotlen(osl_t *osh, void *p)
 {
 	uint total;
 
 	total = 0;
-	for (; p; p = PKTNEXT(drv, p))
-		total += PKTLEN(drv, p);
+	for (; p; p = PKTNEXT(osh, p))
+		total += PKTLEN(osh, p);
 	return (total);
 }
 
-void
-pktq_init(struct pktq *q, uint maxlen, const bool prio_map[])
+/* return the last buffer of chained pkt */
+void *
+pktlast(osl_t *osh, void *p)
 {
-	q->head = q->tail = NULL;
-	q->maxlen = maxlen;
-	q->len = 0;
-	if (prio_map) {
-		q->priority = TRUE;
-		bcopy(prio_map, q->prio_map, sizeof(q->prio_map));
-	}
-	else
-		q->priority = FALSE;
+	for (; PKTNEXT(osh, p); p = PKTNEXT(osh, p))
+		;
+
+	return (p);
 }
 
-/* should always check pktq_full before calling pktenq */
-void
-pktenq(struct pktq *q, void *p, bool lifo)
+
+/*
+ * osl multiple-precedence packet queue
+ * hi_prec is always >= the number of the highest non-empty precedence
+ */
+void *
+pktq_penq(struct pktq *pq, int prec, void *p)
 {
-	void *next, *prev;
+	struct pktq_prec *q;
 
-	/* allow 10 pkts slack */
-	ASSERT(q->len < (q->maxlen + 10));
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);         /* queueing chains not allowed */
 
-	/* Queueing chains not allowed */
-	ASSERT(PKTLINK(p) == NULL);
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
 
-	/* Queue is empty */
-	if (q->tail == NULL) {
-		ASSERT(q->head == NULL);
-		q->head = q->tail = p;
-	}
+	q = &pq->q[prec];
 
-	/* Insert at head or tail */
-	else if (q->priority == FALSE) {
-		/* Insert at head (LIFO) */
-		if (lifo) {
-			PKTSETLINK(p, q->head);
-			q->head = p;
-		}
-		/* Insert at tail (FIFO) */
-		else {
-			ASSERT(PKTLINK(q->tail) == NULL);
+	if (q->head)
 			PKTSETLINK(q->tail, p);
-			PKTSETLINK(p, NULL);
+	else
+		q->head = p;
+
 			q->tail = p;
-		}
-	}
+	q->len++;
 
-	/* Insert by priority */
-	else {
-		/* legal priorities 0-7 */
-		ASSERT(PKTPRIO(p) <= MAXPRIO);
-
-		ASSERT(q->head);
-		ASSERT(q->tail);
-		/* Shortcut to insertion at tail */
-		if (_pktq_pri(q, PKTPRIO(p)) < _pktq_pri(q, PKTPRIO(q->tail)) ||
-		    (!lifo && _pktq_pri(q, PKTPRIO(p)) <= _pktq_pri(q, PKTPRIO(q->tail)))) {
-			prev = q->tail;
-			next = NULL;
-		}
-		/* Insert at head or in the middle */
-		else {
-			prev = NULL;
-			next = q->head;
-		}
-		/* Walk the queue */
-		for (; next; prev = next, next = PKTLINK(next)) {
-			/* Priority queue invariant */
-			ASSERT(!prev || _pktq_pri(q, PKTPRIO(prev)) >= _pktq_pri(q, PKTPRIO(next)));
-			/* Insert at head of string of packets of same priority (LIFO) */
-			if (lifo) {
-				if (_pktq_pri(q, PKTPRIO(p)) >= _pktq_pri(q, PKTPRIO(next)))
-					break;
-			}
-			/* Insert at tail of string of packets of same priority (FIFO) */
-			else {
-				if (_pktq_pri(q, PKTPRIO(p)) > _pktq_pri(q, PKTPRIO(next)))
-					break;
-			}
-		}
-		/* Insert at tail */
-		if (next == NULL) {
-			ASSERT(PKTLINK(q->tail) == NULL);
-			PKTSETLINK(q->tail, p);
-			PKTSETLINK(p, NULL);
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8)prec;
+
+	return p;
+}
+
+void *
+pktq_penq_head(struct pktq *pq, int prec, void *p)
+{
+	struct pktq_prec *q;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);         /* queueing chains not allowed */
+
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
+
+	q = &pq->q[prec];
+
+	if (q->head == NULL)
 			q->tail = p;
-		}
-		/* Insert in the middle */
-		else if (prev) {
-			PKTSETLINK(prev, p);
-			PKTSETLINK(p, next);
-		}
-		/* Insert at head */
-		else {
+
 			PKTSETLINK(p, q->head);
 			q->head = p;
-		}
-	}
+	q->len++;
 
-	/* List invariants after insertion */
-	ASSERT(q->head);
-	ASSERT(PKTLINK(q->tail) == NULL);
+	pq->len++;
 
-	q->len++;
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8)prec;
+
+	return p;
+}
+
+void *
+pktq_pdeq(struct pktq *pq, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
 }
 
-/* dequeue packet at head */
-void*
-pktdeq(struct pktq *q)
+void *
+pktq_pdeq_tail(struct pktq *pq, int prec)
 {
+	struct pktq_prec *q;
+	void *p, *prev;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
+		PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
+	q->tail = prev;
+	q->len--;
+
+	pq->len--;
+
+	return p;
+}
+
+void
+pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir)
+{
+	struct pktq_prec *q;
 	void *p;
 
-	if ((p = q->head)) {
-		ASSERT(q->tail);
+	q = &pq->q[prec];
+	p = q->head;
+	while (p) {
 		q->head = PKTLINK(p);
 		PKTSETLINK(p, NULL);
+		PKTFREE(osh, p, dir);
 		q->len--;
-		if (q->head == NULL)
-			q->tail = NULL;
+		pq->len--;
+		p = q->head;
 	}
-	else {
-		ASSERT(q->tail == NULL);
+	ASSERT(q->len == 0);
+	q->tail = NULL;
+}
+
+bool
+pktq_pdel(struct pktq *pq, void *pktbuf, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	if (!pktbuf)
+		return FALSE;
+
+	q = &pq->q[prec];
+
+	if (q->head == pktbuf) {
+		if ((q->head = PKTLINK(pktbuf)) == NULL)
+			q->tail = NULL;
+	} else {
+		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p))
+			;
+		if (p == NULL)
+			return FALSE;
+
+		PKTSETLINK(p, PKTLINK(pktbuf));
+		if (q->tail == pktbuf)
+			q->tail = p;
 	}
 
-	return (p);
+	q->len--;
+	pq->len--;
+	PKTSETLINK(pktbuf, NULL);
+	return TRUE;
+}
+
+void
+pktq_init(struct pktq *pq, int num_prec, int max_len)
+{
+	int prec;
+
+	ASSERT(num_prec > 0 && num_prec <= PKTQ_MAX_PREC);
+
+	/* pq is variable size; only zero out what's requested */
+	bzero(pq, OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+
+	pq->num_prec = (uint16)num_prec;
+
+	pq->max = (uint16)max_len;
+
+	for (prec = 0; prec < num_prec; prec++)
+		pq->q[prec].max = pq->max;
 }
 
-/* dequeue packet at tail */
-void*
-pktdeqtail(struct pktq *q)
+int
+pktq_setmax(struct pktq *pq, int max_len)
 {
+	int prec;
+
+	if (!max_len)
+		return pq->max;
+
+	pq->max = (uint16)max_len;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pq->q[prec].max = pq->max;
+
+	return pq->max;
+}
+
+void *
+pktq_deq(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
 	void *p;
-	void *next, *prev;
+	int prec;
 
-	if (q->head == q->tail) {  /* last packet on queue or queue empty */
-		p = q->head;
-		q->head = q->tail = NULL;
-		q->len = 0;
-		return(p);
-	}
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
 
-	/* start walk at head */
-	prev = NULL;
-	next = q->head;
-
-	/* Walk the queue to find prev of q->tail */
-	for (; next; prev = next, next = PKTLINK(next)) {
-		if (next == q->tail)
+	q->len--;
+
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *
+pktq_deq_tail(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p, *prev;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
 			break;
-	}
 
-	ASSERT(prev);
+	q = &pq->q[prec];
 
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
 	PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
 	q->tail = prev;
 	q->len--;
-	p = next;
 
-	return (p);
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *
+pktq_peek(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].head);
+}
+
+void *
+pktq_peek_tail(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
+			break;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].tail);
 }
 
-unsigned char bcm_ctype[] = {
+void
+pktq_flush(osl_t *osh, struct pktq *pq, bool dir)
+{
+	int prec;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pktq_pflush(osh, pq, prec, dir);
+	ASSERT(pq->len == 0);
+}
+
+/* Return sum of lengths of a specific set of precedences */
+int
+pktq_mlen(struct pktq *pq, uint prec_bmp)
+{
+	int prec, len;
+
+	len = 0;
+
+	for (prec = 0; prec <= pq->hi_prec; prec++)
+		if (prec_bmp & (1 << prec))
+			len += pq->q[prec].len;
+
+	return len;
+}
+
+/* Priority dequeue from a specific set of precedences */
+void *
+pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	while ((prec_bmp & (1 << prec)) == 0 || pq->q[prec].head == NULL)
+		if (prec-- == 0)
+			return NULL;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+#endif /* BCMDRIVER */
+
+#ifndef	BCMROMOFFLOAD
+
+const unsigned char bcm_ctype[] = {
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 0-7 */
-	_BCM_C,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C,_BCM_C,		/* 8-15 */
+	_BCM_C, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C|_BCM_S, _BCM_C,
+	_BCM_C,	/* 8-15 */
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 16-23 */
 	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 24-31 */
 	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 32-39 */
 	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 40-47 */
 	_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,			/* 48-55 */
 	_BCM_D,_BCM_D,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 56-63 */
-	_BCM_P,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U,	/* 64-71 */
+	_BCM_P, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X, _BCM_U|_BCM_X,
+	_BCM_U|_BCM_X, _BCM_U, /* 64-71 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 72-79 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 80-87 */
 	_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 88-95 */
-	_BCM_P,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L,	/* 96-103 */
+	_BCM_P, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X, _BCM_L|_BCM_X,
+	_BCM_L|_BCM_X, _BCM_L, /* 96-103 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 104-111 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 112-119 */
 	_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_C,			/* 120-127 */
-	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
-	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
-	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,   /* 160-175 */
-	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,       /* 176-191 */
-	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,       /* 192-207 */
-	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_L,       /* 208-223 */
-	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,       /* 224-239 */
-	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L        /* 240-255 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 128-143 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 144-159 */
+	_BCM_S|_BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 160-175 */
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 176-191 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 192-207 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_U, _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_L,	/* 208-223 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 224-239 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_L, _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L /* 240-255 */
 };
 
-uchar
-bcm_toupper(uchar c)
-{
-	if (bcm_islower(c))
-		c -= 'a'-'A';
-	return (c);
-}
-
 ulong
-bcm_strtoul(char *cp, char **endp, uint base)
+BCMROMFN(bcm_strtoul)(char *cp, char **endp, uint base)
 {
 	ulong result, value;
 	bool minus;
@@ -298,196 +543,721 @@
 		cp = &cp[2];
 	}
 		   
-	result = 0;
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong)(result * -1);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+
+int
+BCMROMFN(bcm_atoi)(char *s)
+{
+	return (int)bcm_strtoul(s, NULL, 10);
+}
+
+/* return pointer to location of substring 'needle' in 'haystack' */
+char*
+BCMROMFN(bcmstrstr)(char *haystack, char *needle)
+{
+	int len, nlen;
+	int i;
+
+	if ((haystack == NULL) || (needle == NULL))
+		return (haystack);
+
+	nlen = strlen(needle);
+	len = strlen(haystack) - nlen + 1;
+
+	for (i = 0; i < len; i++)
+		if (memcmp(needle, &haystack[i], nlen) == 0)
+			return (&haystack[i]);
+	return (NULL);
+}
+
+char*
+BCMROMFN(bcmstrcat)(char *dest, const char *src)
+{
+	strcpy(&dest[strlen(dest)], src);
+	return (dest);
+}
+
+char*
+BCMROMFN(bcmstrncat)(char *dest, const char *src, uint size)
+{
+	char *endp;
+	char *p;
+
+	p = dest + strlen(dest);
+	endp = p + size;
+
+	while (p != endp && (*p++ = *src++) != '\0')
+		;
+
+	return (dest);
+}
+
+/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
+int
+BCMROMFN(bcm_ether_atoe)(char *p, struct ether_addr *ea)
+{
+	int i = 0;
+
+	for (;;) {
+		ea->octet[i++] = (char) bcm_strtoul(p, &p, 16);
+		if (!*p++ || i == 6)
+			break;
+	}
+
+	return (i == 6);
+}
+#endif	/* !BCMROMOFFLOAD */
+
+#if defined(CONFIG_USBRNDIS_RETAIL) || defined(NDIS_MINIPORT_DRIVER)
+/* registry routine buffer preparation utility functions:
+ * parameter order is like strncpy, but returns count
+ * of bytes copied. Minimum bytes copied is null char(1)/wchar(2)
+ */
+ulong
+wchar2ascii(
+	char *abuf,
+	ushort *wbuf,
+	ushort wbuflen,
+	ulong abuflen
+)
+{
+	ulong copyct = 1;
+	ushort i;
+
+	if (abuflen == 0)
+		return 0;
+
+	/* wbuflen is in bytes */
+	wbuflen /= sizeof(ushort);
+
+	for (i = 0; i < wbuflen; ++i) {
+		if (--abuflen == 0)
+			break;
+		*abuf++ = (char) *wbuf++;
+		++copyct;
+	}
+	*abuf = '\0';
+
+	return copyct;
+}
+#endif /* CONFIG_USBRNDIS_RETAIL || NDIS_MINIPORT_DRIVER */
+
+char *
+bcm_ether_ntoa(struct ether_addr *ea, char *buf)
+{
+	snprintf(buf, 18, "%02x:%02x:%02x:%02x:%02x:%02x",
+		ea->octet[0]&0xff, ea->octet[1]&0xff, ea->octet[2]&0xff,
+		ea->octet[3]&0xff, ea->octet[4]&0xff, ea->octet[5]&0xff);
+	return (buf);
+}
+
+char *
+bcm_ip_ntoa(struct ipv4_addr *ia, char *buf)
+{
+	snprintf(buf, 16, "%d.%d.%d.%d",
+	         ia->addr[0], ia->addr[1], ia->addr[2], ia->addr[3]);
+	return (buf);
+}
+
+#ifdef BCMDRIVER
+
+void
+bcm_mdelay(uint ms)
+{
+	uint i;
+
+	for (i = 0; i < ms; i++) {
+		OSL_DELAY(1000);
+	}
+}
+
+/*
+ * Search the name=value vars for a specific one and return its value.
+ * Returns NULL if not found.
+ */
+char *
+getvar(char *vars, const char *name)
+{
+#ifdef	_MINOSL_
+	return NULL;
+#else
+	char *s;
+	int len;
+
+	if (!name)
+		return NULL;
+
+	len = strlen(name);
+	if (len == 0)
+		return NULL;
+
+	/* first look in vars[] */
+	for (s = vars; s && *s;) {
+		/* CSTYLED */
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len+1]);
+
+		while (*s++)
+			;
+	}
+
+	/* then query nvram */
+	return (nvram_get(name));
+#endif	/* _MINOSL_ */
+}
+
+/*
+ * Search the vars for a specific one and return its value as
+ * an integer. Returns 0 if not found.
+ */
+int
+getintvar(char *vars, const char *name)
+{
+#ifdef	_MINOSL_
+	return 0;
+#else
+	char *val;
+
+	if ((val = getvar(vars, name)) == NULL)
+		return (0);
+
+	return (bcm_strtoul(val, NULL, 0));
+#endif	/* _MINOSL_ */
+}
+
+
+/* Search for token in comma separated token-string */
+static int
+findmatch(char *string, char *name)
+{
+	uint len;
+	char *c;
+
+	len = strlen(name);
+	/* CSTYLED */
+	while ((c = strchr(string, ',')) != NULL) {
+		if (len == (uint)(c - string) && !strncmp(string, name, len))
+			return 1;
+		string = c + 1;
+	}
+
+	return (!strcmp(string, name));
+}
+
+/* Return gpio pin number assigned to the named pin
+ *
+ * Variable should be in format:
+ *
+ *	gpio<N>=pin_name,pin_name
+ *
+ * This format allows multiple features to share the gpio with mutual
+ * understanding.
+ *
+ * 'def_pin' is returned if a specific gpio is not defined for the requested functionality
+ * and if def_pin is not used by others.
+ */
+uint
+getgpiopin(char *vars, char *pin_name, uint def_pin)
+{
+	char name[] = "gpioXXXX";
+	char *val;
+	uint pin;
+
+	/* Go thru all possibilities till a match in pin name */
+	for (pin = 0; pin < GPIO_NUMPINS; pin ++) {
+		snprintf(name, sizeof(name), "gpio%d", pin);
+		val = getvar(vars, name);
+		if (val && findmatch(val, pin_name))
+			return pin;
+	}
+
+	if (def_pin != GPIO_PIN_NOTDEFINED) {
+		/* make sure the default pin is not used by someone else */
+		snprintf(name, sizeof(name), "gpio%d", def_pin);
+		if (getvar(vars, name)) {
+			def_pin =  GPIO_PIN_NOTDEFINED;
+		}
+	}
+
+	return def_pin;
+}
+
+#ifdef BCMPERFSTATS
+
+#define	LOGSIZE	256			/* should be power of 2 to avoid div below */
+static struct {
+	uint	cycles;
+	char	*fmt;
+	uint	a1;
+	uint	a2;
+} logtab[LOGSIZE];
+
+/* last entry logged  */
+static uint logi = 0;
+/* next entry to read */
+static uint readi = 0;
+
+void
+bcm_perf_enable()
+{
+	BCMPERF_ENABLE_INSTRCOUNT();
+	BCMPERF_ENABLE_ICACHE_MISS();
+	BCMPERF_ENABLE_ICACHE_HIT();
+}
+
+void
+bcmlog(char *fmt, uint a1, uint a2)
+{
+	static uint last = 0;
+	uint cycles, i;
+	OSL_GETCYCLES(cycles);
+
+	i = logi;
+
+	logtab[i].cycles = cycles - last;
+	logtab[i].fmt = fmt;
+	logtab[i].a1 = a1;
+	logtab[i].a2 = a2;
+
+	logi = (i + 1) % LOGSIZE;
+	last = cycles;
+}
+
+
+void
+bcmstats(char *fmt)
+{
+	static uint last = 0;
+	static uint32 ic_miss = 0;
+	static uint32 instr_count = 0;
+	uint32 ic_miss_cur;
+	uint32 instr_count_cur;
+	uint cycles, i;
+
+	OSL_GETCYCLES(cycles);
+	BCMPERF_GETICACHE_MISS(ic_miss_cur);
+	BCMPERF_GETINSTRCOUNT(instr_count_cur);
+
+	i = logi;
+
+	logtab[i].cycles = cycles - last;
+	logtab[i].a1 = ic_miss_cur - ic_miss;
+	logtab[i].a2 = instr_count_cur - instr_count;
+	logtab[i].fmt = fmt;
+
+	logi = (i + 1) % LOGSIZE;
+
+	last = cycles;
+	instr_count = instr_count_cur;
+	ic_miss = ic_miss_cur;
+}
+
+
+void
+bcmdumplog(char *buf, int size)
+{
+	char *limit, *line;
+	int j = 0;
+	int num;
+
+	limit = buf + size - 80;
+	*buf = '\0';
+
+	num = logi - readi;
+
+	if (num < 0)
+		num += LOGSIZE;
+
+	/* print in chronological order */
+
+	for (j = 0; j < num && (buf < limit); readi = (readi + 1) % LOGSIZE, j++) {
+		if (logtab[readi].fmt == NULL)
+		    continue;
+		line = buf;
+		buf += sprintf(buf, "%d\t", logtab[readi].cycles);
+		buf += sprintf(buf, logtab[readi].fmt, logtab[readi].a1, logtab[readi].a2);
+		buf += sprintf(buf, "\n");
+	}
+
+}
+
+
+/*
+ * Dump one log entry at a time.
+ * Return index of next entry or -1 when no more .
+ */
+int
+bcmdumplogent(char *buf, uint i)
+{
+	bool hit;
+
+	/*
+	 * If buf is NULL, return the starting index,
+	 * interpreting i as the indicator of last 'i' entries to dump.
+	 */
+	if (buf == NULL) {
+		i = ((i > 0) && (i < (LOGSIZE - 1))) ? i : (LOGSIZE - 1);
+		return ((logi - i) % LOGSIZE);
+	}
+
+	*buf = '\0';
+
+	ASSERT(i < LOGSIZE);
+
+	if (i == logi)
+		return (-1);
+
+	hit = FALSE;
+	for (; (i != logi) && !hit; i = (i + 1) % LOGSIZE) {
+		if (logtab[i].fmt == NULL)
+			continue;
+		buf += sprintf(buf, "%d: %d\t", i, logtab[i].cycles);
+		buf += sprintf(buf, logtab[i].fmt, logtab[i].a1, logtab[i].a2);
+		buf += sprintf(buf, "\n");
+		hit = TRUE;
+	}
+
+	return (i);
+}
+
+#endif	/* BCMPERFSTATS */
+
+
+/* Takes an Ethernet frame and sets out-of-bound PKTPRIO.
+ * Also updates the inplace vlan tag if requested.
+ * For debugging, it returns an indication of what it did.
+ */
+uint
+pktsetprio(void *pkt, bool update_vtag)
+{
+	struct ether_header *eh;
+	struct ethervlan_header *evh;
+	uint8 *pktdata;
+	int priority = 0;
+	int rc = 0;
+
+	pktdata = (uint8 *) PKTDATA(NULL, pkt);
+	ASSERT(ISALIGNED((uintptr)pktdata, sizeof(uint16)));
+
+	eh = (struct ether_header *) pktdata;
+
+	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
+		uint16 vlan_tag;
+		int vlan_prio, dscp_prio = 0;
+
+		evh = (struct ethervlan_header *)eh;
+
+		vlan_tag = ntoh16(evh->vlan_tag);
+		vlan_prio = (int) (vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
 
-	while (bcm_isxdigit(*cp) &&
-	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
-		result = result*base + value;
-		cp++;
+		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
+			uint8 *ip_body = pktdata + sizeof(struct ethervlan_header);
+			uint8 tos_tc = IP_TOS(ip_body);
+			dscp_prio = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
 	}
 
-	if (minus)
-		result = (ulong)(result * -1);
-
-	if (endp)
-		*endp = (char *)cp;
+		/* DSCP priority gets precedence over 802.1P (vlan tag) */
+		if (dscp_prio != 0) {
+			priority = dscp_prio;
+			rc |= PKTPRIO_VDSCP;
+		} else {
+			priority = vlan_prio;
+			rc |= PKTPRIO_VLAN;
+		}
+		/* 
+		 * If the DSCP priority is not the same as the VLAN priority,
+		 * then overwrite the priority field in the vlan tag, with the
+		 * DSCP priority value. This is required for Linux APs because
+		 * the VLAN driver on Linux, overwrites the skb->priority field
+		 * with the priority value in the vlan tag
+		 */
+		if (update_vtag && (priority != vlan_prio)) {
+			vlan_tag &= ~(VLAN_PRI_MASK << VLAN_PRI_SHIFT);
+			vlan_tag |= (uint16)priority << VLAN_PRI_SHIFT;
+			evh->vlan_tag = hton16(vlan_tag);
+			rc |= PKTPRIO_UPD;
+		}
+	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
+		uint8 *ip_body = pktdata + sizeof(struct ether_header);
+		uint8 tos_tc = IP_TOS(ip_body);
+		priority = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
+		rc |= PKTPRIO_DSCP;
+	}
 
-	return (result);
+	ASSERT(priority >= 0 && priority <= MAXPRIO);
+	PKTSETPRIO(pkt, priority);
+	return (rc | priority);
 }
 
-uint
-bcm_atoi(char *s)
+static char bcm_undeferrstr[BCME_STRLEN];
+
+static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;
+
+/* Convert the error codes into related error strings  */
+const char *
+bcmerrorstr(int bcmerror)
 {
-	uint n;
+	/* check if someone added a bcmerror code but forgot to add errorstring */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
+
+	if (bcmerror > 0 || bcmerror < BCME_LAST) {
+		snprintf(bcm_undeferrstr, BCME_STRLEN, "Undefined error %d", bcmerror);
+		return bcm_undeferrstr;
+	}
 
-	n = 0;
+	ASSERT(strlen(bcmerrorstrtable[-bcmerror]) < BCME_STRLEN);
 
-	while (bcm_isdigit(*s))
-		n = (n * 10) + *s++ - '0';
-	return (n);
+	return bcmerrorstrtable[-bcmerror];
 }
 
-/* return pointer to location of substring 'needle' in 'haystack' */
-char*
-bcmstrstr(char *haystack, char *needle)
+static void
+BCMINITFN(bcm_nvram_refresh)(char *flash)
 {
-	int len, nlen;
 	int i;
+	int ret = 0;
 
-	if ((haystack == NULL) || (needle == NULL))
-		return (haystack);
+	ASSERT(flash);
 
-	nlen = strlen(needle);
-	len = strlen(haystack) - nlen + 1;
+	/* default "empty" vars cache */
+	bzero(flash, 2);
 
-	for (i = 0; i < len; i++)
-		if (bcmp(needle, &haystack[i], nlen) == 0)
-			return (&haystack[i]);
-	return (NULL);
+	if ((ret = nvram_getall(flash, NVRAM_SPACE)))
+		return;
+
+	/* determine nvram length */
+	for (i = 0; i < NVRAM_SPACE; i++) {
+		if (flash[i] == '\0' && flash[i+1] == '\0')
+			break;
+	}
+
+	if (i > 1)
+		vars_len = i + 2;
+	else
+		vars_len = 0;
 }
 
-char*
-bcmstrcat(char *dest, const char *src)
+char *
+bcm_nvram_vars(uint *length)
 {
-	strcpy(&dest[strlen(dest)], src);
-	return (dest);
+#ifndef BCMNVRAMR
+	/* cache may be stale if nvram is read/write */
+	if (nvram_vars) {
+		ASSERT(!bcmreclaimed);
+		bcm_nvram_refresh(nvram_vars);
+	}
+#endif
+	if (length)
+		*length = vars_len;
+	return nvram_vars;
 }
 
-#if defined(CONFIG_USBRNDIS_RETAIL) || defined(NDIS_MINIPORT_DRIVER)
-/* registry routine buffer preparation utility functions:
- * parameter order is like strncpy, but returns count
- * of bytes copied. Minimum bytes copied is null char(1)/wchar(2)
- */
-ulong
-wchar2ascii(
-	char *abuf,
-	ushort *wbuf,
-	ushort wbuflen,
-	ulong abuflen
-)
+/* copy nvram vars into locally-allocated multi-string array */
+int
+BCMINITFN(bcm_nvram_cache)(void *sbh)
 {
-	ulong copyct = 1;
-	ushort i;
-
-	if (abuflen == 0)
+	void *osh;
+	int ret = 0;
+	char *flash = NULL;
+
+	if (vars_len >= 0) {
+#ifndef BCMNVRAMR
+		bcm_nvram_refresh(nvram_vars);
+#endif
 		return 0;
+	}
 
-	/* wbuflen is in bytes */
-	wbuflen /= sizeof(ushort);
+	osh = sb_osh((sb_t *)sbh);
 
-	for (i = 0; i < wbuflen; ++i) {
-		if (--abuflen == 0)
-			break;
-		*abuf++ = (char) *wbuf++;
-		++copyct;
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE))) {
+		ret = BCME_NOMEM;
+		goto exit;
 	}
-	*abuf = '\0';
 
-	return copyct;
-}
-#endif
+	bcm_nvram_refresh(flash);
 
-char*
-bcm_ether_ntoa(char *ea, char *buf)
-{
-	sprintf(buf,"%02x:%02x:%02x:%02x:%02x:%02x",
-		(uchar)ea[0]&0xff, (uchar)ea[1]&0xff, (uchar)ea[2]&0xff,
-		(uchar)ea[3]&0xff, (uchar)ea[4]&0xff, (uchar)ea[5]&0xff);
-	return (buf);
+#ifdef BCMNVRAMR
+	if (vars_len > 3) {
+		/* copy into a properly-sized buffer */
+		if (!(nvram_vars = MALLOC(osh, vars_len))) {
+			ret = BCME_NOMEM;
+		} else
+			bcopy(flash, nvram_vars, vars_len);
+	}
+	MFREE(osh, flash, NVRAM_SPACE);
+#else
+	/* cache must be full size of nvram if read/write */
+	nvram_vars = flash;
+#endif	/* BCMNVRAMR */
+
+exit:
+	return ret;
 }
 
-/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
-int
-bcm_ether_atoe(char *p, char *ea)
+#ifdef BCMDBG_PKT       /* pkt logging for debugging */
+/* Add a packet to the pktlist */
+void
+pktlist_add(pktlist_info_t *pktlist, void *pkt)
 {
-	int i = 0;
+	uint i;
+	ASSERT(pktlist->count < PKTLIST_SIZE);
 
-	for (;;) {
-		ea[i++] = (char) bcm_strtoul(p, &p, 16);
-		if (!*p++ || i == 6)
-			break;
+	/* Verify the packet is not already part of the list */
+	for (i = 0; i < pktlist->count; i++) {
+		if (pktlist->list[i] == pkt)
+			ASSERT(0);
 	}
-
-	return (i == 6);
+	pktlist->list[pktlist->count] = pkt;
+	pktlist->count++;
+	return;
 }
 
+/* Remove a packet from the pktlist */
 void
-bcm_mdelay(uint ms)
+pktlist_remove(pktlist_info_t *pktlist, void *pkt)
 {
 	uint i;
+	uint num = pktlist->count;
 
-	for (i = 0; i < ms; i++) {
-		OSL_DELAY(1000);
+	/* find the index where pkt exists */
+	for (i = 0; i < num; i++)
+	{
+		/* check for the existence of pkt in the list */
+		if (pktlist->list[i] == pkt)
+		{
+			/* replace with the last element */
+			pktlist->list[i] = pktlist->list[num-1];
+			pktlist->count--;
+			return;
+		}
 	}
+	ASSERT(0);
 }
 
-/*
- * Search the name=value vars for a specific one and return its value.
- * Returns NULL if not found.
+/* Dump the pktlist (and the contents of each packet if 'data'
+ * is set). 'buf' should be large enough
  */
-char*
-getvar(char *vars, char *name)
+
+char *
+pktlist_dump(pktlist_info_t *pktlist, char *buf)
 {
-	char *s;
-	int len;
+	char *obuf;
+	uint i;
 
-	len = strlen(name);
+	obuf = buf;
 
-	/* first look in vars[] */
-	for (s = vars; s && *s; ) {
-		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len+1]);
+	buf += sprintf(buf, "Packet list dump:\n");
 
-		while (*s++)
-			;
+	for (i = 0; i < (pktlist->count); i++) {
+		buf += sprintf(buf, "0x%p\t", pktlist->list[i]);
+
+#ifdef NOTDEF     /* Remove this ifdef to print pkttag and pktdata */
+		if (PKTTAG(pktlist->list[i])) {
+			/* Print pkttag */
+			buf += sprintf(buf, "Pkttag(in hex): ");
+			buf += bcm_format_hex(buf, PKTTAG(pktlist->list[i]), OSL_PKTTAG_SZ);
 	}
+		buf += sprintf(buf, "Pktdata(in hex): ");
+		buf += bcm_format_hex(buf, PKTDATA(NULL, pktlist->list[i]),
+			PKTLEN(NULL, pktlist->list[i]));
+#endif /* NOTDEF */
 
-	/* then query nvram */
-	return (BCMINIT(nvram_get)(name));
+		buf += sprintf(buf, "\n");
+	}
+	return obuf;
 }
+#endif  /* BCMDBG_PKT */
 
-/*
- * Search the vars for a specific one and return its value as
- * an integer. Returns 0 if not found.
- */
-int
-getintvar(char *vars, char *name)
+/* iovar table lookup */
+const bcm_iovar_t*
+bcm_iovar_lookup(const bcm_iovar_t *table, const char *name)
 {
-	char *val;
+	const bcm_iovar_t *vi;
+	const char *lookup_name;
 
-	if ((val = getvar(vars, name)) == NULL)
-		return (0);
+	/* skip any ':' delimited option prefixes */
+	lookup_name = strrchr(name, ':');
+	if (lookup_name != NULL)
+		lookup_name++;
+	else
+		lookup_name = name;
 
-	return (bcm_strtoul(val, NULL, 0));
+	ASSERT(table);
+
+	for (vi = table; vi->name; vi++) {
+		if (!strcmp(vi->name, lookup_name))
+			return vi;
+	}
+	/* ran to end of table */
+
+	return NULL; /* var name not found */
 }
 
-/* Return gpio pin number assigned to the named pin */
-/*
-* Variable should be in format:
-*
-*	gpio<N>=pin_name
-*
-* 'def_pin' is returned if there is no such variable found.
-*/
-uint
-getgpiopin(char *vars, char *pin_name, uint def_pin)
+int
+bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 {
-	char name[] = "gpioXXXX";
-	char *val;
-	uint pin;
+	int bcmerror = 0;
 
-	/* Go thru all possibilities till a match in pin name */
-	for (pin = 0; pin < GPIO_NUMPINS; pin ++) {
-		sprintf(name, "gpio%d", pin);
-		val = getvar(vars, name);
-		if (val && !strcmp(val, pin_name))
-			return pin;
+	/* length check on io buf */
+	switch (vi->type) {
+	case IOVT_BOOL:
+	case IOVT_INT8:
+	case IOVT_INT16:
+	case IOVT_INT32:
+	case IOVT_UINT8:
+	case IOVT_UINT16:
+	case IOVT_UINT32:
+		/* all integers are int32 sized args at the ioctl interface */
+		if (len < (int)sizeof(int)) {
+			bcmerror = BCME_BUFTOOSHORT;
 	}
-	return def_pin;
+		break;
+
+	case IOVT_BUFFER:
+		/* buffer must meet minimum length requirement */
+		if (len < vi->minlen) {
+			bcmerror = BCME_BUFTOOSHORT;
+		}
+		break;
+
+	case IOVT_VOID:
+		if (!set) {
+			/* Cannot return nil... */
+			bcmerror = BCME_UNSUPPORTED;
+		} else if (len) {
+			/* Set is an action w/o parameters */
+			bcmerror = BCME_BUFTOOLONG;
+		}
+		break;
+
+	default:
+		/* unknown type for length check in iovar info */
+		ASSERT(0);
+		bcmerror = BCME_UNSUPPORTED;
+	}
+
+	return bcmerror;
 }
 
-#endif	/* #ifdef BCMDRIVER */
+#endif	/* BCMDRIVER */
 
+
+#ifndef	BCMROMOFFLOAD
 /*******************************************************************************
  * crc8
  *
@@ -507,9 +1277,10 @@
  *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
  *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
  *
- ******************************************************************************/
+ * ****************************************************************************
+ */
 
-static uint8 crc8_table[256] = {
+static const uint8 crc8_table[256] = {
     0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
     0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
     0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
@@ -548,14 +1319,15 @@
     (c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
 
 uint8
-hndcrc8(
+BCMROMFN(hndcrc8)(
 	uint8 *pdata,	/* pointer to array of data to process */
 	uint  nbytes,	/* number of input data bytes to process */
 	uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
 )
 {
 	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
-	 * to avoid the undefined and unnecessary (uint8 >> 8) operation. */
+	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 */
 	while (nbytes-- > 0)
 		crc = crc8_table[(crc ^ *pdata++) & 0xff];
 
@@ -581,9 +1353,10 @@
  *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
  *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
  *
- ******************************************************************************/
+ * ****************************************************************************
+ */
 
-static uint16 crc16_table[256] = {
+static const uint16 crc16_table[256] = {
     0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
     0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
     0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
@@ -619,7 +1392,7 @@
 };
 
 uint16
-hndcrc16(
+BCMROMFN(hndcrc16)(
     uint8 *pdata,  /* pointer to array of data to process */
     uint nbytes, /* number of input data bytes to process */
     uint16 crc     /* either CRC16_INIT_VALUE or previous return value */
@@ -630,7 +1403,7 @@
     return crc;
 }
 
-static uint32 crc32_table[256] = {
+static const uint32 crc32_table[256] = {
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
     0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
@@ -698,7 +1471,7 @@
 };
 
 uint32
-hndcrc32(
+BCMROMFN(hndcrc32)(
     uint8 *pdata,  /* pointer to array of data to process */
     uint   nbytes, /* number of input data bytes to process */
     uint32 crc     /* either CRC32_INIT_VALUE or previous return value */
@@ -718,7 +1491,8 @@
     /* handle bulk of data as 32-bit words */
     pend = pdata + (nbytes & 0xfffffffc);
     while (pdata < pend) {
-	*tptr = *((ulong *)pdata)++;
+		*tptr = *(ulong *)pdata;
+		pdata += sizeof(ulong *);
         CRC_INNER_LOOP(32, crc, tmp[0]);
         CRC_INNER_LOOP(32, crc, tmp[1]);
         CRC_INNER_LOOP(32, crc, tmp[2]);
@@ -733,19 +1507,19 @@
     pend = pdata + nbytes;
     while (pdata < pend)
         CRC_INNER_LOOP(32, crc, *pdata++);
-#endif
+#endif /* __mips__ */
        
     return crc;
 }
 
 #ifdef notdef
-#define CLEN 	1499
+#define CLEN 	1499 	/*  CRC Length */
 #define CBUFSIZ 	(CLEN+4)
-#define CNBUFS		5
+#define CNBUFS		5 /* # of bufs */
 
 void testcrc32(void)
 {
-	uint j,k,l;
+	uint j, k, l;
 	uint8 *buf;
 	uint len[CNBUFS];
 	uint32 crcr;
@@ -755,14 +1529,14 @@
 	ASSERT((buf = MALLOC(CBUFSIZ*CNBUFS)) != NULL);
 
 	/* step through all possible alignments */
-	for (l=0;l<=4;l++) {
-		for (j=0; j<CNBUFS; j++) {
+	for (l = 0; l <= 4; l++) {
+		for (j = 0; j < CNBUFS; j++) {
 			len[j] = CLEN;
-			for (k=0; k<len[j]; k++)
+			for (k = 0; k < len[j]; k++)
 				*(buf + j*CBUFSIZ + (k+l)) = (j+k) & 0xff;
 		}
 
-		for (j=0; j<CNBUFS; j++) {
+		for (j = 0; j < CNBUFS; j++) {
 			crcr = crc32(buf + j*CBUFSIZ + l, len[j], CRC32_INIT_VALUE);
 			ASSERT(crcr == crc32tv[j]);
 		}
@@ -771,8 +1545,7 @@
 	MFREE(buf, CBUFSIZ*CNBUFS);
 	return;
 }
-#endif
-
+#endif /* notdef */
 
 /* 
  * Advance from the current 1-byte tag/1-byte length/variable-length value 
@@ -777,26 +1550,28 @@
 /* 
  * Advance from the current 1-byte tag/1-byte length/variable-length value 
  * triple, to the next, returning a pointer to the next.
+ * If the current or next TLV is invalid (does not fit in given buffer length),
+ * NULL is returned.
+ * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
+ * by the TLV parameter's length if it is valid.
  */
 bcm_tlv_t *
-bcm_next_tlv(bcm_tlv_t *elt, int *buflen)
+BCMROMFN(bcm_next_tlv)(bcm_tlv_t *elt, int *buflen)
 {
 	int len;
 
 	/* validate current elt */
-	if (*buflen < 2) {
+	if (!bcm_valid_tlv(elt, *buflen))
 		return NULL;
-	}
 	
+	/* advance to next elt */
 	len = elt->len;
-
-	/* validate remaining buflen */
-	if (*buflen >= (2 + len + 2)) {
 		elt = (bcm_tlv_t*)(elt->data + len);
 		*buflen -= (2 + len);
-	} else {
-		elt = NULL;
-	}
+
+	/* validate next elt */
+	if (!bcm_valid_tlv(elt, *buflen))
+		return NULL;
 	
 	return elt;
 }
@@ -807,7 +1582,7 @@
  * matches tag
  */
 bcm_tlv_t *
-bcm_parse_tlvs(void *buf, int buflen, uint key)
+BCMROMFN(bcm_parse_tlvs)(void *buf, int buflen, uint key)
 {
 	bcm_tlv_t *elt;
 	int totlen;
@@ -837,7 +1612,7 @@
  * than the target key. 
  */
 bcm_tlv_t *
-bcm_parse_ordered_tlvs(void *buf, int buflen, uint key)
+BCMROMFN(bcm_parse_ordered_tlvs)(void *buf, int buflen, uint key)
 {
 	bcm_tlv_t *elt;
 	int totlen;
@@ -852,7 +1627,7 @@
 		
 		/* Punt if we start seeing IDs > than target key */
 		if (id > key)
-			return(NULL);
+			return (NULL);
 
 		/* validate remaining totlen */
 		if ((id == key) && (totlen >= (len + 2)))
@@ -863,5 +1638,233 @@
 	}
 	return NULL;
 }
+#endif	/* !BCMROMOFFLOAD */
+
+
+/* Produce a human-readable string for boardrev */
+char *
+bcm_brev_str(uint16 brev, char *buf)
+{
+	if (brev < 0x100)
+		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
+	else
+		snprintf(buf, 8, "%c%03x", ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
+
+	return (buf);
+}
+
+#define BUFSIZE_TODUMP_ATONCE 512 /* Buffer size */
+
+/* dump large strings to console */
+void
+printfbig(char *buf)
+{
+	uint len, max_len;
+	char c;
+
+	len = strlen(buf);
+
+	max_len = BUFSIZE_TODUMP_ATONCE;
+
+	while (len > max_len) {
+		c = buf[max_len];
+		buf[max_len] = '\0';
+		printf("%s", buf);
+		buf[max_len] = c;
+
+		buf += max_len;
+		len -= max_len;
+	}
+	/* print the remaining string */
+	printf("%s\n", buf);
+	return;
+}
+
+/* routine to dump fields in a fileddesc structure */
+uint
+bcmdumpfields(readreg_rtn read_rtn, void *arg0, void *arg1, struct fielddesc *fielddesc_array,
+	char *buf, uint32 bufsize)
+{
+	uint  filled_len;
+	int len;
+	struct fielddesc *cur_ptr;
+
+	filled_len = 0;
+	cur_ptr = fielddesc_array;
+
+	while (bufsize > 1) {
+		if (cur_ptr->nameandfmt == NULL)
+			break;
+		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
+		               read_rtn(arg0, arg1, cur_ptr->offset));
+		/* check for snprintf overflow or error */
+		if (len < 0 || (uint32)len >= bufsize)
+			len = bufsize - 1;
+		buf += len;
+		bufsize -= len;
+		filled_len += len;
+		cur_ptr++;
+	}
+	return filled_len;
+}
+
+uint
+bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
+{
+	uint len;
+
+	len = strlen(name) + 1;
+
+	if ((len + datalen) > buflen)
+		return 0;
+
+	strncpy(buf, name, buflen);
+
+	/* append data onto the end of the name string */
+	memcpy(&buf[len], data, datalen);
+	len += datalen;
+
+	return len;
+}
+
+#ifndef	BCMROMOFFLOAD
+
+/* Quarter dBm units to mW
+ * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
+ * Table is offset so the last entry is largest mW value that fits in
+ * a uint16.
+ */
+
+#define QDBM_OFFSET 153		/* Offset for first entry */
+#define QDBM_TABLE_LEN 40	/* Table size */
+
+/* Smallest mW value that will round up to the first table entry, QDBM_OFFSET.
+ * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
+ */
+#define QDBM_TABLE_LOW_BOUND 6493 /* Low bound */
+
+/* Largest mW value that will round down to the last table entry,
+ * QDBM_OFFSET + QDBM_TABLE_LEN-1.
+ * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
+ */
+#define QDBM_TABLE_HIGH_BOUND 64938 /* High bound */
+
+static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+/* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
+/* 153: */      6683,	7079,	7499,	7943,	8414,	8913,	9441,	10000,
+/* 161: */      10593,	11220,	11885,	12589,	13335,	14125,	14962,	15849,
+/* 169: */      16788,	17783,	18836,	19953,	21135,	22387,	23714,	25119,
+/* 177: */      26607,	28184,	29854,	31623,	33497,	35481,	37584,	39811,
+/* 185: */      42170,	44668,	47315,	50119,	53088,	56234,	59566,	63096
+};
+
+uint16
+BCMROMFN(bcm_qdbm_to_mw)(uint8 qdbm)
+{
+	uint factor = 1;
+	int idx = qdbm - QDBM_OFFSET;
+
+	if (idx > QDBM_TABLE_LEN) {
+		/* clamp to max uint16 mW value */
+		return 0xFFFF;
+	}
+
+	/* scale the qdBm index up to the range of the table 0-40
+	 * where an offset of 40 qdBm equals a factor of 10 mW.
+	 */
+	while (idx < 0) {
+		idx += 40;
+		factor *= 10;
+	}
+
+	/* return the mW value scaled down to the correct factor of 10,
+	 * adding in factor/2 to get proper rounding.
+	 */
+	return ((nqdBm_to_mW_map[idx] + factor/2) / factor);
+}
+
+uint8
+BCMROMFN(bcm_mw_to_qdbm)(uint16 mw)
+{
+	uint8 qdbm;
+	int offset;
+	uint mw_uint = mw;
+	uint boundary;
+
+	/* handle boundary case */
+	if (mw_uint <= 1)
+		return 0;
+
+	offset = QDBM_OFFSET;
+
+	/* move mw into the range of the table */
+	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
+		mw_uint *= 10;
+		offset -= 40;
+	}
+
+	for (qdbm = 0; qdbm < QDBM_TABLE_LEN-1; qdbm++) {
+		boundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm+1] -
+		                                    nqdBm_to_mW_map[qdbm])/2;
+		if (mw_uint < boundary) break;
+	}
+
+	qdbm += (uint8)offset;
+
+	return (qdbm);
+}
+
+
+uint
+BCMROMFN(bcm_bitcount)(uint8 *bitmap, uint length)
+{
+	uint bitcount = 0, i;
+	uint8 tmp;
+	for (i = 0; i < length; i++) {
+		tmp = bitmap[i];
+		while (tmp) {
+			bitcount++;
+			tmp &= (tmp - 1);
+		}
+	}
+	return bitcount;
+}
 
+#endif /* !BCMROMOFFLOAD */
 
+#ifdef BCMDRIVER
+
+/* Initialization of bcmstrbuf structure */
+void
+bcm_binit(struct bcmstrbuf *b, char *buf, uint size)
+{
+	b->origsize = b->size = size;
+	b->origbuf = b->buf = buf;
+}
+
+/* Buffer sprintf wrapper to guard against buffer overflow */
+int
+bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
+{
+	va_list ap;
+	int r;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+
+	/* Non Ansi C99 compliant returns -1,
+	 * Ansi compliant return r >= b->size,
+	 * bcmstdlib returns 0, handle all
+	 */
+	if ((r == -1) || (r >= (int)b->size) || (r == 0)) {
+		b->size = 0;
+	} else {
+		b->size -= r;
+		b->buf += r;
+	}
+
+	va_end(ap);
+
+	return r;
+}
+#endif /* BCMDRIVER */
--- src/shared.1927/bcmwifi.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/bcmwifi.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,249 @@
+/*
+ * Misc utility routines used by kernel or app-level.
+ * Contents are wifi-specific, used by any kernel or app-level
+ * software that might want wifi things as it grows.
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.                
+ *                                     
+ * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+ * the contents of this file may not be disclosed to third parties, copied
+ * or duplicated in any form, in whole or in part, without the prior      
+ * written permission of Broadcom Corporation.                            
+ * $Id$
+ */
+
+#include <typedefs.h>
+
+#ifdef BCMDRIVER
+#include <osl.h>
+#include <bcmutils.h>
+#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
+#define tolower(c) (bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
+#elif defined(__IOPOS__)
+#include <bcmutils.h>
+#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
+#define tolower(c) (bcm_tolower((c)))
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#endif /* BCMDRIVER */
+#include <bcmwifi.h>
+
+/* Chanspec ASCII representation:
+ * <channel><band><bandwidth><ctl-sideband>
+ *   digit   [AB]      N          [UL]
+ *
+ * <channel>: channel number of the 10MHz or 20MHz channel,
+ *	or control sideband channel of 40MHz channel.
+ * <band>: A for 5GHz, B for 2.4GHz
+ * <bandwidth>: N for 10MHz, nothing for 20MHz or 40MHz
+ *	(ctl-sideband spec implies 40MHz)
+ * <ctl-sideband>: U for upper, L for lower
+ *
+ * <band> may be omitted on input, and will be assumed to be
+ * 2.4GHz if channel number <= 14.
+ *
+ * Examples: ...
+ */
+/* given a chanspec and a string buffer, format the chanspec as a
+ * string, and return the original pointer a. On error, return's NULL
+ */
+char *
+wf_chspec_ntoa(chanspec_t chspec, char *buf)
+{
+	const char *band, *bw, *sb;
+	uint channel;
+
+	bw = "";
+	sb = "";
+	channel = CHSPEC_CHANNEL(chspec);
+	band = (CHSPEC_IS2G(chspec)) ? "b" : "a";
+	if (CHSPEC_IS40(chspec)) {
+		if (CHSPEC_SB_UPPER(chspec)) {
+			sb = "u";
+			channel += CH_10MHZ_APART;
+		} else {
+			sb = "l";
+			channel -= CH_10MHZ_APART;
+		}
+	} else if (CHSPEC_IS10(chspec)) {
+		bw = "n";
+	}
+
+	sprintf(buf, "%d%s%s%s", channel, band, bw, sb);
+	return (buf);
+}
+
+/* given a chanspec string, convert to a chanspec.
+ * On error, return 0
+ */
+
+chanspec_t
+wf_chspec_aton(char *a)
+{
+	char *endp;
+	uint channel, band, bw, ctl_sb;
+	bool band_set = FALSE, bw_set = FALSE, ctl_sb_set = FALSE;
+	int error = 0;
+
+	channel = strtoul(a, &endp, 10);
+	if (endp == a)
+		return 0;
+
+	if (channel > MAXCHANNEL)
+		return 0;
+
+	band = ((channel <= WLC_MAX_2G_CHANNEL) ? WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G);
+	bw = WL_CHANSPEC_BW_20;
+	ctl_sb = WL_CHANSPEC_CTL_SB_NONE;
+
+	a = endp;
+	while (*a != 0 && error != -1) {
+		switch (tolower((int)*a)) {
+			case 'a':
+			case 'b':
+				if (!band_set) {
+					band = (tolower((int)*a) == 'a') ?
+					       WL_CHANSPEC_BAND_5G : WL_CHANSPEC_BAND_2G;
+					band_set = TRUE;
+				} else {
+					error = -1;
+				}
+				break;
+			case 'n':
+				if (!bw_set) {
+					bw = WL_CHANSPEC_BW_10;
+					bw_set = TRUE;
+				} else {
+					error = -1;
+				}
+				break;
+			case 'l':
+			case 'u':
+				if (!ctl_sb_set && !bw_set) {
+					ctl_sb = (tolower((int)*a) == 'l') ?
+						WL_CHANSPEC_CTL_SB_LOWER : WL_CHANSPEC_CTL_SB_UPPER;
+					ctl_sb_set = TRUE;
+					if (ctl_sb == WL_CHANSPEC_CTL_SB_LOWER)
+						channel = UPPER_20_SB(channel);
+					else
+						channel = LOWER_20_SB(channel);
+					bw = WL_CHANSPEC_BW_40;
+					bw_set = TRUE;
+				} else if (bw_set) {
+					error = -1;
+				} else {
+					error = -1;
+				}
+				break;
+			default:
+				error = -1;
+				break;
+		}
+		a++;
+	}
+
+	if (bw_set && (bw == WL_CHANSPEC_BW_40) && !ctl_sb_set)
+		error = -1;
+
+	if (ctl_sb_set && !bw_set)
+		error = -1;
+
+	if (!error)
+		return ((channel | band | bw | ctl_sb));
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_RADIO
+/* channel info structure */
+typedef struct {
+	uint	chan;		/* channel number */
+	uint	freq;		/* in Mhz */
+} chan_info_t;
+
+static chan_info_t chan_info[] = {
+	/* B channels */
+	{ 1,	2412},
+	{ 2,	2417},
+	{ 3,	2422},
+	{ 4,	2427},
+	{ 5,	2432},
+	{ 6,	2437},
+	{ 7,	2442},
+	{ 8,	2447},
+	{ 9,	2452},
+	{ 10,	2457},
+	{ 11,	2462},
+	{ 12,	2467},
+	{ 13,	2472},
+	{ 14,	2484},
+
+	/* A channels */
+	/* 11a usa low */
+	{ 36,	5180},
+	{ 40,	5200},
+	{ 44,	5220},
+	{ 48,	5240},
+	{ 52,	5260},
+	{ 56,	5280},
+	{ 60,	5300},
+	{ 64,	5320},
+
+	/* 11a Europe */
+	{ 100,	5500},
+	{ 104,	5520},
+	{ 108,	5540},
+	{ 112,	5560},
+	{ 116,	5580},
+	{ 120,	5600},
+	{ 124,	5620},
+	{ 128,	5640},
+	{ 132,	5660},
+	{ 136,	5680},
+	{ 140,	5700},
+
+	/* 11a usa high */
+	{ 149,	5745},
+	{ 153,	5765},
+	{ 157,	5785},
+	{ 161,	5805},
+
+	/* 11a japan */
+	{ 184,	4920},
+	{ 188,	4940},
+	{ 192,	4960},
+	{ 196,	4980},
+	{ 200,	5000},
+	{ 204,	5020},
+	{ 208,	5040},
+	{ 212,	5060},
+	{ 216,	5080}
+};
+
+
+uint
+freq2channel(uint freq)
+{
+	int i;
+
+	for (i = 0; i < (int)ARRAYSIZE(chan_info); i++) {
+		if (chan_info[i].freq == freq)
+			return (chan_info[i].chan);
+	}
+	return (0);
+}
+
+uint
+channel2freq(uint channel)
+{
+	uint i;
+
+	for (i = 0; i < ARRAYSIZE(chan_info); i++)
+		if (chan_info[i].chan == channel)
+			return (chan_info[i].freq);
+	return (0);
+}
+#endif /* CONFIG_NET_RADIO */
--- src/shared.1927/boot.S	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/boot.S	2007-11-19 06:40:26.000000000 +0300
@@ -17,38 +17,90 @@
 #include "mipsinc.h"
 #include "sbconfig.h"
 #include "sbchipc.h"
+#include "bcmdevs.h"
 
 	.text
 	LEAF(startup)
 	.set	noreorder
 
+
+	li	a0,KSEG1ADDR(SB_ENUM_BASE)
+
        	# XXX: the following code snipet sets clk frequency to 200M
         # correct pll clk freq to real speed in the 5350 case.
+	# unless its vsim which we detect as pkg option 1 (should be 0xe)
         # It is Ugly...but
+	li	a3,BCM5350_CHIP_ID		# 5350 ChipID
+	lw	t1,CC_CHIPID(a0)		# ChipID register
+	li	t2,CID_ID_MASK			# chip id is bit 0-15
+	and	t2,t1,t2
+	bne	t2,a3,2f			# if not 5350 then skip
+	nop
+	
+	li	t2,CID_PKG_MASK			# if it is a vsim 5350, also skip
+	and	t2,t1,t2
+	li	a3,(HDLSIM5350_PKG_ID << CID_PKG_SHIFT)
+	beq	t2,a3,2f			# if pkg opt 1 then skip
+	nop
+
+	li	a3,CLKC_5350_N
+	lw	t1,CC_CLKC_N(a0)
+	beq	a3,t1,2f			# move ahead if clk freq set correctly
+	nop
+	sw	a3,CC_CLKC_N(a0)		# set control N1 to select 6
+	li	t1,1
+	sw	t1,CC_WATCHDOG(a0)		# set WatchDog Reset
+1:	b	1b
+	nop
+
+2:
+#ifdef	BCM5354
+	lw	t1,CC_CHIPID(a0)		# ChipID register
+	li	t2,CID_ID_MASK			# chip id is bit 0-15
+	li	a3,BCM5354_CHIP_ID		# 5354 ChipID
+	and	t2,t1,t2
+	bne	t2,a3,ramcheck			# if not 5354 then skip
+	nop
+
+	li	t2,0x1				# Need define
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x6800000			# Should only affect the switch bits
+	sw	t3,PMU_REG_CONTROL_DATA(a0)
+	
+	/* 
+	 * Trim the output voltage of the 1.2V BB switcher and 2.5V
+	 * regulator to the correct value.
+	 */
+	li	t2,0x0
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x2000			# Reduce the output voltage of
+	sw	t3,PMU_REG_CONTROL_DATA(a0)	# BB switcher to get 1.2V
+	li	t2,0x3
+	sw	t2,PMU_REG_CONTROL_ADDR(a0)
+	li 	t3,0x02000000			# Increase the output voltage
+	sw	t3,PMU_REG_CONTROL_DATA(a0)	# of VDDP LDO to get 2.5V
+
+	lw	t2,PMU_CTL(a0)			# Check if PLL has been programmed
+	andi	t2,t2,PCTL_XTALFREQ_MASK
+	bnez	t2,3f				# Yup, leave it alone
+	nop
+	li	t2,0x7ffff			# Should only turn off the PLL bit
+	sw	t2,PMU_MIN_RES_MASK(a0)		# Disable base band PLL
+	sw	t2,PMU_MAX_RES_MASK(a0)
+	nop
+
+	/* Init code for FF4 space without TLB, enabling RAC */
+3:	li 	t0,0x1fa0000c			# Set up CBR to 0x1fax_xxxx
+	mtc0 	t0,$22,6
+	li 	t1,0x1fa00000
+	lw 	t2,0x14(t1)
+	or 	t3,t2,0xc0000000		# enable ffxx_xxxx space # without programming TLB
+	sw 	t3,0x14(t1) 
+	li 	t0,0xff40000c			# change CBR to ff4x_xxxx
+	mtc0 	t0,$22,6
+#endif	/* BCM5354 */
 
-	li      t0,KSEG1ADDR(SB_ENUM_BASE)      # Is there a chipcommon core?
-	lw      t1,(SBCONFIGOFF + SBIDHIGH)(t0)
-	and     t1,t1,SBIDH_CC_MASK
-	srl     t1,t1,SBIDH_CC_SHIFT
-	bne     t1,SB_CC,_move_ahead
-	nop
-        li      a2,KSEG1ADDR(SB_ENUM_BASE)
-        li      a3, 0x5350            # 5350 ChipID
-        ll      t1, 0(a2)             # ChipID register
-        andi    t1, 0x0ffff             # chip id is bit 0-15
-        bne     a3, t1, _move_ahead   # if not 5350 then skip
-        nop
-        li      a3, 0x311
-        ll      t1, 0x90(a2)
-        beq     a3, t1, _move_ahead   # move ahead if clk freq set correctly
-        nop
-        sw      a3, 0x90(a2)          # set control N1 to select 6
-        li      t1, 0x1
-        sw      t1, 0x80(a2)          # set WatchDog Reset
-_move_ahead:
-        nop
-
-
+ramcheck:
 	/* Check if we booted from SDRAM */
 	bal	1f
 	nop
@@ -65,18 +117,29 @@
 	nop
 
 inflash:
-	/* Is this chipc rev 11 or 12 and an Atmel serial flash? */
+	/* Is this chipc rev 11 or 12 and a serial flash? */
 	li	t0,KSEG1ADDR(SB_ENUM_BASE)
 	lw	t1,(SBCONFIGOFF + SBIDHIGH)(t0)
 	and	t2,t1,SBIDH_CC_MASK
 	srl	t2,t2,SBIDH_CC_SHIFT
 	bne	t2,SB_CC,checkcon		/* Not chipc */
 	nop
+	and	t2,t1,SBIDH_RC_MASK
+	and	t3,t1,SBIDH_RCE_MASK
+	srl	t3,t3,SBIDH_RCE_SHIFT
+	or	t2,t3
+	ble	t2,10,checkcon			/* ccrev <= 10 */
+	nop
+	bge	t2,13,checkcon			/* ccrev >= 13 */
+	nop
 	lw	t0,CC_CAPABILITIES(t0)
-	and	t0,t0,CAP_FLASH_MASK
-	beq	t0,SFLASH_AT,switchkseg0
+	and	t0,t0,CC_CAP_FLASH_MASK
+	beq	t0,SFLASH_AT,switchkseg0	/* Atmel sflash */
+	nop
+	beq	t0,SFLASH_ST,switchkseg0	/* ST sflash */
 	nop
 
+
 checkcon:
 	/* Check if the caches are already on */
 	mfc0	t0,C0_CONFIG
@@ -90,7 +153,7 @@
 initcaches:
 	/* Turn on the caches in the CP0 register */
 	mfc0	t0,C0_DIAGNOSTIC
-	or	t0,0xc0000000		/* Enable both I$ and D$ */
+	or	t0,(BRCM_IC_ENABLE | BRCM_DC_ENABLE) /* Enable both I$ and D$ */
 	mtc0	t0,C0_DIAGNOSTIC
 
 
@@ -220,11 +283,11 @@
 #else
 	li	a0,KSEG0ADDR(SB_FLASH1)
 	la	a1,text_start
-	and	a1,PHYSADDR_MASK
-	or	a1, KSEG1
-	la	a2,input_data
+	and	a1,PHYSADDR_MASK	/* Uncached writes to avoid a flush */
+	or	a1,KSEG1
+	la	a2,_end
 	and	a2,PHYSADDR_MASK
-	or	a2, KSEG1
+	or	a2,KSEG1
 #endif
 1:	lw	t0,0(a0)
 	sw	t0,0(a1)
@@ -232,8 +295,43 @@
 	add	a1,4
 	blt	a1,a2,1b
 	nop
+	b	setsp
+	nop
+
+	/* Black hole for traps with BEV on */
+	.org	0x380
+bevtrap: nop
+	nop
+	.set	mips32
+	wait
+	.set	mips0
+	nop
+	nop
+	b	bevtrap
+	nop
+
+	/* Record the size of the binary */
+	.org	BISZ_OFFSET
+	.word	BISZ_MAGIC
+	.word	text_start
+	.word	text_end
+	.word	data_start
+	.word	data_end
+	.word	bss_start
+	.word	bss_end
+	.word	_end
+
+	/* Embedded NVRAM */
+	.balign	0x400	
+	.globl	embedded_nvram
+embedded_nvram:
+	.fill	0x100,4,~(0x48534c46)
 
 setsp:
+	/* Record the memory size */
+	la	t0,_memsize
+	sw	v0,0(t0)
+
 	/* Set up stack pointer */
 	or	v0,KSEG0
 	sub	sp,v0,4
@@ -247,6 +345,7 @@
 	nop
 
 	/* Setup trap handlers */
+#ifdef CONFIG_XIP
 	li	t0,KSEG0ADDR(SB_FLASH1)
 	la	t1,text_start
 	la	t2,trap_init
@@ -254,6 +353,11 @@
 	add	t2,t2,t0
 	jalr	t2
 	nop
+#else
+	la	t0,trap_init
+	jalr	t0
+	nop
+#endif
 
 	/* Jump to C */
 	la	t0,c_main
@@ -271,33 +375,10 @@
 	b	theend
 	nop
 
-	/* Black hole for traps with BEV on */
-	.org	0x380
-bevtrap: nop
-	nop
-	.set	mips32
-	wait
-	.set	mips0
-	nop
-	nop
-	b	bevtrap
-	nop
-
-	/* Record the size of the binary */
-	.org	BISZ_OFFSET
-	.word	BISZ_MAGIC
-	.word	text_start
-	.word	text_end
-	.word	data_start
-	.word	data_end
-	.word	bss_start
-	.word	bss_end
-
-	/* Embedded NVRAM */
-	.balign	0x400	
-	.globl	embedded_nvram
-embedded_nvram:
-	.fill	0x100,4,~(0x48534c46)
-	
 	.set reorder
 	END(startup)
+
+	.data
+	.globl	_memsize
+_memsize:
+	.word	0
--- src/shared.1927/bzip2_inflate.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/bzip2_inflate.c	2007-11-19 06:40:26.000000000 +0300
@@ -76,7 +76,7 @@
 --*/
 
 /*-- General stuff. --*/
-
+/* FILE-CSTYLED */
 #define BZ_VERSION  "1.0.2, 30-Dec-2001"
 
 typedef char            Char;
--- src/shared.1927/cfe_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/cfe_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,7 +13,29 @@
  */
 
 #include <typedefs.h>
-#include <cfe_osl.h>
+#include <bcmdefs.h>
+#include <osl.h>
+
+osl_t *
+osl_attach(void *pdev)
+{
+	osl_t *osh;
+
+	osh = (osl_t *)KMALLOC(sizeof(osl_t), 0);
+	ASSERT(osh);
+
+	bzero(osh, sizeof(osl_t));
+	osh->pdev = pdev;
+	return osh;
+}
+
+void
+osl_detach(osl_t *osh)
+{
+	if (osh == NULL)
+		return;
+	KFREE((void*) KERNADDR(PHYSADDR((ulong)osh)));
+}
 
 struct lbuf *
 osl_pktget(uint len)
@@ -37,10 +58,13 @@
 }
 
 void
-osl_pktfree(struct lbuf *lb)
+osl_pktfree(osl_t *osh, struct lbuf *lb, bool send)
 {
 	struct lbuf *next;
 
+	if (send && osh->tx_fn)
+		osh->tx_fn(osh->tx_ctx, lb, 0);
+
 	for (; lb; lb = next) {
 		ASSERT(!lb->link);
 		next = lb->next;
@@ -115,11 +138,54 @@
 	KFREE((void *) KERNADDR(PHYSADDR((ulong) va)));
 }
 
+#ifdef BCMDBG_ASSERT
+void
+osl_assert(char *exp, char *file, int line)
+{
+	printf("assertion \"%s\" failed: file \"%s\", line %d\n", exp, file, line);
+	*((int *) 0) = 0;
+}
+#endif /* BCMDBG_ASSERT */
 
 int
 osl_busprobe(uint32 *val, uint32 addr)
 {
-	*val = R_REG((volatile uint32 *) addr);
+	*val = R_REG(NULL, (volatile uint32 *) addr);
+
+	return 0;
+}
 
+/* translate bcmerros */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror)
+		return -1;
+	else
 	return 0;
 }
+
+/* Converts a OS packet to driver packet.
+ * The original packet data is copied to the new driver packet
+ */
+void
+osl_pkt_frmnative(iocb_buffer_t *buffer, struct lbuf *lb)
+{
+	bcopy(buffer->buf_ptr, PKTDATA(NULL, lb), buffer->buf_length);
+}
+
+/* Converts a driver packet into OS packet.
+ * The data is copied to the OS packet
+ */
+void
+osl_pkt_tonative(struct lbuf* lb, iocb_buffer_t *buffer)
+{
+	bcopy(PKTDATA(NULL, lb), buffer->buf_ptr, PKTLEN(NULL, lb));
+	buffer->buf_retlen = PKTLEN(NULL, lb);
+
+	/* RFC894: Minimum length of IP over Ethernet packet is 46 octets */
+	if (buffer->buf_retlen < 60) {
+		bzero(buffer->buf_ptr + buffer->buf_retlen, 60 - buffer->buf_retlen);
+		buffer->buf_retlen = 60;
+	}
+}
--- src/shared.1927/flashutl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/flashutl.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,118 +12,132 @@
  * $Id$
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
 #include <typedefs.h>
+#include <osl.h>
 
 #define DECLARE_FLASHES
+#include <bcmutils.h>
 #include <sbutils.h>
 #include <sbconfig.h>
 #include <flash.h>
 #include <sflash.h>
 #include <flashutl.h>
 #include <bcmnvram.h>
-#include <bcmutils.h>
-#include <osl.h>
 
 #define DPRINT(x) 
 
-#define ERR2	0x30
-#define DONE	0x80
-#define WBUFSIZE 32
+#define ERR2	0x30 /* Mask for err UNUSED */
+#define DONE	0x80 /* Mask for done */
+#define WBUFSIZE 32  /* Write Buffer size */
 #define FLASH_TRIES 4000000 /* retry count */
 #define CMD_ADDR ((unsigned long)0xFFFFFFFF)
 
 /* 'which' param for block() */
-#define BLOCK_BASE	0
-#define BLOCK_LIM	1
+#define BLOCK_BASE	0  /* Base of block */
+#define BLOCK_LIM	1  /* Limit of block */
 
 #define FLASH_ADDR(off) ((unsigned long)flashutl_base + (off))
 
-static chipcregs_t *cc;
+/* Local vars */
+static sb_t *sbh = NULL;
+static chipcregs_t *cc = NULL;
 
 /* Global vars */
-char*		flashutl_base	= NULL;
-flash_desc_t*	flashutl_desc	= NULL;
-flash_cmds_t*	flashutl_cmd	= NULL;
+uint8		*flashutl_base	= NULL;
+flash_desc_t	*flashutl_desc	= NULL;
+flash_cmds_t	*flashutl_cmd	= NULL;
+uint8 flashutl_wsz = sizeof(uint16);
 
 static void		scmd(uint16 cmd, unsigned long off);
 static void		cmd(uint16 cmd, unsigned long off);
 static void		flash_reset(void);
 static int		flash_poll(unsigned long off, uint16 data);
 static unsigned long	block(unsigned long addr, int which);
-static int	flash_erase(void);
 static int	flash_eraseblk(unsigned long off);
-static int	flash_write(unsigned long off, uint16 *src, uint nbytes);
-static unsigned long	flash_block_base(unsigned long off);
-static unsigned long	flash_block_lim(unsigned long off);
-static chipcregs_t *cc;
+static int	flash_write(unsigned long off, uint8 *src, uint nbytes);
+static uint16 INLINE flash_readword(unsigned long addr);
+static void INLINE flash_writeword(unsigned long addr, uint16 data);
+
+int sysFlashErase(uint off, unsigned int numbytes);
 
 /* Read the flash ID and set the globals */
 int
 sysFlashInit(char *flash_str)
 {
+	osl_t *osh;
 	uint32 fltype = PFLASH;
 	uint16 flash_vendid = 0;
 	uint16 flash_devid = 0;
-	uint16* flash = (uint16*)0xbfc00000;
 	int idx;
 	struct sflash *sflash;
-	void *sbh;
 
 	/*
 	 * Check for serial flash.
 	 */
-	sbh = sb_kattach();
+	sbh = sb_kattach(SB_OSH);
 	ASSERT(sbh);
-	cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0);
 
+	osh = sb_osh(sbh);
+
+	flashutl_base = (uint8*)OSL_UNCACHED(SB_FLASH1);
+	flashutl_wsz = sizeof(uint16);
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
 	if (cc) {
-		flash = (uint16*)0xbc000000;
-		fltype = R_REG(&cc->capabilities) & CAP_FLASH_MASK;
+		flashutl_base = (uint8*)OSL_UNCACHED(SB_FLASH2);
+		flashutl_wsz = (R_REG(osh, &cc->flash_config) & CC_CFG_DS) ?
+		        sizeof(uint16) : sizeof(uint8);
 		/* Select SFLASH ? */
+		fltype = R_REG(osh, &cc->capabilities) & CC_CAP_FLASH_MASK;
 		if (fltype == SFLASH_ST || fltype == SFLASH_AT) {
-			sflash = sflash_init(cc);
+			sflash = sflash_init(sbh, cc);
 			flashutl_cmd = &sflash_cmd_t;
 			flashutl_desc = &sflash_desc;
 			flashutl_desc->size = sflash->size;
 			if (flash_str) 
 				sprintf(flash_str, "SFLASH %d kB", sflash->size/1024);
-			return(0);
+			return (0);
 		}
 	}
 
-	flashutl_base = (uint8*)flash;
+	ASSERT(flashutl_wsz == sizeof(uint8) || flashutl_wsz == sizeof(uint16));
 
 	/* 
 	 * Parallel flash support
 	 *  Some flashes have different unlock addresses, try each it turn
 	 */
-	idx = sizeof(flash_cmds)/sizeof(flash_cmds_t) - 2;
-	flashutl_cmd = &flash_cmds[idx--];
-	while((fltype == PFLASH) && flashutl_cmd->type) {
+	for (idx = 0;
+	     fltype == PFLASH && idx < ARRAYSIZE(flash_cmds);
+	     idx ++) {
+		flashutl_cmd = &flash_cmds[idx];
+		if (flashutl_cmd->type == OLD)
+			continue;
 
 		if (flashutl_cmd->read_id)
 			cmd(flashutl_cmd->read_id, CMD_ADDR);
 
 #ifdef MIPSEB
-		flash_vendid = *(flash + 1);
-		flash_devid = *flash;	
+		flash_vendid = flash_readword(FLASH_ADDR(2));
+		flash_devid = flash_readword(FLASH_ADDR(0));
 #else
-		flash_vendid = *flash;
-		flash_devid = *(flash + 1);
-#endif
-
-		/* Funky AMD */
+		flash_vendid = flash_readword(FLASH_ADDR(0));
+		flash_devid = flash_readword(FLASH_ADDR(2));
+#endif /* MIPSEB */
+
+		/* Funky AMD, uses 3 byte device ID so use first byte (4th addr) to
+		 * identify it is a 3-byte ID and use the next two bytes (5th & 6th addr)
+		 * to form a word for unique identification of format xxyy, where
+		 * xx = 5th addr and yy = 6th addr
+		 */
 		if ((flash_vendid == 1) && (flash_devid == 0x227e)) {
 			/* Get real devid */
+			uint16 flash_devid_5th;
 #ifdef MIPSEB
-			flash_devid = *(flash+0xe);	
+			flash_devid_5th = flash_readword(FLASH_ADDR(0x1e)) << 8;
+			flash_devid = (flash_readword(FLASH_ADDR(0x1c)) & 0xff) | flash_devid_5th;
 #else
-			flash_devid = *(flash+0xf);
-#endif
+			flash_devid_5th = flash_readword(FLASH_ADDR(0x1c)) << 8;
+			flash_devid = (flash_readword(FLASH_ADDR(0x1e)) & 0xff) | flash_devid_5th;
+#endif /* MIPSEB */
 		}
 
 		flashutl_desc = flashes;
@@ -134,8 +148,6 @@
 		}
 		if (flashutl_desc->mfgid != 0)
 			break;
-
-		flashutl_cmd = &flash_cmds[idx--];
 	}
 
 	if (flashutl_desc->mfgid == 0) {
@@ -168,21 +180,6 @@
 }
 
 static int
-flash_erase()
-{
-	unsigned long size = flashutl_desc->size;
-	unsigned long addr;
-	int err = 0;
-	
-	for (addr = 0; addr < size; addr = block(addr, BLOCK_LIM)) {
-		err = flash_eraseblk(addr);
-		if (err) break;
-	}
-	
-	return err;
-}
-
-static int
 flash_eraseblk(unsigned long addr)
 {
 	unsigned long a;
@@ -194,7 +191,7 @@
 	
 	a = block(a, BLOCK_BASE);
 
-	/* Ensure blocks are unlocked (for intel chips)*/ 
+	/* Ensure blocks are unlocked (for intel chips) */
 	if (flashutl_cmd->type == BSC) {
 		scmd((unsigned char)INTEL_UNLOCK1, a);
 		scmd((unsigned char)INTEL_UNLOCK2, a);
@@ -207,6 +204,9 @@
 	if (flashutl_cmd->confirm)
 		scmd(flashutl_cmd->confirm, a);
 
+	if (flashutl_wsz == sizeof(uint8))
+		st = flash_poll(a, 0xff);
+	else
 	st = flash_poll(a, 0xffff);
 	
 	flash_reset();
@@ -217,15 +217,15 @@
 		return st;
 	}
 
-	DPRINT(("Erase of block 0x%08lx-0x%08lx done", a, block((unsigned long)addr, BLOCK_LIM)));
+	DPRINT(("Erase of block 0x%08lx-0x%08lx done\n", a, block((unsigned long)addr, BLOCK_LIM)));
 
 	return 0;
 }
 
 static int
-flash_write(unsigned long off, uint16 *src, uint nbytes)
+flash_write(unsigned long off, uint8 *src, uint nbytes)
 {
-	uint16* dest;
+	uint8 *dest;
 	uint16 st, data;
 	uint i, len;
 
@@ -234,7 +234,9 @@
 	if (off >= flashutl_desc->size)
 		return 1;
 
-	dest = (uint16*)FLASH_ADDR(off);
+	ASSERT(!(off & (flashutl_wsz - 1)));
+
+	dest = (uint8*)FLASH_ADDR(off);
 	st = 0;
 
 	while (nbytes) {
@@ -251,11 +253,12 @@
 
 #ifndef MIPSEB
 			/* write (length - 1) */
-			cmd((len / 2) - 1, off);
+			cmd(len / sizeof(uint16) - 1, off);
 
 			/* write data */
-			for (i = 0; i < len; i += 2, dest++, src++)
-				*dest = *src;
+			for (i = 0; i < len; i += sizeof(uint16),
+			             dest += sizeof(uint16), src += sizeof(uint16))
+				*(uint16 *)dest = *(uint16 *)src;
 #else
 			/* 
 			 * BCM4710 endianness is word consistent but
@@ -268,14 +271,16 @@
 			 */
 
 			/* write (padded length - 1) */
-			cmd((ROUNDUP(len, 4) / 2) - 1, off);
+			cmd((ROUNDUP(len, sizeof(uint32)) / sizeof(uint16)) - 1, off);
 
 			/* write data (plus pad if necessary) */
-			for (i = 0; i < ROUNDUP(len, 4); i += 4, dest += 2, src += 2) {
-				*(dest + 1) = ((i + 2) < len) ? *(src + 1) : 0xffff;
-				*dest = *src;
+			for (i = 0; i < ROUNDUP(len, sizeof(uint32)); i += sizeof(uint32),
+			             dest += sizeof(uint32), src += sizeof(uint32)) {
+				*((uint16 *)dest + 1) = ((i + sizeof(uint16)) < len) ?
+				        *((uint16 *)src + 1) : 0xffff;
+				*(uint16 *)dest = *(uint16 *)src;
 			}
-#endif
+#endif /* MIPSEB */
 
 			/* write confirm */
 			if (flashutl_cmd->confirm)
@@ -289,13 +294,16 @@
 				cmd(flashutl_cmd->write_word, CMD_ADDR);
 
 			/* write data */
-			len = MIN(nbytes, 2);
-			data = *src++;
-			*dest++ = data;
+			data = flash_readword((unsigned long)src);
+			flash_writeword((unsigned long)dest, data);
 
 			/* poll for done */
 			if ((st = flash_poll(off, data)))
 				break;
+
+			len = MIN(nbytes, flashutl_wsz);
+			dest += len;
+			src += len;
 		}
 
 		nbytes -= len;
@@ -307,27 +315,31 @@
 	return st;
 }
 
-static unsigned long
-flash_block_base(unsigned long off)
+static uint16 INLINE
+flash_readword(unsigned long addr)
 {
-	return block(off, BLOCK_BASE);
+	if (flashutl_wsz == sizeof(uint8))
+		return *(uint8*)addr;
+	else
+		return *(uint16*)addr;
 }
 
-static unsigned long
-flash_block_lim(unsigned long off)
+static void INLINE
+flash_writeword(unsigned long addr, uint16 data)
 {
-	return block(off, BLOCK_LIM);
+	if (flashutl_wsz == sizeof(uint8))
+		*(uint8*)addr = (uint8)data;
+	else
+		*(uint16*)addr = data;
 }
 
 /* Writes a single command to the flash. */
 static void
 scmd(uint16 cmd, unsigned long off)
 {
-	ASSERT(flashutl_base != NULL);
-	
 	/*  cmd |= cmd << 8; */
 
-	*(uint16*)(flashutl_base + off) = cmd;
+	flash_writeword(FLASH_ADDR(off), cmd);
 }
 
 /* Writes a command to flash, performing an unlock if needed. */
@@ -335,40 +347,48 @@
 cmd(uint16 cmd, unsigned long off)
 {
 	int i;
-	unlock_cmd_t *ul=NULL;
-	unsigned long cmd_off;
+	unlock_cmd_t *ul = NULL;
 
 	ASSERT(flashutl_cmd != NULL);
 
 	switch (flashutl_cmd->type) {
 	case AMD:
 		ul = &unlock_cmd_amd;
-		cmd_off = AMD_CMD;
 		break;
 	case SST:
 		ul = &unlock_cmd_sst;
-		cmd_off = SST_CMD;
 		break;
 	default:
-		cmd_off = 0;
 		break;
 	}
 	
 	if (flashutl_cmd->need_unlock) {
+		ASSERT(ul);
 		for (i = 0; i < UNLOCK_CMD_WORDS; i++)
-			*(uint16*)(flashutl_base + ul->addr[i]) = ul->cmd[i];
+			flash_writeword(FLASH_ADDR(ul->addr[i]), ul->cmd[i]);
 	}
 	
 	/* cmd |= cmd << 8; */
 
-	if (off == CMD_ADDR) 
-		off = cmd_off;
+	if (off == CMD_ADDR) {
+		switch (flashutl_cmd->type) {
+		case AMD:
+			off = AMD_CMD;
+			break;
+		case SST:
+			off = SST_CMD;
+			break;
+		default:
+			off = 0;
+			break;
+		}
+	}
 
 #ifdef MIPSEB
 	off ^= 2;
-#endif
+#endif /* MIPSEB */
 	
-	*(uint16*)(flashutl_base + off) = cmd;
+	flash_writeword(FLASH_ADDR(off), cmd);
 }
 
 static void
@@ -385,7 +405,7 @@
 static int
 flash_poll(unsigned long off, uint16 data)
 {
-	volatile uint16* addr;
+	unsigned long addr;
 	int cnt = FLASH_TRIES;
 	uint16 st;
 
@@ -393,18 +413,18 @@
 
 	if (flashutl_desc->type == AMD || flashutl_desc->type == SST) {
 		/* AMD style poll checkes the address being written */
-		addr = (volatile uint16*)FLASH_ADDR(off);
-		while ((st = *addr) != data && cnt != 0)
+		addr = FLASH_ADDR(off);
+		while ((st = flash_readword(addr)) != data && cnt != 0)
 			cnt--;
 		if (cnt == 0) {
-			DPRINT(("flash_poll: timeout, read 0x%x, expected 0x%x\n", st, data));
+			DPRINT(("flash_poll: timeout, off %lx, read 0x%x, expected 0x%x\n",
+			        off, st, data));
 			return -1;
 		}
 	} else {
 		/* INTEL style poll is at second word of the block being written */
-		addr = (volatile uint16*)FLASH_ADDR(block(off, BLOCK_BASE));
-		addr++;
-		while (((st = *addr) & DONE) == 0 && cnt != 0)
+		addr = FLASH_ADDR(block(off, BLOCK_BASE)+sizeof(uint16));
+		while (((st = flash_readword(addr)) & DONE) == 0 && cnt != 0)
 			cnt--;
 		if (cnt == 0) {
 			DPRINT(("flash_poll: timeout, error status = 0x%x\n", st));
@@ -453,7 +474,6 @@
 		}
 	}
 
-	ASSERT(1);
 	return 0;
 }
 
@@ -464,6 +484,23 @@
 	sysFlashWrite(off, (uchar*)data, len);
 }
 
+void
+nvWriteChars(unsigned char *data, unsigned int len)
+{
+	uint off = flashutl_desc->size - NVRAM_SPACE;
+	int err;
+
+	if (flashutl_cmd->type == SFLASH)
+		err = sflash_commit(sbh, cc, off, len, data);
+	else /* PFLASH */
+		err = flash_write(off, data, len);
+
+	if (err)
+		DPRINT(("nvWriteChars failed\n"));
+	else
+		DPRINT(("nvWriteChars succeeded\n"));
+}
+
 int
 sysFlashErase(uint off, unsigned int numbytes)
 {
@@ -471,14 +508,13 @@
 	int err = 0;
 	
 	if (flashutl_cmd->type == SFLASH) {
-		err = sflash_commit(cc, off, numbytes, NULL);
+		err = sflash_commit(sbh, cc, off, numbytes, NULL);
 	} else {
-		ASSERT(!(off & 1));
 		while (off < end) {
 			err = flash_eraseblk(off);
 			if (err)
 				break;
-			off = flash_block_lim(off);
+			off = block(off, BLOCK_LIM);
 		}
 	}
 
@@ -495,15 +531,14 @@
 {
 	int err;
 	
-	DPRINT(("Writing 0x%x bytes to flash off @0x%x ...\n", (unsigned int)numbytes, off));
+	DPRINT(("Writing 0x%x bytes to flash @0x%x ...\n", (unsigned int)numbytes, off));
 
 	if (flashutl_cmd->type == SFLASH)
-		err = sflash_commit(cc, off, numbytes, src);
+		err = sflash_commit(sbh, cc, off, numbytes, src);
 	else {
-		ASSERT(!(off & 1));
 		if (!sysFlashErase(off, numbytes)) 
 			return 0;
-		err = flash_write(off, (uint16*)src, numbytes);
+		err = flash_write(off, src, numbytes);
 	}
 
 	if (err) 
@@ -517,30 +552,28 @@
 int 
 sysFlashRead(uint off, uchar *buf, uint numbytes)
 {
-	uint read, total_read=0;
-	uint16 *src, *dst;
+	uint read, total_read = 0;
 
 	if (flashutl_cmd->type == SFLASH) {
 		while (numbytes) {
-			read = sflash_read(cc, off, numbytes, buf);
+			read = sflash_read(sbh, cc, off, numbytes, buf);
 			numbytes -= read;
 			buf += read;
 			off += read;
 			total_read += read;
 		}
 	} else {
-		ASSERT(!(off & 1));
-		ASSERT(!(numbytes & 1));
-		
-		src = (uint16*)(flashutl_base + off);
-		dst = (uint16*)buf;
+		ASSERT(!(off & (flashutl_wsz - 1)));
+		ASSERT(!(numbytes & (flashutl_wsz - 1)));
 		
-		while(numbytes) {
-			*dst++ = *src++;
-			numbytes-=2;
-			total_read+=2;
+		while (numbytes) {
+			flash_writeword((unsigned long)buf, flash_readword(FLASH_ADDR(off)));
+			numbytes -= flashutl_wsz;
+			buf += flashutl_wsz;
+			off += flashutl_wsz;
+			total_read += flashutl_wsz;
 		}
 	}
 
-	return(total_read);
+	return (total_read);
 }
--- src/shared.1927/gzip_inflate.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/gzip_inflate.c	2007-11-19 06:40:26.000000000 +0300
@@ -107,6 +107,8 @@
       the two sets of lengths.
  */
 
+/* FILE-CSTYLED */
+
 #ifdef RCSID
 static char rcsid[] = "#Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp #";
 #endif
--- src/shared.1927/hndchipc.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/hndchipc.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,281 @@
+/*
+ * BCM47XX support code for some chipcommon facilities (uart, jtagm)
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
+#include <bcmnvram.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <hndchipc.h>
+#include <hndcpu.h>
+
+/* debug/trace */
+#define	CC_ERROR(args)
+
+#define	CC_MSG(args)
+
+/* interested chipcommon interrupt source
+ *  - GPIO
+ *  - EXTIF
+ *  - ECI
+ *  - PMU
+ *  - UART
+ */
+#define	MAX_CC_INT_SOURCE 5
+
+/* chipc secondary isr info */
+typedef struct {
+	uint intmask;		/* int mask */
+	cc_isr_fn isr;		/* secondary isr handler */
+	void *cbdata;		/* pointer to private data */
+} cc_isr_info_t;
+
+static cc_isr_info_t cc_isr_desc[MAX_CC_INT_SOURCE];
+
+/* chip common intmask */
+static uint32 cc_intmask = 0;
+
+/*
+ * Initializes UART access. The callback function will be called once
+ * per found UART.
+ */
+void
+BCMINITFN(sb_serial_init)(sb_t *sbh, sb_serial_init_fn add)
+{
+	osl_t *osh;
+	void *regs;
+	chipcregs_t *cc;
+	uint32 rev, cap, pll, baud_base, div;
+	uint irq;
+	int i, n;
+
+	osh = sb_osh(sbh);
+
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	/* Determine core revision and capabilities */
+	rev = sbh->ccrev;
+	cap = sbh->cccaps;
+	pll = cap & CC_CAP_PLL_MASK;
+
+	/* Determine IRQ */
+	irq = sb_irq(sbh);
+
+	if (pll == PLL_TYPE1) {
+		/* PLL clock */
+		baud_base = sb_clock_rate(pll,
+		                          R_REG(osh, &cc->clockcontrol_n),
+		                          R_REG(osh, &cc->clockcontrol_m2));
+		div = 1;
+	} else {
+		/* Fixed ALP clock */
+		if (rev >= 11 && rev != 15) {
+			baud_base = sb_alp_clock(sbh);
+			div = 1;
+			/* Turn off UART clock before switching clock source */
+			if (rev >= 21)
+				AND_REG(osh, &cc->corecontrol, ~CC_UARTCLKEN);
+			/* Set the override bit so we don't divide it */
+			OR_REG(osh, &cc->corecontrol, CC_UARTCLKO);
+			if (rev >= 21)
+				OR_REG(osh, &cc->corecontrol, CC_UARTCLKEN);
+		} else if (rev >= 3) {
+			/* Internal backplane clock */
+			baud_base = sb_clock(sbh);
+			div = 2;	/* Minimum divisor */
+			W_REG(osh, &cc->clkdiv,
+			      ((R_REG(osh, &cc->clkdiv) & ~CLKD_UART) | div));
+		} else {
+			/* Fixed internal backplane clock */
+			baud_base = 88000000;
+			div = 48;
+		}
+
+		/* Clock source depends on strapping if UartClkOverride is unset */
+		if ((rev > 0) &&
+		    ((R_REG(osh, &cc->corecontrol) & CC_UARTCLKO) == 0)) {
+			if ((cap & CC_CAP_UCLKSEL) == CC_CAP_UINTCLK) {
+				/* Internal divided backplane clock */
+				baud_base /= div;
+			} else {
+				/* Assume external clock of 1.8432 MHz */
+				baud_base = 1843200;
+			}
+		}
+	}
+
+	/* Add internal UARTs */
+	n = cap & CC_CAP_UARTS_MASK;
+	for (i = 0; i < n; i++) {
+		/* Register offset changed after revision 0 */
+		if (rev)
+			regs = (void *)((ulong) &cc->uart0data + (i * 256));
+		else
+			regs = (void *)((ulong) &cc->uart0data + (i * 8));
+
+		if (add)
+			add(regs, irq, baud_base, 0);
+	}
+}
+
+/*
+ * Initialize jtag master and return handle for
+ * jtag_rwreg. Returns NULL on failure.
+ */
+void *
+sb_jtagm_init(sb_t *sbh, uint clkd, bool exttap)
+{
+	void *regs;
+
+	if ((regs = sb_setcore(sbh, SB_CC, 0)) != NULL) {
+		chipcregs_t *cc = (chipcregs_t *) regs;
+		uint32 tmp;
+
+		/*
+		 * Determine jtagm availability from
+		 * core revision and capabilities.
+		 */
+
+		/*
+		 * Corerev 10 has jtagm, but the only chip
+		 * with it does not have a mips, and
+		 * the layout of the jtagcmd register is
+		 * different. We'll only accept >= 11.
+		 */
+		if (sbh->ccrev < 11)
+			return (NULL);
+
+		if ((sbh->cccaps & CC_CAP_JTAGP) == 0)
+			return (NULL);
+
+		/* Set clock divider if requested */
+		if (clkd != 0) {
+			tmp = R_REG(osh, &cc->clkdiv);
+			tmp = (tmp & ~CLKD_JTAG) |
+				((clkd << CLKD_JTAG_SHIFT) & CLKD_JTAG);
+			W_REG(osh, &cc->clkdiv, tmp);
+		}
+
+		/* Enable jtagm */
+		tmp = JCTRL_EN | (exttap ? JCTRL_EXT_EN : 0);
+		W_REG(osh, &cc->jtagctrl, tmp);
+	}
+
+	return (regs);
+}
+
+void
+sb_jtagm_disable(osl_t *osh, void *h)
+{
+	chipcregs_t *cc = (chipcregs_t *)h;
+
+	W_REG(osh, &cc->jtagctrl, R_REG(osh, &cc->jtagctrl) & ~JCTRL_EN);
+}
+
+/*
+ * Read/write a jtag register. Assumes a target with
+ * 8 bit IR and 32 bit DR.
+ */
+#define	IRWIDTH		8	/* Default Instruction Register width */
+#define	DRWIDTH		32	/* Default Data Register width */
+
+uint32
+jtag_rwreg(osl_t *osh, void *h, uint32 ir, uint32 dr)
+{
+	chipcregs_t *cc = (chipcregs_t *) h;
+	uint32 tmp;
+
+	W_REG(osh, &cc->jtagir, ir);
+	W_REG(osh, &cc->jtagdr, dr);
+	tmp = JCMD_START | JCMD_ACC_IRDR |
+		((IRWIDTH - 1) << JCMD_IRW_SHIFT) |
+		(DRWIDTH - 1);
+	W_REG(osh, &cc->jtagcmd, tmp);
+	while (((tmp = R_REG(osh, &cc->jtagcmd)) & JCMD_BUSY) == JCMD_BUSY) {
+		/* OSL_DELAY(1); */
+	}
+
+	tmp = R_REG(osh, &cc->jtagdr);
+	return (tmp);
+}
+
+
+/*
+ * Interface to register chipc secondary isr
+ */
+
+bool
+BCMINITFN(sb_cc_register_isr)(sb_t *sbh, cc_isr_fn isr, uint32 ccintmask, void *cbdata)
+{
+	bool done = FALSE;
+	chipcregs_t *regs;
+	uint origidx;
+	uint i;
+
+	/* Save the current core index */
+	origidx = sb_coreidx(sbh);
+	regs = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(regs);
+
+	for (i = 0; i < MAX_CC_INT_SOURCE; i++) {
+		if (cc_isr_desc[i].isr == NULL) {
+			cc_isr_desc[i].isr = isr;
+			cc_isr_desc[i].cbdata = cbdata;
+			cc_isr_desc[i].intmask = ccintmask;
+			done = TRUE;
+			break;
+		}
+	}
+
+	if (done) {
+		cc_intmask = R_REG(sb_osh(sbh), &regs->intmask);
+		cc_intmask |= ccintmask;
+		W_REG(sb_osh(sbh), &regs->intmask, cc_intmask);
+	}
+
+	/* restore original coreidx */
+	sb_setcoreidx(sbh, origidx);
+	return done;
+}
+
+/* 
+ * chipc primary interrupt handler
+ *
+ */
+
+void
+sb_cc_isr(sb_t *sbh, chipcregs_t *regs)
+{
+	uint32 ccintstatus;
+	uint32 intstatus;
+	uint32 i;
+
+	/* prior to rev 21 chipc interrupt means uart and gpio */
+	if (sbh->ccrev >= 21)
+		ccintstatus = R_REG(sb_osh(sbh), &regs->intstatus) & cc_intmask;
+	else
+		ccintstatus = (CI_UART | CI_GPIO);
+
+	for (i = 0; i < MAX_CC_INT_SOURCE; i ++) {
+		if ((cc_isr_desc[i].isr != NULL) &&
+		    (intstatus = (cc_isr_desc[i].intmask & ccintstatus))) {
+			(cc_isr_desc[i].isr)(cc_isr_desc[i].cbdata, intstatus);
+		}
+	}
+}
--- src/shared.1927/hnddma.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/hnddma.c	2007-11-19 06:40:26.000000000 +0300
@@ -14,64 +14,95 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
 #include <bcmendian.h>
 #include <sbconfig.h>
 #include <bcmutils.h>
+#include <bcmdevs.h>
+#include <sbutils.h>
 
-struct dma_info;	/* forward declaration */
-#define di_t struct dma_info
+#include <sbhnddma.h>
 #include <hnddma.h>
 
 /* debug/trace */
 #define DMA_ERROR(args)
 #define	DMA_TRACE(args)
 
-/* default dma message level(if input msg_level pointer is null in dma_attach()) */
-static uint dma_msg_level = 0;
+/* default dma message level (if input msg_level pointer is null in dma_attach()) */
+static uint dma_msg_level =
+	0;
 
-#define	MAXNAMEL	8
-#define	MAXDD		(DMAMAXRINGSZ / sizeof (dmadd_t))
+#define	MAXNAMEL	8		/* 8 char names */
+
+#define	DI_INFO(dmah)	(dma_info_t *)dmah
 
 /* dma engine software state */
 typedef struct dma_info {
-	hnddma_t	hnddma;		/* exported structure */
+	struct hnddma_pub hnddma;	/* exported structure, don't use hnddma_t,
+					 * which could be const
+					 */
 	uint		*msg_level;	/* message level pointer */
-
 	char		name[MAXNAMEL];	/* callers name for diag msgs */
-	void		*drv;		/* driver handle */
+
 	void		*osh;		/* os handle */
-	dmaregs_t	*regs;		/* dma engine registers */
+	sb_t		*sbh;		/* sb handle */
 
-	dmadd_t		*txd;		/* pointer to chip-specific tx descriptor ring */
+	bool		dma64;		/* dma64 enabled */
+	bool		addrext;	/* this dma engine supports DmaExtendedAddrChanges */
+
+	dma32regs_t	*d32txregs;	/* 32 bits dma tx engine registers */
+	dma32regs_t	*d32rxregs;	/* 32 bits dma rx engine registers */
+	dma64regs_t	*d64txregs;	/* 64 bits dma tx engine registers */
+	dma64regs_t	*d64rxregs;	/* 64 bits dma rx engine registers */
+
+	uint32		dma64align;	/* either 8k or 4k depends on number of dd */
+	dma32dd_t	*txd32;		/* pointer to dma32 tx descriptor ring */
+	dma64dd_t	*txd64;		/* pointer to dma64 tx descriptor ring */
+	uint		ntxd;		/* # tx descriptors tunable */
 	uint		txin;		/* index of next descriptor to reclaim */
 	uint		txout;		/* index of next descriptor to post */
-	uint		txavail;	/* # free tx descriptors */
 	void		**txp;		/* pointer to parallel array of pointers to packets */
+	osldma_t 	*tx_dmah;	/* DMA TX descriptor ring handle */
+	osldma_t	**txp_dmah;	/* DMA TX packet data handle */
 	ulong		txdpa;		/* physical address of descriptor ring */
 	uint		txdalign;	/* #bytes added to alloc'd mem to align txd */
 	uint		txdalloc;	/* #bytes allocated for the ring */
 
-	dmadd_t		*rxd;		/* pointer to chip-specific rx descriptor ring */
+	dma32dd_t	*rxd32;		/* pointer to dma32 rx descriptor ring */
+	dma64dd_t	*rxd64;		/* pointer to dma64 rx descriptor ring */
+	uint		nrxd;		/* # rx descriptors tunable */
 	uint		rxin;		/* index of next descriptor to reclaim */
 	uint		rxout;		/* index of next descriptor to post */
 	void		**rxp;		/* pointer to parallel array of pointers to packets */
+	osldma_t 	*rx_dmah;	/* DMA RX descriptor ring handle */
+	osldma_t	**rxp_dmah;	/* DMA RX packet data handle */
 	ulong		rxdpa;		/* physical address of descriptor ring */
 	uint		rxdalign;	/* #bytes added to alloc'd mem to align rxd */
 	uint		rxdalloc;	/* #bytes allocated for the ring */
 
 	/* tunables */
-	uint		ntxd;		/* # tx descriptors */
-	uint		nrxd;		/* # rx descriptors */
-	uint		rxbufsize;	/* rx buffer size in bytes */
+	uint		rxbufsize;	/* rx buffer size in bytes,
+					   not including the extra headroom
+					*/
 	uint		nrxpost;	/* # rx buffers to keep posted */
 	uint		rxoffset;	/* rxcontrol offset */
-	uint		ddoffset;	/* add to get dma address of descriptor ring */
-	uint		dataoffset;	/* add to get dma address of data buffer */
+	uint		ddoffsetlow;	/* add to get dma address of descriptor ring, low 32 bits */
+	uint		ddoffsethigh;	/*   high 32 bits */
+	uint		dataoffsetlow;	/* add to get dma address of data buffer, low 32 bits */
+	uint		dataoffsethigh;	/*   high 32 bits */
 } dma_info_t;
 
+#ifdef BCMDMA64
+#define	DMA64_ENAB(di)	((di)->dma64)
+#define DMA64_CAP	TRUE
+#else
+#define	DMA64_ENAB(di)	(0)
+#define DMA64_CAP	FALSE
+#endif
+
 /* descriptor bumping macros */
-#define	XXD(x, n)	((x) & ((n) - 1))
+#define	XXD(x, n)	((x) & ((n) - 1))	/* faster than %, but n must be power of 2 */
 #define	TXD(x)		XXD((x), di->ntxd)
 #define	RXD(x)		XXD((x), di->nrxd)
 #define	NEXTTXD(i)	TXD(i + 1)
@@ -81,118 +112,452 @@
 #define	NRXDACTIVE(h, t)	RXD(t - h)
 
 /* macros to convert between byte offsets and indexes */
-#define	B2I(bytes)	((bytes) / sizeof (dmadd_t))
-#define	I2B(index)	((index) * sizeof (dmadd_t))
+#define	B2I(bytes, type)	((bytes) / sizeof(type))
+#define	I2B(index, type)	((index) * sizeof(type))
 
-/*
- * This assume the largest i/o address is, in fact, the pci big window
- * and that the pci core sb2pcitranslation2 register has been left with
- * the default 0x0 pci base address.
- */
-#define	MAXDMAADDR		SB_PCI_DMA_SZ
-#define	DMA_ADDRESSABLE(x)	!((x) & ~(MAXDMAADDR - 1))
-
-/* prototypes */
-
-void* 
-dma_attach(void *drv, void *osh, char *name, dmaregs_t *regs, uint ntxd, uint nrxd,
-	uint rxbufsize, uint nrxpost, uint rxoffset, uint ddoffset, uint dataoffset, uint *msg_level)
+#define	PCI32ADDR_HIGH		0xc0000000	/* address[31:30] */
+#define	PCI32ADDR_HIGH_SHIFT	30		/* address[31:30] */
+
+
+/* common prototypes */
+static bool _dma_isaddrext(dma_info_t *di);
+static bool _dma_alloc(dma_info_t *di, uint direction);
+static void _dma_detach(dma_info_t *di);
+static void _dma_ddtable_init(dma_info_t *di, uint direction, ulong pa);
+static void _dma_rxinit(dma_info_t *di);
+static void *_dma_rx(dma_info_t *di);
+static void _dma_rxfill(dma_info_t *di);
+static void _dma_rxreclaim(dma_info_t *di);
+static void _dma_rxenable(dma_info_t *di);
+static void * _dma_getnextrxp(dma_info_t *di, bool forceall);
+
+static void _dma_txblock(dma_info_t *di);
+static void _dma_txunblock(dma_info_t *di);
+static uint _dma_txactive(dma_info_t *di);
+
+static void* _dma_peeknexttxp(dma_info_t *di);
+static uintptr _dma_getvar(dma_info_t *di, const char *name);
+static void _dma_counterreset(dma_info_t *di);
+static void _dma_fifoloopbackenable(dma_info_t *di);
+
+/* ** 32 bit DMA prototypes */
+static bool dma32_alloc(dma_info_t *di, uint direction);
+static bool dma32_txreset(dma_info_t *di);
+static bool dma32_rxreset(dma_info_t *di);
+static bool dma32_txsuspendedidle(dma_info_t *di);
+static int  dma32_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma32_getnexttxp(dma_info_t *di, bool forceall);
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall);
+static void dma32_txrotate(dma_info_t *di);
+static bool dma32_rxidle(dma_info_t *di);
+static void dma32_txinit(dma_info_t *di);
+static bool dma32_txenabled(dma_info_t *di);
+static void dma32_txsuspend(dma_info_t *di);
+static void dma32_txresume(dma_info_t *di);
+static bool dma32_txsuspended(dma_info_t *di);
+static void dma32_txreclaim(dma_info_t *di, bool forceall);
+static bool dma32_txstopped(dma_info_t *di);
+static bool dma32_rxstopped(dma_info_t *di);
+static bool dma32_rxenabled(dma_info_t *di);
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs);
+
+/* ** 64 bit DMA prototypes and stubs */
+#ifdef BCMDMA64
+static bool dma64_alloc(dma_info_t *di, uint direction);
+static bool dma64_txreset(dma_info_t *di);
+static bool dma64_rxreset(dma_info_t *di);
+static bool dma64_txsuspendedidle(dma_info_t *di);
+static int  dma64_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma64_getnexttxp(dma_info_t *di, bool forceall);
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall);
+static void dma64_txrotate(dma_info_t *di);
+
+static bool dma64_rxidle(dma_info_t *di);
+static void dma64_txinit(dma_info_t *di);
+static bool dma64_txenabled(dma_info_t *di);
+static void dma64_txsuspend(dma_info_t *di);
+static void dma64_txresume(dma_info_t *di);
+static bool dma64_txsuspended(dma_info_t *di);
+static void dma64_txreclaim(dma_info_t *di, bool forceall);
+static bool dma64_txstopped(dma_info_t *di);
+static bool dma64_rxstopped(dma_info_t *di);
+static bool dma64_rxenabled(dma_info_t *di);
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
+
+#else
+static bool dma64_alloc(dma_info_t *di, uint direction) { return FALSE; }
+static bool dma64_txreset(dma_info_t *di) { return FALSE; }
+static bool dma64_rxreset(dma_info_t *di) { return FALSE; }
+static bool dma64_txsuspendedidle(dma_info_t *di) { return FALSE;}
+static int  dma64_txfast(dma_info_t *di, void *p0, bool commit) { return 0; }
+static void *dma64_getnexttxp(dma_info_t *di, bool forceall) { return NULL; }
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall) { return NULL; }
+static void dma64_txrotate(dma_info_t *di) { return; }
+
+static bool dma64_rxidle(dma_info_t *di) { return FALSE; }
+static void dma64_txinit(dma_info_t *di) { return; }
+static bool dma64_txenabled(dma_info_t *di) { return FALSE; }
+static void dma64_txsuspend(dma_info_t *di) { return; }
+static void dma64_txresume(dma_info_t *di) { return; }
+static bool dma64_txsuspended(dma_info_t *di) {return FALSE; }
+static void dma64_txreclaim(dma_info_t *di, bool forceall) { return; }
+static bool dma64_txstopped(dma_info_t *di) { return FALSE; }
+static bool dma64_rxstopped(dma_info_t *di) { return FALSE; }
+static bool dma64_rxenabled(dma_info_t *di) { return FALSE; }
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs) { return FALSE; }
+
+#endif	/* BCMDMA64 */
+
+
+
+static di_fcn_t dma64proc = {
+	(di_detach_t)_dma_detach,
+	(di_txinit_t)dma64_txinit,
+	(di_txreset_t)dma64_txreset,
+	(di_txenabled_t)dma64_txenabled,
+	(di_txsuspend_t)dma64_txsuspend,
+	(di_txresume_t)dma64_txresume,
+	(di_txsuspended_t)dma64_txsuspended,
+	(di_txsuspendedidle_t)dma64_txsuspendedidle,
+	(di_txfast_t)dma64_txfast,
+	(di_txstopped_t)dma64_txstopped,
+	(di_txreclaim_t)dma64_txreclaim,
+	(di_getnexttxp_t)dma64_getnexttxp,
+	(di_peeknexttxp_t)_dma_peeknexttxp,
+	(di_txblock_t)_dma_txblock,
+	(di_txunblock_t)_dma_txunblock,
+	(di_txactive_t)_dma_txactive,
+	(di_txrotate_t)dma64_txrotate,
+
+	(di_rxinit_t)_dma_rxinit,
+	(di_rxreset_t)dma64_rxreset,
+	(di_rxidle_t)dma64_rxidle,
+	(di_rxstopped_t)dma64_rxstopped,
+	(di_rxenable_t)_dma_rxenable,
+	(di_rxenabled_t)dma64_rxenabled,
+	(di_rx_t)_dma_rx,
+	(di_rxfill_t)_dma_rxfill,
+	(di_rxreclaim_t)_dma_rxreclaim,
+	(di_getnextrxp_t)_dma_getnextrxp,
+
+	(di_fifoloopbackenable_t)_dma_fifoloopbackenable,
+	(di_getvar_t)_dma_getvar,
+	(di_counterreset_t)_dma_counterreset,
+
+	NULL,
+	NULL,
+	NULL,
+	34
+};
+
+static di_fcn_t dma32proc = {
+	(di_detach_t)_dma_detach,
+	(di_txinit_t)dma32_txinit,
+	(di_txreset_t)dma32_txreset,
+	(di_txenabled_t)dma32_txenabled,
+	(di_txsuspend_t)dma32_txsuspend,
+	(di_txresume_t)dma32_txresume,
+	(di_txsuspended_t)dma32_txsuspended,
+	(di_txsuspendedidle_t)dma32_txsuspendedidle,
+	(di_txfast_t)dma32_txfast,
+	(di_txstopped_t)dma32_txstopped,
+	(di_txreclaim_t)dma32_txreclaim,
+	(di_getnexttxp_t)dma32_getnexttxp,
+	(di_peeknexttxp_t)_dma_peeknexttxp,
+	(di_txblock_t)_dma_txblock,
+	(di_txunblock_t)_dma_txunblock,
+	(di_txactive_t)_dma_txactive,
+	(di_txrotate_t)dma32_txrotate,
+
+	(di_rxinit_t)_dma_rxinit,
+	(di_rxreset_t)dma32_rxreset,
+	(di_rxidle_t)dma32_rxidle,
+	(di_rxstopped_t)dma32_rxstopped,
+	(di_rxenable_t)_dma_rxenable,
+	(di_rxenabled_t)dma32_rxenabled,
+	(di_rx_t)_dma_rx,
+	(di_rxfill_t)_dma_rxfill,
+	(di_rxreclaim_t)_dma_rxreclaim,
+	(di_getnextrxp_t)_dma_getnextrxp,
+
+	(di_fifoloopbackenable_t)_dma_fifoloopbackenable,
+	(di_getvar_t)_dma_getvar,
+	(di_counterreset_t)_dma_counterreset,
+
+	NULL,
+	NULL,
+	NULL,
+	34
+};
+
+hnddma_t *
+dma_attach(osl_t *osh, char *name, sb_t *sbh, void *dmaregstx, void *dmaregsrx,
+           uint ntxd, uint nrxd, uint rxbufsize, uint nrxpost, uint rxoffset, uint *msg_level)
 {
 	dma_info_t *di;
 	uint size;
-	void *va;
-
-	ASSERT(ntxd <= MAXDD);
-	ASSERT(ISPOWEROF2(ntxd));
-	ASSERT(nrxd <= MAXDD);
-	ASSERT(ISPOWEROF2(nrxd));
 
 	/* allocate private info structure */
 	if ((di = MALLOC(osh, sizeof (dma_info_t))) == NULL) {
 		return (NULL);
 	}
-	bzero((char*)di, sizeof (dma_info_t));
+	bzero((char *)di, sizeof(dma_info_t));
 
-	/* allocate tx packet pointer vector */
-	if (ntxd) {
-		size = ntxd * sizeof (void*);
-		if ((di->txp = MALLOC(osh, size)) == NULL)
-			goto fail;
-		bzero((char*)di->txp, size);
-	}
+	di->msg_level = msg_level ? msg_level : &dma_msg_level;
 
-	/* allocate rx packet pointer vector */
-	if (nrxd) {
-		size = nrxd * sizeof (void*);
-		if ((di->rxp = MALLOC(osh, size)) == NULL)
+	/* old chips w/o sb is no longer supported */
+	ASSERT(sbh != NULL);
+
+	di->dma64 = ((sb_coreflagshi(sbh, 0, 0) & SBTMH_DMA64) == SBTMH_DMA64);
+
+#ifndef BCMDMA64
+	if (di->dma64) {
+		DMA_ERROR(("dma_attach: driver doesn't have the capability to support "
+		           "64 bits DMA\n"));
 			goto fail;
-		bzero((char*)di->rxp, size);
 	}
+#endif
 
-	/* set message level */
-	di->msg_level = msg_level ? msg_level : &dma_msg_level;
+	/* check arguments */
+	ASSERT(ISPOWEROF2(ntxd));
+	ASSERT(ISPOWEROF2(nrxd));
+	if (nrxd == 0)
+		ASSERT(dmaregsrx == NULL);
+	if (ntxd == 0)
+		ASSERT(dmaregstx == NULL);
+
+
+	/* init dma reg pointer */
+	if (di->dma64) {
+		ASSERT(ntxd <= D64MAXDD);
+		ASSERT(nrxd <= D64MAXDD);
+		di->d64txregs = (dma64regs_t *)dmaregstx;
+		di->d64rxregs = (dma64regs_t *)dmaregsrx;
+
+		di->dma64align = D64RINGALIGN;
+		if ((ntxd < D64MAXDD / 2) && (nrxd < D64MAXDD / 2)) {
+			/* for smaller dd table, HW relax the alignment requirement */
+			di->dma64align = D64RINGALIGN / 2;
+		}
+	} else {
+		ASSERT(ntxd <= D32MAXDD);
+		ASSERT(nrxd <= D32MAXDD);
+		di->d32txregs = (dma32regs_t *)dmaregstx;
+		di->d32rxregs = (dma32regs_t *)dmaregsrx;
+	}
 
-	DMA_TRACE(("%s: dma_attach: drv %p osh %p regs %p ntxd %d nrxd %d rxbufsize %d nrxpost %d rxoffset %d ddoffset 0x%x dataoffset 0x%x\n", name, drv, osh, regs, ntxd, nrxd, rxbufsize, nrxpost, rxoffset, ddoffset, dataoffset));
+	DMA_TRACE(("%s: dma_attach: %s osh %p ntxd %d nrxd %d rxbufsize %d nrxpost %d "
+	           "rxoffset %d dmaregstx %p dmaregsrx %p\n",
+	           name, (di->dma64 ? "DMA64" : "DMA32"), osh, ntxd, nrxd, rxbufsize,
+	           nrxpost, rxoffset, dmaregstx, dmaregsrx));
 
 	/* make a private copy of our callers name */
 	strncpy(di->name, name, MAXNAMEL);
 	di->name[MAXNAMEL-1] = '\0';
 
-	di->drv = drv;
 	di->osh = osh;
-	di->regs = regs;
+	di->sbh = sbh;
+
+	/* save tunables */
+	di->ntxd = ntxd;
+	di->nrxd = nrxd;
 
-	/* allocate transmit descriptor ring */
+	/* the actual dma size doesn't include the extra headroom */
+	if (rxbufsize > BCMEXTRAHDROOM)
+		di->rxbufsize = rxbufsize - BCMEXTRAHDROOM;
+	else
+		di->rxbufsize = rxbufsize;
+
+	di->nrxpost = nrxpost;
+	di->rxoffset = rxoffset;
+
+	/*
+	 * figure out the DMA physical address offset for dd and data
+	 *   for old chips w/o sb, use zero
+	 *   for new chips w sb,
+	 *     PCI/PCIE: they map silicon backplace address to zero based memory, need offset
+	 *     Other bus: use zero
+	 *     SB_BUS BIGENDIAN kludge: use sdram swapped region for data buffer, not descriptor
+	 */
+	di->ddoffsetlow = 0;
+	di->dataoffsetlow = 0;
+	/* for pci bus, add offset */
+	if (sbh->bustype == PCI_BUS) {
+		if ((sbh->buscoretype == SB_PCIE) && di->dma64) {
+			/* pcie with DMA64 */
+			di->ddoffsetlow = 0;
+			di->ddoffsethigh = SB_PCIE_DMA_H32;
+		} else {
+			/* pci(DMA32/DMA64) or pcie with DMA32 */
+			di->ddoffsetlow = SB_PCI_DMA;
+			di->ddoffsethigh = 0;
+		}
+		di->dataoffsetlow =  di->ddoffsetlow;
+		di->dataoffsethigh =  di->ddoffsethigh;
+	}
+
+#if defined(__mips__) && defined(IL_BIGENDIAN)
+	di->dataoffsetlow = di->dataoffsetlow + SB_SDRAM_SWAPPED;
+#endif
+
+	di->addrext = _dma_isaddrext(di);
+
+	/* allocate tx packet pointer vector */
 	if (ntxd) {
-		/* only need ntxd descriptors but it must be DMARINGALIGNed */
-		size = ntxd * sizeof (dmadd_t);
-		if (!ISALIGNED(DMA_CONSISTENT_ALIGN, DMARINGALIGN))
-			size += DMARINGALIGN;
-		if ((va = DMA_ALLOC_CONSISTENT(osh, size, &di->txdpa)) == NULL)
+		size = ntxd * sizeof(void *);
+		if ((di->txp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of tx memory, malloced %d bytes\n",
+			           di->name, MALLOCED(osh)));
 			goto fail;
-		di->txd = (dmadd_t*) ROUNDUP((uintptr)va, DMARINGALIGN);
-		di->txdalign = (uint)((int8*)di->txd - (int8*)va);
-		di->txdpa += di->txdalign;
-		di->txdalloc = size;
-		ASSERT(ISALIGNED((uintptr)di->txd, DMARINGALIGN));
-		ASSERT(DMA_ADDRESSABLE(di->txdpa));
+		}
+		bzero((char *)di->txp, size);
 	}
 
-	/* allocate receive descriptor ring */
+	/* allocate rx packet pointer vector */
 	if (nrxd) {
-		/* only need nrxd descriptors but it must be DMARINGALIGNed */
-		size = nrxd * sizeof (dmadd_t);
-		if (!ISALIGNED(DMA_CONSISTENT_ALIGN, DMARINGALIGN))
-			size += DMARINGALIGN;
-		if ((va = DMA_ALLOC_CONSISTENT(osh, size, &di->rxdpa)) == NULL)
+		size = nrxd * sizeof(void *);
+		if ((di->rxp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of rx memory, malloced %d bytes\n",
+			           di->name, MALLOCED(osh)));
 			goto fail;
-		di->rxd = (dmadd_t*) ROUNDUP((uintptr)va, DMARINGALIGN);
-		di->rxdalign = (uint)((int8*)di->rxd - (int8*)va);
-		di->rxdpa += di->rxdalign;
-		di->rxdalloc = size;
-		ASSERT(ISALIGNED((uintptr)di->rxd, DMARINGALIGN));
-		ASSERT(DMA_ADDRESSABLE(di->rxdpa));
+		}
+		bzero((char *)di->rxp, size);
 	}
 
-	/* save tunables */
-	di->ntxd = ntxd;
-	di->nrxd = nrxd;
-	di->rxbufsize = rxbufsize;
-	di->nrxpost = nrxpost;
-	di->rxoffset = rxoffset;
-	di->ddoffset = ddoffset;
-	di->dataoffset = dataoffset;
+	/* allocate transmit descriptor ring, only need ntxd descriptors but it must be aligned */
+	if (ntxd) {
+		if (!_dma_alloc(di, DMA_TX))
+			goto fail;
+	}
+
+	/* allocate receive descriptor ring, only need nrxd descriptors but it must be aligned */
+	if (nrxd) {
+		if (!_dma_alloc(di, DMA_RX))
+			goto fail;
+	}
+
+	if ((di->ddoffsetlow == SB_PCI_DMA) && (di->txdpa > SB_PCI_DMA_SZ) && !di->addrext) {
+		DMA_ERROR(("%s: dma_attach: txdpa 0x%lx: addrext not supported\n",
+		           di->name, di->txdpa));
+		goto fail;
+	}
+	if ((di->ddoffsetlow == SB_PCI_DMA) && (di->rxdpa > SB_PCI_DMA_SZ) && !di->addrext) {
+		DMA_ERROR(("%s: dma_attach: rxdpa 0x%lx: addrext not supported\n",
+		           di->name, di->rxdpa));
+		goto fail;
+	}
+
+	DMA_TRACE(("ddoffsetlow 0x%x ddoffsethigh 0x%x dataoffsetlow 0x%x dataoffsethigh "
+	           "0x%x addrext %d\n", di->ddoffsetlow, di->ddoffsethigh, di->dataoffsetlow,
+	           di->dataoffsethigh, di->addrext));
+
+	/* allocate tx packet pointer vector and DMA mapping vectors */
+	if (ntxd) {
+
+		size = ntxd * sizeof(osldma_t **);
+		if ((di->txp_dmah = (osldma_t **)MALLOC(osh, size)) == NULL)
+			goto fail;
+		bzero((char*)di->txp_dmah, size);
+	}else
+		di->txp_dmah = NULL;
+
+	/* allocate rx packet pointer vector and DMA mapping vectors */
+	if (nrxd) {
+
+		size = nrxd * sizeof(osldma_t **);
+		if ((di->rxp_dmah = (osldma_t **)MALLOC(osh, size)) == NULL)
+			goto fail;
+		bzero((char*)di->rxp_dmah, size);
 
-	return ((void*)di);
+	}else
+		di->rxp_dmah = NULL;
+
+	/* initialize opsvec of function pointers */
+	di->hnddma.di_fn = DMA64_ENAB(di) ? dma64proc : dma32proc;
+
+	return ((hnddma_t *)di);
 
 fail:
-	dma_detach((void*)di);
+	_dma_detach(di);
 	return (NULL);
 }
 
-/* may be called with core in reset */
-void
-dma_detach(dma_info_t *di)
+/* init the tx or rx descriptor */
+static INLINE void
+dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, ulong pa, uint outidx, uint32 *flags,
+             uint32 bufcount)
+{
+	/* dma32 uses 32 bits control to fit both flags and bufcounter */
+	*flags = *flags | (bufcount & CTRL_BC_MASK);
+
+	if ((di->dataoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+		W_SM(&ddring[outidx].addr, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	} else {
+		/* address extension */
+		uint32 ae;
+		ASSERT(di->addrext);
+		ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		pa &= ~PCI32ADDR_HIGH;
+
+		*flags |= (ae << CTRL_AE_SHIFT);
+		W_SM(&ddring[outidx].addr, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	}
+}
+
+static INLINE void
+dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, ulong pa, uint outidx, uint32 *flags,
+             uint32 bufcount)
+{
+	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
+
+	/* PCI bus with big(>1G) physical address, use address extension */
+	if ((di->dataoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+		W_SM(&ddring[outidx].addrlow, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh, BUS_SWAP32(0 + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	} else {
+		/* address extension */
+		uint32 ae;
+		ASSERT(di->addrext);
+
+		ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		pa &= ~PCI32ADDR_HIGH;
+
+		ctrl2 |= (ae << D64_CTRL2_AE_SHIFT) & D64_CTRL2_AE;
+		W_SM(&ddring[outidx].addrlow, BUS_SWAP32(pa + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh, BUS_SWAP32(0 + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	}
+}
+
+static bool
+_dma32_addrext(osl_t *osh, dma32regs_t *dma32regs)
+{
+	uint32 w;
+
+	OR_REG(osh, &dma32regs->control, XC_AE);
+	w = R_REG(osh, &dma32regs->control);
+	AND_REG(osh, &dma32regs->control, ~XC_AE);
+	return ((w & XC_AE) == XC_AE);
+}
+
+static bool
+_dma_alloc(dma_info_t *di, uint direction)
+{
+	if (DMA64_ENAB(di)) {
+		return dma64_alloc(di, direction);
+	} else {
+		return dma32_alloc(di, direction);
+	}
+}
+
+/* !! may be called with core in reset */
+static void
+_dma_detach(dma_info_t *di)
 {
 	if (di == NULL)
 		return;
@@ -204,331 +569,1089 @@
 	ASSERT(di->rxin == di->rxout);
 
 	/* free dma descriptor rings */
-	if (di->txd)
-		DMA_FREE_CONSISTENT(di->osh, ((int8*)di->txd - di->txdalign),
-			di->txdalloc, (di->txdpa - di->txdalign));
-	if (di->rxd)
-		DMA_FREE_CONSISTENT(di->osh, ((int8*)di->rxd - di->rxdalign),
-			di->rxdalloc, (di->rxdpa - di->rxdalign));
+	if (DMA64_ENAB(di)) {
+		if (di->txd64)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->txd64 - di->txdalign),
+			                    di->txdalloc, (di->txdpa - di->txdalign), &di->tx_dmah);
+		if (di->rxd64)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->rxd64 - di->rxdalign),
+			                    di->rxdalloc, (di->rxdpa - di->rxdalign), &di->rx_dmah);
+	} else {
+		if (di->txd32)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->txd32 - di->txdalign),
+			                    di->txdalloc, (di->txdpa - di->txdalign), &di->tx_dmah);
+		if (di->rxd32)
+			DMA_FREE_CONSISTENT(di->osh, ((int8*)(uintptr)di->rxd32 - di->rxdalign),
+			                    di->rxdalloc, (di->rxdpa - di->rxdalign), &di->rx_dmah);
+	}
 
 	/* free packet pointer vectors */
 	if (di->txp)
-		MFREE(di->osh, (void*)di->txp, (di->ntxd * sizeof (void*)));
+		MFREE(di->osh, (void *)di->txp, (di->ntxd * sizeof(void *)));
 	if (di->rxp)
-		MFREE(di->osh, (void*)di->rxp, (di->nrxd * sizeof (void*)));
+		MFREE(di->osh, (void *)di->rxp, (di->nrxd * sizeof(void *)));
+
+	/* free tx packet DMA handles */
+	if (di->txp_dmah)
+		MFREE(di->osh, (void *)di->txp_dmah, di->ntxd * sizeof(osldma_t **));
+
+	/* free rx packet DMA handles */
+	if (di->rxp_dmah)
+		MFREE(di->osh, (void *)di->rxp_dmah, di->nrxd * sizeof(osldma_t **));
 
 	/* free our private info structure */
-	MFREE(di->osh, (void*)di, sizeof (dma_info_t));
+	MFREE(di->osh, (void *)di, sizeof(dma_info_t));
+
 }
 
+/* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
+static bool
+_dma_isaddrext(dma_info_t *di)
+{
+	if (DMA64_ENAB(di)) {
+		/* DMA64 supports full 32 bits or 64 bits. AE is always valid */
 
-void
-dma_txreset(dma_info_t *di)
+		/* not all tx or rx channel are available */
+		if (di->d64txregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64txregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 tx doesn't have AE set\n",
+					di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		} else if (di->d64rxregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64rxregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 rx doesn't have AE set\n",
+					di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		}
+		return FALSE;
+	} else if (di->d32txregs)
+		return (_dma32_addrext(di->osh, di->d32txregs));
+	else if (di->d32rxregs)
+		return (_dma32_addrext(di->osh, di->d32rxregs));
+	return FALSE;
+}
+
+/* initialize descriptor table base address */
+static void
+_dma_ddtable_init(dma_info_t *di, uint direction, ulong pa)
+{
+	if (DMA64_ENAB(di)) {
+
+		if ((di->ddoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh, di->ddoffsethigh);
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh, di->ddoffsethigh);
+			}
+		} else {
+			/* DMA64 32bits address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+			pa &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh, di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64txregs->control, D64_XC_AE,
+					(ae << D64_XC_AE_SHIFT));
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow, (pa + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh, di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64rxregs->control, D64_RC_AE,
+					(ae << D64_RC_AE_SHIFT));
+			}
+		}
+
+	} else {
+		if ((di->ddoffsetlow != SB_PCI_DMA) || !(pa & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX)
+				W_REG(di->osh, &di->d32txregs->addr, (pa + di->ddoffsetlow));
+			else
+				W_REG(di->osh, &di->d32rxregs->addr, (pa + di->ddoffsetlow));
+		} else {
+			/* dma32 address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (pa & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+			pa &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d32txregs->addr, (pa + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32txregs->control, XC_AE, ae <<XC_AE_SHIFT);
+			} else {
+				W_REG(di->osh, &di->d32rxregs->addr, (pa + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32rxregs->control, RC_AE, ae <<RC_AE_SHIFT);
+			}
+		}
+	}
+}
+
+static void
+_dma_fifoloopbackenable(dma_info_t *di)
 {
-	uint32 status;
+	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
+	if (DMA64_ENAB(di))
+		OR_REG(di->osh, &di->d64txregs->control, D64_XC_LE);
+	else
+		OR_REG(di->osh, &di->d32txregs->control, XC_LE);
+}
 
-	DMA_TRACE(("%s: dma_txreset\n", di->name));
+static void
+_dma_rxinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxinit\n", di->name));
 
-	/* suspend tx DMA first */
-	W_REG(&di->regs->xmtcontrol, XC_SE);
-	SPINWAIT((status = (R_REG(&di->regs->xmtstatus) & XS_XS_MASK)) != XS_XS_DISABLED &&
-		 status != XS_XS_IDLE &&
-		 status != XS_XS_STOPPED,
-		 10000);
+	if (di->nrxd == 0)
+		return;
 
-	W_REG(&di->regs->xmtcontrol, 0);
-	SPINWAIT((status = (R_REG(&di->regs->xmtstatus) & XS_XS_MASK)) != XS_XS_DISABLED,
-		 10000);
+	di->rxin = di->rxout = 0;
 
-	if (status != XS_XS_DISABLED) {
-		DMA_ERROR(("%s: dma_txreset: dma cannot be stopped\n", di->name));
+	/* clear rx descriptor ring */
+	if (DMA64_ENAB(di))
+		BZERO_SM((void *)(uintptr)di->rxd64, (di->nrxd * sizeof(dma64dd_t)));
+	else
+		BZERO_SM((void *)(uintptr)di->rxd32, (di->nrxd * sizeof(dma32dd_t)));
+
+	_dma_rxenable(di);
+	_dma_ddtable_init(di, DMA_RX, di->rxdpa);
+}
+
+static void
+_dma_rxenable(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxenable\n", di->name));
+
+	if (DMA64_ENAB(di))
+		W_REG(di->osh, &di->d64rxregs->control,
+		      ((di->rxoffset << D64_RC_RO_SHIFT) | D64_RC_RE));
+	else
+		W_REG(di->osh, &di->d32rxregs->control, ((di->rxoffset << RC_RO_SHIFT) | RC_RE));
+}
+
+/* !! rx entry routine, returns a pointer to the next frame received,
+ * or NULL if there are no more
+ */
+static void *
+_dma_rx(dma_info_t *di)
+{
+	void *p;
+	uint len;
+	int skiplen = 0;
+
+	while ((p = _dma_getnextrxp(di, FALSE))) {
+		/* skip giant packets which span multiple rx descriptors */
+		if (skiplen > 0) {
+			skiplen -= di->rxbufsize;
+			if (skiplen < 0)
+				skiplen = 0;
+			PKTFREE(di->osh, p, FALSE);
+			continue;
 	}
 
-	/* wait for the last transaction to complete */
-	OSL_DELAY(300);
+		len = ltoh16(*(uint16*)(PKTDATA(di->osh, p)));
+		DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
+
+		/* bad frame length check */
+		if (len > (di->rxbufsize - di->rxoffset)) {
+			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n", di->name, len));
+			if (len > 0)
+				skiplen = len - (di->rxbufsize - di->rxoffset);
+			PKTFREE(di->osh, p, FALSE);
+			di->hnddma.rxgiants++;
+			continue;
+		}
+
+		/* set actual length */
+		PKTSETLEN(di->osh, p, (di->rxoffset + len));
+
+		break;
+	}
+
+	return (p);
 }
 
-void
-dma_rxreset(dma_info_t *di)
+/* post receive buffers */
+static void
+_dma_rxfill(dma_info_t *di)
 {
-	uint32 status;
+	void *p;
+	uint rxin, rxout;
+	uint32 flags = 0;
+	uint n;
+	uint i;
+	uint32 pa;
+	uint extra_offset = 0;
 
-	DMA_TRACE(("%s: dma_rxreset\n", di->name));
+	/*
+	 * Determine how many receive buffers we're lacking
+	 * from the full complement, allocate, initialize,
+	 * and post them, then update the chip rx lastdscr.
+	 */
 
-	W_REG(&di->regs->rcvcontrol, 0);
-	SPINWAIT((status = (R_REG(&di->regs->rcvstatus) & RS_RS_MASK)) != RS_RS_DISABLED,
-		 10000);
+	rxin = di->rxin;
+	rxout = di->rxout;
+
+	n = di->nrxpost - NRXDACTIVE(rxin, rxout);
+
+	DMA_TRACE(("%s: dma_rxfill: post %d\n", di->name, n));
+
+	if (di->rxbufsize > BCMEXTRAHDROOM)
+		extra_offset = BCMEXTRAHDROOM;
+
+	for (i = 0; i < n; i++) {
+		/* the di->rxbufsize doesn't include the extra headroom, we need to add it to the
+		   size to be allocated
+		*/
+		if ((p = PKTGET(di->osh, di->rxbufsize + extra_offset,
+		                FALSE)) == NULL) {
+			DMA_ERROR(("%s: dma_rxfill: out of rxbufs\n", di->name));
+			di->hnddma.rxnobuf++;
+			break;
+		}
+		/* reserve an extra headroom, if applicable */
+		if (extra_offset)
+			PKTPULL(di->osh, p, extra_offset);
+
+		/* Do a cached write instead of uncached write since DMA_MAP
+		 * will flush the cache.
+		 */
+		*(uint32*)(PKTDATA(di->osh, p)) = 0;
+
+		pa = (uint32) DMA_MAP(di->osh, PKTDATA(di->osh, p),
+		                      di->rxbufsize, DMA_RX, p,
+		                      &di->rxp_dmah[rxout]);
+
+		ASSERT(ISALIGNED(pa, 4));
+
+		/* save the free packet pointer */
+		ASSERT(di->rxp[rxout] == NULL);
+		di->rxp[rxout] = p;
+
+		/* reset flags for each descriptor */
+		flags = 0;
+		if (DMA64_ENAB(di)) {
+			if (rxout == (di->nrxd - 1))
+				flags = D64_CTRL1_EOT;
+
+			dma64_dd_upd(di, di->rxd64, pa, rxout, &flags, di->rxbufsize);
+		} else {
+			if (rxout == (di->nrxd - 1))
+				flags = CTRL_EOT;
+
+			dma32_dd_upd(di, di->rxd32, pa, rxout, &flags, di->rxbufsize);
+		}
+		rxout = NEXTRXD(rxout);
+	}
+
+	di->rxout = rxout;
 
-	if (status != RS_RS_DISABLED) {
-		DMA_ERROR(("%s: dma_rxreset: dma cannot be stopped\n", di->name));
+	/* update the chip lastdscr pointer */
+	if (DMA64_ENAB(di)) {
+		W_REG(di->osh, &di->d64rxregs->ptr, I2B(rxout, dma64dd_t));
+	} else {
+		W_REG(di->osh, &di->d32rxregs->ptr, I2B(rxout, dma32dd_t));
 	}
 }
 
-void
-dma_txinit(dma_info_t *di)
+/* like getnexttxp but no reclaim */
+static void *
+_dma_peeknexttxp(dma_info_t *di)
 {
-	DMA_TRACE(("%s: dma_txinit\n", di->name));
+	uint end, i;
 
-	di->txin = di->txout = 0;
-	di->txavail = di->ntxd - 1;
+	if (di->ntxd == 0)
+		return (NULL);
 
-	/* clear tx descriptor ring */
-	BZERO_SM((void*)di->txd, (di->ntxd * sizeof (dmadd_t)));
+	if (DMA64_ENAB(di)) {
+		end = B2I(R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_CD_MASK, dma64dd_t);
+	} else {
+		end = B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK, dma32dd_t);
+	}
+
+	for (i = di->txin; i != end; i = NEXTTXD(i))
+		if (di->txp[i])
+			return (di->txp[i]);
 
-	W_REG(&di->regs->xmtcontrol, XC_XE);
-	W_REG(&di->regs->xmtaddr, (di->txdpa + di->ddoffset));
+	return (NULL);
 }
 
-bool
-dma_txenabled(dma_info_t *di)
+static void
+_dma_rxreclaim(dma_info_t *di)
 {
-	uint32 xc;
+	void *p;
 
-	/* If the chip is dead, it is not enabled :-) */
-	xc = R_REG(&di->regs->xmtcontrol);
-	return ((xc != 0xffffffff) && (xc & XC_XE));
+	/* "unused local" warning suppression for OSLs that
+	 * define PKTFREE() without using the di->osh arg
+	 */
+	di = di;
+
+	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
+
+	while ((p = _dma_getnextrxp(di, TRUE)))
+		PKTFREE(di->osh, p, FALSE);
+}
+
+static void *
+_dma_getnextrxp(dma_info_t *di, bool forceall)
+{
+	if (di->nrxd == 0)
+		return (NULL);
+
+	if (DMA64_ENAB(di)) {
+		return dma64_getnextrxp(di, forceall);
+	} else {
+		return dma32_getnextrxp(di, forceall);
+	}
+}
+
+static void
+_dma_txblock(dma_info_t *di)
+{
+	di->hnddma.txavail = 0;
 }
 
-void
-dma_txsuspend(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
-	OR_REG(&di->regs->xmtcontrol, XC_SE);
+static void
+_dma_txunblock(dma_info_t *di)
+{
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+}
+
+static uint
+_dma_txactive(dma_info_t *di)
+{
+	return (NTXDACTIVE(di->txin, di->txout));
+}
+
+static void
+_dma_counterreset(dma_info_t *di)
+{
+	/* reset all software counter */
+	di->hnddma.rxgiants = 0;
+	di->hnddma.rxnobuf = 0;
+	di->hnddma.txnobuf = 0;
+}
+
+/* get the address of the var in order to change later */
+static uintptr
+_dma_getvar(dma_info_t *di, const char *name)
+{
+	if (!strcmp(name, "&txavail"))
+		return ((uintptr) &(di->hnddma.txavail));
+	else {
+		ASSERT(0);
+	}
+	return (0);
+}
+
+void
+dma_txpioloopback(osl_t *osh, dma32regs_t *regs)
+{
+	OR_REG(osh, &regs->control, XC_LE);
+}
+
+
+
+/* 32 bits DMA functions */
+static void
+dma32_txinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr)di->txd32, (di->ntxd * sizeof(dma32dd_t)));
+	W_REG(di->osh, &di->d32txregs->control, XC_XE);
+	_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool
+dma32_txenabled(dma_info_t *di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d32txregs->control);
+	return ((xc != 0xffffffff) && (xc & XC_XE));
+}
+
+static void
+dma32_txsuspend(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d32txregs->control, XC_SE);
+}
+
+static void
+dma32_txresume(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d32txregs->control, ~XC_SE);
+}
+
+static bool
+dma32_txsuspended(dma_info_t *di)
+{
+	return (di->ntxd == 0) || ((R_REG(di->osh, &di->d32txregs->control) & XC_SE) == XC_SE);
+}
+
+static void
+dma32_txreclaim(dma_info_t *di, bool forceall)
+{
+	void *p;
+
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
+
+	while ((p = dma32_getnexttxp(di, forceall)))
+		PKTFREE(di->osh, p, TRUE);
+}
+
+static bool
+dma32_txstopped(dma_info_t *di)
+{
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) == XS_XS_STOPPED);
+}
+
+static bool
+dma32_rxstopped(dma_info_t *di)
+{
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_RS_MASK) == RS_RS_STOPPED);
+}
+
+static bool
+dma32_alloc(dma_info_t *di, uint direction)
+{
+	uint size;
+	uint ddlen;
+	void *va;
+
+	ddlen = sizeof(dma32dd_t);
+
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
+
+	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, D32RINGALIGN))
+		size += D32RINGALIGN;
+
+
+	if (direction == DMA_TX) {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->txdpa, &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(ntxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+
+		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr)va, D32RINGALIGN);
+		di->txdalign = (uint)((int8*)(uintptr)di->txd32 - (int8*)va);
+		di->txdpa += di->txdalign;
+		di->txdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->txd32, D32RINGALIGN));
+	} else {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->rxdpa, &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(nrxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr)va, D32RINGALIGN);
+		di->rxdalign = (uint)((int8*)(uintptr)di->rxd32 - (int8*)va);
+		di->rxdpa += di->rxdalign;
+		di->rxdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->rxd32, D32RINGALIGN));
+	}
+
+	return TRUE;
+}
+
+static bool
+dma32_txreset(dma_info_t *di)
+{
+	uint32 status;
+
+	if (di->ntxd == 0)
+		return TRUE;
+
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d32txregs->control, XC_SE);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK))
+		 != XS_XS_DISABLED) &&
+		 (status != XS_XS_IDLE) &&
+		 (status != XS_XS_STOPPED),
+		 (10000));
+
+	W_REG(di->osh, &di->d32txregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+	         &di->d32txregs->status) & XS_XS_MASK)) != XS_XS_DISABLED),
+	         10000);
+
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
+
+	return (status == XS_XS_DISABLED);
+}
+
+static bool
+dma32_rxidle(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK) ==
+	        R_REG(di->osh, &di->d32rxregs->ptr));
+}
+
+static bool
+dma32_rxreset(dma_info_t *di)
+{
+	uint32 status;
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	W_REG(di->osh, &di->d32rxregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+	         &di->d32rxregs->status) & RS_RS_MASK)) != RS_RS_DISABLED),
+	         10000);
+
+	return (status == RS_RS_DISABLED);
+}
+
+static bool
+dma32_rxenabled(dma_info_t *di)
+{
+	uint32 rc;
+
+	rc = R_REG(di->osh, &di->d32rxregs->control);
+	return ((rc != 0xffffffff) && (rc & RC_RE));
+}
+
+static bool
+dma32_txsuspendedidle(dma_info_t *di)
+{
+	if (di->ntxd == 0)
+		return TRUE;
+
+	if (!(R_REG(di->osh, &di->d32txregs->control) & XC_SE))
+		return 0;
+
+	if ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) != XS_XS_IDLE)
+		return 0;
+
+	OSL_DELAY(2);
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) == XS_XS_IDLE);
+}
+
+/* !! tx entry routine
+ * supports full 32bit dma engine buffer addressing so
+ * dma buffers can cross 4 Kbyte page boundaries.
+ */
+static int
+dma32_txfast(dma_info_t *di, void *p0, bool commit)
+{
+	void *p, *next;
+	uchar *data;
+	uint len;
+	uint txout;
+	uint32 flags = 0;
+	uint32 pa;
+
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
+
+	txout = di->txout;
+
+	/*
+	 * Walk the chain of packet buffers
+	 * allocating and initializing transmit descriptor entries.
+	 */
+	for (p = p0; p; p = next) {
+		data = PKTDATA(di->osh, p);
+		len = PKTLEN(di->osh, p);
+		next = PKTNEXT(di->osh, p);
+
+		/* return nonzero if out of tx descriptors */
+		if (NEXTTXD(txout) == di->txin)
+			goto outoftxd;
+
+		if (len == 0)
+			continue;
+
+		/* get physical address of buffer start */
+		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p, &di->txp_dmah[txout]);
+
+		flags = 0;
+		if (p == p0)
+			flags |= CTRL_SOF;
+		if (next == NULL)
+			flags |= (CTRL_IOC | CTRL_EOF);
+		if (txout == (di->ntxd - 1))
+			flags |= CTRL_EOT;
+
+		dma32_dd_upd(di, di->txd32, pa, txout, &flags, len);
+		ASSERT(di->txp[txout] == NULL);
+
+		txout = NEXTTXD(txout);
+	}
+
+	/* if last txd eof not set, fix it */
+	if (!(flags & CTRL_EOF))
+		W_SM(&di->txd32[PREVTXD(txout)].ctrl, BUS_SWAP32(flags | CTRL_IOC | CTRL_EOF));
+
+	/* save the packet */
+	di->txp[PREVTXD(txout)] = p0;
+
+	/* bump the tx descriptor index */
+	di->txout = txout;
+
+	/* kick the chip */
+	if (commit)
+		W_REG(di->osh, &di->d32txregs->ptr, I2B(txout, dma32dd_t));
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (0);
+
+outoftxd:
+	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
+	di->hnddma.txnobuf++;
+	return (-1);
+}
+
+/*
+ * Reclaim next completed txd (txds if using chained buffers) and
+ * return associated packet.
+ * If 'force' is true, reclaim txd(s) and return associated packet
+ * regardless of the value of the hardware "curr" pointer.
+ */
+static void *
+dma32_getnexttxp(dma_info_t *di, bool forceall)
+{
+	uint start, end, i;
+	void *txp;
+
+	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name, forceall ? "all" : ""));
+
+	if (di->ntxd == 0)
+		return (NULL);
+
+	txp = NULL;
+
+	start = di->txin;
+	if (forceall)
+		end = di->txout;
+	else
+		end = B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK, dma32dd_t);
+
+	if ((start == 0) && (end > di->txout))
+		goto bogus;
+
+	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
+		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd32[i].addr)) - di->dataoffsetlow),
+		          (BUS_SWAP32(R_SM(&di->txd32[i].ctrl)) & CTRL_BC_MASK),
+		          DMA_TX, di->txp[i], &di->txp_dmah[i]);
+
+		W_SM(&di->txd32[i].addr, 0xdeadbeef);
+		txp = di->txp[i];
+		di->txp[i] = NULL;
+	}
+
+	di->txin = i;
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (txp);
+
+bogus:
+/*
+	DMA_ERROR(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n",
+		start, end, di->txout, forceall));
+*/
+	return (NULL);
+}
+
+static void *
+dma32_getnextrxp(dma_info_t *di, bool forceall)
+{
+	uint i;
+	void *rxp;
+
+	/* if forcing, dma engine must be disabled */
+	ASSERT(!forceall || !dma32_rxenabled(di));
+
+	i = di->rxin;
+
+	/* return if no packets posted */
+	if (i == di->rxout)
+		return (NULL);
+
+	/* ignore curr if forceall */
+	if (!forceall && (i == B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK, dma32dd_t)))
+		return (NULL);
+
+	/* get the packet pointer that corresponds to the rx descriptor */
+	rxp = di->rxp[i];
+	ASSERT(rxp);
+	di->rxp[i] = NULL;
+
+	/* clear this packet from the descriptor ring */
+	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd32[i].addr)) - di->dataoffsetlow),
+	          di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd32[i].addr, 0xdeadbeef);
+
+	di->rxin = NEXTRXD(i);
+
+	return (rxp);
+}
+
+/*
+ * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
+ */
+static void
+dma32_txrotate(dma_info_t *di)
+{
+	uint ad;
+	uint nactive;
+	uint rot;
+	uint old, new;
+	uint32 w;
+	uint first, last;
+
+	ASSERT(dma32_txsuspendedidle(di));
+
+	nactive = _dma_txactive(di);
+	ad = B2I(((R_REG(di->osh, &di->d32txregs->status) & XS_AD_MASK) >> XS_AD_SHIFT), dma32dd_t);
+	rot = TXD(ad - di->txin);
+
+	ASSERT(rot < di->ntxd);
+
+	/* full-ring case is a lot harder - don't worry about this */
+	if (rot >= (di->ntxd - nactive)) {
+		DMA_ERROR(("%s: dma_txrotate: ring full - punt\n", di->name));
+		return;
+	}
+
+	first = di->txin;
+	last = PREVTXD(di->txout);
+
+	/* move entries starting at last and moving backwards to first */
+	for (old = last; old != PREVTXD(first); old = PREVTXD(old)) {
+		new = TXD(old + rot);
+
+		/*
+		 * Move the tx dma descriptor.
+		 * EOT is set only in the last entry in the ring.
+		 */
+		w = BUS_SWAP32(R_SM(&di->txd32[old].ctrl)) & ~CTRL_EOT;
+		if (new == (di->ntxd - 1))
+			w |= CTRL_EOT;
+		W_SM(&di->txd32[new].ctrl, BUS_SWAP32(w));
+		W_SM(&di->txd32[new].addr, R_SM(&di->txd32[old].addr));
+
+		/* zap the old tx dma descriptor address field */
+		W_SM(&di->txd32[old].addr, BUS_SWAP32(0xdeadbeef));
+
+		/* move the corresponding txp[] entry */
+		ASSERT(di->txp[new] == NULL);
+		di->txp[new] = di->txp[old];
+		di->txp[old] = NULL;
+	}
+
+	/* update txin and txout */
+	di->txin = ad;
+	di->txout = TXD(di->txout + rot);
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	/* kick the chip */
+	W_REG(di->osh, &di->d32txregs->ptr, I2B(di->txout, dma32dd_t));
+}
+
+/* 64 bits DMA functions */
+
+#ifdef BCMDMA64
+static void
+dma64_txinit(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr)di->txd64, (di->ntxd * sizeof(dma64dd_t)));
+	W_REG(di->osh, &di->d64txregs->control, D64_XC_XE);
+	_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool
+dma64_txenabled(dma_info_t *di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d64txregs->control);
+	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
+}
+
+static void
+dma64_txsuspend(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+}
+
+static void
+dma64_txresume(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d64txregs->control, ~D64_XC_SE);
 }
 
-void
-dma_txresume(dma_info_t *di)
+static bool
+dma64_txsuspended(dma_info_t *di)
 {
-	DMA_TRACE(("%s: dma_txresume\n", di->name));
-	AND_REG(&di->regs->xmtcontrol, ~XC_SE);
+	return (di->ntxd == 0) || ((R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE)
+	        == D64_XC_SE);
 }
 
-bool
-dma_txsuspended(dma_info_t *di)
+static void
+dma64_txreclaim(dma_info_t *di, bool forceall)
 {
-	if (!(R_REG(&di->regs->xmtcontrol) & XC_SE))
-		return 0;
+	void *p;
 	
-	if ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) != XS_XS_IDLE)
-		return 0;
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
 
-	OSL_DELAY(2);
-	return ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) == XS_XS_IDLE);
+	while ((p = dma64_getnexttxp(di, forceall)))
+		PKTFREE(di->osh, p, TRUE);
 }
 
-bool
-dma_txstopped(dma_info_t *di)
+static bool
+dma64_txstopped(dma_info_t *di)
 {
-	return ((R_REG(&di->regs->xmtstatus) & XS_XS_MASK) == XS_XS_STOPPED);
+	return ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) == D64_XS0_XS_STOPPED);
 }
 
-bool
-dma_rxstopped(dma_info_t *di)
+static bool
+dma64_rxstopped(dma_info_t *di)
 {
-	return ((R_REG(&di->regs->rcvstatus) & RS_RS_MASK) == RS_RS_STOPPED);
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK) == D64_RS0_RS_STOPPED);
 }
 
-void
-dma_fifoloopbackenable(dma_info_t *di)
+static bool
+dma64_alloc(dma_info_t *di, uint direction)
 {
-	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
-	OR_REG(&di->regs->xmtcontrol, XC_LE);
-}
+	uint size;
+	uint ddlen;
+	uint32 alignbytes;
+	void *va;
 
-void
-dma_rxinit(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_rxinit\n", di->name));
+	ddlen = sizeof(dma64dd_t);
 
-	di->rxin = di->rxout = 0;
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
 
-	/* clear rx descriptor ring */
-	BZERO_SM((void*)di->rxd, (di->nrxd * sizeof (dmadd_t)));
+	alignbytes = di->dma64align;
 
-	dma_rxenable(di);
-	W_REG(&di->regs->rcvaddr, (di->rxdpa + di->ddoffset));
-}
+	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, alignbytes))
+		size += alignbytes;
 
-void
-dma_rxenable(dma_info_t *di)
-{
-	DMA_TRACE(("%s: dma_rxenable\n", di->name));
-	W_REG(&di->regs->rcvcontrol, ((di->rxoffset << RC_RO_SHIFT) | RC_RE));
-}
+	if (direction == DMA_TX) {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->txdpa, &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(ntxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
 
-bool
-dma_rxenabled(dma_info_t *di)
-{
-	uint32 rc;
+		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr)va, alignbytes);
+		di->txdalign = (uint)((int8*)(uintptr)di->txd64 - (int8*)va);
+		di->txdpa += di->txdalign;
+		di->txdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->txd64, alignbytes));
+	} else {
+		if ((va = DMA_ALLOC_CONSISTENT(di->osh, size, &di->rxdpa, &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: DMA_ALLOC_CONSISTENT(nrxd) failed\n",
+			           di->name));
+			return FALSE;
+		}
+		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr)va, alignbytes);
+		di->rxdalign = (uint)((int8*)(uintptr)di->rxd64 - (int8*)va);
+		di->rxdpa += di->rxdalign;
+		di->rxdalloc = size;
+		ASSERT(ISALIGNED((uintptr)di->rxd64, alignbytes));
+	}
 
-	rc = R_REG(&di->regs->rcvcontrol);
-	return ((rc != 0xffffffff) && (rc & RC_RE));
+	return TRUE;
 }
 
-/*
- * The BCM47XX family supports full 32bit dma engine buffer addressing so
- * dma buffers can cross 4 Kbyte page boundaries.
- */
-int
-dma_txfast(dma_info_t *di, void *p0, uint32 coreflags)
+static bool
+dma64_txreset(dma_info_t *di)
 {
-	void *p, *next;
-	uchar *data;
-	uint len;
-	uint txout;
-	uint32 ctrl;
-	uint32 pa;
+	uint32 status;
 
-	DMA_TRACE(("%s: dma_txfast\n", di->name));
+	if (di->ntxd == 0)
+		return TRUE;
 
-	txout = di->txout;
-	ctrl = 0;
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK)) !=
+	          D64_XS0_XS_DISABLED) &&
+	         (status != D64_XS0_XS_IDLE) &&
+	         (status != D64_XS0_XS_STOPPED),
+	         10000);
 
-	/*
-	 * Walk the chain of packet buffers
-	 * allocating and initializing transmit descriptor entries.
-	 */
-	for (p = p0; p; p = next) {
-		data = PKTDATA(di->drv, p);
-		len = PKTLEN(di->drv, p);
-		next = PKTNEXT(di->drv, p);
+	W_REG(di->osh, &di->d64txregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK)) !=
+	          D64_XS0_XS_DISABLED),
+	         10000);
 
-		/* return nonzero if out of tx descriptors */
-		if (NEXTTXD(txout) == di->txin)
-			goto outoftxd;
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
 
-		if (len == 0)
-			continue;
+	return (status == D64_XS0_XS_DISABLED);
+}
 
-		/* get physical address of buffer start */
-		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p);
-		ASSERT(DMA_ADDRESSABLE(pa));
+static bool
+dma64_rxidle(dma_info_t *di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
-		/* build the descriptor control value */
-		ctrl = len & CTRL_BC_MASK;
+	if (di->nrxd == 0)
+		return TRUE;
 
-		ctrl |= coreflags;
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) ==
+		R_REG(di->osh, &di->d64rxregs->ptr));
+}
 		
-		if (p == p0)
-			ctrl |= CTRL_SOF;
-		if (next == NULL)
-			ctrl |= (CTRL_IOC | CTRL_EOF);
-		if (txout == (di->ntxd - 1))
-			ctrl |= CTRL_EOT;
+static bool
+dma64_rxreset(dma_info_t *di)
+{
+	uint32 status;
 
-		/* init the tx descriptor */
-		W_SM(&di->txd[txout].ctrl, BUS_SWAP32(ctrl));
-		W_SM(&di->txd[txout].addr, BUS_SWAP32(pa + di->dataoffset));
+	if (di->nrxd == 0)
+		return TRUE;
 
-		ASSERT(di->txp[txout] == NULL);
+	W_REG(di->osh, &di->d64rxregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK)) !=
+	          D64_RS0_RS_DISABLED),
+	         10000);
 
-		txout = NEXTTXD(txout);
-	}
+	return (status == D64_RS0_RS_DISABLED);
+}
 
-	/* if last txd eof not set, fix it */
-	if (!(ctrl & CTRL_EOF))
-		W_SM(&di->txd[PREVTXD(txout)].ctrl, BUS_SWAP32(ctrl | CTRL_IOC | CTRL_EOF));
+static bool
+dma64_rxenabled(dma_info_t *di)
+{
+	uint32 rc;
 
-	/* save the packet */
-	di->txp[PREVTXD(txout)] = p0;
+	rc = R_REG(di->osh, &di->d64rxregs->control);
+	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
+}
 
-	/* bump the tx descriptor index */
-	di->txout = txout;
+static bool
+dma64_txsuspendedidle(dma_info_t *di)
+{
 
-	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(txout));
+	if (di->ntxd == 0)
+		return TRUE;
 
-	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	if (!(R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE))
+		return 0;
 
-	return (0);
+	if ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) == D64_XS0_XS_IDLE)
+		return 1;
 
-outoftxd:
-	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
-	PKTFREE(di->drv, p0, TRUE);
-	di->txavail = 0;
-	di->hnddma.txnobuf++;
-	return (-1);
+	return 0;
 }
 
-#define	PAGESZ		4096
-#define	PAGEBASE(x)	((uintptr)(x) & ~4095)
 
-/*
- * Just like above except go through the extra effort of splitting
- * buffers that cross 4Kbyte boundaries into multiple tx descriptors.
- */
-int
-dma_tx(dma_info_t *di, void *p0, uint32 coreflags)
+/* !! tx entry routine */
+static int
+dma64_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
 	uchar *data;
-	uint plen, len;
-	uchar *page, *start, *end;
+	uint len;
 	uint txout;
-	uint32 ctrl;
+	uint32 flags = 0;
 	uint32 pa;
 
-	DMA_TRACE(("%s: dma_tx\n", di->name));
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
 
 	txout = di->txout;
-	ctrl = 0;
 
 	/*
 	 * Walk the chain of packet buffers
-	 * splitting those that cross 4 Kbyte boundaries
 	 * allocating and initializing transmit descriptor entries.
 	 */
 	for (p = p0; p; p = next) {
-		data = PKTDATA(di->drv, p);
-		plen = PKTLEN(di->drv, p);
-		next = PKTNEXT(di->drv, p);
-
-		if (plen == 0)
-			continue;
-
-		for (page = (uchar*)PAGEBASE(data);
-			page <= (uchar*)PAGEBASE(data + plen - 1);
-			page += PAGESZ) {
+		data = PKTDATA(di->osh, p);
+		len = PKTLEN(di->osh, p);
+		next = PKTNEXT(di->osh, p);
 
 			/* return nonzero if out of tx descriptors */
 			if (NEXTTXD(txout) == di->txin)
 				goto outoftxd;
 
-			start = (page == (uchar*)PAGEBASE(data))?  data: page;
-			end = (page == (uchar*)PAGEBASE(data + plen))?
-				(data + plen): (page + PAGESZ);
-			len = (uint)(end - start);
-
-			/* build the descriptor control value */
-			ctrl = len & CTRL_BC_MASK;
-
-			ctrl |= coreflags;
-
-			if ((p == p0) && (start == data))
-				ctrl |= CTRL_SOF;
-			if ((next == NULL) && (end == (data + plen)))
-				ctrl |= (CTRL_IOC | CTRL_EOF);
-			if (txout == (di->ntxd - 1))
-				ctrl |= CTRL_EOT;
+		if (len == 0)
+			continue;
 
 			/* get physical address of buffer start */
-			pa = (uint32) DMA_MAP(di->osh, start, len, DMA_TX, p);
-			ASSERT(DMA_ADDRESSABLE(pa));
+		pa = (uint32) DMA_MAP(di->osh, data, len, DMA_TX, p, &di->txp_dmah[txout]);
 
-			/* init the tx descriptor */
-			W_SM(&di->txd[txout].ctrl, BUS_SWAP32(ctrl));
-			W_SM(&di->txd[txout].addr, BUS_SWAP32(pa + di->dataoffset));
+		flags = 0;
+		if (p == p0)
+			flags |= D64_CTRL1_SOF;
+		if (next == NULL)
+			flags |= (D64_CTRL1_IOC | D64_CTRL1_EOF);
+		if (txout == (di->ntxd - 1))
+			flags |= D64_CTRL1_EOT;
 
+		dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
 			ASSERT(di->txp[txout] == NULL);
 
 			txout = NEXTTXD(txout);
 		}
-	}
 
 	/* if last txd eof not set, fix it */
-	if (!(ctrl & CTRL_EOF))
-		W_SM(&di->txd[PREVTXD(txout)].ctrl, BUS_SWAP32(ctrl | CTRL_IOC | CTRL_EOF));
+	if (!(flags & D64_CTRL1_EOF))
+		W_SM(&di->txd64[PREVTXD(txout)].ctrl1,
+		     BUS_SWAP32(flags | D64_CTRL1_IOC | D64_CTRL1_EOF));
 
 	/* save the packet */
 	di->txp[PREVTXD(txout)] = p0;
@@ -537,162 +1660,58 @@
 	di->txout = txout;
 
 	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(txout));
+	if (commit)
+		W_REG(di->osh, &di->d64txregs->ptr, I2B(txout, dma64dd_t));
 
 	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	return (0);
 
 outoftxd:
-	DMA_ERROR(("%s: dma_tx: out of txds\n", di->name));
-	PKTFREE(di->drv, p0, TRUE);
-	di->txavail = 0;
+	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
 	return (-1);
 }
 
-/* returns a pointer to the next frame received, or NULL if there are no more */
-void*
-dma_rx(dma_info_t *di)
-{
-	void *p;
-	uint len;
-	int skiplen = 0;
-
-	while ((p = dma_getnextrxp(di, FALSE))) {
-		/* skip giant packets which span multiple rx descriptors */
-		if (skiplen > 0) {
-			skiplen -= di->rxbufsize;
-			if (skiplen < 0)
-				skiplen = 0;
-			PKTFREE(di->drv, p, FALSE);
-			continue;
-		}
-
-		len = ltoh16(*(uint16*)(PKTDATA(di->drv, p)));
-		DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
-
-		/* bad frame length check */
-		if (len > (di->rxbufsize - di->rxoffset)) {
-			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n", di->name, len));
-			if (len > 0)
-				skiplen = len - (di->rxbufsize - di->rxoffset);
-			PKTFREE(di->drv, p, FALSE);
-			di->hnddma.rxgiants++;
-			continue;
-		}
-
-		/* set actual length */
-		PKTSETLEN(di->drv, p, (di->rxoffset + len));
-
-		break;
-	}
-
-	return (p);
-}
-
-/* post receive buffers */
-void
-dma_rxfill(dma_info_t *di)
-{
-	void *p;
-	uint rxin, rxout;
-	uint ctrl;
-	uint n;
-	uint i;
-	uint32 pa;
-	uint rxbufsize;
-
-	/*
-	 * Determine how many receive buffers we're lacking
-	 * from the full complement, allocate, initialize,
-	 * and post them, then update the chip rx lastdscr.
-	 */
-
-	rxin = di->rxin;
-	rxout = di->rxout;
-	rxbufsize = di->rxbufsize;
-
-	n = di->nrxpost - NRXDACTIVE(rxin, rxout);
-
-	DMA_TRACE(("%s: dma_rxfill: post %d\n", di->name, n));
-
-	for (i = 0; i < n; i++) {
-		if ((p = PKTGET(di->drv, rxbufsize, FALSE)) == NULL) {
-			DMA_ERROR(("%s: dma_rxfill: out of rxbufs\n", di->name));
-			di->hnddma.rxnobuf++;
-			break;
-		}
-
-		*(uint32*)(OSL_UNCACHED(PKTDATA(di->drv, p))) = 0;
-
-		pa = (uint32) DMA_MAP(di->osh, PKTDATA(di->drv, p), rxbufsize, DMA_RX, p);
-		ASSERT(ISALIGNED(pa, 4));
-		ASSERT(DMA_ADDRESSABLE(pa));
-
-		/* save the free packet pointer */
-		ASSERT(di->rxp[rxout] == NULL);
-		di->rxp[rxout] = p;
-
-		/* prep the descriptor control value */
-		ctrl = rxbufsize;
-		if (rxout == (di->nrxd - 1))
-			ctrl |= CTRL_EOT;
-
-		/* init the rx descriptor */
-		W_SM(&di->rxd[rxout].ctrl, BUS_SWAP32(ctrl));
-		W_SM(&di->rxd[rxout].addr, BUS_SWAP32(pa + di->dataoffset));
-
-		rxout = NEXTRXD(rxout);
-	}
-
-	di->rxout = rxout;
-
-	/* update the chip lastdscr pointer */
-	W_REG(&di->regs->rcvptr, I2B(rxout));
-}
-
-void
-dma_txreclaim(dma_info_t *di, bool forceall)
-{
-	void *p;
-
-	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name, forceall ? "all" : ""));
-
-	while ((p = dma_getnexttxp(di, forceall)))
-		PKTFREE(di->drv, p, TRUE);
-}
-
 /*
  * Reclaim next completed txd (txds if using chained buffers) and
  * return associated packet.
  * If 'force' is true, reclaim txd(s) and return associated packet
  * regardless of the value of the hardware "curr" pointer.
  */
-void*
-dma_getnexttxp(dma_info_t *di, bool forceall)
+static void *
+dma64_getnexttxp(dma_info_t *di, bool forceall)
 {
 	uint start, end, i;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name, forceall ? "all" : ""));
 
+	if (di->ntxd == 0)
+		return (NULL);
+
 	txp = NULL;
 
 	start = di->txin;
 	if (forceall)
 		end = di->txout;
 	else
-		end = B2I(R_REG(&di->regs->xmtstatus) & XS_CD_MASK);
+		end = B2I(R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_CD_MASK, dma64dd_t);
 
 	if ((start == 0) && (end > di->txout))
 		goto bogus;
 
 	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
-		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd[i].addr)) - di->dataoffset),
-			  (BUS_SWAP32(R_SM(&di->txd[i].ctrl)) & CTRL_BC_MASK), DMA_TX, di->txp[i]);
-		W_SM(&di->txd[i].addr, 0xdeadbeef);
+		DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->txd64[i].addrlow)) - di->dataoffsetlow),
+		          (BUS_SWAP32(R_SM(&di->txd64[i].ctrl2)) & D64_CTRL2_BC_MASK),
+		          DMA_TX, di->txp[i], &di->txp_dmah[i]);
+
+		W_SM(&di->txd64[i].addrlow, 0xdeadbeef);
+		W_SM(&di->txd64[i].addrhigh, 0xdeadbeef);
+
 		txp = di->txp[i];
 		di->txp[i] = NULL;
 	}
@@ -700,7 +1719,7 @@
 	di->txin = i;
 
 	/* tx flow control */
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	return (txp);
 
@@ -712,40 +1731,14 @@
 	return (NULL);
 }
 
-/* like getnexttxp but no reclaim */
-void*
-dma_peeknexttxp(dma_info_t *di)
-{
-	uint end, i;
-
-	end = B2I(R_REG(&di->regs->xmtstatus) & XS_CD_MASK);
-
-	for (i = di->txin; i != end; i = NEXTTXD(i))
-		if (di->txp[i])
-			return (di->txp[i]);
-
-	return (NULL);
-}
-
-void
-dma_rxreclaim(dma_info_t *di)
-{
-	void *p;
-
-	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
-
-	while ((p = dma_getnextrxp(di, TRUE)))
-		PKTFREE(di->drv, p, FALSE);
-}
-
-void *
-dma_getnextrxp(dma_info_t *di, bool forceall)
+static void *
+dma64_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i;
 	void *rxp;
 
 	/* if forcing, dma engine must be disabled */
-	ASSERT(!forceall || !dma_rxenabled(di));
+	ASSERT(!forceall || !dma64_rxenabled(di));
 
 	i = di->rxin;
 
@@ -754,7 +1747,8 @@
 		return (NULL);
 
 	/* ignore curr if forceall */
-	if (!forceall && (i == B2I(R_REG(&di->regs->rcvstatus) & RS_CD_MASK)))
+	if (!forceall &&
+	    (i == B2I(R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK, dma64dd_t)))
 		return (NULL);
 
 	/* get the packet pointer that corresponds to the rx descriptor */
@@ -763,50 +1757,32 @@
 	di->rxp[i] = NULL;
 
 	/* clear this packet from the descriptor ring */
-	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd[i].addr)) - di->dataoffset),
-		  di->rxbufsize, DMA_RX, rxp);
-	W_SM(&di->rxd[i].addr, 0xdeadbeef);
+	DMA_UNMAP(di->osh, (BUS_SWAP32(R_SM(&di->rxd64[i].addrlow)) - di->dataoffsetlow),
+	          di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd64[i].addrlow, 0xdeadbeef);
+	W_SM(&di->rxd64[i].addrhigh, 0xdeadbeef);
 
 	di->rxin = NEXTRXD(i);
 
 	return (rxp);
 }
 
-
-uintptr
-dma_getvar(dma_info_t *di, char *name)
-{
-	if (!strcmp(name, "&txavail"))
-		return ((uintptr) &di->txavail);
-	else {
-		ASSERT(0);
-	}
-	return (0);
-}
-
-void
-dma_txblock(dma_info_t *di)
-{
-	di->txavail = 0;
-}
-
-void
-dma_txunblock(dma_info_t *di)
-{
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
-}
-
-uint
-dma_txactive(dma_info_t *di)
+static bool
+_dma64_addrext(osl_t *osh, dma64regs_t *dma64regs)
 {
-	return (NTXDACTIVE(di->txin, di->txout));
+	uint32 w;
+	OR_REG(osh, &dma64regs->control, D64_XC_AE);
+	w = R_REG(osh, &dma64regs->control);
+	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
+	return ((w & D64_XC_AE) == D64_XC_AE);
 }
 
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-void
-dma_txrotate(di_t *di)
+static void
+dma64_txrotate(dma_info_t *di)
 {
 	uint ad;
 	uint nactive;
@@ -815,10 +1791,10 @@
 	uint32 w;
 	uint first, last;
 
-	ASSERT(dma_txsuspended(di));
+	ASSERT(dma64_txsuspendedidle(di));
 
-	nactive = dma_txactive(di);
-	ad = B2I((R_REG(&di->regs->xmtstatus) & XS_AD_MASK) >> XS_AD_SHIFT);
+	nactive = _dma_txactive(di);
+	ad = B2I((R_REG(di->osh, &di->d64txregs->status1) & D64_XS1_AD_MASK), dma64dd_t);
 	rot = TXD(ad - di->txin);
 
 	ASSERT(rot < di->ntxd);
@@ -840,14 +1816,20 @@
 		 * Move the tx dma descriptor.
 		 * EOT is set only in the last entry in the ring.
 		 */
-		w = R_SM(&di->txd[old].ctrl) & ~CTRL_EOT;
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl1)) & ~D64_CTRL1_EOT;
 		if (new == (di->ntxd - 1))
-			w |= CTRL_EOT;
-		W_SM(&di->txd[new].ctrl, w);
-		W_SM(&di->txd[new].addr, R_SM(&di->txd[old].addr));
+			w |= D64_CTRL1_EOT;
+		W_SM(&di->txd64[new].ctrl1, BUS_SWAP32(w));
+
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl2));
+		W_SM(&di->txd64[new].ctrl2, BUS_SWAP32(w));
+
+		W_SM(&di->txd64[new].addrlow, R_SM(&di->txd64[old].addrlow));
+		W_SM(&di->txd64[new].addrhigh, R_SM(&di->txd64[old].addrhigh));
 
 		/* zap the old tx dma descriptor address field */
-		W_SM(&di->txd[old].addr, 0xdeadbeef);
+		W_SM(&di->txd64[old].addrlow, BUS_SWAP32(0xdeadbeef));
+		W_SM(&di->txd64[old].addrhigh, BUS_SWAP32(0xdeadbeef));
 
 		/* move the corresponding txp[] entry */
 		ASSERT(di->txp[new] == NULL);
@@ -858,8 +1840,50 @@
 	/* update txin and txout */
 	di->txin = ad;
 	di->txout = TXD(di->txout + rot);
-	di->txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
 	/* kick the chip */
-	W_REG(&di->regs->xmtptr, I2B(di->txout));
+	W_REG(di->osh, &di->d64txregs->ptr, I2B(di->txout, dma64dd_t));
+}
+
+#endif	/* BCMDMA64 */
+
+uint
+dma_addrwidth(sb_t *sbh, void *dmaregs)
+{
+	dma32regs_t *dma32regs;
+	osl_t *osh;
+
+	osh = sb_osh(sbh);
+
+	if (DMA64_CAP) {
+		/* DMA engine is 64-bit capable */
+		if (((sb_coreflagshi(sbh, 0, 0) & SBTMH_DMA64) == SBTMH_DMA64)) {
+			/* backplane are 64 bits capable */
+			if (sb_backplane64(sbh))
+				/* If bus is System Backplane or PCIE then we can access 64-bits */
+				if ((BUSTYPE(sbh->bustype) == SB_BUS) ||
+				    ((BUSTYPE(sbh->bustype) == PCI_BUS) &&
+					sbh->buscoretype == SB_PCIE))
+					return (DMADDRWIDTH_64);
+
+			/* DMA64 is always 32 bits capable, AE is always TRUE */
+#ifdef BCMDMA64
+			ASSERT(_dma64_addrext(osh, (dma64regs_t *)dmaregs));
+#endif
+			return (DMADDRWIDTH_32);
+		}
+	}
+
+	/* Start checking for 32-bit / 30-bit addressing */
+	dma32regs = (dma32regs_t *)dmaregs;
+
+	/* For System Backplane, PCIE bus or addrext feature, 32-bits ok */
+	if ((BUSTYPE(sbh->bustype) == SB_BUS) ||
+	    ((BUSTYPE(sbh->bustype) == PCI_BUS) && sbh->buscoretype == SB_PCIE) ||
+	    (_dma32_addrext(osh, dma32regs)))
+		return (DMADDRWIDTH_32);
+
+	/* Fallthru */
+	return (DMADDRWIDTH_30);
 }
--- src/shared.1927/hndgige.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/hndgige.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,123 @@
+/*
+ * HND SiliconBackplane Gigabit Ethernet core software interface
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <pcicfg.h>
+#include <sbconfig.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <sbgige.h>
+#include <hndpci.h>
+#include <hndgige.h>
+
+/*
+ * Setup the gige core.
+ * Resetting the core will lose all settings.
+ */
+void
+sb_gige_init(sb_t *sbh, uint32 unit, bool *rgmii)
+{
+	volatile pci_config_regs *pci;
+	sbgige_pcishim_t *ocp;
+	sbconfig_t *sb;
+	osl_t *osh;
+	uint32 statelow;
+	uint32 statehigh;
+	uint32 base;
+	uint32 idx;
+	void *regs;
+
+	/* Sanity checks */
+	ASSERT(sbh);
+	ASSERT(rgmii);
+
+	idx = sb_coreidx(sbh);
+
+	/* point to the gige core registers */
+	regs = sb_setcore(sbh, SB_GIGETH, unit);
+	ASSERT(regs);
+
+	osh = sb_osh(sbh);
+
+	pci = &((sbgige_t *)regs)->pcicfg;
+	ocp = &((sbgige_t *)regs)->pcishim;
+	sb = &((sbgige_t *)regs)->sbconfig;
+
+	/* Enable the core clock and memory access */
+	if (!sb_iscoreup(sbh))
+		sb_core_reset(sbh, 0, 0);
+
+	/*
+	 * Setup the 64K memory-mapped region base address through BAR0.
+	 * Leave the other BAR values alone.
+	 */
+	base = sb_base(R_REG(osh, &sb->sbadmatch1));
+	W_REG(osh, &pci->base[0], base);
+	W_REG(osh, &pci->base[1], 0);
+
+	/*
+	 * Enable the PCI memory access anyway. Any PCI config commands
+	 * issued before the core is enabled will go to the emulation
+	 * only and will not go to the real PCI config registers.
+	 */
+	OR_REG(osh, &pci->command, 2);
+
+	/*
+	 * Enable the posted write flush scheme as follows:
+	 *
+	 * - Enable flush on any core register read
+	 * - Enable timeout on the flush
+	 * - Disable the interrupt mask when flushing
+	 *
+	 * This differs from the default setting only in that interrupts are
+	 * not masked.  Since posted writes are not flushed on interrupt, the
+	 * driver must explicitly request a flush in its interrupt handling
+	 * by reading a core register.
+	 */
+	W_REG(osh, &ocp->FlushStatusControl, 0x68);
+
+	/*
+	 * Determine whether the GbE is in GMII or RGMII mode.  This is
+	 * indicated in bit 16 of the SBTMStateHigh register, which is
+	 * part of the core-specific flags field.
+	 *
+	 * For GMII, bypass the Rx/Tx DLLs, i.e. add no delay to RXC/GTXC
+	 * within the core.  For RGMII, do not bypass the DLLs, resulting
+	 * in added delay for RXC/GTXC.  The SBTMStateLow register contains
+	 * the controls for doing this in the core-specific flags field:
+	 *
+	 *   bit 24 - Enable DLL controls
+	 *   bit 20 - Bypass Rx DLL
+	 *   bit 19 - Bypass Tx DLL
+	 */
+	statelow = R_REG(osh, &sb->sbtmstatelow);	/* DLL controls */
+	statehigh = R_REG(osh, &sb->sbtmstatehigh);	/* GMII/RGMII mode */
+	if ((statehigh & (1 << 16)) != 0)	/* RGMII */
+	{
+		statelow &= ~(1 << 20);		/* no Rx bypass (delay) */
+		statelow &= ~(1 << 19);		/* no Tx bypass (delay) */
+		*rgmii = TRUE;
+	}
+	else					/* GMII */
+	{
+		statelow |= (1 << 20);		/* Rx bypass (no delay) */
+		statelow |= (1 << 19);		/* Tx bypass (no delay) */
+		*rgmii = FALSE;
+	}
+	statelow |= (1 << 24);			/* enable DLL controls */
+	W_REG(osh, &sb->sbtmstatelow, statelow);
+
+	sb_setcoreidx(sbh, idx);
+}
--- src/shared.1927/hndmips.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/hndmips.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,1143 @@
+/*
+ * BCM47XX Sonics SiliconBackplane MIPS core routines
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <sbextif.h>
+#include <bcmdevs.h>
+#include <bcmnvram.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <sbmemc.h>
+#include <mipsinc.h>
+#include <sbhndmips.h>
+#include <hndcpu.h>
+#include <hndmips.h>
+
+/* sbipsflag register format, indexed by irq. */
+static const uint32 sbips_int_mask[] = {
+	0,	/* placeholder */
+	SBIPS_INT1_MASK,
+	SBIPS_INT2_MASK,
+	SBIPS_INT3_MASK,
+	SBIPS_INT4_MASK
+};
+
+static const uint32 sbips_int_shift[] = {
+	0,	/* placeholder */
+	SBIPS_INT1_SHIFT,
+	SBIPS_INT2_SHIFT,
+	SBIPS_INT3_SHIFT,
+	SBIPS_INT4_SHIFT
+};
+
+/*
+ * Map SB cores sharing the MIPS hardware IRQ0 to virtual dedicated OS IRQs.
+ * Per-port BSP code is required to provide necessary translations between
+ * the shared MIPS IRQ and the virtual OS IRQs based on SB core flag.
+ *
+ * See sb_irq() for the mapping.
+ */
+static uint shirq_map_base = 0;
+
+/*
+ * Returns the MIPS IRQ assignment of the current core. If unassigned,
+ * 0 is returned.
+ */
+static uint
+sb_getirq(sb_t *sbh)
+{
+	osl_t *osh;
+	uint idx;
+	void *regs;
+	sbconfig_t *sb;
+	uint32 flag, sbipsflag;
+	uint irq = 0;
+
+	osh = sb_osh(sbh);
+	flag = sb_flag(sbh);
+
+	idx = sb_coreidx(sbh);
+
+	if ((regs = sb_setcore(sbh, SB_MIPS33, 0)) != NULL) {
+		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+		/* sbipsflag specifies which core is routed to interrupts 1 to 4 */
+		sbipsflag = R_REG(osh, &sb->sbipsflag);
+		for (irq = 1; irq <= 4; irq++) {
+			if (((sbipsflag & sbips_int_mask[irq]) >> sbips_int_shift[irq]) == flag)
+				break;
+		}
+		if (irq == 5)
+			irq = 0;
+	}
+
+	sb_setcoreidx(sbh, idx);
+
+	return irq;
+}
+
+/*
+ * Return the MIPS IRQ assignment of the current core. If necessary
+ * map cores sharing the MIPS hw IRQ0 to virtual dedicated OS IRQs.
+ */
+uint
+sb_irq(sb_t *sbh)
+{
+	uint irq = sb_getirq(sbh);
+	if (irq == 0 && shirq_map_base)
+		irq = sb_flag(sbh) + shirq_map_base;
+	return irq;
+}
+
+/* Clears the specified MIPS IRQ. */
+static void
+BCMINITFN(sb_clearirq)(sb_t *sbh, uint irq)
+{
+	osl_t *osh;
+	void *regs;
+	sbconfig_t *sb;
+
+	osh = sb_osh(sbh);
+
+	regs = sb_setcore(sbh, SB_MIPS33, 0);
+	ASSERT(regs);
+	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	if (irq == 0)
+		W_REG(osh, &sb->sbintvec, 0);
+	else
+		OR_REG(osh, &sb->sbipsflag, sbips_int_mask[irq]);
+}
+
+/*
+ * Assigns the specified MIPS IRQ to the specified core. Shared MIPS
+ * IRQ 0 may be assigned more than once.
+ *
+ * The old assignment to the specified core is removed first.
+ */
+static void
+BCMINITFN(sb_setirq)(sb_t *sbh, uint irq, uint coreid, uint coreunit)
+{
+	osl_t *osh;
+	void *regs;
+	sbconfig_t *sb;
+	uint32 flag;
+	uint oldirq;
+
+	osh = sb_osh(sbh);
+
+	regs = sb_setcore(sbh, coreid, coreunit);
+	ASSERT(regs);
+	flag = sb_flag(sbh);
+	oldirq = sb_getirq(sbh);
+	if (oldirq)
+		sb_clearirq(sbh, oldirq);
+
+	regs = sb_setcore(sbh, SB_MIPS33, 0);
+	ASSERT(regs);
+	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	if (!oldirq)
+		AND_REG(osh, &sb->sbintvec, ~(1 << flag));
+
+	if (irq == 0)
+		OR_REG(osh, &sb->sbintvec, 1 << flag);
+	else {
+		flag <<= sbips_int_shift[irq];
+		ASSERT(!(flag & ~sbips_int_mask[irq]));
+		flag |= R_REG(osh, &sb->sbipsflag) & ~sbips_int_mask[irq];
+		W_REG(osh, &sb->sbipsflag, flag);
+	}
+}
+
+/*
+ * Initializes clocks and interrupts. SB and NVRAM access must be
+ * initialized prior to calling.
+ *
+ * 'shirqmap' enables virtual dedicated OS IRQ mapping if non-zero.
+ */
+void
+BCMINITFN(sb_mips_init)(sb_t *sbh, uint shirqmap)
+{
+	osl_t *osh;
+	ulong hz, ns, tmp;
+	chipcregs_t *cc;
+	uint irq;
+
+	osh = sb_osh(sbh);
+
+	/* Figure out current SB clock speed */
+	if ((hz = sb_clock(sbh)) == 0)
+		hz = 100000000;
+	ns = 1000000000 / hz;
+
+	/* Setup external interface timing */
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	/* Set timing for the flash */
+	tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+	tmp |= CEIL(10, ns) << FW_W1_SHIFT;	/* W1 = 10nS */
+	tmp |= CEIL(120, ns);			/* W0 = 120nS */
+	if (sbh->ccrev < 9)
+		W_REG(osh, &cc->flash_waitcount, tmp);
+
+	if ((sbh->ccrev < 9) ||
+	    ((sb_chip(sbh) == BCM5350_CHIP_ID) && sb_chiprev(sbh) == 0)) {
+		W_REG(osh, &cc->pcmcia_memwait, tmp);
+	}
+
+	/* Save shared IRQ mapping base */
+	shirq_map_base = shirqmap;
+
+	/* Chip specific initialization */
+	switch (sb_chip(sbh)) {
+	case BCM5350_CHIP_ID:
+		/* Clear interrupt map */
+		for (irq = 0; irq <= 4; irq++)
+			sb_clearirq(sbh, irq);
+		sb_setirq(sbh, 0, SB_CC, 0);
+		sb_setirq(sbh, 0, SB_MIPS33, 0);
+		sb_setirq(sbh, 1, SB_D11, 0);
+		sb_setirq(sbh, 2, SB_ENET, 0);
+		sb_setirq(sbh, 3, SB_PCI, 0);
+		sb_setirq(sbh, 4, SB_USB, 0);
+		break;
+	case BCM4785_CHIP_ID:
+		/* Reassign PCI to irq 4 */
+		sb_setirq(sbh, 4, SB_PCI, 0);
+		break;
+	}
+}
+
+/* Do any setup necessary to run a new image and jump to it. */
+void
+hnd_cpu_jumpto(void *addr)
+{
+	void (*jumpto)(void) = addr;
+
+	(jumpto)();
+}
+
+uint32
+BCMINITFN(sb_cpu_clock)(sb_t *sbh)
+{
+	chipcregs_t *cc;
+	uint32 n, m;
+	uint idx;
+	uint32 pll_type, rate = 0;
+
+	/* get index of the current core */
+	idx = sb_coreidx(sbh);
+	pll_type = PLL_TYPE1;
+
+	/* switch to chipc core */
+	cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	/* 5354 chip uses a non programmable PLL of frequency 240MHz */
+	if (sb_chip(sbh) == BCM5354_CHIP_ID) {
+		rate = 240000000;
+		goto out;
+	}
+
+	pll_type = sbh->cccaps & CC_CAP_PLL_MASK;
+	n = R_REG(osh, &cc->clockcontrol_n);
+	if ((pll_type == PLL_TYPE2) ||
+	    (pll_type == PLL_TYPE4) ||
+	    (pll_type == PLL_TYPE6) ||
+	    (pll_type == PLL_TYPE7))
+		m = R_REG(osh, &cc->clockcontrol_m3);
+	else if (pll_type == PLL_TYPE5) {
+		rate = 200000000;
+		goto out;
+	} else if (pll_type == PLL_TYPE3) {
+		if (sb_chip(sbh) == BCM5365_CHIP_ID) {
+			rate = 200000000;
+			goto out;
+		}
+		/* 5350 uses m2 to control mips */
+		else
+			m = R_REG(osh, &cc->clockcontrol_m2);
+	} else
+		m = R_REG(osh, &cc->clockcontrol_sb);
+
+	/* calculate rate */
+	rate = sb_clock_rate(pll_type, n, m);
+
+	if (pll_type == PLL_TYPE6)
+		rate = SB2MIPS_T6(rate);
+
+out:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return rate;
+}
+
+#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4)
+
+static void
+BCMINITFN(handler)(void)
+{
+	__asm__(
+		".set\tmips32\n\t"
+		"ssnop\n\t"
+		"ssnop\n\t"
+	/* Disable interrupts */
+	/*	MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~(ALLINTS | STO_IE)); */
+		"mfc0 $15, $12\n\t"
+	/* Just a Hack to not to use reg 'at' which was causing problems on 4704 A2 */
+		"li $14, -31746\n\t"
+		"and $15, $15, $14\n\t"
+		"mtc0 $15, $12\n\t"
+		"eret\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set\tmips0");
+}
+
+/* The following MUST come right after handler() */
+static void
+BCMINITFN(afterhandler)(void)
+{
+}
+
+/*
+ * Set the MIPS, backplane and PCI clocks as closely as possible.
+ *
+ * MIPS clocks synchronization function has been moved from PLL in chipcommon
+ * core rev. 15 to a DLL inside the MIPS core in 4785.
+ */
+bool
+BCMINITFN(sb_mips_setclock)(sb_t *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock)
+{
+	chipcregs_t *cc = NULL;
+	mipsregs_t *mipsr = NULL;
+	volatile uint32 *clockcontrol_n, *clockcontrol_sb, *clockcontrol_pci, *clockcontrol_m2;
+	uint32 orig_n, orig_sb, orig_pci, orig_m2, orig_mips, orig_ratio_parm, orig_ratio_cfg;
+	uint32 pll_type, sync_mode;
+	uint ic_size, ic_lsize;
+	uint idx, i;
+
+	/* PLL configuration: type 1 */
+	typedef struct {
+		uint32 mipsclock;
+		uint16 n;
+		uint32 sb;
+		uint32 pci33;
+		uint32 pci25;
+	} n3m_table_t;
+	static n3m_table_t BCMINITDATA(type1_table)[] = {
+		/* 96.000 32.000 24.000 */
+		{ 96000000, 0x0303, 0x04020011, 0x11030011, 0x11050011 },
+		/* 100.000 33.333 25.000 */
+		{ 100000000, 0x0009, 0x04020011, 0x11030011, 0x11050011 },
+		/* 104.000 31.200 24.960 */
+		{ 104000000, 0x0802, 0x04020011, 0x11050009, 0x11090009 },
+		/* 108.000 32.400 24.923 */
+		{ 108000000, 0x0403, 0x04020011, 0x11050009, 0x02000802 },
+		/* 112.000 32.000 24.889 */
+		{ 112000000, 0x0205, 0x04020011, 0x11030021, 0x02000403 },
+		/* 115.200 32.000 24.000 */
+		{ 115200000, 0x0303, 0x04020009, 0x11030011, 0x11050011 },
+		/* 120.000 30.000 24.000 */
+		{ 120000000, 0x0011, 0x04020011, 0x11050011, 0x11090011 },
+		/* 124.800 31.200 24.960 */
+		{ 124800000, 0x0802, 0x04020009, 0x11050009, 0x11090009 },
+		/* 128.000 32.000 24.000 */
+		{ 128000000, 0x0305, 0x04020011, 0x11050011, 0x02000305 },
+		/* 132.000 33.000 24.750 */
+		{ 132000000, 0x0603, 0x04020011, 0x11050011, 0x02000305 },
+		/* 136.000 32.640 24.727 */
+		{ 136000000, 0x0c02, 0x04020011, 0x11090009, 0x02000603 },
+		/* 140.000 30.000 24.706 */
+		{ 140000000, 0x0021, 0x04020011, 0x11050021, 0x02000c02 },
+		/* 144.000 30.857 24.686 */
+		{ 144000000, 0x0405, 0x04020011, 0x01020202, 0x11090021 },
+		/* 150.857 33.000 24.000 */
+		{ 150857142, 0x0605, 0x04020021, 0x02000305, 0x02000605 },
+		/* 152.000 32.571 24.000 */
+		{ 152000000, 0x0e02, 0x04020011, 0x11050021, 0x02000e02 },
+		/* 156.000 31.200 24.960 */
+		{ 156000000, 0x0802, 0x04020005, 0x11050009, 0x11090009 },
+		/* 160.000 32.000 24.000 */
+		{ 160000000, 0x0309, 0x04020011, 0x11090011, 0x02000309 },
+		/* 163.200 32.640 24.727 */
+		{ 163200000, 0x0c02, 0x04020009, 0x11090009, 0x02000603 },
+		/* 168.000 32.000 24.889 */
+		{ 168000000, 0x0205, 0x04020005, 0x11030021, 0x02000403 },
+		/* 176.000 33.000 24.000 */
+		{ 176000000, 0x0602, 0x04020003, 0x11050005, 0x02000602 },
+		};
+
+	/* PLL configuration: type 3 */
+	typedef struct {
+		uint32 mipsclock;
+		uint16 n;
+		uint32 m2; /* that is the clockcontrol_m2 */
+	} type3_table_t;
+	static type3_table_t type3_table[] = {
+		/* for 5350, mips clock is always double sb clock */
+		{ 150000000, 0x311, 0x4020005 },
+		{ 200000000, 0x311, 0x4020003 },
+		};
+
+	/* PLL configuration: type 2, 4, 7 */
+	typedef struct {
+		uint32 mipsclock;
+		uint32 sbclock;
+		uint32 pciclock;
+		uint16 n;
+		uint32 sb;
+		uint32 pci33;
+		uint32 m2;
+		uint32 m3;
+		uint32 ratio_cfg;
+		uint32 ratio_parm;
+		uint32 d11_r1;
+		uint32 d11_r2;
+	} n4m_table_t;
+	static n4m_table_t BCMINITDATA(type2_table)[] = {
+		{ 120000000, 60000000, 32000000, 0x0303, 0x01000200, 0x01000600, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 150000000, 75000000, 33333333, 0x0303, 0x01000100, 0x01000600, 0x01000100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 180000000, 80000000, 30000000, 0x0403, 0x01010000, 0x01020300, 0x01020600,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 180000000, 90000000, 30000000, 0x0403, 0x01000100, 0x01020300, 0x01000100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 200000000, 100000000, 33333333, 0x0303, 0x02010000, 0x02040001, 0x02010000,
+		0x06000001, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 211200000, 105600000, 30171428, 0x0902, 0x01000200, 0x01030400, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 220800000, 110400000, 31542857, 0x1500, 0x01000200, 0x01030400, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 230400000, 115200000, 32000000, 0x0604, 0x01000200, 0x01020600, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 234000000, 104000000, 31200000, 0x0b01, 0x01010000, 0x01010700, 0x01020600,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 240000000, 120000000, 33333333, 0x0803, 0x01000200, 0x01020600, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 252000000, 126000000, 33333333, 0x0504, 0x01000100, 0x01020500, 0x01000100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 264000000, 132000000, 33000000, 0x0903, 0x01000200, 0x01020700, 0x01000200,
+		0x05000200, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 270000000, 120000000, 30000000, 0x0703, 0x01010000, 0x01030400, 0x01020600,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 276000000, 122666666, 31542857, 0x1500, 0x01010000, 0x01030400, 0x01020600,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 280000000, 140000000, 31111111, 0x0503, 0x01000000, 0x01010600, 0x01000000,
+		0x05000000, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 288000000, 128000000, 32914285, 0x0604, 0x01010000, 0x01030400, 0x01020600,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 288000000, 144000000, 32000000, 0x0404, 0x01000000, 0x01010600, 0x01000000,
+		0x05000000, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 300000000, 133333333, 33333333, 0x0803, 0x01010000, 0x01020600, 0x01010100,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 300000000, 133333333, 37500000, 0x0803, 0x01010000, 0x01020500, 0x01010100,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 300000000, 133333333, 42857142, 0x0803, 0x01010000, 0x01020400, 0x01010100,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 300000000, 133333333, 50000000, 0x0803, 0x01010000, 0x01020300, 0x01010100,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 300000000, 133333333, 60000000, 0x0803, 0x01010000, 0x01020200, 0x01010100,
+		0x05000100, 8, 0x012a00a9, 9 /* ratio  4/9 */, 0x012a00a9 },
+		{ 300000000, 150000000, 33333333, 0x0803, 0x01000100, 0x01020600, 0x01010100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 300000000, 150000000, 37500000, 0x0803, 0x01000100, 0x01020500, 0x01010100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 300000000, 150000000, 42857142, 0x0803, 0x01000100, 0x01020400, 0x01010100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 300000000, 150000000, 50000000, 0x0803, 0x01000100, 0x01020300, 0x01010100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 300000000, 150000000, 60000000, 0x0803, 0x01000100, 0x01020200, 0x01010100,
+		0x05000100, 11, 0x0aaa0555, 8 /* ratio  4/8 */, 0x00aa0055 },
+		{ 330000000, 132000000, 33000000, 0x0903, 0x01000200, 0x00020200, 0x01010100,
+		0x05000100, 0, 0, 10 /* ratio 4/10 */, 0x02520129 },
+		{ 330000000, 146666666, 33000000, 0x0903, 0x01010000, 0x00020200, 0x01010100,
+		0x05000100, 0, 0, 9 /* ratio 4/9 */, 0x012a00a9 },
+		{ 330000000, 165000000, 33000000, 0x0903, 0x01000100, 0x00020200, 0x01010100,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 330000000, 165000000, 41250000, 0x0903, 0x01000100, 0x00020100, 0x01010100,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 330000000, 165000000, 55000000, 0x0903, 0x01000100, 0x00020000, 0x01010100,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 360000000, 120000000, 32000000, 0x0a03, 0x01000300, 0x00010201, 0x01010200,
+		0x05000100, 0, 0, 12 /* ratio 4/12 */, 0x04920492 },
+		{ 360000000, 144000000, 32000000, 0x0a03, 0x01000200, 0x00010201, 0x01010200,
+		0x05000100, 0, 0, 10 /* ratio 4/10 */, 0x02520129 },
+		{ 360000000, 160000000, 32000000, 0x0a03, 0x01010000, 0x00010201, 0x01010200,
+		0x05000100, 0, 0, 9 /* ratio 4/9 */, 0x012a00a9 },
+		{ 360000000, 180000000, 32000000, 0x0a03, 0x01000100, 0x00010201, 0x01010200,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 360000000, 180000000, 40000000, 0x0a03, 0x01000100, 0x00010101, 0x01010200,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 360000000, 180000000, 53333333, 0x0a03, 0x01000100, 0x00010001, 0x01010200,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+		{ 390000000, 130000000, 32500000, 0x0b03, 0x01010100, 0x00020101, 0x01020100,
+		0x05000100, 0, 0, 12 /* ratio 4/12 */, 0x04920492 },
+		{ 390000000, 156000000, 32500000, 0x0b03, 0x01000200, 0x00020101, 0x01020100,
+		0x05000100, 0, 0, 10 /* ratio 4/10 */, 0x02520129 },
+		{ 390000000, 173000000, 32500000, 0x0b03, 0x01010000, 0x00020101, 0x01020100,
+		0x05000100, 0, 0, 9 /* ratio 4/9 */, 0x012a00a9 },
+		{ 390000000, 195000000, 32500000, 0x0b03, 0x01000100, 0x00020101, 0x01020100,
+		0x05000100, 0, 0, 8 /* ratio 4/8 */, 0x00aa0055 },
+	};
+	static n4m_table_t BCMINITDATA(type4_table)[] = {
+		{ 120000000, 60000000, 0, 0x0009, 0x11020009, 0x01030203, 0x11020009, 0x04000009,
+		11, 0x0aaa0555 },
+		{ 150000000, 75000000, 0, 0x0009, 0x11050002, 0x01030203, 0x11050002, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 192000000, 96000000, 0, 0x0702, 0x04000011, 0x11030011, 0x04000011, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 198000000, 99000000, 0, 0x0603, 0x11020005, 0x11030011, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0, 0x0009, 0x04020011, 0x11030011, 0x04020011, 0x04020003,
+		11, 0x0aaa0555 },
+		{ 204000000, 102000000, 0, 0x0c02, 0x11020005, 0x01030303, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 208000000, 104000000, 0, 0x0802, 0x11030002, 0x11090005, 0x11030002, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 210000000, 105000000, 0, 0x0209, 0x11020005, 0x01030303, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 216000000, 108000000, 0, 0x0111, 0x11020005, 0x01030303, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 224000000, 112000000, 0, 0x0205, 0x11030002, 0x02002103, 0x11030002, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 228000000, 101333333, 0, 0x0e02, 0x11030003, 0x11210005, 0x01030305, 0x04000005,
+		8, 0x012a00a9 },
+		{ 228000000, 114000000, 0, 0x0e02, 0x11020005, 0x11210005, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 240000000, 102857143, 0, 0x0109, 0x04000021, 0x01050203, 0x11030021, 0x04000003,
+		13, 0x254a14a9 },
+		{ 240000000, 120000000, 0, 0x0109, 0x11030002, 0x01050203, 0x11030002, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 252000000, 100800000, 0, 0x0203, 0x04000009, 0x11050005, 0x02000209, 0x04000002,
+		9, 0x02520129 },
+		{ 252000000, 126000000, 0, 0x0203, 0x04000005, 0x11050005, 0x04000005, 0x04000002,
+		11, 0x0aaa0555 },
+		{ 264000000, 132000000, 0, 0x0602, 0x04000005, 0x11050005, 0x04000005, 0x04000002,
+		11, 0x0aaa0555 },
+		{ 272000000, 116571428, 0, 0x0c02, 0x04000021, 0x02000909, 0x02000221, 0x04000003,
+		13, 0x254a14a9 },
+		{ 280000000, 120000000, 0, 0x0209, 0x04000021, 0x01030303, 0x02000221, 0x04000003,
+		13, 0x254a14a9 },
+		{ 288000000, 123428571, 0, 0x0111, 0x04000021, 0x01030303, 0x02000221, 0x04000003,
+		13, 0x254a14a9 },
+		{ 300000000, 120000000, 0, 0x0009, 0x04000009, 0x01030203, 0x02000902, 0x04000002,
+		9, 0x02520129 },
+		{ 300000000, 150000000, 0, 0x0009, 0x04000005, 0x01030203, 0x04000005, 0x04000002,
+		11, 0x0aaa0555 }
+	};
+	static n4m_table_t BCMINITDATA(type7_table)[] = {
+		{ 183333333, 91666666, 0, 0x0605, 0x04000011, 0x11030011, 0x04000011, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 187500000, 93750000, 0, 0x0a03, 0x04000011, 0x11030011, 0x04000011, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 196875000, 98437500, 0, 0x1003, 0x11020005, 0x11050011, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0, 0x0311, 0x04000011, 0x11030011, 0x04000009, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0, 0x0311, 0x04020011, 0x11030011, 0x04020011, 0x04020003,
+		11, 0x0aaa0555 },
+		{ 206250000, 103125000, 0, 0x1103, 0x11020005, 0x11050011, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 212500000, 106250000, 0, 0x0c05, 0x11020005, 0x01030303, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 215625000, 107812500, 0, 0x1203, 0x11090009, 0x11050005, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 216666666, 108333333, 0, 0x0805, 0x11020003, 0x11030011, 0x11020003, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 225000000, 112500000, 0, 0x0d03, 0x11020003, 0x11030011, 0x11020003, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 233333333, 116666666, 0, 0x0905, 0x11020003, 0x11030011, 0x11020003, 0x04000003,
+		11, 0x0aaa0555 },
+		{ 237500000, 118750000, 0, 0x0e05, 0x11020005, 0x11210005, 0x11020005, 0x04000005,
+		11, 0x0aaa0555 },
+		{ 240000000, 120000000, 0, 0x0b11, 0x11020009, 0x11210009, 0x11020009, 0x04000009,
+		11, 0x0aaa0555 },
+		{ 250000000, 125000000, 0, 0x0f03, 0x11020003, 0x11210003, 0x11020003, 0x04000003,
+		11, 0x0aaa0555 }
+	};
+
+	ulong start, end, dst;
+	bool ret = FALSE;
+
+	volatile uint32 *dll_ctrl = (volatile uint32 *)0xff400008;
+	volatile uint32 *dll_r1 = (volatile uint32 *)0xff400010;
+	volatile uint32 *dll_r2 = (volatile uint32 *)0xff400018;
+
+	/* get index of the current core */
+	idx = sb_coreidx(sbh);
+	clockcontrol_m2 = NULL;
+
+	/* switch to chipc core */
+	cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	/* 5354 chipcommon pll setting can't be changed. 
+	 * The PMU on power up comes up with the default clk frequency
+	 * of 240MHz
+	 */
+	if (sb_chip(sbh) == BCM5354_CHIP_ID) {
+		ret = TRUE;
+		goto done;
+	}
+
+	pll_type = sbh->cccaps & CC_CAP_PLL_MASK;
+	if (pll_type == PLL_TYPE6) {
+		clockcontrol_n = NULL;
+		clockcontrol_sb = NULL;
+		clockcontrol_pci = NULL;
+	} else {
+		clockcontrol_n = &cc->clockcontrol_n;
+		clockcontrol_sb = &cc->clockcontrol_sb;
+		clockcontrol_pci = &cc->clockcontrol_pci;
+		clockcontrol_m2 = &cc->clockcontrol_m2;
+	}
+
+	if (pll_type == PLL_TYPE6) {
+		/* Silence compilers */
+		orig_n = orig_sb = orig_pci = 0;
+	} else {
+		/* Store the current clock register values */
+		orig_n = R_REG(osh, clockcontrol_n);
+		orig_sb = R_REG(osh, clockcontrol_sb);
+		orig_pci = R_REG(osh, clockcontrol_pci);
+	}
+
+	if (pll_type == PLL_TYPE1) {
+		/* Keep the current PCI clock if not specified */
+		if (pciclock == 0) {
+			pciclock = sb_clock_rate(pll_type, R_REG(osh, clockcontrol_n),
+			                         R_REG(osh, clockcontrol_pci));
+			pciclock = (pciclock <= 25000000) ? 25000000 : 33000000;
+		}
+
+		/* Search for the closest MIPS clock less than or equal to a preferred value */
+		for (i = 0; i < ARRAYSIZE(type1_table); i++) {
+			ASSERT(type1_table[i].mipsclock ==
+			       sb_clock_rate(pll_type, type1_table[i].n,
+			       type1_table[i].sb));
+			if (type1_table[i].mipsclock > mipsclock)
+				break;
+		}
+		if (i == 0) {
+			ret = FALSE;
+			goto done;
+		} else {
+			ret = TRUE;
+			i--;
+		}
+		ASSERT(type1_table[i].mipsclock <= mipsclock);
+
+		/* No PLL change */
+		if ((orig_n == type1_table[i].n) &&
+		    (orig_sb == type1_table[i].sb) &&
+		    (orig_pci == type1_table[i].pci33))
+			goto done;
+
+		/* Set the PLL controls */
+		W_REG(osh, clockcontrol_n, type1_table[i].n);
+		W_REG(osh, clockcontrol_sb, type1_table[i].sb);
+		if (pciclock == 25000000)
+			W_REG(osh, clockcontrol_pci, type1_table[i].pci25);
+		else
+			W_REG(osh, clockcontrol_pci, type1_table[i].pci33);
+
+		/* Reset */
+		sb_watchdog(sbh, 1);
+		while (1);
+	} else if (pll_type == PLL_TYPE3) {
+		/* 5350 */
+		if (sb_chip(sbh) != BCM5365_CHIP_ID) {
+			/*
+			 * Search for the closest MIPS clock less than or equal to
+			 * a preferred value.
+			 */
+			for (i = 0; i < ARRAYSIZE(type3_table); i++) {
+				if (type3_table[i].mipsclock > mipsclock)
+					break;
+			}
+			if (i == 0) {
+				ret = FALSE;
+				goto done;
+			} else {
+				ret = TRUE;
+				i--;
+			}
+			ASSERT(type3_table[i].mipsclock <= mipsclock);
+
+			/* No PLL change */
+			orig_m2 = R_REG(osh, &cc->clockcontrol_m2);
+			if ((orig_n == type3_table[i].n) &&
+			    (orig_m2 == type3_table[i].m2)) {
+				goto done;
+			}
+
+			/* Set the PLL controls */
+			W_REG(osh, clockcontrol_n, type3_table[i].n);
+			W_REG(osh, clockcontrol_m2, type3_table[i].m2);
+
+			/* Reset */
+			sb_watchdog(sbh, 1);
+			while (1);
+		}
+	} else if ((pll_type == PLL_TYPE2) ||
+	           (pll_type == PLL_TYPE4) ||
+	           (pll_type == PLL_TYPE6) ||
+	           (pll_type == PLL_TYPE7)) {
+		n4m_table_t *table = NULL, *te;
+		uint tabsz = 0;
+
+		ASSERT(cc);
+
+		orig_mips = R_REG(osh, &cc->clockcontrol_m3);
+
+		switch (pll_type) {
+		case PLL_TYPE6: {
+			uint32 new_mips = 0;
+
+			ret = TRUE;
+			if (mipsclock <= SB2MIPS_T6(CC_T6_M1))
+				new_mips = CC_T6_MMASK;
+
+			if (orig_mips == new_mips)
+				goto done;
+
+			W_REG(osh, &cc->clockcontrol_m3, new_mips);
+			goto end_fill;
+		}
+		case PLL_TYPE2:
+			table = type2_table;
+			tabsz = ARRAYSIZE(type2_table);
+			break;
+		case PLL_TYPE4:
+			table = type4_table;
+			tabsz = ARRAYSIZE(type4_table);
+			break;
+		case PLL_TYPE7:
+			table = type7_table;
+			tabsz = ARRAYSIZE(type7_table);
+			break;
+		default:
+			ASSERT("No table for plltype" == NULL);
+			break;
+		}
+
+		/* Store the current clock register values */
+		orig_m2 = R_REG(osh, &cc->clockcontrol_m2);
+		orig_ratio_parm = 0;
+		orig_ratio_cfg = 0;
+
+		/* Look up current ratio */
+		for (i = 0; i < tabsz; i++) {
+			if ((orig_n == table[i].n) &&
+			    (orig_sb == table[i].sb) &&
+			    (orig_pci == table[i].pci33) &&
+			    (orig_m2 == table[i].m2) &&
+			    (orig_mips == table[i].m3)) {
+				orig_ratio_parm = table[i].ratio_parm;
+				orig_ratio_cfg = table[i].ratio_cfg;
+				break;
+			}
+		}
+
+		/* Search for the closest MIPS clock greater or equal to a preferred value */
+		for (i = 0; i < tabsz; i++) {
+			ASSERT(table[i].mipsclock ==
+			       sb_clock_rate(pll_type, table[i].n, table[i].m3));
+			if ((mipsclock <= table[i].mipsclock) &&
+			    ((sbclock == 0) || (sbclock <= table[i].sbclock)) &&
+			    ((pciclock == 0) || (pciclock <= table[i].pciclock)))
+				break;
+		}
+		if (i == tabsz) {
+			ret = FALSE;
+			goto done;
+		} else {
+			te = &table[i];
+			ret = TRUE;
+		}
+
+		/* No PLL change */
+		if ((orig_n == te->n) &&
+		    (orig_sb == te->sb) &&
+		    (orig_pci == te->pci33) &&
+		    (orig_m2 == te->m2) &&
+		    (orig_mips == te->m3))
+			goto done;
+
+		/* Set the PLL controls */
+		W_REG(osh, clockcontrol_n, te->n);
+		W_REG(osh, clockcontrol_sb, te->sb);
+		W_REG(osh, clockcontrol_pci, te->pci33);
+		W_REG(osh, &cc->clockcontrol_m2, te->m2);
+		W_REG(osh, &cc->clockcontrol_m3, te->m3);
+
+		/* Set the chipcontrol bit to change mipsref to the backplane divider if needed */
+		if ((pll_type == PLL_TYPE7) && (te->sb != te->m2) &&
+		    (sb_clock_rate(pll_type, te->n, te->m2) == 120000000))
+			W_REG(osh, &cc->chipcontrol,
+			      R_REG(osh, &cc->chipcontrol) | 0x100);
+
+		/* No ratio change */
+		if (sb_chip(sbh) != BCM4785_CHIP_ID) {
+			if (orig_ratio_parm == te->ratio_parm)
+				goto end_fill;
+		}
+
+		/* Preload the code into the cache */
+		icache_probe(MFC0(C0_CONFIG, 1), &ic_size, &ic_lsize);
+		if (sb_chip(sbh) == BCM4785_CHIP_ID) {
+			start = ((ulong) &&start_fill_4785) & ~(ic_lsize - 1);
+			end = ((ulong) &&end_fill_4785 + (ic_lsize - 1)) & ~(ic_lsize - 1);
+		}
+		else {
+			start = ((ulong) &&start_fill) & ~(ic_lsize - 1);
+			end = ((ulong) &&end_fill + (ic_lsize - 1)) & ~(ic_lsize - 1);
+		}
+		while (start < end) {
+			cache_op(start, Fill_I);
+			start += ic_lsize;
+		}
+
+		/* 4785 clock freq change procedures */
+		if (sb_chip(sbh) == BCM4785_CHIP_ID) {
+	start_fill_4785:
+			/* Switch to async */
+			MTC0(C0_BROADCOM, 4, (1 << 22));
+
+			/* Set clock ratio in MIPS */
+			*dll_r1 = (*dll_r1 & 0xfffffff0) | (te->d11_r1 - 1);
+			*dll_r2 = te->d11_r2;
+
+			/* Enable new settings in MIPS */
+			*dll_r1 = *dll_r1 | 0xc0000000;
+
+			/* Set active cfg */
+			MTC0(C0_BROADCOM, 2, MFC0(C0_BROADCOM, 2) | (1 << 3) | 1);
+
+			/* Fake soft reset (clock cfg registers not reset) */
+			MTC0(C0_BROADCOM, 5, MFC0(C0_BROADCOM, 5) | (1 << 2));
+
+			/* Clear active cfg */
+			MTC0(C0_BROADCOM, 2, MFC0(C0_BROADCOM, 2) & ~(1 << 3));
+
+			/* set watchdog timer */
+			W_REG(osh, &cc->watchdog, 20);
+			(void) R_REG(osh, &cc->chipid);
+
+			/* wait for timer interrupt */
+			__asm__ __volatile__(
+				".set\tmips3\n\t"
+				"sync\n\t"
+				"wait\n\t"
+				".set\tmips0");
+	end_fill_4785:
+			while (1);
+		}
+		/* Generic clock freq change procedures */
+		else {
+			/* Copy the handler */
+			start = (ulong) &handler;
+			end = (ulong) &afterhandler;
+			dst = KSEG1ADDR(0x180);
+			for (i = 0; i < (end - start); i += 4)
+				*((ulong *)(dst + i)) = *((ulong *)(start + i));
+
+			/* Preload the handler into the cache one line at a time */
+			for (i = 0; i < (end - start); i += ic_lsize)
+				cache_op(dst + i, Fill_I);
+
+			/* Clear BEV bit */
+			MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~ST0_BEV);
+
+			/* Enable interrupts */
+			MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) | (ALLINTS | ST0_IE));
+
+			/* Enable MIPS timer interrupt */
+			mipsr = sb_setcore(sbh, SB_MIPS33, 0);
+			ASSERT(mipsr);
+			W_REG(osh, &mipsr->intmask, 1);
+
+	start_fill:
+			/* step 1, set clock ratios */
+			MTC0(C0_BROADCOM, 3, te->ratio_parm);
+			MTC0(C0_BROADCOM, 1, te->ratio_cfg);
+
+			/* step 2: program timer intr */
+			W_REG(osh, &mipsr->timer, 100);
+			(void) R_REG(osh, &mipsr->timer);
+
+			/* step 3, switch to async */
+			sync_mode = MFC0(C0_BROADCOM, 4);
+			MTC0(C0_BROADCOM, 4, 1 << 22);
+
+			/* step 4, set cfg active */
+			MTC0(C0_BROADCOM, 2, (1 << 3) | 1);
+
+			/* steps 5 & 6 */
+			__asm__ __volatile__(
+				".set\tmips3\n\t"
+				"wait\n\t"
+				".set\tmips0");
+
+			/* step 7, clear cfg active */
+			MTC0(C0_BROADCOM, 2, 0);
+
+			/* Additional Step: set back to orig sync mode */
+			MTC0(C0_BROADCOM, 4, sync_mode);
+
+			/* step 8, fake soft reset */
+			MTC0(C0_BROADCOM, 5, MFC0(C0_BROADCOM, 5) | (1 << 2));
+
+	end_fill:
+			/* set watchdog timer */
+			W_REG(osh, &cc->watchdog, 20);
+			(void) R_REG(osh, &cc->chipid);
+
+			/* wait for timer interrupt */
+			__asm__ __volatile__(
+				".set\tmips3\n\t"
+				"sync\n\t"
+				"wait\n\t"
+				".set\tmips0");
+			while (1);
+		}
+	}
+
+done:
+	/* Enable 4785 DLL */
+	if (sb_chip(sbh) == BCM4785_CHIP_ID) {
+		uint32 tmp;
+
+		/* set mask to 1e, enable DLL (bit 0) */
+		*dll_ctrl |= 0x0041e021;
+
+		/* enable aggressive hardware mode */
+		*dll_ctrl |= 0x00000080;
+
+		/* wait for lock flag to clear */
+		while ((*dll_ctrl & 0x2) == 0);
+
+		/* clear sticky flags (clear on write 1) */
+		tmp = *dll_ctrl;
+		*dll_ctrl = tmp;
+
+		/* set mask to 5b'10001 */
+		*dll_ctrl = (*dll_ctrl & 0xfffc1fff) | 0x00022000;
+
+		/* enable sync mode */
+		MTC0(C0_BROADCOM, 4, MFC0(C0_BROADCOM, 4) & 0xfe3fffff);
+		(void)MFC0(C0_BROADCOM, 4);
+	}
+
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
+void
+BCMINITFN(enable_pfc)(uint32 mode)
+{
+	ulong start, end;
+	uint ic_size, ic_lsize;
+
+	/* If auto then choose the correct mode for this
+	 * platform, currently we only ever select one mode
+	 */
+	if (mode == PFC_AUTO)
+		mode = PFC_INST;
+
+	icache_probe(MFC0(C0_CONFIG, 1), &ic_size, &ic_lsize);
+
+	/* enable prefetch cache if available */
+	if (MFC0(C0_BROADCOM, 0) & BRCM_PFC_AVAIL) {
+		start = ((ulong) &&setpfc_start) & ~(ic_lsize - 1);
+		end = ((ulong) &&setpfc_end + (ic_lsize - 1)) & ~(ic_lsize - 1);
+
+		/* Preload setpfc code into the cache one line at a time */
+		while (start < end) {
+			cache_op(start, Fill_I);
+			start += ic_lsize;
+		}
+
+		/* Now set the pfc */
+	setpfc_start:
+		/* write range */
+		*(volatile uint32 *)PFC_CR1 = 0xffff0000;
+
+		/* enable */
+		*(volatile uint32 *)PFC_CR0 = mode;
+	setpfc_end:
+		/* Compiler foder */
+		ic_size = 0;
+	}
+}
+
+/* returns the ncdl value to be programmed into sdram_ncdl for calibration */
+uint32
+BCMINITFN(sb_memc_get_ncdl)(sb_t *sbh)
+{
+	osl_t *osh;
+	sbmemcregs_t *memc;
+	uint32 ret = 0;
+	uint32 config, rd, wr, misc, dqsg, cd, sm, sd;
+	uint idx, rev;
+
+	osh = sb_osh(sbh);
+
+	idx = sb_coreidx(sbh);
+
+	memc = (sbmemcregs_t *)sb_setcore(sbh, SB_MEMC, 0);
+	if (memc == 0)
+		goto out;
+
+	rev = sb_corerev(sbh);
+
+	config = R_REG(osh, &memc->config);
+	wr = R_REG(osh, &memc->wrncdlcor);
+	rd = R_REG(osh, &memc->rdncdlcor);
+	misc = R_REG(osh, &memc->miscdlyctl);
+	dqsg = R_REG(osh, &memc->dqsgatencdl);
+
+	rd &= MEMC_RDNCDLCOR_RD_MASK;
+	wr &= MEMC_WRNCDLCOR_WR_MASK;
+	dqsg &= MEMC_DQSGATENCDL_G_MASK;
+
+	if (config & MEMC_CONFIG_DDR) {
+		ret = (wr << 16) | (rd << 8) | dqsg;
+	} else {
+		if (rev > 0)
+			cd = rd;
+		else
+			cd = (rd == MEMC_CD_THRESHOLD) ? rd : (wr + MEMC_CD_THRESHOLD);
+		sm = (misc & MEMC_MISC_SM_MASK) >> MEMC_MISC_SM_SHIFT;
+		sd = (misc & MEMC_MISC_SD_MASK) >> MEMC_MISC_SD_SHIFT;
+		ret = (sm << 16) | (sd << 8) | cd;
+	}
+
+out:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
+void
+hnd_cpu_reset(sb_t *sbh)
+{
+	if (sb_chip(sbh) == BCM4785_CHIP_ID)
+		MTC0(C0_BROADCOM, 4, (1 << 22));
+	sb_watchdog(sbh, 1);
+	if (sb_chip(sbh) == BCM4785_CHIP_ID) {
+		__asm__ __volatile__(
+			".set\tmips3\n\t"
+			"sync\n\t"
+			"wait\n\t"
+			".set\tmips0");
+	}
+	while (1);
+}
+
+#if defined(CONFIG_BCMPERFSTATS)
+/*
+ * CP0 Register 25 supports 4 semi-independent 32bit performance counters.
+ * $25 select 0, 1, 2, and 3 are the counters.  The counters *decrement* (who thought this one up?)
+ * $25 select 4 and 5 each contain 2-16bit control fields, one for each of the 4 counters
+ * $25 select 6 is the global perf control register.
+ */
+/* enable and start instruction counting */
+
+void
+hndmips_perf_cyclecount_enable(void)
+{
+	MTC0(C0_PERFORMANCE, 6, 0x80000200);	/* global enable perf counters */
+	MTC0(C0_PERFORMANCE, 4,
+	     0x8048 | MFC0(C0_PERFORMANCE, 4));	/* enable cycles counting for counter 0 */
+	MTC0(C0_PERFORMANCE, 0, 0);		/* zero counter zero */
+}
+
+void
+hndmips_perf_instrcount_enable(void)
+{
+	MTC0(C0_PERFORMANCE, 6, 0x80000200);	/* global enable perf counters */
+	MTC0(C0_PERFORMANCE, 4,
+	     0x8044 | MFC0(C0_PERFORMANCE, 4));	/* enable instructions counting for counter 0 */
+	MTC0(C0_PERFORMANCE, 0, 0);		/* zero counter zero */
+}
+
+/* enable and start I$ hit and I$ miss counting */
+void
+hndmips_perf_icachecount_enable(void)
+{
+	MTC0(C0_PERFORMANCE, 6, 0x80000218);	/* enable I$ counting */
+	MTC0(C0_PERFORMANCE, 4, 0x80148018);	/* count I$ hits in cntr 0 and misses in cntr 1 */
+	MTC0(C0_PERFORMANCE, 0, 0);		/* zero counter 0 - # I$ hits */
+	MTC0(C0_PERFORMANCE, 1, 0);		/* zero counter 1 - # I$ misses */
+}
+
+/* enable and start D$ hit and I$ miss counting */
+void
+hndmips_perf_dcachecount_enable(void)
+{
+	MTC0(C0_PERFORMANCE, 6, 0x80000211);	/* enable D$ counting */
+	MTC0(C0_PERFORMANCE, 4, 0x80248028);	/* count D$ hits in cntr 0 and misses in cntr 1 */
+	MTC0(C0_PERFORMANCE, 0, 0);		/* zero counter 0 - # D$ hits */
+	MTC0(C0_PERFORMANCE, 1, 0);		/* zero counter 1 - # D$ misses */
+}
+
+void
+hndmips_perf_icache_miss_enable()
+{
+	MTC0(C0_PERFORMANCE, 4,
+	     0x80140000 | MFC0(C0_PERFORMANCE, 4)); /* enable cache misses counting for counter 1 */
+	MTC0(C0_PERFORMANCE, 1, 0); /* zero counter one */
+}
+
+
+void
+hndmips_perf_icache_hit_enable()
+{
+	MTC0(C0_PERFORMANCE, 5, 0x8018 | MFC0(C0_PERFORMANCE, 5));
+	/* enable cache hits counting for counter 2 */
+	MTC0(C0_PERFORMANCE, 2, 0);		/* zero counter 2 */
+}
+
+uint32
+hndmips_perf_read_instrcount()
+{
+	return -(long)(MFC0(C0_PERFORMANCE, 0));
+}
+
+uint32
+hndmips_perf_read_cache_miss()
+{
+	return -(long)(MFC0(C0_PERFORMANCE, 1));
+}
+
+uint32
+hndmips_perf_read_cache_hit()
+{
+	return -(long)(MFC0(C0_PERFORMANCE, 2));
+}
+
+#endif 
--- src/shared.1927/hndpci.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/hndpci.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,803 @@
+/*
+ * Low-Level PCI and SB support for BCM47xx
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <pcicfg.h>
+#include <bcmdevs.h>
+#include <sbconfig.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <sbpci.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <hndcpu.h>
+#include <hndmips.h>
+#include <hndpci.h>
+
+/* debug/trace */
+#ifdef BCMDBG_PCI
+#define	PCI_MSG(args)	printf args
+#else
+#define	PCI_MSG(args)
+#endif	/* BCMDBG_PCI */
+
+/* Can free sbpci_init() memory after boot */
+#ifndef linux
+#define __init
+#endif /* linux */
+
+/* Emulated configuration space */
+typedef struct {
+	int	n;
+	uint	size0;
+	uint	size1;
+	uint	size2;
+	uint	size3;
+} sb_bar_cfg_t;
+static pci_config_regs sb_config_regs[SB_MAXCORES];
+static sb_bar_cfg_t sb_bar_cfg[SB_MAXCORES];
+
+/* Links to emulated and real PCI configuration spaces */
+#define MAXFUNCS  2
+typedef struct {
+	pci_config_regs *emu;	/* emulated PCI config */
+	pci_config_regs *pci;	/* real PCI config */
+	sb_bar_cfg_t *bar;	/* region sizes */
+} sb_pci_cfg_t;
+static sb_pci_cfg_t sb_pci_cfg[SB_MAXCORES][MAXFUNCS];
+
+/* Special emulated config space for non-existing device */
+static pci_config_regs sb_pci_null = { 0xffff, 0xffff };
+
+/* Banned cores */
+static uint16 pci_ban[SB_MAXCORES] = { 0 };
+static uint pci_banned = 0;
+
+/* CardBus mode */
+static bool cardbus = FALSE;
+
+/* Disable PCI host core */
+static bool pci_disabled = FALSE;
+
+/* Host bridge slot #, default to 0 */
+static uint8 pci_hbslot = 0;
+
+/* Internal macros */
+#define PCI_SLOTAD_MAP	16	/* SLOT<n> mapps to AD<n+16> */
+#define PCI_HBSBCFG_REV	8	/* MIN. core rev. required to
+				 * access host bridge PCI cfg space
+				 * from SB
+				 */
+
+/*
+ * Functions for accessing external PCI configuration space
+ */
+
+/* Assume one-hot slot wiring */
+#define PCI_SLOT_MAX 16	/* Max. PCI Slots */
+
+static uint32
+config_cmd(sb_t *sbh, uint bus, uint dev, uint func, uint off)
+{
+	uint coreidx;
+	sbpciregs_t *regs;
+	uint32 addr = 0;
+	osl_t *osh;
+
+	/* CardBusMode supports only one device */
+	if (cardbus && dev > 1)
+		return 0;
+
+	osh = sb_osh(sbh);
+
+	coreidx = sb_coreidx(sbh);
+	regs = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0);
+
+	/* Type 0 transaction */
+	if (bus == 1) {
+		/* Skip unwired slots */
+		if (dev < PCI_SLOT_MAX) {
+			uint32 win;
+
+			/* Slide the PCI window to the appropriate slot */
+			win = (SBTOPCI_CFG0 | ((1 << (dev + PCI_SLOTAD_MAP)) & SBTOPCI1_MASK));
+			W_REG(osh, &regs->sbtopci1, win);
+			addr = SB_PCI_CFG |
+			        ((1 << (dev + PCI_SLOTAD_MAP)) & ~SBTOPCI1_MASK) |
+			        (func << PCICFG_FUN_SHIFT) |
+			        (off & ~3);
+		}
+	} else {
+		/* Type 1 transaction */
+		W_REG(osh, &regs->sbtopci1, SBTOPCI_CFG1);
+		addr = SB_PCI_CFG |
+		        (bus << PCICFG_BUS_SHIFT) |
+		        (dev << PCICFG_SLOT_SHIFT) |
+		        (func << PCICFG_FUN_SHIFT) |
+		        (off & ~3);
+	}
+
+	sb_setcoreidx(sbh, coreidx);
+
+	return addr;
+}
+
+/*
+ * Read host bridge PCI config registers from Silicon Backplane (>=rev8).
+ *
+ * It returns TRUE to indicate that access to the host bridge's pci config
+ * from SB is ok, and values in 'addr' and 'val' are valid.
+ *
+ * It can only read registers at multiple of 4-bytes. Callers must pick up
+ * needed bytes from 'val' based on 'off' value. Value in 'addr' reflects
+ * the register address where value in 'val' is read.
+ */
+static bool
+sb_pcihb_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off,
+                  uint32 **addr, uint32 *val)
+{
+	sbpciregs_t *regs;
+	osl_t *osh;
+	uint coreidx;
+	bool ret = FALSE;
+
+	/* sanity check */
+	ASSERT(bus == 1);
+	ASSERT(dev == pci_hbslot);
+	ASSERT(func == 0);
+
+	osh = sb_osh(sbh);
+
+	/* read pci config when core rev >= 8 */
+	coreidx = sb_coreidx(sbh);
+	regs = (sbpciregs_t *)sb_setcore(sbh, SB_PCI, 0);
+	if (regs && sb_corerev(sbh) >= PCI_HBSBCFG_REV) {
+		*addr = (uint32 *)&regs->pcicfg[func][off >> 2];
+		*val = R_REG(osh, *addr);
+		ret = TRUE;
+	}
+	sb_setcoreidx(sbh, coreidx);
+
+	return ret;
+}
+
+int
+extpci_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	uint32 addr = 0, *reg = NULL, val;
+	int ret = 0;
+
+	/*
+	 * Set value to -1 when:
+	 *	flag 'pci_disabled' is true;
+	 *	value of 'addr' is zero;
+	 *	REG_MAP() fails;
+	 *	BUSPROBE() fails;
+	 */
+	if (pci_disabled)
+		val = 0xffffffff;
+	else if (bus == 1 && dev == pci_hbslot && func == 0 &&
+	         sb_pcihb_read_config(sbh, bus, dev, func, off, &reg, &val))
+		;
+	else if (((addr = config_cmd(sbh, bus, dev, func, off)) == 0) ||
+	         ((reg = (uint32 *)REG_MAP(addr, len)) == 0) ||
+	         (BUSPROBE(val, reg) != 0)) {
+		PCI_MSG(("%s: Failed to read!\n", __FUNCTION__));
+		val = 0xffffffff;
+	}
+
+	PCI_MSG(("%s: 0x%x <= 0x%p(0x%x), len %d, off 0x%x, buf 0x%p\n",
+	       __FUNCTION__, val, reg, addr, len, off, buf));
+
+	val >>= 8 * (off & 3);
+	if (len == 4)
+		*((uint32 *) buf) = val;
+	else if (len == 2)
+		*((uint16 *) buf) = (uint16) val;
+	else if (len == 1)
+		*((uint8 *) buf) = (uint8) val;
+	else
+		ret = -1;
+
+	if (reg && addr)
+		REG_UNMAP(reg);
+
+	return ret;
+}
+
+int
+extpci_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	osl_t *osh;
+	uint32 addr = 0, *reg = NULL, val;
+	int ret = 0;
+
+	osh = sb_osh(sbh);
+
+	/*
+	 * Ignore write attempt when:
+	 *	flag 'pci_disabled' is true;
+	 *	value of 'addr' is zero;
+	 *	REG_MAP() fails;
+	 *	BUSPROBE() fails;
+	 */
+	if (pci_disabled)
+		return 0;
+	else if (bus == 1 && dev == pci_hbslot && func == 0 &&
+	         sb_pcihb_read_config(sbh, bus, dev, func, off, &reg, &val))
+		;
+	else if (((addr = config_cmd(sbh, bus, dev, func, off)) == 0) ||
+	         ((reg = (uint32 *) REG_MAP(addr, len)) == 0) ||
+	         (BUSPROBE(val, reg) != 0)) {
+		PCI_MSG(("%s: Failed to write!\n", __FUNCTION__));
+		goto done;
+	}
+
+	if (len == 4)
+		val = *((uint32 *) buf);
+	else if (len == 2) {
+		val &= ~(0xffff << (8 * (off & 3)));
+		val |= *((uint16 *) buf) << (8 * (off & 3));
+	} else if (len == 1) {
+		val &= ~(0xff << (8 * (off & 3)));
+		val |= *((uint8 *) buf) << (8 * (off & 3));
+	} else {
+		ret = -1;
+		goto done;
+	}
+
+	PCI_MSG(("%s: 0x%x => 0x%p\n", __FUNCTION__, val, reg));
+
+	W_REG(osh, reg, val);
+
+done:
+	if (reg && addr)
+		REG_UNMAP(reg);
+
+	return ret;
+}
+
+/*
+ * Must access emulated PCI configuration at these locations even when
+ * the real PCI config space exists and is accessible.
+ *
+ * PCI_CFG_VID (0x00)
+ * PCI_CFG_DID (0x02)
+ * PCI_CFG_PROGIF (0x09)
+ * PCI_CFG_SUBCL  (0x0a)
+ * PCI_CFG_BASECL (0x0b)
+ * PCI_CFG_HDR (0x0e)
+ * PCI_CFG_INT (0x3c)
+ * PCI_CFG_PIN (0x3d)
+ */
+#define FORCE_EMUCFG(off, len) \
+	((off == PCI_CFG_VID) || (off == PCI_CFG_DID) || \
+	 (off == PCI_CFG_PROGIF) || \
+	 (off == PCI_CFG_SUBCL) || (off == PCI_CFG_BASECL) || \
+	 (off == PCI_CFG_HDR) || \
+	 (off == PCI_CFG_INT) || (off == PCI_CFG_PIN))
+
+/* Sync the emulation registers and the real PCI config registers. */
+static void
+sb_pcid_read_config(sb_t *sbh, uint coreidx, sb_pci_cfg_t *cfg,
+                    uint off, uint len)
+{
+	osl_t *osh;
+	uint oldidx;
+
+	ASSERT(cfg);
+	ASSERT(cfg->emu);
+	ASSERT(cfg->pci);
+
+	/* decide if real PCI config register access is necessary */
+	if (FORCE_EMUCFG(off, len))
+		return;
+
+	osh = sb_osh(sbh);
+
+	/* access to the real pci config space only when the core is up */
+	oldidx = sb_coreidx(sbh);
+	sb_setcoreidx(sbh, coreidx);
+	if (sb_iscoreup(sbh)) {
+		if (len == 4)
+			*(uint32 *)((ulong)cfg->emu + off) =
+			        htol32(R_REG(osh, (uint32 *)((ulong)cfg->pci + off)));
+		else if (len == 2)
+			*(uint16 *)((ulong)cfg->emu + off) =
+			        htol16(R_REG(osh, (uint16 *)((ulong)cfg->pci + off)));
+		else if (len == 1)
+			*(uint8 *)((ulong)cfg->emu + off) =
+			        R_REG(osh, (uint8 *)((ulong)cfg->pci + off));
+	}
+	sb_setcoreidx(sbh, oldidx);
+}
+
+static void
+sb_pcid_write_config(sb_t *sbh, uint coreidx, sb_pci_cfg_t *cfg,
+                     uint off, uint len)
+{
+	osl_t *osh;
+	uint oldidx;
+
+	ASSERT(cfg);
+	ASSERT(cfg->emu);
+	ASSERT(cfg->pci);
+
+	osh = sb_osh(sbh);
+
+	/* decide if real PCI config register access is necessary */
+	if (FORCE_EMUCFG(off, len))
+		return;
+
+	/* access to the real pci config space only when the core is up */
+	oldidx = sb_coreidx(sbh);
+	sb_setcoreidx(sbh, coreidx);
+	if (sb_iscoreup(sbh)) {
+		if (len == 4)
+			W_REG(osh, (uint32 *)((ulong)cfg->pci + off),
+			      ltoh32(*(uint32 *)((ulong)cfg->emu + off)));
+		else if (len == 2)
+			W_REG(osh, (uint16 *)((ulong)cfg->pci + off),
+			      ltoh16(*(uint16 *)((ulong)cfg->emu + off)));
+		else if (len == 1)
+			W_REG(osh, (uint8 *)((ulong)cfg->pci + off),
+			      *(uint8 *)((ulong)cfg->emu + off));
+	}
+	sb_setcoreidx(sbh, oldidx);
+}
+
+/*
+ * Functions for accessing translated SB configuration space
+ */
+static int
+sb_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	pci_config_regs *cfg;
+
+	if (dev >= SB_MAXCORES || func >= MAXFUNCS || (off + len) > sizeof(pci_config_regs))
+		return -1;
+	cfg = sb_pci_cfg[dev][func].emu;
+
+	ASSERT(ISALIGNED(off, len));
+	ASSERT(ISALIGNED((uintptr)buf, len));
+
+	/* use special config space if the device does not exist */
+	if (!cfg)
+		cfg = &sb_pci_null;
+	/* sync emulation with real PCI config if necessary */
+	else if (sb_pci_cfg[dev][func].pci)
+		sb_pcid_read_config(sbh, dev, &sb_pci_cfg[dev][func], off, len);
+
+	if (len == 4)
+		*((uint32 *) buf) = ltoh32(*((uint32 *)((ulong) cfg + off)));
+	else if (len == 2)
+		*((uint16 *) buf) = ltoh16(*((uint16 *)((ulong) cfg + off)));
+	else if (len == 1)
+		*((uint8 *) buf) = *((uint8 *)((ulong) cfg + off));
+	else
+		return -1;
+
+	return 0;
+}
+
+static int
+sb_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	uint coreidx;
+	void *regs;
+	pci_config_regs *cfg;
+	osl_t *osh;
+	sb_bar_cfg_t *bar;
+
+	if (dev >= SB_MAXCORES || func >= MAXFUNCS || (off + len) > sizeof(pci_config_regs))
+		return -1;
+	cfg = sb_pci_cfg[dev][func].emu;
+	if (!cfg)
+		return -1;
+
+	ASSERT(ISALIGNED(off, len));
+	ASSERT(ISALIGNED((uintptr)buf, len));
+
+	osh = sb_osh(sbh);
+
+	/* Emulate BAR sizing */
+	if (off >= OFFSETOF(pci_config_regs, base[0]) &&
+	    off <= OFFSETOF(pci_config_regs, base[3]) &&
+	    len == 4 && *((uint32 *) buf) == ~0) {
+		coreidx = sb_coreidx(sbh);
+		if ((regs = sb_setcoreidx(sbh, dev))) {
+			bar = sb_pci_cfg[dev][func].bar;
+			/* Highest numbered address match register */
+			if (off == OFFSETOF(pci_config_regs, base[0]))
+				cfg->base[0] = ~(bar->size0 - 1);
+			else if (off == OFFSETOF(pci_config_regs, base[1]) && bar->n >= 1)
+				cfg->base[1] = ~(bar->size1 - 1);
+			else if (off == OFFSETOF(pci_config_regs, base[2]) && bar->n >= 2)
+				cfg->base[2] = ~(bar->size2 - 1);
+			else if (off == OFFSETOF(pci_config_regs, base[3]) && bar->n >= 3)
+				cfg->base[3] = ~(bar->size3 - 1);
+		}
+		sb_setcoreidx(sbh, coreidx);
+	} else if (len == 4)
+		*((uint32 *)((ulong) cfg + off)) = htol32(*((uint32 *) buf));
+	else if (len == 2)
+		*((uint16 *)((ulong) cfg + off)) = htol16(*((uint16 *) buf));
+	else if (len == 1)
+		*((uint8 *)((ulong) cfg + off)) = *((uint8 *) buf);
+	else
+		return -1;
+
+	/* sync emulation with real PCI config if necessary */
+	if (sb_pci_cfg[dev][func].pci)
+		sb_pcid_write_config(sbh, dev, &sb_pci_cfg[dev][func], off, len);
+
+	return 0;
+}
+
+int
+sbpci_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	if (bus == 0)
+		return sb_read_config(sbh, bus, dev, func, off, buf, len);
+	else
+		return extpci_read_config(sbh, bus, dev, func, off, buf, len);
+}
+
+int
+sbpci_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	if (bus == 0)
+		return sb_write_config(sbh, bus, dev, func, off, buf, len);
+	else
+		return extpci_write_config(sbh, bus, dev, func, off, buf, len);
+}
+
+void
+sbpci_ban(uint16 core)
+{
+	if (pci_banned < ARRAYSIZE(pci_ban))
+		pci_ban[pci_banned++] = core;
+}
+
+/*
+ * Initiliaze PCI core. Return 0 after a successful initialization.
+ * Otherwise return -1 to indicate there is no PCI core and return 1
+ * to indicate PCI core is disabled.
+ */
+int __init
+sbpci_init_pci(sb_t *sbh)
+{
+	uint chip, chiprev, chippkg, host;
+	uint32 boardflags;
+	sbpciregs_t *pci;
+	sbconfig_t *sb;
+	uint32 val;
+	int ret = 0;
+	char *hbslot;
+	osl_t *osh;
+
+	chip = sb_chip(sbh);
+	chiprev = sb_chiprev(sbh);
+	chippkg = sb_chippkg(sbh);
+
+	osh = sb_osh(sbh);
+
+	if (!(pci = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0))) {
+		printf("PCI: no core\n");
+		pci_disabled = TRUE;
+		return -1;
+	}
+	sb = (sbconfig_t *)((ulong) pci + SBCONFIGOFF);
+
+	boardflags = (uint32) getintvar(NULL, "boardflags");
+
+	/*
+	 * The 200-pin BCM4712 package does not bond out PCI. Even when
+	 * PCI is bonded out, some boards may leave the pins
+	 * floating.
+	 */
+	if (((chip == BCM4712_CHIP_ID) &&
+	     ((chippkg == BCM4712SMALL_PKG_ID) ||
+	      (chippkg == BCM4712MID_PKG_ID))) ||
+	    (boardflags & BFL_NOPCI))
+		pci_disabled = TRUE;
+
+	/* Enable the core */
+	sb_core_reset(sbh, 0, 0);
+
+	/*
+	 * If the PCI core should not be touched (disabled, not bonded
+	 * out, or pins floating), do not even attempt to access core
+	 * registers. Otherwise, try to determine if it is in host
+	 * mode.
+	 */
+	if (pci_disabled)
+		host = 0;
+	else
+		host = !BUSPROBE(val, &pci->control);
+
+	if (!host) {
+		ret = 1;
+
+		/* Disable PCI interrupts in client mode */
+		W_REG(osh, &sb->sbintvec, 0);
+
+		/* Disable the PCI bridge in client mode */
+		sbpci_ban(SB_PCI);
+		sb_core_disable(sbh, 0);
+
+		printf("PCI: Disabled\n");
+	} else {
+		printf("PCI: Initializing host\n");
+
+		/* Disable PCI SBReqeustTimeout for BCM4785 rev. < 2 */
+		if (chip == BCM4785_CHIP_ID && chiprev < 2) {
+			AND_REG(osh, &sb->sbimconfiglow, ~0x00000070);
+			sb_commit(sbh);
+		}
+
+		/* Reset the external PCI bus and enable the clock */
+		W_REG(osh, &pci->control, 0x5);		/* enable the tristate drivers */
+		W_REG(osh, &pci->control, 0xd);		/* enable the PCI clock */
+		OSL_DELAY(150);				/* delay > 100 us */
+		W_REG(osh, &pci->control, 0xf);		/* deassert PCI reset */
+		/* Use internal arbiter and park REQ/GRNT at external master 0
+		 * We will set it later after the bus has been probed
+		 */
+		W_REG(osh, &pci->arbcontrol, PCI_INT_ARB);
+		OSL_DELAY(1);				/* delay 1 us */
+
+		/* Enable CardBusMode */
+		cardbus = getintvar(NULL, "cardbus") == 1;
+		if (cardbus) {
+			printf("PCI: Enabling CardBus\n");
+			/* GPIO 1 resets the CardBus device on bcm94710ap */
+			sb_gpioout(sbh, 1, 1, GPIO_DRV_PRIORITY);
+			sb_gpioouten(sbh, 1, 1, GPIO_DRV_PRIORITY);
+			W_REG(osh, &pci->sprom[0], R_REG(osh, &pci->sprom[0]) | 0x400);
+		}
+
+		/* 64 MB I/O access window */
+		W_REG(osh, &pci->sbtopci0, SBTOPCI_IO);
+		/* 64 MB configuration access window */
+		W_REG(osh, &pci->sbtopci1, SBTOPCI_CFG0);
+		/* 1 GB memory access window */
+		W_REG(osh, &pci->sbtopci2, SBTOPCI_MEM | SB_PCI_DMA);
+
+		/* Host bridge slot # nvram overwrite */
+		if ((hbslot = nvram_get("pcihbslot"))) {
+			pci_hbslot = bcm_strtoul(hbslot, NULL, 0);
+			ASSERT(pci_hbslot < PCI_MAX_DEVICES);
+		}
+
+		/* Enable PCI bridge BAR0 prefetch and burst */
+		val = 6;
+		sbpci_write_config(sbh, 1, pci_hbslot, 0, PCI_CFG_CMD, &val, sizeof(val));
+
+		/* Enable PCI interrupts */
+		W_REG(osh, &pci->intmask, PCI_INTA);
+	}
+
+	return ret;
+}
+
+void
+sbpci_arb_park(sb_t *sbh, uint parkid)
+{
+	sbpciregs_t *pci;
+	uint pcirev;
+	uint32  arb;
+
+	if (!(pci = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0))) {
+		/* Should not happen */
+		printf("%s: no PCI core\n", __FUNCTION__);
+		return;
+	}
+
+	pcirev = sb_corerev(sbh);
+
+	/* Nothing to do, not supported for these revs */
+	if (pcirev < 8)
+		return;
+
+	/* Get parkid from NVRAM */
+	if (parkid == PCI_PARK_NVRAM) {
+		parkid = getintvar(NULL, "parkid");
+		if (getvar(NULL, "parkid") == NULL)
+			/* Not present in NVRAM use defaults */
+			parkid = (pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST;
+	}
+
+	/* Check the parkid is valid, if not set it to default */
+	if (parkid > ((pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST)) {
+		printf("%s: Invalid parkid %d\n", __FUNCTION__, parkid);
+		parkid = (pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST;
+	}
+
+	/* Now set the parkid */
+	arb = R_REG(sb_osh(sbh), &pci->arbcontrol);
+	arb &= ~PCI_PARKID_MASK;
+	arb |= parkid << PCI_PARKID_SHIFT;
+	W_REG(sb_osh(sbh), &pci->arbcontrol, arb);
+	OSL_DELAY(1);
+}
+
+/*
+ * Get the PCI region address and size information.
+ */
+static void __init
+sbpci_init_regions(sb_t *sbh, uint func, pci_config_regs *cfg, sb_bar_cfg_t *bar)
+{
+	osl_t *osh;
+	uint16 coreid;
+	void *regs;
+	sbconfig_t *sb;
+	uint32 base;
+
+	osh	= sb_osh(sbh);
+	coreid	= sb_coreid(sbh);
+	regs	= sb_coreregs(sbh);
+	sb	= (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	switch (coreid) {
+	case SB_USB20H:
+		base = htol32(sb_base(R_REG(osh, &sb->sbadmatch0)));
+
+		cfg->base[0] = func == 0 ? base : base + 0x800;  /* OHCI/EHCI */
+		cfg->base[1] = 0;
+		cfg->base[2] = 0;
+		cfg->base[3] = 0;
+		cfg->base[4] = 0;
+		cfg->base[5] = 0;
+		bar->n       = 1;
+		bar->size0   = func == 0 ? 0x200 : 0x100;  /* OHCI/EHCI */
+		bar->size1   = 0;
+		bar->size2   = 0;
+		bar->size3   = 0;
+		break;
+	default:
+		cfg->base[0] = htol32(sb_base(R_REG(osh, &sb->sbadmatch0)));
+		cfg->base[1] = htol32(sb_base(R_REG(osh, &sb->sbadmatch1)));
+		cfg->base[2] = htol32(sb_base(R_REG(osh, &sb->sbadmatch2)));
+		cfg->base[3] = htol32(sb_base(R_REG(osh, &sb->sbadmatch3)));
+		cfg->base[4] = 0;
+		cfg->base[5] = 0;
+		bar->n       = (R_REG(osh, &sb->sbidlow) & SBIDL_AR_MASK) >> SBIDL_AR_SHIFT;
+		bar->size0   = sb_size(R_REG(osh, &sb->sbadmatch0));
+		bar->size1   = sb_size(R_REG(osh, &sb->sbadmatch1));
+		bar->size2   = sb_size(R_REG(osh, &sb->sbadmatch2));
+		bar->size3   = sb_size(R_REG(osh, &sb->sbadmatch3));
+		break;
+	}
+}
+
+/*
+ * Construct PCI config spaces for SB cores so that they
+ * can be accessed as if they were PCI devices.
+ */
+void __init
+sbpci_init_cores(sb_t *sbh)
+{
+	uint chiprev, coreidx, i;
+	sbconfig_t *sb;
+	pci_config_regs *cfg, *pci;
+	sb_bar_cfg_t *bar;
+	void *regs;
+	osl_t *osh;
+	uint16 vendor, device;
+	uint16 coreid;
+	uint8 class, subclass, progif;
+	uint dev;
+	uint8 header;
+	uint func;
+
+	chiprev = sb_chiprev(sbh);
+	coreidx = sb_coreidx(sbh);
+
+	osh = sb_osh(sbh);
+
+	/* Scan the SB bus */
+	bzero(sb_config_regs, sizeof(sb_config_regs));
+	bzero(sb_bar_cfg, sizeof(sb_bar_cfg));
+	bzero(sb_pci_cfg, sizeof(sb_pci_cfg));
+	memset(&sb_pci_null, -1, sizeof(sb_pci_null));
+	cfg = sb_config_regs;
+	bar = sb_bar_cfg;
+	for (dev = 0; dev < SB_MAXCORES; dev ++) {
+		/* Check if the core exists */
+		if (!(regs = sb_setcoreidx(sbh, dev)))
+			continue;
+		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+		/* Check if this core is banned */
+		coreid = sb_coreid(sbh);
+		for (i = 0; i < pci_banned; i++)
+			if (coreid == pci_ban[i])
+				break;
+		if (i < pci_banned)
+			continue;
+
+		for (func = 0; func < MAXFUNCS; ++func) {
+			/* Make sure we won't go beyond the limit */
+			if (cfg >= &sb_config_regs[SB_MAXCORES]) {
+				printf("PCI: too many emulated devices\n");
+				goto done;
+			}
+
+			/* Convert core id to pci id */
+			if (sb_corepciid(sbh, func, &vendor, &device, &class, &subclass,
+			                 &progif, &header))
+				continue;
+
+			/*
+			 * Differentiate real PCI config from emulated.
+			 * non zero 'pci' indicate there is a real PCI config space
+			 * for this device.
+			 */
+			switch (device) {
+			case BCM47XX_GIGETH_ID:
+				pci = (pci_config_regs *)((uint32)regs + 0x800);
+				break;
+			case BCM47XX_SATAXOR_ID:
+				pci = (pci_config_regs *)((uint32)regs + 0x400);
+				break;
+			case BCM47XX_ATA100_ID:
+				pci = (pci_config_regs *)((uint32)regs + 0x800);
+				break;
+			default:
+				pci = NULL;
+				break;
+			}
+			/* Supported translations */
+			cfg->vendor = htol16(vendor);
+			cfg->device = htol16(device);
+			cfg->rev_id = chiprev;
+			cfg->prog_if = progif;
+			cfg->sub_class = subclass;
+			cfg->base_class = class;
+			cfg->header_type = header;
+			sbpci_init_regions(sbh, func, cfg, bar);
+			/* Save core interrupt flag */
+			cfg->int_pin = R_REG(osh, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
+			/* Save core interrupt assignment */
+			cfg->int_line = sb_irq(sbh);
+			/* Indicate there is no SROM */
+			*((uint32 *) &cfg->sprom_control) = 0xffffffff;
+
+			/* Point to the PCI config spaces */
+			sb_pci_cfg[dev][func].emu = cfg;
+			sb_pci_cfg[dev][func].pci = pci;
+			sb_pci_cfg[dev][func].bar = bar;
+			cfg ++;
+			bar ++;
+		}
+	}
+
+done:
+	sb_setcoreidx(sbh, coreidx);
+}
+
+/*
+ * Initialize PCI core and construct PCI config spaces for SB cores.
+ * Must propagate sbpci_init_pci() return value to the caller to let
+ * them know the PCI core initialization status.
+ */
+int __init
+sbpci_init(sb_t *sbh)
+{
+	int status = sbpci_init_pci(sbh);
+	sbpci_init_cores(sbh);
+	return status;
+}
--- src/shared.1927/hndpmu.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/hndpmu.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,1146 @@
+/*
+ * Misc utility routines for accessing PMU corerev specific features
+ * of the SiliconBackplane-based Broadcom chips.
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <hndpmu.h>
+
+/* debug/trace */
+#define	PMU_ERROR(args)
+
+#define	PMU_MSG(args)
+
+/* PMU & control */
+#if defined(CONFIG_BCM4328) || defined(CONFIG_BCM5354)
+/* PMU rev 0 pll control for BCM4328 and BCM5354 */
+static void sb_pmu0_pllinit0(sb_t *sbh, osl_t *osh, chipcregs_t *cc, uint32 xtal);
+static uint32 sb_pmu0_alpclk0(sb_t *sbh, osl_t *osh, chipcregs_t *cc);
+static uint32 sb_pmu0_cpuclk0(sb_t *sbh, osl_t *osh, chipcregs_t *cc);
+#endif
+#if defined(CONFIG_BCM4325) || defined(CONFIG_BCM4312)
+/* PMU rev 0 pll control for BCM4325 BCM4329 */
+static void sb_pmu1_pllinit0(sb_t *sbh, osl_t *osh, chipcregs_t *cc, uint32 xtal);
+static uint32 sb_pmu1_cpuclk0(sb_t *sbh, osl_t *osh, chipcregs_t *cc);
+static uint32 sb_pmu1_alpclk0(sb_t *sbh, osl_t *osh, chipcregs_t *cc);
+#endif
+
+/* Setup switcher voltage */
+void
+BCMINITFN(sb_pmu_set_switcher_voltage)(sb_t *sbh, osl_t *osh,
+                                       uint8 bb_voltage, uint8 rf_voltage)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	W_REG(osh, &cc->regcontrol_addr, 0x01);
+	W_REG(osh, &cc->regcontrol_data, (uint32)(bb_voltage & 0x1f) << 22);
+
+	W_REG(osh, &cc->regcontrol_addr, 0x00);
+	W_REG(osh, &cc->regcontrol_data, (uint32)(rf_voltage & 0x1f) << 14);
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+
+void
+sb_pmu_set_ldo_voltage(sb_t *sbh, osl_t *osh, uint8 ldo, uint8 voltage)
+{
+	uint8 sr_cntl_shift, rc_shift, shift, mask;
+	uint32 addr;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328) || defined(CONFIG_BCM5354)
+		case BCM4328_CHIP_ID:
+		case BCM5354_CHIP_ID:
+			switch (ldo) {
+				case SET_LDO_VOLTAGE_LDO1:
+					addr = 2;
+					sr_cntl_shift = 8;
+					rc_shift = 17;
+					mask = 0xf;
+					break;
+				case SET_LDO_VOLTAGE_LDO2:
+					addr = 3;
+					sr_cntl_shift = 0;
+					rc_shift = 1;
+					mask = 0xf;
+					break;
+				case SET_LDO_VOLTAGE_LDO3:
+					addr = 3;
+					sr_cntl_shift = 0;
+					rc_shift = 9;
+					mask = 0xf;
+					break;
+				case SET_LDO_VOLTAGE_PAREF:
+					addr = 3;
+					sr_cntl_shift = 0;
+					rc_shift = 17;
+					mask = 0x3f;
+					break;
+				default:
+					ASSERT(FALSE);
+					return;
+			}
+			break;
+#endif	/* defined(CONFIG_BCM4328) || defined(CONFIG_BCM5354) */
+#if defined(CONFIG_BCM4312)
+		case BCM4312_CHIP_ID:
+			switch (ldo) {
+				case SET_LDO_VOLTAGE_PAREF:
+					addr = 0;
+					sr_cntl_shift = 0;
+					rc_shift = 21;
+					mask = 0x3f;
+					break;
+				default:
+					ASSERT(FALSE);
+					return;
+			}
+			break;
+#endif	/* defined(CONFIG_BCM4312) */
+		default:
+			ASSERT(FALSE);
+			return;
+	}
+
+	shift = sr_cntl_shift + rc_shift;
+
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr),
+		~0, addr);
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_data),
+		mask << shift, (voltage & mask) << shift);
+}
+
+void
+sb_pmu_paref_ldo_enable(sb_t *sbh, osl_t *osh, bool enable)
+{
+	uint ldo = 0;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		ldo = RES4328_PA_REF_LDO;
+		break;
+#endif /* defined(CONFIG_BCM4328) */
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		ldo = RES5354_PA_REF_LDO;
+		break;
+#endif /* defined(CONFIG_BCM5354) */
+#if defined(CONFIG_BCM4312)
+	case BCM4312_CHIP_ID:
+		ldo = RES4312_PA_REF_LDO;
+		break;
+#endif /* defined(CONFIG_BCM5354) */
+	default:
+		return;
+	}
+
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, min_res_mask),
+	           PMURES_BIT(ldo), enable ? PMURES_BIT(ldo) : 0);
+}
+
+uint16
+BCMINITFN(sb_pmu_fast_pwrup_delay)(sb_t *sbh, osl_t *osh)
+{
+	uint16 delay = PMU_MAX_TRANSITION_DLY;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		delay = 7000;
+		break;
+#endif	/* BCM4328 */
+
+#if defined(CONFIG_BCM4325) || defined(CONFIG_BCM4312)
+	case BCM4325_CHIP_ID:
+	case BCM4312_CHIP_ID:
+#ifdef BCMQT
+		delay = 70;
+#else
+		delay = 2800;
+#endif
+		break;
+#endif	/* BCM4325 || BCM4312 */
+
+	default:
+		PMU_MSG(("No PMU fast power up delay specified "
+			"for chip %x rev %d, using default %d us\n",
+			sbh->chip, sbh->chiprev, delay));
+		break;
+	}
+
+	return delay;
+}
+
+uint32
+BCMINITFN(sb_pmu_force_ilp)(sb_t *sbh, osl_t *osh, bool force)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 oldpmucontrol;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	oldpmucontrol = R_REG(osh, &cc->pmucontrol);
+	if (force)
+		W_REG(osh, &cc->pmucontrol, oldpmucontrol &
+			~(PCTL_HT_REQ_EN | PCTL_ALP_REQ_EN));
+	else
+		W_REG(osh, &cc->pmucontrol, oldpmucontrol |
+			(PCTL_HT_REQ_EN | PCTL_ALP_REQ_EN));
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+
+	return oldpmucontrol;
+}
+
+/* Setup min/max resources and up/down timers */
+typedef struct {
+	uint8 resnum;
+	uint16 updown;
+} pmu_res_updown_t;
+
+typedef struct {
+	uint8 resnum;
+	int8 action;	/* 0 - set, 1 - add, -1 - remove */
+	uint32 depend_mask;
+} pmu_res_depend_t;
+
+#if defined(CONFIG_BCM4328)
+static const pmu_res_updown_t BCMINITDATA(bcm4328a0_res_updown)[] = {
+	{ RES4328_EXT_SWITCHER_PWM, 0x0101 },
+	{ RES4328_BB_SWITCHER_PWM, 0x1f01 },
+	{ RES4328_BB_SWITCHER_BURST, 0x010f },
+	{ RES4328_BB_EXT_SWITCHER_BURST, 0x0101 },
+	{ RES4328_ILP_REQUEST, 0x0202 },
+	{ RES4328_RADIO_SWITCHER_PWM, 0x0f01 },
+	{ RES4328_RADIO_SWITCHER_BURST, 0x0f01 },
+	{ RES4328_ROM_SWITCH, 0x0101 },
+	{ RES4328_PA_REF_LDO, 0x0f01 },
+	{ RES4328_RADIO_LDO, 0x0f01 },
+	{ RES4328_AFE_LDO, 0x0f01 },
+	{ RES4328_PLL_LDO, 0x0f01 },
+	{ RES4328_BG_FILTBYP, 0x0101 },
+	{ RES4328_TX_FILTBYP, 0x0101 },
+	{ RES4328_RX_FILTBYP, 0x0101 },
+	{ RES4328_XTAL_PU, 0x0101 },
+	{ RES4328_XTAL_EN, 0xa001 },
+	{ RES4328_BB_PLL_FILTBYP, 0x0101 },
+	{ RES4328_RF_PLL_FILTBYP, 0x0101 },
+	{ RES4328_BB_PLL_PU, 0x0701 }
+};
+
+static const pmu_res_depend_t BCMINITDATA(bcm4328a0_res_depend)[] = {
+	/* Adjust ILP request resource not to force ext/BB switchers into burst mode */
+	{
+		RES4328_ILP_REQUEST, 0,
+		PMURES_BIT(RES4328_EXT_SWITCHER_PWM) |
+		PMURES_BIT(RES4328_BB_SWITCHER_PWM)
+	}
+};
+#endif	/* BCM4328 */
+
+#if defined(CONFIG_BCM4325)
+#ifdef BCMQT	    /* for power save on slow QT/small beacon interval */
+static const pmu_res_updown_t BCMINITDATA(bcm4325a0_res_updown_qt)[] = {
+	{ RES4325_HT_AVAIL, 0x0300 },
+	{ RES4325_BBPLL_PWRSW_PU, 0x0101 },
+	{ RES4325_RFPLL_PWRSW_PU, 0x0101 },
+	{ RES4325_ALP_AVAIL, 0x0100 },
+	{ RES4325_XTAL_PU, 0x1000 },
+	{ RES4325_LNLDO1_PU, 0x0800 },
+	{ RES4325_CLDO_CBUCK_PWM, 0x0101 },
+	{ RES4325_CBUCK_PWM, 0x0803 }
+};
+#else
+static const pmu_res_updown_t BCMINITDATA(bcm4325a0_res_updown)[] = {
+	{ RES4325_XTAL_PU, 0x1501 }
+};
+#endif	/* !BCMQT */
+
+static const pmu_res_depend_t BCMINITDATA(bcm4325a0_res_depend)[] = {
+	/* Adjust HT Avail resource dependencies */
+	{
+		RES4325_HT_AVAIL, 1,
+		PMURES_BIT(RES4325_RX_PWRSW_PU) | PMURES_BIT(RES4325_TX_PWRSW_PU) |
+		PMURES_BIT(RES4325_LOGEN_PWRSW_PU) | PMURES_BIT(RES4325_AFE_PWRSW_PU)
+	}
+};
+#endif	/* BCM4325 */
+
+void
+BCMINITFN(sb_pmu_res_init)(sb_t *sbh, osl_t *osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	const pmu_res_updown_t *pmu_res_updown_table = NULL;
+	int pmu_res_updown_table_sz = 0;
+	const pmu_res_depend_t *pmu_res_depend_table = NULL;
+	int pmu_res_depend_table_sz = 0;
+	uint32 min_mask = 0, max_mask = 0;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		/* Down to ILP request excluding ROM */
+		min_mask = PMURES_BIT(RES4328_EXT_SWITCHER_PWM) |
+		        PMURES_BIT(RES4328_BB_SWITCHER_PWM) |
+		        PMURES_BIT(RES4328_XTAL_EN);
+#ifdef BCMROMOFFLOAD
+		/* Including ROM */
+		min_mask |= PMURES_BIT(RES4328_ROM_SWITCH);
+#endif
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0xfffff;
+		pmu_res_updown_table = bcm4328a0_res_updown;
+		pmu_res_updown_table_sz = ARRAYSIZE(bcm4328a0_res_updown);
+		pmu_res_depend_table = bcm4328a0_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4328a0_res_depend);
+		break;
+#endif	/* BCM4328 */
+#if defined(CONFIG_BCM4312)
+	case BCM4312_CHIP_ID:
+		/* keep default
+		 * min_mask = 0xcbb; max_mask = 0x7ffff;
+		 * pmu_res_updown_table_sz = 0;
+		 * pmu_res_depend_table_sz = 0;
+		 */
+		break;
+#endif	/* BCM4312 */
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0xfffff;
+		break;
+#endif	/* BCM5354 */
+
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		/* Leave OTP powered up and power it down later. */
+		min_mask =
+		        PMURES_BIT(RES4325_CBUCK_BURST) |
+		        PMURES_BIT(RES4325_LNLDO2_PU);
+		if (((sbh->chipst & CST4325_PMUTOP_2B_MASK) >>
+		     CST4325_PMUTOP_2B_SHIFT) == 1)
+			min_mask |= PMURES_BIT(RES4325_CLDO_CBUCK_BURST);
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0x3fffff;
+#ifdef BCMQT
+		pmu_res_updown_table = bcm4325a0_res_updown_qt;
+		pmu_res_updown_table_sz = ARRAYSIZE(bcm4325a0_res_updown_qt);
+#else
+		pmu_res_updown_table = bcm4325a0_res_updown;
+		pmu_res_updown_table_sz = ARRAYSIZE(bcm4325a0_res_updown);
+		pmu_res_depend_table = bcm4325a0_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4325a0_res_depend);
+#endif
+		break;
+#endif	/* BCM4325 */
+
+	default:
+		break;
+	}
+
+	/* Program up/down timers */
+	while (pmu_res_updown_table_sz--) {
+		ASSERT(pmu_res_updown_table);
+		W_REG(osh, &cc->res_table_sel,
+			pmu_res_updown_table[pmu_res_updown_table_sz].resnum);
+		W_REG(osh, &cc->res_updn_timer,
+			pmu_res_updown_table[pmu_res_updown_table_sz].updown);
+	}
+
+	/* Program resource dependencies table */
+	while (pmu_res_depend_table_sz--) {
+		ASSERT(pmu_res_depend_table);
+		W_REG(osh, &cc->res_table_sel,
+			pmu_res_depend_table[pmu_res_depend_table_sz].resnum);
+		switch (pmu_res_depend_table[pmu_res_depend_table_sz].action) {
+		case 0:
+			W_REG(osh, &cc->res_dep_mask,
+				pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask);
+			break;
+		case 1:
+			OR_REG(osh, &cc->res_dep_mask,
+				pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask);
+			break;
+		case -1:
+			AND_REG(osh, &cc->res_dep_mask,
+				~pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask);
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+	}
+
+	/* program min resource mask */
+	if (min_mask) {
+		PMU_MSG(("Changing min_res_mask to 0x%x\n", min_mask));
+		W_REG(osh, &cc->min_res_mask, min_mask);
+	}
+	/* program max resource mask */
+	if (max_mask) {
+		PMU_MSG(("Changing max_res_mask to 0x%x\n", max_mask));
+		W_REG(osh, &cc->max_res_mask, max_mask);
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+
+#if defined(CONFIG_BCM4328) || defined(CONFIG_BCM5354)
+/* setup pll and query clock speed */
+typedef struct {
+	uint16	freq;
+	uint8	xf;
+	uint8	wbint;
+	uint32	wbfrac;
+} pmu0_xtaltab0_t;
+
+/* the following table is based on 880Mhz Fvco */
+#define PMU0_PLL0_FVCO	880000	/* Fvco 880Mhz */
+static const pmu0_xtaltab0_t BCMINITDATA(pmu0_xtaltab0)[] = {
+	{ 12000,	1,	73,	349525 },
+	{ 13000,	2,	67,	725937 },
+	{ 14400,	3,	61,	116508 },
+	{ 15360,	4,	57,	305834 },
+	{ 16200,	5,	54,	336579 },
+	{ 16800,	6,	52,	399457 },
+	{ 19200,	7,	45,	873813 },
+	{ 19800,	8,	44,	466033 },
+	{ 20000,	9,	44,	0 },
+	{ 25000,	10,	70,	419430 },
+	{ 26000,	11,	67,	725937 },
+	{ 30000,	12,	58,	699050 },
+	{ 38400,	13,	45,	873813 },
+	{ 40000,	14,	45,	0 },
+	{ 0,		0,	0,	0 }
+};
+
+#ifdef BCMUSBDEV
+#define	PMU0_XTAL0_DEFAULT	11
+#else
+#define PMU0_XTAL0_DEFAULT	8
+#endif
+
+#if defined(CONFIG_BCM4328)
+#ifdef BCMUSBDEV
+/*
+ * Set new backplane PLL clock frequency
+ */
+static void
+BCMINITFN(sb_pmu0_sbclk4328)(sb_t *sbh, int freq)
+{
+	uint32 tmp, oldmax, oldmin, origidx;
+	chipcregs_t *cc;
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	/* Set new backplane PLL clock */
+	W_REG(osh, &cc->pllcontrol_addr, PMU0_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	tmp &= ~(PMU0_PLL0_PC0_DIV_ARM_MASK);
+	tmp |= freq << PMU0_PLL0_PC0_DIV_ARM_SHIFT;
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Power cycle BB_PLL_PU by disabling/enabling it to take on new freq */
+	/* Disable PLL */
+	oldmin = R_REG(osh, &cc->min_res_mask);
+	oldmax = R_REG(osh, &cc->max_res_mask);
+	W_REG(osh, &cc->min_res_mask, oldmin & ~PMURES_BIT(RES4328_BB_PLL_PU));
+	W_REG(osh, &cc->max_res_mask, oldmax & ~PMURES_BIT(RES4328_BB_PLL_PU));
+
+	/* It takes over several hundred usec to re-enable the PLL since the
+	 * sequencer state machines run on ILP clock. Set delay at 450us to be safe.
+	 *
+	 * Be sure PLL is powered down first before re-enabling it.
+	 */
+
+	OSL_DELAY(PLL_DELAY);
+	SPINWAIT((R_REG(osh, &cc->res_state) & PMURES_BIT(RES4328_BB_PLL_PU)), PLL_DELAY*3);
+
+	if (R_REG(osh, &cc->res_state) & PMURES_BIT(RES4328_BB_PLL_PU)) {
+		/* If BB_PLL not powered down yet, new backplane PLL clock
+		 *  may not take effect.
+		 *
+		 * Still early during bootup so no serial output here.
+		 */
+		PMU_ERROR(("Fatal: BB_PLL not power down yet!\n"));
+		ASSERT(!(R_REG(osh, &cc->res_state) & PMURES_BIT(RES4328_BB_PLL_PU)));
+	}
+
+	/* Enable PLL */
+	W_REG(osh, &cc->max_res_mask, oldmax);
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+#endif /* BCMUSBDEV */
+#endif /* BCM4328 */
+
+/* Set up PLL registers in the PMU as per the crystal speed.
+ * Uses xtalfreq variable, or passed-in default.
+ */
+static void
+BCMINITFN(sb_pmu0_pllinit0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc, uint32 xtal)
+{
+	uint32 tmp;
+	const pmu0_xtaltab0_t *xt;
+
+	if ((sb_chip(sbh) == BCM5354_CHIP_ID) && (xtal == 0)) {
+		/* 5354 has xtal freq of 25MHz */
+		xtal = 25000;
+	}
+
+	/* Find the frequency in the table */
+	for (xt = pmu0_xtaltab0; xt->freq; xt ++)
+		if (xt->freq == xtal)
+			break;
+	if (xt->freq == 0)
+		xt = &pmu0_xtaltab0[PMU0_XTAL0_DEFAULT];
+
+	PMU_MSG(("XTAL %d (%d)\n", xtal, xt->xf));
+
+	/* Check current PLL state */
+	tmp = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	        PCTL_XTALFREQ_SHIFT;
+	if (tmp == xt->xf) {
+		PMU_MSG(("PLL already programmed for %d.%d MHz\n",
+			(xt->freq / 1000), (xt->freq % 1000)));
+
+#if defined(CONFIG_BCM4328)
+#ifdef BCMUSBDEV
+		if (sbh->chip == BCM4328_CHIP_ID)
+			sb_pmu0_sbclk4328(sbh, PMU0_PLL0_PC0_DIV_ARM_88MHZ);
+#endif
+#endif	/* BCM4328 */
+		return;
+	}
+
+	if (tmp) {
+		PMU_MSG(("Reprogramming PLL for %d.%d MHz (was %d.%dMHz)\n",
+		         (xt->freq / 1000), (xt->freq % 1000),
+		         (pmu0_xtaltab0[tmp-1].freq / 1000), (pmu0_xtaltab0[tmp-1].freq % 1000)));
+	} else {
+		PMU_MSG(("Programming PLL for %d.%d MHz\n", (xt->freq / 1000),
+		         (xt->freq % 1000)));
+	}
+
+	/* Make sure the PLL is off */
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		AND_REG(osh, &cc->min_res_mask, ~PMURES_BIT(RES4328_BB_PLL_PU));
+		AND_REG(osh, &cc->max_res_mask, ~PMURES_BIT(RES4328_BB_PLL_PU));
+		break;
+#endif
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		AND_REG(osh, &cc->min_res_mask, ~PMURES_BIT(RES5354_BB_PLL_PU));
+		AND_REG(osh, &cc->max_res_mask, ~PMURES_BIT(RES5354_BB_PLL_PU));
+		break;
+#endif
+	default:
+		ASSERT(0);
+	}
+	SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS0_HTAVAIL,
+	         PMU_MAX_TRANSITION_DLY);
+	ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS0_HTAVAIL));
+
+	PMU_MSG(("Done masking\n"));
+
+	/* Write PDIV in pllcontrol[0] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU0_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	if (xt->freq >= PMU0_PLL0_PC0_PDIV_FREQ)
+		tmp |= PMU0_PLL0_PC0_PDIV_MASK;
+	else
+		tmp &= ~PMU0_PLL0_PC0_PDIV_MASK;
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write WILD in pllcontrol[1] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU0_PLL0_PLLCTL1);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	tmp = ((tmp & ~(PMU0_PLL0_PC1_WILD_INT_MASK | PMU0_PLL0_PC1_WILD_FRAC_MASK)) |
+	       (((xt->wbint << PMU0_PLL0_PC1_WILD_INT_SHIFT) &
+	         PMU0_PLL0_PC1_WILD_INT_MASK) |
+	        ((xt->wbfrac << PMU0_PLL0_PC1_WILD_FRAC_SHIFT) &
+	         PMU0_PLL0_PC1_WILD_FRAC_MASK)));
+	if (xt->wbfrac == 0)
+		tmp |= PMU0_PLL0_PC1_STOP_MOD;
+	else
+		tmp &= ~PMU0_PLL0_PC1_STOP_MOD;
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write WILD in pllcontrol[2] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU0_PLL0_PLLCTL2);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	tmp = ((tmp & ~PMU0_PLL0_PC2_WILD_INT_MASK) |
+	       ((xt->wbint >> PMU0_PLL0_PC2_WILD_INT_SHIFT) &
+	        PMU0_PLL0_PC2_WILD_INT_MASK));
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	PMU_MSG(("Done pll\n"));
+
+	/* Write XtalFreq. Set the divisor also. */
+	tmp = R_REG(osh, &cc->pmucontrol);
+	tmp = ((tmp & ~PCTL_ILP_DIV_MASK) |
+	       (((((xt->freq + 127) / 128) - 1) << PCTL_ILP_DIV_SHIFT) &
+	        PCTL_ILP_DIV_MASK));
+	tmp = ((tmp & ~PCTL_XTALFREQ_MASK) |
+	       ((xt->xf << PCTL_XTALFREQ_SHIFT) & PCTL_XTALFREQ_MASK));
+	W_REG(osh, &cc->pmucontrol, tmp);
+}
+
+static uint32
+BCMINITFN(sb_pmu0_alpclk0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc)
+{
+	const pmu0_xtaltab0_t *xt;
+	uint32 xf;
+
+	/* Find the frequency in the table */
+	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	        PCTL_XTALFREQ_SHIFT;
+	for (xt = pmu0_xtaltab0; xt->freq; xt++)
+		if (xt->xf == xf)
+			break;
+	if (xt->freq == 0)
+		xt = &pmu0_xtaltab0[PMU0_XTAL0_DEFAULT];
+
+	return xt->freq * 1000;
+}
+
+static uint32
+BCMINITFN(sb_pmu0_cpuclk0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc)
+{
+	const pmu0_xtaltab0_t *xt;
+	uint32 xf, tmp, divarm;
+
+	if (sb_chip(sbh) == BCM5354_CHIP_ID) {
+		/* 5354 gets sb clock of 120MHz from main pll */
+		return 120000000;
+	}
+
+	/* Find the xtal frequency in the table */
+	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	        PCTL_XTALFREQ_SHIFT;
+	for (xt = pmu0_xtaltab0; xt->freq; xt++)
+		if (xt->xf == xf)
+			break;
+	if (xt->freq == 0)
+		xt = &pmu0_xtaltab0[PMU0_XTAL0_DEFAULT];
+
+	/* Read divarm from pllcontrol[0] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU0_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	divarm = (tmp & PMU0_PLL0_PC0_DIV_ARM_MASK) >> PMU0_PLL0_PC0_DIV_ARM_SHIFT;
+
+
+	/* Return ARM/SB clock */
+	return PMU0_PLL0_FVCO / (divarm + PMU0_PLL0_PC0_DIV_ARM_BASE) * 1000;
+}
+#endif	/* BCM4328 || BCM5354 */
+
+/* PMU corerev 1 pll programming for BCM4325 */
+#if defined(CONFIG_BCM4325) || defined(CONFIG_BCM4312)
+/* setup pll and query clock speed */
+typedef struct {
+	uint16	fref;
+	uint8	xf;
+	uint8	p1div;
+	uint8	p2div;
+	uint8	ndiv_int;
+	uint32	ndiv_frac;
+} pmu1_xtaltab0_t;
+
+/* the following table is based on 880Mhz Fvco */
+#define PMU1_PLL0_FVCO	880000	/* Fvco 880Mhz */
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0)[] = {
+	{12000,	1,	3,	22,	0x9,	0xFFFFEF},
+	{13000,	2,	1,	6,	0xb,	0x483483},
+	{14400,	3,	1,	10,	0xa,	0x1C71C7},
+	{15360,	4,	1,	5,	0xb,	0x755555},
+	{16200,	5,	1,	10,	0x5,	0x6E9E06},
+	{16800,	6,	1,	10,	0x5,	0x3Cf3Cf},
+	{19200,	7,	1,	9,	0x5,	0x17B425},
+	{19800,	8,	1,	11,	0x4,	0xA57EB},
+	{20000,	9,	1,	11,	0x4,	0x0},
+	{24000,	10,	3,	11,	0xa,	0x0},
+	{25000,	11,	5,	16,	0xb,	0x0},
+	{26000,	12,	1,	2,	0x10,	0xEC4EC4},
+	{30000,	13,	3,	8,	0xb,	0x0},
+	{38400,	14,	1,	5,	0x4,	0x955555},
+	{40000,	15,	1,	2,	0xb,	0},
+	{0,	0,	0,	0,	0,	0}
+};
+
+/* Default to 15360Khz crystal */
+#define PMU1_XTAL0_DEFAULT	3
+
+static uint32
+BCMINITFN(sb_pmu1_alpclk0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc)
+{
+	const pmu1_xtaltab0_t *xt;
+	uint32 xf;
+
+	/* Find the frequency in the table */
+	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	        PCTL_XTALFREQ_SHIFT;
+	for (xt = pmu1_xtaltab0; xt->fref; xt++)
+		if (xt->xf == xf)
+			break;
+	if (xt->fref == 0)
+		xt = &pmu1_xtaltab0[PMU1_XTAL0_DEFAULT];
+
+	return xt->fref * 1000;
+}
+
+/* Set up PLL registers in the PMU as per the crystal speed.
+ * Uses xtalfreq variable, or passed-in default.
+ */
+static void
+BCMINITFN(sb_pmu1_pllinit0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc, uint32 xtal)
+{
+	const pmu1_xtaltab0_t *xt;
+	uint32 tmp;
+	uint32 buf_strength = 0;
+
+	/* 4312: assume default works */
+	if (sbh->chip == BCM4312_CHIP_ID)
+		return;
+
+	/* Find the frequency in the table */
+	for (xt = pmu1_xtaltab0; xt->fref; xt++)
+		if (xt->fref == xtal)
+			break;
+	if (xt->fref == 0)
+		xt = &pmu1_xtaltab0[PMU1_XTAL0_DEFAULT];
+
+	PMU_MSG(("XTAL %d (%d)\n", xtal, xt->xf));
+
+	/* Check current PLL state */
+	if (((R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	     PCTL_XTALFREQ_SHIFT) == xt->xf) {
+		PMU_MSG(("PLL already programmed for %d.%d MHz\n",
+			(xt->fref / 1000), (xt->fref % 1000)));
+		return;
+	}
+
+	PMU_MSG(("Programming PLL for %d.%d MHz\n", (xt->fref / 1000),
+	         (xt->fref % 1000)));
+
+	/* Make sure the PLL is off */
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		AND_REG(osh, &cc->min_res_mask,
+		        ~(PMURES_BIT(RES4325_BBPLL_PWRSW_PU) | PMURES_BIT(RES4325_HT_AVAIL)));
+		AND_REG(osh, &cc->max_res_mask,
+		        ~(PMURES_BIT(RES4325_BBPLL_PWRSW_PU) | PMURES_BIT(RES4325_HT_AVAIL)));
+
+		/* Change the BBPLL drive strength to 2 for all channels */
+		buf_strength = 0x222222;
+		break;
+#endif
+	default:
+		ASSERT(0);
+	}
+	SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL, PMU_MAX_TRANSITION_DLY);
+	ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
+
+	PMU_MSG(("Done masking\n"));
+
+	/* Write p1div and p2div to pllcontrol[0] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data) &
+	        ~(PMU1_PLL0_PC0_P1DIV_MASK | PMU1_PLL0_PC0_P2DIV_MASK);
+	tmp |= ((xt->p1div << PMU1_PLL0_PC0_P1DIV_SHIFT) & PMU1_PLL0_PC0_P1DIV_MASK) |
+	        ((xt->p2div << PMU1_PLL0_PC0_P2DIV_SHIFT) & PMU1_PLL0_PC0_P2DIV_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write ndiv_int and ndiv_mode to pllcontrol[2] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+	tmp = R_REG(osh, &cc->pllcontrol_data) &
+	        ~(PMU1_PLL0_PC2_NDIV_INT_MASK | PMU1_PLL0_PC2_NDIV_MODE_MASK);
+	tmp |= ((xt->ndiv_int << PMU1_PLL0_PC2_NDIV_INT_SHIFT) & PMU1_PLL0_PC2_NDIV_INT_MASK) |
+	        ((1 << PMU1_PLL0_PC2_NDIV_MODE_SHIFT) & PMU1_PLL0_PC2_NDIV_MODE_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write ndiv_frac to pllcontrol[3] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+	tmp = R_REG(osh, &cc->pllcontrol_data) & ~PMU1_PLL0_PC3_NDIV_FRAC_MASK;
+	tmp |= ((xt->ndiv_frac << PMU1_PLL0_PC3_NDIV_FRAC_SHIFT) &
+	        PMU1_PLL0_PC3_NDIV_FRAC_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	if (buf_strength) {
+		PMU_MSG(("Adjusting PLL buffer drive strength: %x\n", buf_strength));
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		tmp = R_REG(osh, &cc->pllcontrol_data) & ~PMU1_PLL0_PC5_CLK_DRV_MASK;
+		tmp |= (buf_strength << PMU1_PLL0_PC5_CLK_DRV_SHIFT);
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+	}
+
+	PMU_MSG(("Done pll\n"));
+
+	/* Write XtalFreq. Set the divisor also. */
+	tmp = R_REG(osh, &cc->pmucontrol) &
+	        ~(PCTL_ILP_DIV_MASK | PCTL_XTALFREQ_MASK);
+	tmp |= (((((xt->fref + 127) / 128) - 1) << PCTL_ILP_DIV_SHIFT) &
+	        PCTL_ILP_DIV_MASK) |
+	       ((xt->xf << PCTL_XTALFREQ_SHIFT) & PCTL_XTALFREQ_MASK);
+	W_REG(osh, &cc->pmucontrol, tmp);
+}
+
+
+static uint32
+BCMINITFN(sb_pmu1_cpuclk0)(sb_t *sbh, osl_t *osh, chipcregs_t *cc)
+{
+	const pmu1_xtaltab0_t *xt;
+	uint32 xf, tmp, m1div;
+
+	/* Find the xtal frequency in the table */
+	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	        PCTL_XTALFREQ_SHIFT;
+	for (xt = pmu1_xtaltab0; xt->fref; xt++)
+		if (xt->xf == xf)
+			break;
+	if (xt->fref == 0)
+		xt = &pmu1_xtaltab0[PMU1_XTAL0_DEFAULT];
+
+	/* Read m1div from pllcontrol[1] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	m1div = (tmp & PMU1_PLL0_PC1_M1DIV_MASK) >> PMU1_PLL0_PC1_M1DIV_SHIFT;
+
+
+	/* Return ARM/SB clock */
+	return PMU1_PLL0_FVCO / m1div * 1000;
+}
+#endif	
+
+void
+BCMINITFN(sb_pmu_pll_init)(sb_t *sbh, osl_t *osh, uint xtalfreq)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		sb_pmu0_pllinit0(sbh, osh, cc, xtalfreq);
+		break;
+#endif
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		sb_pmu0_pllinit0(sbh, osh, cc, xtalfreq);
+		break;
+#endif
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		sb_pmu1_pllinit0(sbh, osh, cc, xtalfreq);
+		break;
+#endif
+#if defined(CONFIG_BCM4312)
+	case BCM4312_CHIP_ID:
+		sb_pmu1_pllinit0(sbh, osh, cc, xtalfreq);
+		break;
+#endif
+	default:
+		PMU_MSG(("No PLL init done for chip %x rev %d pmurev %d\n",
+		         sbh->chip, sbh->chiprev, sbh->pmurev));
+		break;
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+
+uint32
+BCMINITFN(sb_pmu_alp_clock)(sb_t *sbh, osl_t *osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock = ALP_CLOCK;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		clock = sb_pmu0_alpclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		clock = sb_pmu0_alpclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		clock = sb_pmu1_alpclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM4312)
+	case BCM4312_CHIP_ID:
+		clock = sb_pmu1_alpclk0(sbh, osh, cc);
+		/* always 20Mhz */
+		clock = 20000 * 1000;
+		break;
+#endif
+	default:
+		PMU_MSG(("No ALP clock specified "
+			"for chip %x rev %d pmurev %d, using default %d Hz\n",
+			sbh->chip, sbh->chiprev, sbh->pmurev, clock));
+		break;
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+	return clock;
+}
+
+uint
+BCMINITFN(sb_pmu_cpu_clock)(sb_t *sbh, osl_t *osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock = HT_CLOCK;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4328)
+	case BCM4328_CHIP_ID:
+		clock = sb_pmu0_cpuclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM5354)
+	case BCM5354_CHIP_ID:
+		clock = sb_pmu0_cpuclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		clock = sb_pmu1_cpuclk0(sbh, osh, cc);
+		break;
+#endif
+#if defined(CONFIG_BCM4312)
+	case BCM4312_CHIP_ID:
+		clock = sb_pmu1_cpuclk0(sbh, osh, cc);
+		break;
+#endif
+	default:
+		PMU_MSG(("No CPU clock specified "
+			"for chip %x rev %d pmurev %d, using default %d Hz\n",
+			sbh->chip, sbh->chiprev, sbh->pmurev, clock));
+		break;
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+	return clock;
+}
+
+void
+BCMINITFN(sb_pmu_init)(sb_t *sbh, osl_t *osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	if (sbh->pmurev >= 1) {
+#if defined(CONFIG_BCM4325)
+		if (sbh->chip == BCM4325_CHIP_ID && sbh->chiprev <= 1)
+			AND_REG(osh, &cc->pmucontrol, ~PCTL_NOILP_ON_WAIT);
+		else
+#endif	/* BCM4325 */
+			OR_REG(osh, &cc->pmucontrol, PCTL_NOILP_ON_WAIT);
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+
+void
+BCMINITFN(sb_pmu_otp_power)(sb_t *sbh, osl_t *osh, bool on)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		if (on) {
+			OR_REG(osh, &cc->min_res_mask, PMURES_BIT(RES4325_LNLDO2_PU));
+			if (sbh->boardflags & BFL_BUCKBOOST)
+				AND_REG(osh, &cc->min_res_mask,
+					~PMURES_BIT(RES4325_BUCK_BOOST_PWM));
+			OSL_DELAY(500);
+		}
+		else {
+			if (sbh->boardflags & BFL_BUCKBOOST)
+				OR_REG(osh, &cc->min_res_mask, PMURES_BIT(RES4325_BUCK_BOOST_PWM));
+			AND_REG(osh, &cc->min_res_mask, ~PMURES_BIT(RES4325_LNLDO2_PU));
+		}
+		break;
+#endif	/* BCM4325 */
+	default:
+		break;
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
+
+void
+sb_pmu_rcal(sb_t *sbh, osl_t *osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sbh->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = sb_coreidx(sbh);
+	cc = sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	switch (sbh->chip) {
+#if defined(CONFIG_BCM4325)
+	case BCM4325_CHIP_ID:
+		{
+		uint8 rcal_code;
+		uint32 val;
+
+		/* Kick RCal */
+		W_REG(osh, &cc->chipcontrol_addr, 1);
+		AND_REG(osh, &cc->chipcontrol_data, ~0x04);
+		OR_REG(osh, &cc->chipcontrol_data, 0x04);
+
+		/* Wait for completion */
+		SPINWAIT(0 == (R_REG(osh, &cc->chipstatus) & 0x08), 10 * 1000 * 1000);
+		ASSERT(R_REG(osh, &cc->chipstatus) & 0x08);
+
+		/* Drop the LSB to convert from 5 bit code to 4 bit code */
+		rcal_code =  (uint8)(R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
+		PMU_MSG(("RCal completed, status 0x%x, code 0x%x\n",
+			R_REG(osh, &cc->chipstatus), rcal_code));
+
+		/* Write RCal code into pmu_vreg_ctrl[32:29] */
+		W_REG(osh, &cc->regcontrol_addr, 0);
+		val = R_REG(osh, &cc->regcontrol_data) & ~((uint32)0x07 << 29);
+		val |= (uint32)(rcal_code & 0x07) << 29;
+		W_REG(osh, &cc->regcontrol_data, val);
+		W_REG(osh, &cc->regcontrol_addr, 1);
+		val = R_REG(osh, &cc->regcontrol_data) & ~(uint32)0x01;
+		val |= (uint32)((rcal_code >> 3) & 0x01);
+		W_REG(osh, &cc->regcontrol_data, val);
+
+		/* Write RCal code into pmu_chip_ctrl[33:30] */
+		W_REG(osh, &cc->chipcontrol_addr, 0);
+		val = R_REG(osh, &cc->chipcontrol_data) & ~((uint32)0x03 << 30);
+		val |= (uint32)(rcal_code & 0x03) << 30;
+		W_REG(osh, &cc->chipcontrol_data, val);
+		W_REG(osh, &cc->chipcontrol_addr, 1);
+		val = R_REG(osh, &cc->chipcontrol_data) & ~(uint32)0x03;
+		val |= (uint32)((rcal_code >> 2) & 0x03);
+		W_REG(osh, &cc->chipcontrol_data, val);
+
+		/* Set override in pmu_chip_ctrl[29] */
+		W_REG(osh, &cc->chipcontrol_addr, 0);
+		OR_REG(osh, &cc->chipcontrol_data, (0x01 << 29));
+
+		/* Power off RCal block */
+		W_REG(osh, &cc->chipcontrol_addr, 1);
+		AND_REG(osh, &cc->chipcontrol_data, ~0x04);
+
+		break;
+		}
+#endif	/* BCM4325 */
+	default:
+		break;
+	}
+
+	/* Return to original core */
+	sb_setcoreidx(sbh, origidx);
+}
--- src/shared.1927/hndrte.lds.in	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/hndrte.lds.in	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-OUTPUT_ARCH(mips)
+OUTPUT_ARCH(TARGET_ARCH)
 ENTRY(startup)
 SECTIONS {
 	. = TEXT_START;
@@ -9,10 +9,12 @@
 		*(.text)
 		*(.text.*)
 		*(.fini)
+		*(.glue_7t)
+		*(.glue_7)
+		*(.rdata)
+		*(.rdata.*)
 		*(.rodata)
 		*(.rodata.*)
-		_rstart = .;
-		*(.textini.*)
 		_etext = .;
 		text_end = .;
 	}
@@ -20,9 +22,6 @@
 	.data : {
 		data_start = .;
 		_fdata = .;
-		*(.dataini.*)
-		_rend = .;
-		*(.rdata)
 		*(.data)
 		*(.data.*)
 		*(.sdata)
@@ -36,8 +35,22 @@
 		*(.sbss)
 		*(.scommon)
 		*(.bss)
+		*(.bss.*)
 		*(COMMON)
 		bss_end = .;
 	}
+
+	.textrc : {
+		_rstart = .;
+		*(.textini.*)
+		. = ALIGN(16);
+		_retext = .;
+	}
+
+	.datarc : {
+		*(.dataini.*)
+		. = ALIGN(4);
+		_rend = .;
+	}
 	_end = .;
 }
--- src/shared.1927/linux_gpio.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/linux_gpio.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,123 @@
+/*
+ * Linux Broadcom BCM47xx GPIO char driver
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
+
+#include <linux_gpio.h>
+
+/* handle to the sb */
+static sb_t *gpio_sbh;
+
+/* major number assigned to the device and device handles */
+static int gpio_major;
+devfs_handle_t gpiodev_handle;
+
+static int
+gpio_open(struct inode *inode, struct file * file)
+{
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static int
+gpio_release(struct inode *inode, struct file * file)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static int
+gpio_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct gpio_ioctl gpioioc;
+
+	if (copy_from_user(&gpioioc, (struct gpio_ioctl *)arg, sizeof(struct gpio_ioctl)))
+		return -EFAULT;
+
+	switch (cmd) {
+		case GPIO_IOC_RESERVE:
+			gpioioc.val = sb_gpioreserve(gpio_sbh, gpioioc.mask, GPIO_APP_PRIORITY);
+			break;
+		case GPIO_IOC_RELEASE:
+			/*
+			 * releasing the gpio doesn't change the current
+			 * value on the GPIO last write value
+			 * persists till some one overwrites it
+			 */
+			gpioioc.val = sb_gpiorelease(gpio_sbh, gpioioc.mask, GPIO_APP_PRIORITY);
+			break;
+		case GPIO_IOC_OUT:
+			gpioioc.val = sb_gpioout(gpio_sbh, gpioioc.mask, gpioioc.val,
+			                         GPIO_APP_PRIORITY);
+			break;
+		case GPIO_IOC_OUTEN:
+			gpioioc.val = sb_gpioouten(gpio_sbh, gpioioc.mask, gpioioc.val,
+			                           GPIO_APP_PRIORITY);
+			break;
+		case GPIO_IOC_IN:
+			gpioioc.val = sb_gpioin(gpio_sbh);
+			break;
+		default:
+			break;
+	}
+	if (copy_to_user((struct gpio_ioctl *)arg, &gpioioc, sizeof(struct gpio_ioctl)))
+		return -EFAULT;
+
+	return 0;
+
+}
+static struct file_operations gpio_fops = {
+	owner:		THIS_MODULE,
+	open:		gpio_open,
+	release:	gpio_release,
+	ioctl:		gpio_ioctl,
+	};
+
+static int __init
+gpio_init(void)
+{
+	if (!(gpio_sbh = sb_kattach(SB_OSH)))
+		return -ENODEV;
+
+	if ((gpio_major = devfs_register_chrdev(0, "gpio", &gpio_fops)) < 0)
+		return gpio_major;
+
+	gpiodev_handle = devfs_register(NULL, "gpio", DEVFS_FL_DEFAULT,
+	                                gpio_major, 0, S_IFCHR | S_IRUGO | S_IWUGO,
+	                                &gpio_fops, NULL);
+
+	return 0;
+}
+
+static void __exit
+gpio_exit(void)
+{
+	if (gpiodev_handle != NULL)
+		devfs_unregister(gpiodev_handle);
+	gpiodev_handle = NULL;
+	devfs_unregister_chrdev(gpio_major, "gpio");
+	sb_detach(gpio_sbh);
+}
+
+module_init(gpio_init);
+module_exit(gpio_exit);
--- src/shared.1927/linux_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/linux_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -16,20 +16,20 @@
 
 #include <typedefs.h>
 #include <bcmendian.h>
-#include <linux/module.h>
 #include <linuxver.h>
-#include <linux_osl.h>
+#include <bcmdefs.h>
+#include <osl.h>
 #include <bcmutils.h>
 #include <linux/delay.h>
 #ifdef mips
 #include <asm/paccess.h>
-#endif
+#endif /* mips */
 #include <pcicfg.h>
 
 #define PCI_CFG_RETRY 		10	
 
-#define OS_HANDLE_MAGIC		0x1234abcd
-#define BCM_MEM_FILENAME_LEN 	24
+#define OS_HANDLE_MAGIC		0x1234abcd	/* Magic # to recognise osh */
+#define BCM_MEM_FILENAME_LEN 	24		/* Mem. filename length */
 
 typedef struct bcm_mem_link {
 	struct bcm_mem_link *prev;
@@ -39,91 +39,203 @@
 	char	file[BCM_MEM_FILENAME_LEN];
 } bcm_mem_link_t;
 
-typedef struct os_handle {
+struct osl_info {
+	osl_pubinfo_t pub;
 	uint magic;
 	void *pdev;
 	uint malloced;
 	uint failed;
+	uint bustype;
 	bcm_mem_link_t *dbgmem_list;
-} os_handle_t;
+#if defined(DSLCPE_DELAY)
+	shared_osl_t *oshsh; /* osh shared */
+#endif
+#ifdef BCMDBG_PKT      /* pkt logging for debugging */
+	pktlist_info_t pktlist;
+#endif  /* BCMDBG_PKT */
+};
+
+static int16 linuxbcmerrormap[] =  \
+{	0, 			/* 0 */
+	-EINVAL,		/* BCME_ERROR */
+	-EINVAL,		/* BCME_BADARG */
+	-EINVAL,		/* BCME_BADOPTION */
+	-EINVAL,		/* BCME_NOTUP */
+	-EINVAL,		/* BCME_NOTDOWN */
+	-EINVAL,		/* BCME_NOTAP */
+	-EINVAL,		/* BCME_NOTSTA */
+	-EINVAL,		/* BCME_BADKEYIDX */
+	-EINVAL,		/* BCME_RADIOOFF */
+	-EINVAL,		/* BCME_NOTBANDLOCKED */
+	-EINVAL, 		/* BCME_NOCLK */
+	-EINVAL, 		/* BCME_BADRATESET */
+	-EINVAL, 		/* BCME_BADBAND */
+	-E2BIG,			/* BCME_BUFTOOSHORT */
+	-E2BIG,			/* BCME_BUFTOOLONG */
+	-EBUSY, 		/* BCME_BUSY */
+	-EINVAL, 		/* BCME_NOTASSOCIATED */
+	-EINVAL, 		/* BCME_BADSSIDLEN */
+	-EINVAL, 		/* BCME_OUTOFRANGECHAN */
+	-EINVAL, 		/* BCME_BADCHAN */
+	-EFAULT, 		/* BCME_BADADDR */
+	-ENOMEM, 		/* BCME_NORESOURCE */
+	-EOPNOTSUPP,		/* BCME_UNSUPPORTED */
+	-EMSGSIZE,		/* BCME_BADLENGTH */
+	-EINVAL,		/* BCME_NOTREADY */
+	-EPERM,			/* BCME_NOTPERMITTED */
+	-ENOMEM, 		/* BCME_NOMEM */
+	-EINVAL, 		/* BCME_ASSOCIATED */
+	-ERANGE, 		/* BCME_RANGE */
+	-EINVAL, 		/* BCME_NOTFOUND */
+	-EINVAL, 		/* BCME_WME_NOT_ENABLED */
+	-EINVAL, 		/* BCME_TSPEC_NOTFOUND */
+	-EINVAL, 		/* BCME_ACM_NOTSUPPORTED */
+	-EINVAL,		/* BCME_NOT_WME_ASSOCIATION */
+	-EIO,			/* BCME_SDIO_ERROR */
+	-ENODEV,		/* BCME_DONGLE_DOWN */
+	-EINVAL			/* BCME_VERSION */
 
-void *
-osl_attach(void *pdev)
+/* When an new error code is added to bcmutils.h, add os 
+ * spcecific error translation here as well
+ */
+/* check if BCME_LAST changed since the last time this function was updated */
+#if BCME_LAST != -37
+#error "You need to add a OS error translation in the linuxbcmerrormap \
+	for new error code defined in bcmuitls.h"
+#endif /* BCME_LAST != -37 */
+};
+
+/* translate bcmerrors into linux errors */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror > 0)
+		bcmerror = 0;
+	else if (bcmerror < BCME_LAST)
+		bcmerror = BCME_ERROR;
+
+	/* Array bounds covered by ASSERT in osl_attach */
+	return linuxbcmerrormap[-bcmerror];
+}
+
+osl_t *
+osl_attach(void *pdev, uint bustype, bool pkttag)
 {
-	os_handle_t *osh;
+	osl_t *osh;
 
-	osh = kmalloc(sizeof(os_handle_t), GFP_ATOMIC);
+	osh = kmalloc(sizeof(osl_t), GFP_ATOMIC);
 	ASSERT(osh);
 
+	bzero(osh, sizeof(osl_t));
+
+	/* Check that error map has the right number of entries in it */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(linuxbcmerrormap) - 1));
+
 	osh->magic = OS_HANDLE_MAGIC;
 	osh->malloced = 0;
 	osh->failed = 0;
 	osh->dbgmem_list = NULL;
 	osh->pdev = pdev;
+	osh->pub.pkttag = pkttag;
+	osh->bustype = bustype;
+
+	switch (bustype) {
+		case PCI_BUS:
+		case SB_BUS:
+		case PCMCIA_BUS:
+			osh->pub.mmbus = TRUE;
+			break;
+		case JTAG_BUS:
+		case SDIO_BUS:
+		case USB_BUS:
+			osh->pub.mmbus = FALSE;
+			break;
+		default:
+			ASSERT(FALSE);
+			break;
+	}
 
 	return osh;
 }
 
 void
-osl_detach(void *osh)
+osl_detach(osl_t *osh)
 {
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	if (osh == NULL)
+		return;
+
+	ASSERT(osh->magic == OS_HANDLE_MAGIC);
 	kfree(osh);
 }
 
+/* Return a new packet. zero out pkttag */
 void*
-osl_pktget(void *drv, uint len, bool send)
+osl_pktget(osl_t *osh, uint len)
 {
 	struct sk_buff *skb;
 
-	if ((skb = dev_alloc_skb(len)) == NULL)
-		return (NULL);
-
+	if ((skb = dev_alloc_skb(len))) {
 	skb_put(skb, len);
+		skb->priority = 0;
 
-	/* ensure the cookie field is cleared */ 
-	PKTSETCOOKIE(skb, NULL);
+#ifdef BCMDBG_PKT
+	pktlist_add(&(osh->pktlist), (void *) skb);
+#endif  /* BCMDBG_PKT */
+
+		osh->pub.pktalloced++;
+	}
 
 	return ((void*) skb);
 }
 
+/* Free the driver packet. Free the tag if present */
 void
-osl_pktfree(void *p)
+osl_pktfree(osl_t *osh, void *p, bool send)
 {
 	struct sk_buff *skb, *nskb;
 
 	skb = (struct sk_buff*) p;
 
+	if (send && osh->pub.tx_fn)
+		osh->pub.tx_fn(osh->pub.tx_ctx, p, 0);
+
 	/* perversion: we use skb->next to chain multi-skb packets */
 	while (skb) {
 		nskb = skb->next;
 		skb->next = NULL;
+
+#ifdef BCMDBG_PKT
+		pktlist_remove(&(osh->pktlist), (void *) skb);
+#endif  /* BCMDBG_PKT */
+
 		if (skb->destructor) {
-			/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists */
+			/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists
+			 */
 			dev_kfree_skb_any(skb);
 		} else {
 			/* can free immediately (even in_irq()) if destructor does not exist */
 			dev_kfree_skb(skb);
 		}
+
+		osh->pub.pktalloced--;
+
 		skb = nskb;
 	}
 }
 
 uint32
-osl_pci_read_config(void *osh, uint offset, uint size)
+osl_pci_read_config(osl_t *osh, uint offset, uint size)
 {
-	struct pci_dev *pdev;
 	uint val;
-	uint retry=PCI_CFG_RETRY;	 
+	uint retry = PCI_CFG_RETRY;	 
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	/* only 4byte access supported */
 	ASSERT(size == 4);
 
-	pdev = ((os_handle_t *)osh)->pdev;
 	do {
-		pci_read_config_dword(pdev, offset, &val);
+		pci_read_config_dword(osh->pdev, offset, &val);
 		if (val != 0xffffffff)
 			break;
 	} while (retry--);
@@ -133,41 +245,56 @@
 }
 
 void
-osl_pci_write_config(void *osh, uint offset, uint size, uint val)
+osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
 {
-	struct pci_dev *pdev;
-	uint retry=PCI_CFG_RETRY;	 
+	uint retry = PCI_CFG_RETRY;	 
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	/* only 4byte access supported */
 	ASSERT(size == 4);
 
-	pdev = ((os_handle_t *)osh)->pdev;
-
 	do {
-		pci_write_config_dword(pdev, offset, val);
-		if (offset!=PCI_BAR0_WIN)
+		pci_write_config_dword(osh->pdev, offset, val);
+		if (offset != PCI_BAR0_WIN)
 			break;
-		if (osl_pci_read_config(osh,offset,size) == val) 
+		if (osl_pci_read_config(osh, offset, size) == val)
 			break;
 	} while (retry--);
 
 }
 
+/* return bus # for the pci device pointed by osh->pdev */
+uint
+osl_pci_bus(osl_t *osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return ((struct pci_dev *)osh->pdev)->bus->number;
+}
+
+/* return slot # for the pci device pointed by osh->pdev */
+uint
+osl_pci_slot(osl_t *osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
+}
+
 static void
-osl_pcmcia_attr(void *osh, uint offset, char *buf, int size, bool write)
+osl_pcmcia_attr(osl_t *osh, uint offset, char *buf, int size, bool write)
 {
 }
 
 void
-osl_pcmcia_read_attr(void *osh, uint offset, void *buf, int size)
+osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *) buf, size, FALSE);
 }
 
 void
-osl_pcmcia_write_attr(void *osh, uint offset, void *buf, int size)
+osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *) buf, size, TRUE);
 }
@@ -176,19 +303,15 @@
 #ifdef BCMDBG_MEM
 
 void*
-osl_debug_malloc(void *osh, uint size, int line, char* file)
+osl_debug_malloc(osl_t *osh, uint size, int line, char* file)
 {
 	bcm_mem_link_t *p;
 	char* basename;
-	os_handle_t *h = (os_handle_t *)osh;
 	
-	if (size == 0) {
-		return NULL;
-	}
+	ASSERT(size);
 	
-	p = (bcm_mem_link_t*)osl_malloc(osh, sizeof(bcm_mem_link_t) + size);
-	if (p == NULL)
-		return p;
+	if ((p = (bcm_mem_link_t*)osl_malloc(osh, sizeof(bcm_mem_link_t) + size)) == NULL)
+		return (NULL);
 	
 	p->size = size;
 	p->line = line;
@@ -206,31 +329,33 @@
 
 	/* link this block */
 	p->prev = NULL;
-	p->next = h->dbgmem_list;
+	p->next = osh->dbgmem_list;
 	if (p->next)
 		p->next->prev = p;
-	h->dbgmem_list = p;
+	osh->dbgmem_list = p;
 
 	return p + 1;
 }
 
 void
-osl_debug_mfree(void *osh, void *addr, uint size, int line, char* file)
+osl_debug_mfree(osl_t *osh, void *addr, uint size, int line, char* file)
 {
 	bcm_mem_link_t *p = (bcm_mem_link_t *)((int8*)addr - sizeof(bcm_mem_link_t));
-	os_handle_t *h = (os_handle_t *)osh;
 	
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	if (p->size == 0) {
-		printk("osl_debug_mfree: double free on addr 0x%x size %d at line %d file %s\n", 
-			(uint)addr, size, line, file);
+		printk("osl_debug_mfree: double free on addr %p size %d at line %d file %s\n",
+			addr, size, line, file);
+		ASSERT(p->size);
 		return;
 	}
 
 	if (p->size != size) {
-		printk("osl_debug_mfree: dealloc size %d does not match alloc size %d on addr 0x%x at line %d file %s\n",
-		       size, p->size, (uint)addr, line, file);
+		printk("osl_debug_mfree: dealloc size %d does not match alloc size %d on addr %p"
+		       " at line %d file %s\n",
+		       size, p->size, addr, line, file);
+		ASSERT(p->size == size);
 		return;
 	}
 
@@ -239,123 +364,111 @@
 		p->prev->next = p->next;
 	if (p->next)
 		p->next->prev = p->prev;
-	if (h->dbgmem_list == p)
-		h->dbgmem_list = p->next;
+	if (osh->dbgmem_list == p)
+		osh->dbgmem_list = p->next;
 	p->next = p->prev = NULL;
 
 	osl_mfree(osh, p, size + sizeof(bcm_mem_link_t));
 }
 
-char*
-osl_debug_memdump(void *osh, char *buf, uint sz)
+int
+osl_debug_memdump(osl_t *osh, struct bcmstrbuf *b)
 {
 	bcm_mem_link_t *p;
-	char *obuf;
-	os_handle_t *h = (os_handle_t *)osh;
 
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	obuf = buf;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	buf += sprintf(buf, "   Address\tSize\tFile:line\n");
-	for (p = h->dbgmem_list; p && ((buf - obuf) < (sz - 128)); p = p->next)
-		buf += sprintf(buf, "0x%08x\t%5d\t%s:%d\n",
-			(int)p + sizeof(bcm_mem_link_t), p->size, p->file, p->line);
+	bcm_bprintf(b, "   Address\tSize\tFile:line\n");
+	for (p = osh->dbgmem_list; p; p = p->next)
+		bcm_bprintf(b, "0x%08x\t%5d\t%s:%d\n",
+			(uintptr)p + sizeof(bcm_mem_link_t), p->size, p->file, p->line);
 
-	return (obuf);
+	return 0;
 }
 
 #endif	/* BCMDBG_MEM */
 
 void*
-osl_malloc(void *osh, uint size)
+osl_malloc(osl_t *osh, uint size)
 {
-	os_handle_t *h = (os_handle_t *)osh;
 	void *addr;
 
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	h->malloced += size;
-	addr = kmalloc(size, GFP_ATOMIC);
-	if (!addr)
-		h->failed++;
+	/* only ASSERT if osh is defined */
+	if (osh)
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+
+	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+		if (osh)
+			osh->failed++;
+		return (NULL);
+	}
+	if (osh)
+		osh->malloced += size;
+
 	return (addr);
 }
 
 void
-osl_mfree(void *osh, void *addr, uint size)
+osl_mfree(osl_t *osh, void *addr, uint size)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	h->malloced -= size;
+	if (osh) {
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+		osh->malloced -= size;
+	}
 	kfree(addr);
 }
 
 uint
-osl_malloced(void *osh)
+osl_malloced(osl_t *osh)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	return (h->malloced);
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->malloced);
 }
 
-uint osl_malloc_failed(void *osh)
+uint
+osl_malloc_failed(osl_t *osh)
 {
-	os_handle_t *h = (os_handle_t *)osh;
-
-	ASSERT((h && (h->magic == OS_HANDLE_MAGIC)));
-	return (h->failed);
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->failed);
 }
 
 void*
-osl_dma_alloc_consistent(void *osh, uint size, ulong *pap)
+osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap)
 {
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
-	return (pci_alloc_consistent(dev, size, (dma_addr_t*)pap));
+	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t*)pap));
 }
 
 void
-osl_dma_free_consistent(void *osh, void *va, uint size, ulong pa)
+osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
 {
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
-	pci_free_consistent(dev, size, va, (dma_addr_t)pa);
+	pci_free_consistent(osh->pdev, size, va, (dma_addr_t)pa);
 }
 
 uint
-osl_dma_map(void *osh, void *va, uint size, int direction)
+osl_dma_map(osl_t *osh, void *va, uint size, int direction)
 {
 	int dir;
-	struct pci_dev *dev;
 
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
-
-	dev = ((os_handle_t *)osh)->pdev;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
-	return (pci_map_single(dev, va, size, dir));
+	return (pci_map_single(osh->pdev, va, size, dir));
 }
 
 void
-osl_dma_unmap(void *osh, uint pa, uint size, int direction)
+osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction)
 {
 	int dir;
-	struct pci_dev *dev;
-
-	ASSERT((osh && (((os_handle_t *)osh)->magic == OS_HANDLE_MAGIC)));
 
-	dev = ((os_handle_t *)osh)->pdev;
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE;
-	pci_unmap_single(dev, (uint32)pa, size, dir);
+	pci_unmap_single(osh->pdev, (uint32)pa, size, dir);
 }
 
-#if defined(BINOSL)
+#if defined(BINOSL) || defined(CONFIG_BCMDBG_ASSERT)
 void
 osl_assert(char *exp, char *file, int line)
 {
@@ -364,7 +477,128 @@
 	sprintf(tempbuf, "assertion \"%s\" failed: file \"%s\", line %d\n", exp, file, line);
 	panic(tempbuf);
 }
-#endif	/* BCMDBG || BINOSL */
+#endif	/* BCMDBG_ASSERT || BINOSL */
+
+void
+osl_delay(uint usec)
+{
+	uint d;
+
+	while (usec > 0) {
+		d = MIN(usec, 1000);
+		udelay(d);
+		usec -= d;
+	}
+}
+
+#if defined(DSLCPE_DELAY)
+
+void
+osl_oshsh_init(osl_t *osh, shared_osl_t* oshsh)
+{
+	extern unsigned long loops_per_jiffy;
+	osh->oshsh = oshsh;
+	osh->oshsh->MIPS = loops_per_jiffy / (500000/HZ);
+}
+
+int
+in_long_delay(osl_t *osh)
+{
+	return osh->oshsh->long_delay;
+}
+
+void
+osl_long_delay(osl_t *osh, uint usec, bool yield)
+{
+	uint d;
+	bool yielded = TRUE;
+	int usec_to_delay = usec;
+	unsigned long tick1, tick2, tick_diff = 0;
+
+	/* delay at least requested usec */
+	while (usec_to_delay > 0) {
+		if (!yield || !yielded) {
+			d = MIN(usec_to_delay, 10);
+			udelay(d);
+			usec_to_delay -= d;
+		}
+		if (usec_to_delay > 0) {
+			osh->oshsh->long_delay++;
+			OSL_GETCYCLES(tick1);
+			spin_unlock_bh(osh->oshsh->lock);
+			if (usec_to_delay > 0 && !in_irq() && !in_softirq() && !in_interrupt()) {
+				schedule();
+				yielded = TRUE;
+			} else {
+				yielded = FALSE;
+			}
+			spin_lock_bh(osh->oshsh->lock);
+			OSL_GETCYCLES(tick2);
+
+			if (yielded) {
+				tick_diff = TICKDIFF(tick2, tick1);
+				tick_diff = (tick_diff * 2)/(osh->oshsh->MIPS);
+				if (tick_diff) {
+					usec_to_delay -= tick_diff;
+				} else
+					yielded = 0;
+			}
+			osh->oshsh->long_delay--;
+			ASSERT(osh->oshsh->long_delay >= 0);
+		}
+	}
+}
+#endif /* DSLCPE_DELAY */
+
+/* Clone a packet.
+ * The pkttag contents are NOT cloned.
+ */
+void *
+osl_pktdup(osl_t *osh, void *skb)
+{
+	void * p;
+
+	if ((p = skb_clone((struct sk_buff*)skb, GFP_ATOMIC)) == NULL)
+		return NULL;
+
+	/* skb_clone copies skb->cb.. we don't want that */
+	if (osh->pub.pkttag)
+		bzero((void*)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	osh->pub.pktalloced++;
+#ifdef BCMDBG_PKT
+	pktlist_add(&(osh->pktlist), (void *) p);
+#endif  /* BCMDBG_PKT */
+	return (p);
+}
+
+uint
+osl_pktalloced(osl_t *osh)
+{
+	return (osh->pub.pktalloced);
+}
+
+#ifdef BCMDBG_PKT
+char *
+osl_pktlist_dump(osl_t *osh, char *buf)
+{
+	pktlist_dump(&(osh->pktlist), buf);
+	return buf;
+}
+
+void
+osl_pktlist_add(osl_t *osh, void *p)
+{
+	pktlist_add(&(osh->pktlist), p);
+}
+
+void
+osl_pktlist_remove(osl_t *osh, void *p)
+{
+	pktlist_remove(&(osh->pktlist), p);
+}
+#endif /* BCMDBG_PKT */
 
 /*
  * BINOSL selects the slightly slower function-call-based binary compatible osl.
@@ -380,10 +614,10 @@
 
 	/* sprintf into a local buffer because there *is* no "vprintk()".. */
 	va_start(args, format);
-	len = vsprintf(buf, format, args);
+	len = vsnprintf(buf, 1024, format, args);
 	va_end(args);
 
-	if (len > sizeof (buf)) {
+	if (len > sizeof(buf)) {
 		printk("osl_printf: buffer overrun\n");
 		return (0);
 	}
@@ -416,7 +650,7 @@
 }
 
 int
-osl_strlen(char *s)
+osl_strlen(const char *s)
 {
 	return (strlen(s));
 }
@@ -494,7 +728,7 @@
 	return ((void*)KSEG1ADDR(va));
 #else
 	return ((void*)va);
-#endif
+#endif /* mips */
 }
 
 uint
@@ -508,7 +742,7 @@
 	rdtscl(cycles);
 #else
 	cycles = 0;
-#endif
+#endif /* defined(mips) */
 	return cycles;
 }
 
@@ -528,45 +762,45 @@
 osl_busprobe(uint32 *val, uint32 addr)
 {
 #ifdef mips
-	return get_dbe(*val, (uint32*)addr);
+	return get_dbe(*val, (uint32 *)addr);
 #else
-	*val = readl(addr);
+	*val = readl((uint32 *)(uintptr)addr);
 	return 0;
-#endif
+#endif /* mips */
 }
 
-void
-osl_delay(uint usec)
+bool
+osl_pktshared(void *skb)
 {
-	udelay(usec);
+	return (((struct sk_buff*)skb)->cloned);
 }
 
 uchar*
-osl_pktdata(void *drv, void *skb)
+osl_pktdata(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->data);
 }
 
 uint
-osl_pktlen(void *drv, void *skb)
+osl_pktlen(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->len);
 }
 
 uint
-osl_pktheadroom(void *drv, void *skb)
+osl_pktheadroom(osl_t *osh, void *skb)
 {
 	return (uint) skb_headroom((struct sk_buff *) skb);
 }
 
 uint
-osl_pkttailroom(void *drv, void *skb)
+osl_pkttailroom(osl_t *osh, void *skb)
 {
 	return (uint) skb_tailroom((struct sk_buff *) skb);
 }
 
 void*
-osl_pktnext(void *drv, void *skb)
+osl_pktnext(osl_t *osh, void *skb)
 {
 	return (((struct sk_buff*)skb)->next);
 }
@@ -578,39 +812,27 @@
 }
 
 void
-osl_pktsetlen(void *drv, void *skb, uint len)
+osl_pktsetlen(osl_t *osh, void *skb, uint len)
 {
 	__skb_trim((struct sk_buff*)skb, len);
 }
 
 uchar*
-osl_pktpush(void *drv, void *skb, int bytes)
+osl_pktpush(osl_t *osh, void *skb, int bytes)
 {
 	return (skb_push((struct sk_buff*)skb, bytes));
 }
 
 uchar*
-osl_pktpull(void *drv, void *skb, int bytes)
+osl_pktpull(osl_t *osh, void *skb, int bytes)
 {
 	return (skb_pull((struct sk_buff*)skb, bytes));
 }
 
 void*
-osl_pktdup(void *drv, void *skb)
-{
-	return (skb_clone((struct sk_buff*)skb, GFP_ATOMIC));
-}
-
-void*
-osl_pktcookie(void *skb)
-{
-	return ((void*)((struct sk_buff*)skb)->csum);
-}
-
-void
-osl_pktsetcookie(void *skb, void *x)
+osl_pkttag(void *skb)
 {
-	((struct sk_buff*)skb)->csum = (uint)x;
+	return ((void*)(((struct sk_buff*)skb)->cb));
 }
 
 void*
@@ -637,4 +859,51 @@
 	((struct sk_buff*)skb)->priority = x;
 }
 
+/* Convert a driver packet to native(OS) packet
+ * In the process, packettag is zeroed out before sending up
+ * IP code depends on skb->cb to be setup correctly with various options
+ * In our case, that means it should be 0
+ */
+struct sk_buff *
+osl_pkt_tonative(osl_t *osh, void *pkt)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pub.pkttag)
+		bzero((void*)((struct sk_buff *)pkt)->cb, OSL_PKTTAG_SZ);
+
+	/* Decrement the packet counter */
+	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		pktlist_remove(&(osh->pktlist), (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pub.pktalloced--;
+	}
+
+	return (struct sk_buff *)pkt;
+}
+
+/* Convert a native(OS) packet to driver packet.
+ * In the process, native packet is destroyed, there is no copying
+ * Also, a packettag is zeroed out
+ */
+void *
+osl_pkt_frmnative(osl_t *osh, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pub.pkttag)
+		bzero((void*)skb->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	for (nskb = skb; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		pktlist_add(&(osh->pktlist), (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pub.pktalloced++;
+	}
+
+	return (void *)skb;
+}
+
 #endif	/* BINOSL */
--- src/shared.1927/load.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/load.c	2007-11-19 07:01:01.000000000 +0300
@@ -14,21 +14,21 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
-#include <bcmdevs.h>
 #include <bcmutils.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
 #include <sbconfig.h>
-#include <sbextif.h>
 #include <sbchipc.h>
 #include <hndmips.h>
 #include <sbmemc.h>
 #include <sflash.h>
-#include <sbutils.h>
 #include <bcmsrom.h>
 
 void c_main(unsigned long ra);
 
-static void *sbh;
+static sb_t *sbh;
 static chipcregs_t *cc;
 
 static struct sflash *sflash;
@@ -37,7 +37,7 @@
 extern char data_start[], data_end[];
 extern char bss_start[], bss_end[];
 
-#define INBUFSIZ 4096
+#define INBUFSIZ 4096	/* Buffer size */
 #define WSIZE 0x8000    	/* window size--must be a power of two, and */
 				/*  at least 32K for zip's deflate method */
 
@@ -57,10 +57,11 @@
 
 	for (insize = 0; insize < INBUFSIZ; insize += bytes, inoff += bytes) {
 		if (sflash) {
-			if ((bytes = sflash_read(cc, inoff, INBUFSIZ - insize, &inbuf[insize])) < 0)
+			if ((bytes = sflash_read(cc, inoff, INBUFSIZ - insize,
+			                         &inbuf[insize])) < 0)
 				return bytes;
 		} else {
-			*((uint32 *) &inbuf[insize]) = *((uint32 *) KSEG1ADDR(0x1fc00000 + inoff));
+			*((uint32 *) &inbuf[insize]) = *((uint32 *) KSEG1ADDR(SB_FLASH1 + inoff));
 			bytes = sizeof(uint32);
 		}
 	}
@@ -101,12 +102,12 @@
 
 /* Diagnostic functions (stubbed out) */
 
-#define Assert(cond,msg)
+#define Assert(cond, msg)
 #define Trace(x)
 #define Tracev(x)
 #define Tracevv(x)
-#define Tracec(c,x)
-#define Tracecv(c,x)
+#define Tracec(c, x)
+#define Tracecv(c, x)
 
 static uchar *window;		/* Sliding window buffer */
 static unsigned outcnt;		/* bytes in window buffer */
@@ -157,7 +158,7 @@
  * bzip2 declarations
  */
 
-void bz_internal_error (int i)
+void bz_internal_error(int i)
 {
 	char msg[128];
 
@@ -204,7 +205,7 @@
 	return ret;
 }
 
-#endif
+#endif /* defined(USE_GZIP) */
 
 extern char input_data[];
 extern int input_len;
@@ -219,7 +220,7 @@
 	inoff = ((ulong)text_end - (ulong)text_start) + ((ulong)input_data - (ulong)data_start);
 #else
 	inoff = (ulong) input_data - (ulong) text_start;
-#endif
+#endif /* CONFIG_XIP */
 	outbuf = (uchar *) LOADADDR;
 	bytes_out = 0;
 	inbuf = malloc(INBUFSIZ);	/* input buffer */
@@ -240,7 +241,7 @@
 		memcpy(&outbuf[bytes_out], inbuf, insize);
 		bytes_out += insize;
 	}
-#endif
+#endif /* defined(USE_GZIP) */
 	if (ret) {
 		printf("error %d\n", ret);
 	} else
@@ -286,12 +287,12 @@
 c_main(unsigned long ra)
 {
 	/* Basic initialization */
-	sbh = osl_init();
+	sbh = (sb_t *)osl_init();
 
 #ifndef CFG_UNCACHED
 	/* Initialize and turn caches on */
 	caches_on();
-#endif
+#endif /* CFG_UNCACHED */
 
 	cc = sb_setcore(sbh, SB_CC, 0);
 
@@ -299,7 +300,7 @@
 	sflash = cc ? sflash_init(cc) : NULL;
 
 	/* Copy self to flash if we booted from SDRAM */
-	if (PHYSADDR(ra) < 0x1fc00000) {
+	if (PHYSADDR(ra) < SB_FLASH1) {
 		if (sflash)
 			sflash_self(cc);
 	}
--- src/shared.1927/min_osl.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/min_osl.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,9 +13,14 @@
  * $Id$
  */
 
+#include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <bcmutils.h>
 #include <sbutils.h>
-#include <hndmips.h>
+#include <hndcpu.h>
+#include <sbchipc.h>
+#include <hndchipc.h>
 
 /* Cache support */
 
@@ -35,11 +40,9 @@
 	if ((prid & (PRID_COMP_MASK | PRID_IMP_MASK)) ==
 	    (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) {
 		c0reg = MFC0(C0_BROADCOM, 0);
-		/* Enable icache */
-		c0reg |= (1 << 31);
-		/* Enable dcache */
-		c0reg |= (1 << 30);
-		MTC0(C0_BROADCOM, 0 , c0reg);
+		/* Enable icache & dcache */
+		c0reg |= BRCM_IC_ENABLE | BRCM_DC_ENABLE;
+		MTC0(C0_BROADCOM, 0, c0reg);
 	}
 }	
 static void (*change_cachability)(uint32);
@@ -61,6 +64,9 @@
 	dcache_size = size;
 	dc_lsize = lsize;
 	
+	/* If caches are not in the default state then
+	 * presume that caches are already init'd
+	 */
 	if ((MFC0(C0_CONFIG, 0) & CONF_CM_CMASK) != CONF_CM_UNCACHED) {
 		blast_dcache();
 		blast_icache();
@@ -73,7 +79,7 @@
 	MTC0(C0_TAGLO, 0, 0);
 	MTC0(C0_TAGHI, 0, 0);
 	while (start < end) {
-		cache_unroll(start, Index_Store_Tag_I);
+		cache_op(start, Index_Store_Tag_I);
 		start += ic_lsize;
 	}
 	
@@ -83,7 +89,7 @@
 	MTC0(C0_TAGLO, 0, 0);
 	MTC0(C0_TAGHI, 0, 0);
 	while (start < end) {
-		cache_unroll(start, Index_Store_Tag_D);
+		cache_op(start, Index_Store_Tag_D);
 		start += dc_lsize;
 	}
 
@@ -93,7 +99,7 @@
 }
 
 
-#define BCM4710_DUMMY_RREG() (((sbconfig_t *)(KSEG1ADDR(0x18000000 + SBCONFIGOFF)))->sbimstate)
+#define BCM4710_DUMMY_RREG() (((sbconfig_t *)(KSEG1ADDR(SB_ENUM_BASE + SBCONFIGOFF)))->sbimstate)
 
 void
 blast_dcache(void)
@@ -103,9 +109,9 @@
 	start = KSEG0;
 	end = start + dcache_size;
 
-	while(start < end) {
+	while (start < end) {
 		BCM4710_DUMMY_RREG();
-		cache_unroll(start, Index_Writeback_Inv_D);
+		cache_op(start, Index_Writeback_Inv_D);
 		start += dc_lsize;
 	}
 }
@@ -118,8 +124,8 @@
 	start = KSEG0;
 	end = start + icache_size;
 
-	while(start < end) {
-		cache_unroll(start, Index_Invalidate_I);
+	while (start < end) {
+		cache_op(start, Index_Invalidate_I);
 		start += ic_lsize;
 	}
 }
@@ -127,13 +133,13 @@
 /* uart output */
 
 struct serial_struct {
-	unsigned char	*iomem_base;
-	unsigned short	iomem_reg_shift;
+	unsigned char	*reg_base;
+	unsigned short	reg_shift;
 	int	irq;
 	int	baud_base;
 };
 
-static struct serial_struct hndrte_uart;
+static struct serial_struct min_uart;
 
 #define LOG_BUF_LEN	(1024)
 #define LOG_BUF_MASK	(LOG_BUF_LEN-1)
@@ -144,14 +150,14 @@
 static inline int
 serial_in(struct serial_struct *info, int offset)
 {
-	return ((int)R_REG((uint8 *)(info->iomem_base + (offset << info->iomem_reg_shift))));
+	return ((int)R_REG(NULL, (uint8 *)(info->reg_base + (offset << info->reg_shift))));
 }
 
 static inline void
 serial_out(struct serial_struct *info, int offset, int value)
 {
-	W_REG((uint8 *)(info->iomem_base + (offset << info->iomem_reg_shift)), value);
-	*((volatile unsigned int *) KSEG1ADDR(0x18000000));
+	W_REG(NULL, (uint8 *)(info->reg_base + (offset << info->reg_shift)), value);
+	*((volatile unsigned int *) KSEG1ADDR(SB_ENUM_BASE));
 }
 
 void
@@ -166,15 +172,22 @@
 	log_start = (log_start + 1) & LOG_BUF_MASK;
 
 	/* No UART */
-	if (!hndrte_uart.iomem_base)
+	if (!min_uart.reg_base)
 		return;
 
-	while (!(serial_in(&hndrte_uart, UART_LSR) & UART_LSR_THRE));
-	serial_out(&hndrte_uart, UART_TX, c);
+	while (!(serial_in(&min_uart, UART_LSR) & UART_LSR_THRE));
+	serial_out(&min_uart, UART_TX, c);
 }
 
 /* assert & debugging */
 
+#ifdef BCMDBG_ASSERT
+void
+assfail(char *exp, char *file, int line)
+{
+	printf("ASSERT %s file %s line %d\n", exp, file, line);
+}
+#endif /* BCMDBG_ASSERT */
 
 /* general purpose memory allocation */
 
@@ -222,7 +235,7 @@
 static inline void
 __delay(uint loops)
 {
-        __asm__ __volatile__ (
+	__asm__ __volatile__(
                 ".set\tnoreorder\n"
                 "1:\tbnez\t%0,1b\n\t"
                 "subu\t%0,1\n\t"
@@ -241,12 +254,6 @@
 	__delay(loops);
 }
 
-extern int
-getintvar(char *vars, char *name)
-{
-	return 0;
-}
-
 /* No trap handling in self-decompressing boots */
 extern void trap_init(void);
 
@@ -261,20 +268,20 @@
 {
 	int quot;
 
-	if (hndrte_uart.iomem_base)
+	if (min_uart.reg_base)
 		return;
 
-	hndrte_uart.iomem_base = regs;
-	hndrte_uart.irq = irq;
-	hndrte_uart.baud_base = baud_base / 16;
-	hndrte_uart.iomem_reg_shift = reg_shift;
+	min_uart.reg_base = regs;
+	min_uart.irq = irq;
+	min_uart.baud_base = baud_base / 16;
+	min_uart.reg_shift = reg_shift;
 
 	/* Set baud and 8N1 */
-	quot = hndrte_uart.baud_base / 115200;
-	serial_out(&hndrte_uart, UART_LCR, UART_LCR_DLAB);
-	serial_out(&hndrte_uart, UART_DLL, quot & 0xff);
-	serial_out(&hndrte_uart, UART_DLM, quot >> 8);
-	serial_out(&hndrte_uart, UART_LCR, UART_LCR_WLEN8);
+	quot = (min_uart.baud_base + 57600) / 115200;
+	serial_out(&min_uart, UART_LCR, UART_LCR_DLAB);
+	serial_out(&min_uart, UART_DLL, quot & 0xff);
+	serial_out(&min_uart, UART_DLM, quot >> 8);
+	serial_out(&min_uart, UART_LCR, UART_LCR_WLEN8);
 
 	/* According to the Synopsys website: "the serial clock
 	 * modules must have time to see new register values
@@ -292,22 +299,32 @@
 osl_init()
 {
 	uint32 c0reg;
-	void *sbh;
+	sb_t *sbh;
 
 	/* Disable interrupts */
 	c0reg = MFC0(C0_STATUS, 0);
 	c0reg &= ~ST0_IE;
-	MTC0(C0_STATUS, 0 , c0reg);
+	MTC0(C0_STATUS, 0, c0reg);
 
 	/* Scan backplane */
-	sbh = sb_kattach();
+	sbh = sb_kattach(SB_OSH);
 
-	sb_mips_init(sbh);
+	sb_mips_init(sbh, 0);
 	sb_serial_init(sbh, serial_add);
 
 	/* Init malloc */
 	free_mem_ptr = (ulong) bss_end;
 	free_mem_ptr_end = ((ulong)&c0reg) - 8192;	/* Enough stack? */
 
-	return (sbh);
+	return ((void *)sbh);
+}
+
+/* translate bcmerros */
+int
+osl_error(int bcmerror)
+{
+	if (bcmerror)
+		return -1;
+	else
+		return 0;
 }
--- src/shared.1927/ndiserrmap.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/ndiserrmap.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,102 @@
+/*
+ * NDIS Error codes
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.                
+ *                                     
+ * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+ * the contents of this file may not be disclosed to third parties, copied
+ * or duplicated in any form, in whole or in part, without the prior      
+ * written permission of Broadcom Corporation.                            
+ *
+ * $Id$
+ */
+#ifndef NDIS
+#include <bcm_ndis.h>
+#endif
+#include <typedefs.h>
+#include <osl.h>
+#include <epivers.h>
+#include <bcmutils.h>
+
+#include <ndiserrmap.h>
+
+
+static NDIS_STATUS ndisbcmerrormap[] =  \
+{	NDIS_STATUS_SUCCESS, 			/* 0 */
+	NDIS_STATUS_FAILURE,			/* BCME_ERROR */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_BADARG */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_BADOPTION */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTUP */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTDOWN */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTAP */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTSTA */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_BADKEYIDX */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_RADIOOFF */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTBANDLOCKED */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_NOCLK */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_BADRATESET */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_BADBAND */
+	NDIS_STATUS_INVALID_LENGTH,		/* BCME_BUFTOOSHORT */
+	NDIS_STATUS_INVALID_LENGTH,		/* BCME_BUFTOOLONG */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_BUSY */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_NOTASSOCIATED */
+	NDIS_STATUS_INVALID_LENGTH, 		/* BCME_BADSSIDLEN */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_OUTOFRANGECHAN */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_BADCHAN */
+	NDIS_STATUS_INVALID_DATA, 		/* BCME_BADADDR */
+	NDIS_STATUS_RESOURCES, 			/* BCME_NORESOURCE */
+	NDIS_STATUS_NOT_SUPPORTED,		/* BCME_UNSUPPORTED */
+	NDIS_STATUS_INVALID_LENGTH,		/* BCME_BADLENGTH */
+	NDIS_STATUS_ADAPTER_NOT_READY,		/* BCME_NOTREADY */
+	NDIS_STATUS_FAILURE,			/* BCME_NOTPERMITTED */
+	NDIS_STATUS_RESOURCES, 			/* BCME_NOMEM */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_ASSOCIATED */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_RANGE */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOTFOUND */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_WME_NOT_ENABLED */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_TSPEC_NOTFOUND */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_ACM_NOTSUPPORTED */
+	NDIS_STATUS_INVALID_DATA,		/* BCME_NOT_WME_ASSOCIATION */
+	NDIS_STATUS_FAILURE,			/* BCME_SDIO_ERROR */
+	NDIS_STATUS_FAILURE,			/* BCME_DONGLE_DOWN */
+	NDIS_STATUS_FAILURE				/* BCME_VERSION */
+
+/* When an new error code is added to bcmutils.h, add os 
+ * spcecific error translation here as well
+ */
+/* check if BCME_LAST changed since the last time this function was updated */
+#if BCME_LAST != -37
+#error "You need to add a OS error translation in the ndisbcmerrormap \
+	for new error code defined in bcmuitls.h"
+#endif /* BCME_LAST != -37 */
+	};
+
+int
+ndisstatus2bcmerror(NDIS_STATUS status)
+{
+	int i, array_size = ARRAYSIZE(ndisbcmerrormap);
+
+	ASSERT(ABS(BCME_LAST) == (array_size - 1));
+
+	for (i = 0; i < array_size; i++)
+		if (ndisbcmerrormap[i] == status)
+			return -i;
+
+	if (status == NDIS_STATUS_INVALID_OID)
+		return BCME_UNSUPPORTED;
+
+	return BCME_ERROR;
+}
+
+NDIS_STATUS
+bcmerror2ndisstatus(int bcmerror)
+{
+	if (bcmerror > 0)
+		bcmerror = 0;
+	else if (bcmerror < BCME_LAST)
+		bcmerror = BCME_ERROR;
+
+	/* Array bounds covered by ASSERT in osl_attach */
+	return ndisbcmerrormap[-bcmerror];
+}
--- src/shared.1927/nvram/bcm94320lph.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94320lph.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,34 @@
+# BCM94320lph board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x046a
+boardnum=${serno}
+# Board revision 4.0
+boardrev=0x40
+# Flags: NOPCI, CCKHIPWR & ADCDIV.
+boardflags=0x648
+sromrev=2
+
+# Make the d11 i/f single band
+wl0id=0x4318
+
+# 4320 802.11g parameters
+il0macaddr=00:90:4c:82:${maclo}
+aa0=3
+ag0=0x82
+pa0maxpwr=76
+pa0itssit=62
+pa0b0=0x1607
+pa0b1=0xfa93
+pa0b2=0xfea7
+opo=8
+
+# Commons wireless parameters
+cctl=0
+ccode=0
--- src/shared.1927/nvram/bcm94320pagh.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94320pagh.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,50 @@
+# bcm94320pagh board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x0468
+boardnum=${serno}
+# Board revision 1.5
+boardrev=0x15
+boardflags=0x0648
+sromrev=2
+
+# Dualband id
+wl0id=0x4319
+
+# 4320 802.11g parameters
+il0macaddr=00:90:4c:93:${maclo}
+aa0=3
+ag0=2
+pa0maxpwr=76
+pa0itssit=62
+pa0b0=0x1616
+pa0b1=0xfa8d
+pa0b2=0xfe9b
+
+# 4320 802.11a parameters
+et1macaddr=00:90:4c:94:${maclo}
+aa1=2
+ag1=2
+pa1itssit=120
+pa1lomaxpwr=58
+pa1lob0=0x18c4
+pa1lob1=0xfcd7
+pa1lob2=0xff67
+pa1maxpwr=58
+pa1b0=0x173b
+pa1b1=0xfd04
+pa1b2=0xff37
+pa1himaxpwr=58
+pa1hib0=0x1e78
+pa1hib1=0xfc2e
+pa1hib2=0xffca
+
+# Commons wireless parameters
+cctl=0
+ccode=0
--- src/shared.1927/nvram/bcm94320pflsh.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320pflsh.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320pflsh board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x045e
 boardnum=${serno}
-# Board revision 4.3
-boardrev=0x43
+# Board revision 4.6
+boardrev=0x46
 # Flags: NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0x448
+boardflags=0x648
 sromrev=2
 
 # Make the d11 i/f single band
@@ -21,12 +21,13 @@
 # 4320 802.11g parameters
 il0macaddr=00:90:4c:87:${maclo}
 aa0=3
-ag0=2
-pa0maxpwr=76
+ag0=5
+pa0maxpwr=80
 pa0itssit=62
 pa0b0=0x1707
 pa0b1=0xfa61
 pa0b2=0xfeac
+opo=8
 
 # Commons wireless parameters
 cctl=0
--- src/shared.1927/nvram/bcm94320ph.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320ph.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320ph board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x045a
 boardnum=${serno}
-# Board revision 2.0
-boardrev=0x20
+# Board revision 3.6
+boardrev=0x36
 # Flags: NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0x448
+boardflags=0x648
 sromrev=2
 
 # Make the d11 i/f single band
@@ -21,13 +21,13 @@
 # 4320 802.11g parameters
 il0macaddr=00:90:4c:82:${maclo}
 aa0=3
-ag0=5
-pa0maxpwr=80
+ag0=0x82
+pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x1670
-pa0b1=0xfa71
-pa0b2=0xfe8c
-opo=2
+pa0b0=0x1665
+pa0b1=0xfa60
+pa0b2=0xfe83
+opo=8
 
 # Commons wireless parameters
 cctl=0
--- src/shared.1927/nvram/bcm94320r.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94320r.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94320Retail board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -9,10 +9,10 @@
 # $Id$
 boardtype=0x0461
 boardnum=${serno}
-# Board revision 1.0
-boardrev=0x10
-# Flags: FEM, NOPCI, CCKHIPWR & ADCDIV.
-boardflags=0xc48
+# Board revision 3.1
+boardrev=0x31
+# Flags: FEM, NOPCI, CCKHIPWR & ADCDIV, Afterburner ON.
+boardflags=0xe48
 sromrev=2
 
 # Make the d11 i/f single band
@@ -24,10 +24,15 @@
 ag0=2
 pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x1707
-pa0b1=0xfa61
-pa0b2=0xfeac
+pa0b0=5516
+pa0b1=-1417
+pa0b2=-368
+opo=16
 
 # Commons wireless parameters
 cctl=0
 ccode=0
+
+# PID and VID
+product_id=0xD11B
+vendor_id=0x0A5C
--- src/shared.1927/nvram/bcm94333u.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94333u.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94333U board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -37,5 +37,5 @@
 vendor_id=0x0a5c
 product_id=0xd11b
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
--- src/shared.1927/nvram/bcm94702ap-5325e.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap-5325e.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board with BCM5325E
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,8 +37,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # GPIO mapping
 gpio6=robo_reset
--- src/shared.1927/nvram/bcm94702ap-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board as l2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,8 +37,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 et1 wl0 wl1
--- src/shared.1927/nvram/bcm94702ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702AP board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -37,6 +37,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94702dev.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702dev.txt	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-# BCM94702DEV board
-# Copyright 2004, Broadcom Corporation
-# All Rights Reserved.                
-#                                     
-# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
-# the contents of this file may not be disclosed to third parties, copied
-# or duplicated in any form, in whole or in part, without the prior      
-# written permission of Broadcom Corporation.                            
-# $Id$
-boardtype=bcm94710dev
-boardnum=${serno}
-
-# 4702 CPU clock frequency in Mhz
-# Only valid value is 125, anything else defaults to 100Mhz
-clkfreq=125
-
-# 4702 SDRAM controller parameters
-sdram_init=0x0419
-sdram_config=0x0000
-sdram_refresh=0x8040
-sdram_ncdl=0
-
-# 4702 MAC and PHY parameters
-et0macaddr=00:90:4c:21:${maclo}
-et0phyaddr=6
-et0mdcport=0
-et1macaddr=00:90:4c:22:${maclo}
-et1phyaddr=7
-et1mdcport=1
-
-# PMON variables
-dl_ram_addr=a0001000
-os_ram_addr=80001000
-os_flash_addr=bfc40000
-lan_ipaddr=192.168.1.1
-lan_netmask=255.255.255.0
-scratch=a0180000
-boot_wait=on
-
-# watchdog set to 1 sec
-watchdog=1000
-
--- src/shared.1927/nvram/bcm94702mn.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94702mn.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94702MN board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -37,5 +37,5 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
--- src/shared.1927/nvram/bcm94704agr-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94704agr-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94704agr board as l2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -43,7 +43,7 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Reset 
 reset_gpio=7
--- src/shared.1927/nvram/bcm94704agr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94704agr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94704agr board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -43,7 +43,7 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Reset 
 reset_gpio=7
--- src/shared.1927/nvram/bcm94704cbonly.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94704cbonly.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,54 @@
+# BCM94704mpcb board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x0472
+boardnum=${serno}
+# Board revision 2.3
+boardrev=0x23
+# BCM5325 RoboSwitch requires reverse MII initialization
+boardflags=0x10
+
+# With cardbus flag set, mPCI will NOT work.
+cardbus=1
+
+# MIPS clock frequency in MHz
+clkfreq=264
+
+# 64 MB DDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# BCM5325F
+et0macaddr=00:90:4c:a0:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# BCM5325F Wan port
+et1macaddr=00:90:4c:a1:${maclo}
+et1phyaddr=4
+et1mdcport=0
+
+# BCM5325F reset
+gpio0=robo_reset
+
+# SES Button on GPIO 6
+gpio6=ses_button
+
+# Bootloader variables
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
--- src/shared.1927/nvram/bcm94704mpcb-cb.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94704mpcb-cb.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,57 @@
+# BCM94704mpcb board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x0472
+boardnum=${serno}
+# Board revision 4.3
+boardrev=0x43
+# BCM5325 RoboSwitch requires reverse MII initialization
+boardflags=0x10
+
+# MIPS clock frequency in MHz
+clkfreq=264
+
+cardbus=1
+
+# 64 MB DDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0149
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# BCM5325F
+et0macaddr=00:90:4c:a0:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# BCM5325F Wan port
+et1macaddr=00:90:4c:a1:${maclo}
+et1phyaddr=4
+et1mdcport=0
+
+# BCM5325F reset
+gpio0=robo_reset
+
+# SES Button on GPIO 6
+gpio6=ses_button
+
+# Bootloader variables
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
+
+# Set parkid=<x> where <x> is the pci slot containing the MIMO radio.
+# On BCM94704MPCB parkid=0 for miniPCI, parkid=1 for CB, parkid=2 for PCI.
+parkid=1
--- src/shared.1927/nvram/bcm94704mpcb-sdr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94704mpcb-sdr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,48 @@
+# BCM94704mpcb board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x0472
+boardnum=${serno}
+# Board revision 2.2
+boardrev=0x22
+# BCM5325 RoboSwitch requires reverse MII initialization
+boardflags=0x10
+
+# MIPS clock frequency in MHz
+clkfreq=264
+
+# 64 MB SDR SDRAM (16 Meg x 16 x 2)
+sdram_init=0x0008
+sdram_config=0x0032
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# BCM5325F
+et0macaddr=00:90:4c:a0:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# BCM5325F Wan port
+et1macaddr=00:90:4c:a1:${maclo}
+et1phyaddr=4
+et1mdcport=0
+
+# BCM5325F reset
+gpio0=robo_reset
+
+# Bootloader variables
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
--- src/shared.1927/nvram/bcm94704mpcb.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94704mpcb.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,51 @@
+# BCM94704mpcb board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x0472
+boardnum=${serno}
+# Board revision 3.7
+boardrev=0x37
+# BCM5325 RoboSwitch requires reverse MII initialization
+boardflags=0x10
+
+# MIPS clock frequency in MHz
+clkfreq=264
+
+# 64 MB DDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0149
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# BCM5325F
+et0macaddr=00:90:4c:a0:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# BCM5325F Wan port
+et1macaddr=00:90:4c:a1:${maclo}
+et1phyaddr=4
+et1mdcport=0
+
+# BCM5325F reset
+gpio0=robo_reset
+
+# SES Button on GPIO 6
+gpio6=ses_button
+
+# Bootloader variables
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
--- src/shared.1927/nvram/bcm94705lmp.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94705lmp.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,59 @@
+# Broadcom 4705L reference design
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+
+boardtype=0x489
+boardnum=${serno}
+# Board revision 1.0
+boardrev=0x10
+# BFL_ENETROBO, BFL_ENETVLAN
+boardflags=0x110
+
+# MIPS clock frequency in MHz
+clkfreq=300,150,37
+
+# 64 MB DDR SDRAM (16 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# Ethernet 
+et0macaddr=00:90:4c:b9:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
+
+# SES Button on GPIO 8
+gpio8=ses_button
+
+# Variables used by CFE and run-time OS image
+# which may be modified by the run-time OS image
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+
+# Ethernet switch config (vlan1:LAN, vlan2:WAN)
+vlan1ports=0 1 2 3 8*
+vlan1hwname=et0
+vlan2ports=4 8u
+
+# bootloader/OS glue
+landevs=vlan1 wl0 wl1
+wandevs=et0
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+
+# CFE variables
+boot_wait=on
+wait_time=5
--- src/shared.1927/nvram/bcm94705.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94705.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,170 @@
+# Broadcom 4705 reference design, including a 4321mp
+boardtype=0x489
+boardnum=${serno}
+# Board revision 1.0
+boardrev=0x10
+# BFL_ENETROBO, BFL_ENETVLAN
+boardflags=0x110
+
+# MIPS clock frequency in MHz
+clkfreq=300,150,37
+
+# 64 MB DDR SDRAM (16 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# Ethernet 
+et0macaddr=00:90:4c:b9:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Reset 
+reset_gpio=7
+
+# SES Button on GPIO 8
+gpio8=ses_button
+
+# Variables used by CFE and run-time OS image
+# which may be modified by the run-time OS image
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+
+# Ethernet switch config (vlan1:LAN, vlan2:WAN)
+vlan1ports=0 1 2 3 8*
+vlan1hwname=et0
+vlan2ports=4 8u
+
+# bootloader/OS glue
+landevs=vlan1 wl0
+wandevs=et0
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+
+# CFE variables
+boot_wait=on
+wait_time=5
+
+# The following should be uncommented if the 4321mp does not have an srom.
+
+## Variables for the 4321mp:
+#pci/1/1/venid=0x14e4
+#pci/1/1/devid=0x4328
+#pci/1/1/sromrev=4
+#pci/1/1/boardtype=0x46c
+#pci/1/1/boardvendor=0x14e4
+#pci/1/1/boardrev=0x34
+#pci/1/1/boardflags=0x4a01
+#pci/1/1/boardflags2=0
+#pci/1/1/macaddr=00:90:4c:98:${maclo}
+#pci/1/1/ccode=
+#pci/1/1/regrev=0
+#pci/1/1/ledbh0=-1
+#pci/1/1/ledbh1=-1
+#pci/1/1/ledbh2=-1
+#pci/1/1/ledbh3=-1
+#pci/1/1/aa2g=3
+#pci/1/1/aa5g=3
+#pci/1/1/ag0=2
+#pci/1/1/ag1=2
+#pci/1/1/txpid2ga0=91
+#pci/1/1/txpid2ga1=91
+#pci/1/1/txpid5ga0=91
+#pci/1/1/txpid5ga1=91
+#pci/1/1/txpid5gla0=91
+#pci/1/1/txpid5gla1=91
+#pci/1/1/txpid5gha0=91
+#pci/1/1/txpid5gha1=91
+#pci/1/1/txpt2g=0x3c
+#pci/1/1/txpt5g=0x30
+#pci/1/1/txpt5gl=0x30
+#pci/1/1/txpt5gh=0x30
+#pci/1/1/itt2ga0=0
+#pci/1/1/maxp2ga0=0
+#pci/1/1/pa2gw0a0=0
+#pci/1/1/pa2gw1a0=0
+#pci/1/1/pa2gw2a0=0
+#pci/1/1/pa2gw3a0=0
+#pci/1/1/itt5ga0=0
+#pci/1/1/maxp5ga0=0
+#pci/1/1/pa5gw0a0=0
+#pci/1/1/pa5gw1a0=0
+#pci/1/1/pa5gw2a0=0
+#pci/1/1/pa5gw3a0=0
+#pci/1/1/maxp5gla0=0
+#pci/1/1/pa5glw0a0=0
+#pci/1/1/pa5glw1a0=0
+#pci/1/1/pa5glw2a0=0
+#pci/1/1/pa5glw3a0=0
+#pci/1/1/maxp5gha0=0
+#pci/1/1/pa5ghw0a0=0
+#pci/1/1/pa5ghw1a0=0
+#pci/1/1/pa5ghw2a0=0
+#pci/1/1/pa5ghw3a0=0
+#pci/1/1/itt2ga1=0
+#pci/1/1/maxp2ga1=0
+#pci/1/1/pa2gw0a1=0
+#pci/1/1/pa2gw1a1=0
+#pci/1/1/pa2gw2a1=0
+#pci/1/1/pa2gw3a1=0
+#pci/1/1/itt5ga1=0
+#pci/1/1/maxp5ga1=0
+#pci/1/1/pa5gw0a1=0
+#pci/1/1/pa5gw1a1=0
+#pci/1/1/pa5gw2a1=0
+#pci/1/1/pa5gw3a1=0
+#pci/1/1/maxp5gla1=0
+#pci/1/1/pa5glw0a1=0
+#pci/1/1/pa5glw1a1=0
+#pci/1/1/pa5glw2a1=0
+#pci/1/1/pa5glw3a1=0
+#pci/1/1/maxp5gha1=0
+#pci/1/1/pa5ghw0a1=0
+#pci/1/1/pa5ghw1a1=0
+#pci/1/1/pa5ghw2a1=0
+#pci/1/1/pa5ghw3a1=0
+#pci/1/1/cck2gpo=0
+#pci/1/1/ofdm2gpo=0
+#pci/1/1/ofdm5gpo=0
+#pci/1/1/ofdm5lgpo=0
+#pci/1/1/ofdm5hgpo=0
+#pci/1/1/mcs2gpo0=0
+#pci/1/1/mcs2gpo1=0
+#pci/1/1/mcs2gpo2=0
+#pci/1/1/mcs2gpo3=0
+#pci/1/1/mcs2gpo4=0
+#pci/1/1/mcs2gpo5=0
+#pci/1/1/mcs2gpo6=0
+#pci/1/1/mcs2gpo7=0
+#pci/1/1/mcs5gpo0=0
+#pci/1/1/mcs5gpo1=0
+#pci/1/1/mcs5gpo2=0
+#pci/1/1/mcs5gpo3=0
+#pci/1/1/mcs5gpo4=0
+#pci/1/1/mcs5gpo5=0
+#pci/1/1/mcs5gpo6=0
+#pci/1/1/mcs5gpo7=0
+#pci/1/1/mcs5glpo0=0
+#pci/1/1/mcs5glpo1=0
+#pci/1/1/mcs5glpo2=0
+#pci/1/1/mcs5glpo3=0
+#pci/1/1/mcs5glpo4=0
+#pci/1/1/mcs5glpo5=0
+#pci/1/1/mcs5glpo6=0
+#pci/1/1/mcs5glpo7=0
+#pci/1/1/mcs5ghpo0=0
+#pci/1/1/mcs5ghpo1=0
+#pci/1/1/mcs5ghpo2=0
+#pci/1/1/mcs5ghpo3=0
+#pci/1/1/mcs5ghpo4=0
+#pci/1/1/mcs5ghpo5=0
+#pci/1/1/mcs5ghpo6=0
+#pci/1/1/mcs5ghpo7=0
+#pci/1/1/ccdpo=0
+#pci/1/1/stbcpo=0
+#pci/1/1/bw40po=0
+#pci/1/1/bwduppo=0
--- src/shared.1927/nvram/bcm94710ap-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710ap-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710AP board as switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,8 +38,8 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 et1 wl0 wl1 il0
--- src/shared.1927/nvram/bcm94710ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710AP board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,6 +38,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94710dev.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710dev.txt	1970-01-01 03:00:00.000000000 +0300
@@ -1,43 +0,0 @@
-# BCM94710DEV board
-# Copyright 2004, Broadcom Corporation
-# All Rights Reserved.                
-#                                     
-# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
-# the contents of this file may not be disclosed to third parties, copied
-# or duplicated in any form, in whole or in part, without the prior      
-# written permission of Broadcom Corporation.                            
-# $Id$
-boardtype=bcm94710dev
-boardnum=${serno}
-
-# 4710 CPU clock frequency in Mhz
-# Only valid value is 125, anything else defaults to 100Mhz
-clkfreq=125
-
-# 4710 SDRAM controller parameters
-sdram_init=0x0419
-sdram_config=0x0000
-sdram_refresh=0x8040
-sdram_ncdl=0
-
-# 4710 MAC and PHY parameters
-il0macaddr=00:90:4c:20:${maclo}
-et0macaddr=00:90:4c:21:${maclo}
-et0phyaddr=6
-et0mdcport=0
-et1macaddr=00:90:4c:22:${maclo}
-et1phyaddr=7
-et1mdcport=1
-
-# PMON variables
-dl_ram_addr=a0001000
-os_ram_addr=80001000
-os_flash_addr=bfc40000
-lan_ipaddr=192.168.1.1
-lan_netmask=255.255.255.0
-scratch=a0180000
-boot_wait=on
-
-# watchdog set to 1 sec
-watchdog=1000
-
--- src/shared.1927/nvram/bcm94710r1.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710r1.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710R1 board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.                
 #                                     
 # This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
@@ -40,6 +40,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94710r4.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94710r4.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94710R4 board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -38,6 +38,6 @@
 scratch=a0180000
 boot_wait=on
 
-# watchdog set to 1 sec
-watchdog=1000
+# watchdog set to 3 sec
+watchdog=3000
 
--- src/shared.1927/nvram/bcm94712agr-sd-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr-sd-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board with sdram as l2 switch.
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -65,7 +65,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # glue between bootloader and firmware
 landevs=et0 wl0 wl1
--- src/shared.1927/nvram/bcm94712agr-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board with sdram.
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -74,4 +74,4 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712agr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712agr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # bcm94712agr board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -74,4 +74,4 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712agsdio.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm94712agsdio.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,74 @@
+# bcm94712agsdio board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x047b
+boardnum=${serno}
+# Board revision 1.2
+boardrev=0x12
+boardflags=0x0a08
+sromrev=2
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 64 MB DDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# Ethernet Phy
+et0macaddr=00:90:4c:a7:${maclo}
+et0phyaddr=01
+et0mdcport=0
+
+# No eth1
+et1phyaddr=0x1f
+
+# Make the d11 i/f dual band
+wl0id=0x4319
+
+# 4712 802.11g parameters
+il0macaddr=00:90:4c:a8:${maclo}
+aa0=3
+ag0=2
+pa0maxpwr=74
+pa0itssit=62
+pa0b0=0x1691
+pa0b1=0xfa77
+pa0b2=0xfe8a
+
+# 4320 802.11a parameters
+et1macaddr=00:90:4c:a9:${maclo}
+aa1=2
+ag1=2
+pa1itssit=120
+pa1lomaxpwr=60
+pa1lob0=0x1825
+pa1lob1=0xfcf2
+pa1lob2=0xff65
+pa1maxpwr=60
+pa1b0=0x1b49
+pa1b1=0xfcb1
+pa1b2=0xff9e
+pa1himaxpwr=60
+pa1hib0=0x1a8f
+pa1hib1=0xfcb7
+pa1hib2=0xff89
+
+# Commons wireless parameters
+cctl=0
+ccode=0
+
+# Bootlaoder variables
+boot_wait=on
+reset_gpio=7
+
+# Watchdog timer in ms
+watchdog=3000
--- src/shared.1927/nvram/bcm94712ap-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712ap-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM4712ap board with SDRAM memory
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -49,10 +49,6 @@
 cctl=0
 ccode=0
 
-# It's an AP only
-router_disable=1
-lan_ifnames="eth0 eth1"
-
 # Bootlaoder variables
 dl_ram_addr=a0001000
 os_ram_addr=80001000
@@ -63,4 +59,9 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
+
+# glue between bootloader and OS
+landevs=et0 wl0
+wandevs=
+
--- src/shared.1927/nvram/bcm94712ap.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712ap.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM4712ap board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -49,9 +49,9 @@
 cctl=0
 ccode=0
 
-# It's an AP only
-router_disable=1
-lan_ifnames="eth0 eth1"
+# glue between bootloader and OS
+landevs=et0 wl0
+wandevs=
 
 # Bootlaoder variables
 dl_ram_addr=a0001000
@@ -63,4 +63,4 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm94712lgr-sd-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sd-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR SDR board as L2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712lgr-sd.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sd.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR SDR board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -9,9 +9,10 @@
 # $Id$
 boardtype=0x0460
 boardnum=${serno}
-# Board revision 1.8
-boardrev=0x18
-boardflags=0x0758
+# Board revision 2.1 
+boardrev=0x21
+boardflags=0x1758
+# EXT_LNA enabled
 sromrev=2
 
 # MIPS clock frequency in MHz
@@ -40,9 +41,9 @@
 ag0=2
 pa0maxpwr=76
 pa0itssit=62
-pa0b0=0x153d
-pa0b1=0xfb91
-pa0b2=0xfeb7
+pa0b0=0x183d
+pa0b1=0xf9fa
+pa0b2=0xfe74
 opo=8
 
 # Commons wireless parameters
--- src/shared.1927/nvram/bcm94712lgr-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR DDR board as L2 switch
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712lgr.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712lgr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM94712LGR DDR board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvram/bcm94712p.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm94712p.txt	2007-11-19 06:40:26.000000000 +0300
@@ -9,8 +9,8 @@
 # $Id$
 boardtype=0x0446
 boardnum=${serno}
-# Board revision 5.1
-boardrev=0x51
+# Board revision 6.0
+boardrev=0x60
 boardflags=0x48
 sromrev=2
 
@@ -55,4 +55,4 @@
 boot_wait=on
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
--- src/shared.1927/nvram/bcm95350rg_rev3.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95350rg_rev3.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,77 @@
+# BCM95350RG sdram board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x0456
+boardnum=${serno}
+# Board revision 4.1
+boardrev=0x41
+boardflags=0x1758
+sromrev=2
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 16 MB SDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0000
+sdram_config=0x22
+sdram_refresh=0x0
+sdram_ncdl=0
+
+# Ethernet w/Robo switch
+et0macaddr=00:90:4c:7d:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Bootloader variables
+dl_ram_addr=a0001000
+os_ram_addr=80001000
+os_flash_addr=bfc40000
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+scratch=a0180000
+boot_wait=on
+reset_gpio=3
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Make the d11 i/f single band
+wl0id=0x4320
+
+# 5350 802.11g parameters
+il0macaddr=00:90:4c:7e:${maclo}
+aa0=1
+ag0=255
+pa0maxpwr=80
+pa0itssit=62
+pa0b0=0x1780
+pa0b1=0xfa7a
+pa0b2=0xfea5
+opo=12
+
+# Commons wireless parameters
+ccode=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0hwname=et0
+vlan0ports=1 2 3 4 5*
+vlan1hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0
+wandevs=et0
+
+# Wireless LED GPIO mapping/behavior
+wl0gpio2=11
+
+# SES parameters
+gpio1=ses_led
+gpio2=ses_button
+
--- src/shared.1927/nvram/bcm95350rg-sw.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm95350rg-sw.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM95350RG sdram board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -39,7 +39,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Make the d11 i/f single band
 wl0id=0x4320
--- src/shared.1927/nvram/bcm95350rg.txt	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/bcm95350rg.txt	2007-11-19 06:40:26.000000000 +0300
@@ -1,5 +1,5 @@
 # BCM95350RG sdram board
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -39,7 +39,7 @@
 reset_gpio=7
 
 # Watchdog timer in ms
-watchdog=0
+watchdog=3000
 
 # Make the d11 i/f single band
 wl0id=0x4320
--- src/shared.1927/nvram/bcm95351agr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95351agr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,119 @@
+# BCM95351AGR sdram board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x0470
+boardnum=${serno}
+# VLAN + ROBO
+boardflags=0x0110
+# Board revision 1.4
+boardrev=0x14
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 16 MB SDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x2000
+sdram_config=0x22
+sdram_refresh=0x0
+sdram_ncdl=0
+
+# Bootloader variables
+dl_ram_addr=a0001000
+os_ram_addr=80001000
+os_flash_addr=bfc40000
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+scratch=a0180000
+boot_wait=on
+reset_gpio=3
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Ethernet w/Robo switch
+et0macaddr=00:90:4c:9c:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0 wl1
+wandevs=et0
+
+# SES parameters
+gpio2=ses_button
+
+#
+# --- on-chip d11 device ---
+#
+sb/7/sromrev=2
+# HGPA + AB + CCK + AD
+sb/7/boardflags=0x2248
+
+# single band 802.11b/g device
+sb/7/devid=0x4320
+
+# 802.11g parameters
+sb/7/il0macaddr=00:90:4c:9d:${maclo}
+sb/7/aa0=1
+sb/7/ag0=255
+sb/7/pa0maxpwr=76
+sb/7/pa0itssit=62
+sb/7/pa0b0=0x15c8
+sb/7/pa0b1=0xfa80
+sb/7/pa0b2=0xfe65
+sb/7/opo=12
+
+# LED GPIO assignments
+sb/7/wl0gpio2=0
+
+# misc. parameters
+sb/7/ccode=0
+
+#
+# --- off-chip d11 device ---
+#
+pci/1/1/sromrev=2
+# ALTIQ + HGPA + AB + CCK + AD
+pci/1/1/boardflags=0xa248
+
+# single band 802.11a device
+pci/1/1/devid=0x431a
+
+# 802.11a parameters
+pci/1/1/et1macaddr=00:90:4c:9e:${maclo}
+pci/1/1/aa1=1
+pci/1/1/ag1=2
+pci/1/1/pa1lomaxpwr=60
+pci/1/1/pa1himaxpwr=60
+pci/1/1/pa1lob0=0x1880
+pci/1/1/pa1lob1=0xfcbd
+pci/1/1/pa1lob2=0xff4b
+pci/1/1/pa1hib0=0x18a8
+pci/1/1/pa1hib1=0xfcc1
+pci/1/1/pa1hib2=0xff41
+pci/1/1/pa1maxpwr=60
+pci/1/1/pa1b0=0x184c
+pci/1/1/pa1b1=0xfcc3
+pci/1/1/pa1b2=0xff40
+pci/1/1/pa1itssit=120
+pci/1/1/opo=0
+
+# LED GPIO assignments
+pci/1/1/wl0gpio0=2
+pci/1/1/wl0gpio1=0
+pci/1/1/wl0gpio2=4
+
+# misc. parameters
+pci/1/1/ccode=0
+
--- src/shared.1927/nvram/bcm95351bu_ddr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95351bu_ddr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,90 @@
+# BCM95351BU ddr board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x047a
+boardnum=${serno}
+# VLAN + ROBO
+boardflags=0x0110
+# Board revision 1.2
+boardrev=0x12
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 16 MB SDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x62
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# Bootloader variables
+dl_ram_addr=a0001000
+os_ram_addr=80001000
+os_flash_addr=bfc40000
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+scratch=a0180000
+boot_wait=on
+reset_gpio=3
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Ethernet w/Robo switch
+et0macaddr=00:90:4c:9c:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0 wl1
+wandevs=et0
+
+# SES parameters
+gpio2=ses_button
+
+#
+# --- on-chip d11 device ---
+#
+# 802.11g parameters
+sb/7/il0macaddr=00:90:4c:9d:${maclo}
+sb/7/aa0=1
+sb/7/ag0=255
+sb/7/pa0maxpwr=76
+sb/7/pa0itssit=62
+sb/7/pa0b0=0x15c8
+sb/7/pa0b1=0xfa80
+sb/7/pa0b2=0xfe65
+sb/7/opo=12
+
+# LED GPIO assignments
+sb/7/wl0gpio2=0
+
+# misc. parameters
+sb/7/ccode=0
+
+#
+# --- off-chip d11 device ---
+#
+pci/1/1/sromrev=2
+# ALTIQ + HGPA + AB + CCK + AD
+pci/1/1/boardflags=0xa248
+
+# LED GPIO assignments
+pci/1/1/wl0gpio0=2
+pci/1/1/wl0gpio1=0
+pci/1/1/wl0gpio2=4
+
+# misc. parameters
+pci/1/1/ccode=0
+
--- src/shared.1927/nvram/bcm95351bu_sdram.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95351bu_sdram.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,119 @@
+# BCM95351BU SDRAM board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x047a
+boardnum=${serno}
+# VLAN + ROBO
+boardflags=0x0110
+# Board revision 1.0
+boardrev=0x11
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 64 MB DDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x0009
+sdram_config=0x0062
+sdram_refresh=0x0000
+sdram_ncdl=0
+
+# Bootloader variables
+dl_ram_addr=a0001000
+os_ram_addr=80001000
+os_flash_addr=bfc40000
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+scratch=a0180000
+boot_wait=on
+reset_gpio=3
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Ethernet w/Robo switch
+et0macaddr=00:90:4c:9c:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0 wl1
+wandevs=et0
+
+# SES parameters
+gpio2=ses_button
+
+#
+# --- on-chip d11 device ---
+#
+sb/7/sromrev=2
+# HGPA + AB + CCK + AD
+sb/7/boardflags=0x2248
+
+# single band 802.11b/g device
+sb/7/devid=0x4320
+
+# 802.11g parameters
+sb/7/il0macaddr=00:90:4c:9d:${maclo}
+sb/7/aa0=1
+sb/7/ag0=255
+sb/7/pa0maxpwr=76
+sb/7/pa0itssit=62
+sb/7/pa0b0=0x15c8
+sb/7/pa0b1=0xfa80
+sb/7/pa0b2=0xfe65
+sb/7/opo=12
+
+# LED GPIO assignments
+sb/7/wl0gpio2=0
+
+# misc. parameters
+sb/7/ccode=0
+
+#
+# --- off-chip d11 device ---
+#
+pci/1/1/sromrev=2
+# ALTIQ + HGPA + AB + CCK + AD
+pci/1/1/boardflags=0xa248
+
+# single band 802.11a device
+# pci/1/1/devid=0x431a
+
+# 802.11a parameters
+# pci/1/1/et1macaddr=00:90:4c:9e:${maclo}
+# pci/1/1/aa1=1
+# pci/1/1/ag1=2
+# pci/1/1/pa1lomaxpwr=60
+# pci/1/1/pa1himaxpwr=60
+# pci/1/1/pa1lob0=0x1880
+# pci/1/1/pa1lob1=0xfcbd
+# pci/1/1/pa1lob2=0xff4b
+# pci/1/1/pa1hib0=0x18a8
+# pci/1/1/pa1hib1=0xfcc1
+# pci/1/1/pa1hib2=0xff41
+# pci/1/1/pa1maxpwr=60
+# pci/1/1/pa1b0=0x184c
+# pci/1/1/pa1b1=0xfcc3
+# pci/1/1/pa1b2=0xff40
+# pci/1/1/pa1itssit=120
+# pci/1/1/opo=0
+
+# LED GPIO assignments
+pci/1/1/wl0gpio0=2
+pci/1/1/wl0gpio1=0
+pci/1/1/wl0gpio2=4
+
+# misc. parameters
+pci/1/1/ccode=0
+
--- src/shared.1927/nvram/bcm95351bu.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95351bu.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,119 @@
+# BCM95351BU sdram board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+boardtype=0x047a
+boardnum=${serno}
+# VLAN + ROBO
+boardflags=0x0110
+# Board revision 1.0
+boardrev=0x10
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 16 MB SDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0x2000
+sdram_config=0x22
+sdram_refresh=0x0
+sdram_ncdl=0
+
+# Bootloader variables
+dl_ram_addr=a0001000
+os_ram_addr=80001000
+os_flash_addr=bfc40000
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+scratch=a0180000
+boot_wait=on
+reset_gpio=3
+
+# Watchdog timer in ms
+watchdog=3000
+
+# Ethernet w/Robo switch
+et0macaddr=00:90:4c:9c:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0 wl1
+wandevs=et0
+
+# SES parameters
+gpio2=ses_button
+
+#
+# --- on-chip d11 device ---
+#
+sb/7/sromrev=2
+# HGPA + AB + CCK + AD
+sb/7/boardflags=0x2248
+
+# single band 802.11b/g device
+sb/7/devid=0x4320
+
+# 802.11g parameters
+sb/7/il0macaddr=00:90:4c:9d:${maclo}
+sb/7/aa0=1
+sb/7/ag0=255
+sb/7/pa0maxpwr=76
+sb/7/pa0itssit=62
+sb/7/pa0b0=0x15c8
+sb/7/pa0b1=0xfa80
+sb/7/pa0b2=0xfe65
+sb/7/opo=12
+
+# LED GPIO assignments
+sb/7/wl0gpio2=0
+
+# misc. parameters
+sb/7/ccode=0
+
+#
+# --- off-chip d11 device ---
+#
+pci/1/1/sromrev=2
+# ALTIQ + HGPA + AB + CCK + AD
+pci/1/1/boardflags=0xa248
+
+# single band 802.11a device
+# pci/1/1/devid=0x431a
+
+# 802.11a parameters
+# pci/1/1/et1macaddr=00:90:4c:9e:${maclo}
+# pci/1/1/aa1=1
+# pci/1/1/ag1=2
+# pci/1/1/pa1lomaxpwr=60
+# pci/1/1/pa1himaxpwr=60
+# pci/1/1/pa1lob0=0x1880
+# pci/1/1/pa1lob1=0xfcbd
+# pci/1/1/pa1lob2=0xff4b
+# pci/1/1/pa1hib0=0x18a8
+# pci/1/1/pa1hib1=0xfcc1
+# pci/1/1/pa1hib2=0xff41
+# pci/1/1/pa1maxpwr=60
+# pci/1/1/pa1b0=0x184c
+# pci/1/1/pa1b1=0xfcc3
+# pci/1/1/pa1b2=0xff40
+# pci/1/1/pa1itssit=120
+# pci/1/1/opo=0
+
+# LED GPIO assignments
+pci/1/1/wl0gpio0=2
+pci/1/1/wl0gpio1=0
+pci/1/1/wl0gpio2=4
+
+# misc. parameters
+pci/1/1/ccode=0
+
--- src/shared.1927/nvram/bcm95352elgr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95352elgr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,71 @@
+# bcm95352elrg 16bit sdram board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+
+boardtype=0x047f
+boardnum=${serno}
+# Board revision 1.1
+boardrev=0x11
+# NO_EXTLNA, NOPCI, AFTERBURNER, ENETVLAN, CCKHIPWR, ENETROBO, ADC.
+boardflags=0x758
+sromrev=2
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 8 MB SDR-16 SDRAM (4 Meg x 16)
+sdram_init=2
+sdram_config=0x22
+sdram_refresh=0
+sdram_ncdl=0
+
+# Integrated Ethernet switch
+et0macaddr=00:90:4c:ad:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# single band d11 interface
+wl0id=0x4318
+
+# 802.11g parameters
+il0macaddr=00:90:4c:ae:${maclo}
+aa0=3
+ag0=2
+pa0maxpwr=72
+pa0itssit=62
+pa0b0=0x169f
+pa0b1=0xfa5e
+pa0b2=0xfe8a
+opo=12
+
+# Commons wireless parameters
+wl0gpio2=0
+wl0gpio3=0
+cctl=0
+ccode=0
+
+# Ethernet switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0
+wandevs=et0
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+reset_gpio=7
+
+# Watchdog timer in ms
+watchdog=3000
+
+# SES parameters
+gpio13=ses_led
+gpio14=ses_button
--- src/shared.1927/nvram/bcm95352gr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95352gr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,71 @@
+# bcm95352rg sdram board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+# $Id$
+
+boardtype=0x0467
+boardnum=${serno}
+# Board revision 3.0
+boardrev=0x30
+# NO_EXTLNA, NOPCI, AFTERBURNER, ENETVLAN, CCKHIPWR, ENETROBO, ADC.
+boardflags=0x758
+sromrev=2
+
+# MIPS clock frequency in MHz
+clkfreq=200
+
+# 16 MB SDR SDRAM (4 Meg x 16 x 2)
+sdram_init=0
+sdram_config=0x22
+sdram_refresh=0
+sdram_ncdl=0
+
+# Integrated Ethernet switch
+et0macaddr=00:90:4c:91:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# single band d11 interface
+wl0id=0x4318
+
+# 802.11g parameters
+il0macaddr=00:90:4c:92:${maclo}
+aa0=3
+ag0=2
+pa0maxpwr=72
+pa0itssit=62
+pa0b0=0x169f
+pa0b1=0xfa5e
+pa0b2=0xfe8a
+opo=12
+
+# Commons wireless parameters
+wl0gpio2=0
+wl0gpio3=0
+cctl=0
+ccode=0
+
+# Ethernet switch config (vlan0:LAN, vlan1:WAN)
+vlan0ports=1 2 3 4 5*
+vlan0hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0
+wandevs=et0
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+reset_gpio=7
+
+# Watchdog timer in ms
+watchdog=3000
+
+# SES parameters
+gpio13=ses_led
+gpio14=ses_button
--- src/shared.1927/nvram/bcm95354gr.txt	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/bcm95354gr.txt	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,87 @@
+# bcm95354gr board
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.                
+#                                     
+# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
+# the contents of this file may not be disclosed to third parties, copied
+# or duplicated in any form, in whole or in part, without the prior      
+# written permission of Broadcom Corporation.                            
+# $Id$
+boardtype=0x048e
+boardnum=${serno}
+# Board revision 3.5
+boardrev=0x35
+boardflags=0x750
+sromrev=3
+
+# MIPS clock frequency in MHz. This value shouldn't be changed
+clkfreq=240
+
+# On board crystal frequency in KHz
+xtalfreq=25000
+
+# 32 MB SDR SDRAM (16 Meg x 16)
+sdram_init=0x000b
+sdram_config=0x0062
+sdram_refresh=0
+sdram_ncdl=0
+
+# Ethernet w/ internal roboswitch
+et0macaddr=00:90:4c:c0:${maclo}
+et0phyaddr=30
+et0mdcport=0
+
+# No eth1
+et1phyaddr=0x1f
+
+# Its a 2.4Ghz only board
+wl0id=0x4318
+
+# 5354 802.11g parameters
+il0macaddr=00:90:4c:c1:${maclo}
+aa0=3
+ag0=2
+pa0maxpwr=72
+pa0itssit=62
+pa0b0=0x141a
+pa0b1=0xfb16
+pa0b2=0xfeb2
+opo=12
+bxa2g=1
+rssismf2g=0
+rssismc2g=2
+rssisav2g=2
+tri2g=78
+rxpo2g=0xfff8
+parefldovoltage=0x28
+
+# Commons wireless parameters
+wl0gpio0=255
+wl0gpio1=255
+wl0gpio2=255
+wl0gpio3=255
+cctl=0
+ccode=0
+
+# Robo switch config (vlan0:LAN, vlan1:WAN)
+vlan0hwname=et0
+vlan0ports=1 2 3 4 5*
+vlan1hwname=et0
+vlan1ports=0 5u
+
+# Bootloader and OS glue
+landevs=vlan0 wl0
+wandevs=et0
+
+# Bootlaoder variables
+lan_ipaddr=192.168.1.1
+lan_netmask=255.255.255.0
+boot_wait=on
+reset_gpio=7
+
+# Watchdog timer in ms
+watchdog=3000
+
+# SES parameters
+gpio5=ses_led
+gpio6=ses_button
--- src/shared.1927/nvram/nvram.c	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/nvram.c	2007-11-19 06:40:26.000000000 +0300
@@ -13,23 +13,27 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmendian.h>
 #include <bcmnvram.h>
-#include <bcmutils.h>
 #include <sbsdram.h>
 
-extern struct nvram_tuple * BCMINIT(_nvram_realloc)(struct nvram_tuple *t, const char *name, const char *value);
-extern void BCMINIT(_nvram_free)(struct nvram_tuple *t);
-extern int BCMINIT(_nvram_read)(void *buf);
-
-char * BCMINIT(_nvram_get)(const char *name);
-int BCMINIT(_nvram_set)(const char *name, const char *value);
-int BCMINIT(_nvram_unset)(const char *name);
-int BCMINIT(_nvram_getall)(char *buf, int count);
-int BCMINIT(_nvram_commit)(struct nvram_header *header);
-int BCMINIT(_nvram_init)(void);
-void BCMINIT(_nvram_exit)(void);
+extern struct nvram_tuple * _nvram_realloc(struct nvram_tuple *t, const char *name,
+                                           const char *value);
+extern void _nvram_free(struct nvram_tuple *t);
+extern int _nvram_read(void *buf);
+
+char * _nvram_get(const char *name);
+int _nvram_set(const char *name, const char *value);
+int _nvram_unset(const char *name);
+int _nvram_getall(char *buf, int count);
+int _nvram_commit(struct nvram_header *header);
+int _nvram_init(void *sb);
+void _nvram_exit(void);
+uint8 nvram_calc_crc(struct nvram_header * nvh);
 
 static struct nvram_tuple * BCMINITDATA(nvram_hash)[257];
 static struct nvram_tuple * nvram_dead;
@@ -42,23 +46,23 @@
 	struct nvram_tuple *t, *next;
 
 	/* Free hash table */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = next) {
 			next = t->next;
-			BCMINIT(_nvram_free)(t);
+			_nvram_free(t);
 		}
-		BCMINIT(nvram_hash)[i] = NULL;
+		nvram_hash[i] = NULL;
 	}
 
 	/* Free dead table */
 	for (t = nvram_dead; t; t = next) {
 		next = t->next;
-		BCMINIT(_nvram_free)(t);
+		_nvram_free(t);
 	}
 	nvram_dead = NULL;
 
 	/* Indicate to per-port code that all tuples have been freed */
-	BCMINIT(_nvram_free)(NULL);
+	_nvram_free(NULL);
 }
 
 /* String hash */
@@ -80,7 +84,7 @@
 	char buf[] = "0xXXXXXXXX", *name, *value, *end, *eq;
 
 	/* (Re)initialize hash table */
-	BCMINIT(nvram_free)();
+	nvram_free();
 
 	/* Parse and set "name=value\0 ... \0\0" */
 	name = (char *) &header[1];
@@ -91,26 +95,26 @@
 			break;
 		*eq = '\0';
 		value = eq + 1;
-		BCMINIT(_nvram_set)(name, value);
+		_nvram_set(name, value);
 		*eq = '=';
 	}
 
 	/* Set special SDRAM parameters */
-	if (!BCMINIT(_nvram_get)("sdram_init")) {
+	if (!_nvram_get("sdram_init")) {
 		sprintf(buf, "0x%04X", (uint16)(header->crc_ver_init >> 16));
-		BCMINIT(_nvram_set)("sdram_init", buf);
+		_nvram_set("sdram_init", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_config")) {
+	if (!_nvram_get("sdram_config")) {
 		sprintf(buf, "0x%04X", (uint16)(header->config_refresh & 0xffff));
-		BCMINIT(_nvram_set)("sdram_config", buf);
+		_nvram_set("sdram_config", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_refresh")) {
+	if (!_nvram_get("sdram_refresh")) {
 		sprintf(buf, "0x%04X", (uint16)((header->config_refresh >> 16) & 0xffff));
-		BCMINIT(_nvram_set)("sdram_refresh", buf);
+		_nvram_set("sdram_refresh", buf);
 	}
-	if (!BCMINIT(_nvram_get)("sdram_ncdl")) {
+	if (!_nvram_get("sdram_ncdl")) {
 		sprintf(buf, "0x%08X", header->config_ncdl);
-		BCMINIT(_nvram_set)("sdram_ncdl", buf);
+		_nvram_set("sdram_ncdl", buf);
 	}
 
 	return 0;
@@ -118,7 +122,7 @@
 
 /* Get the value of an NVRAM variable. Should be locked. */
 char * 
-BCMINITFN(_nvram_get)(const char *name)
+_nvram_get(const char *name)
 {
 	uint i;
 	struct nvram_tuple *t;
@@ -128,17 +132,17 @@
 		return NULL;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (t = BCMINIT(nvram_hash)[i]; t && strcmp(t->name, name); t = t->next);
+	for (t = nvram_hash[i]; t && strcmp(t->name, name); t = t->next);
 
 	value = t ? t->value : NULL;
 
 	return value;
 }
 
-/* Get the value of an NVRAM variable. Should be locked. */
+/* Set the value of an NVRAM variable. Should be locked. */
 int 
 BCMINITFN(_nvram_set)(const char *name, const char *value)
 {
@@ -146,13 +150,14 @@
 	struct nvram_tuple *t, *u, **prev;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (prev = &BCMINIT(nvram_hash)[i], t = *prev; t && strcmp(t->name, name); prev = &t->next, t = *prev);
+	for (prev = &nvram_hash[i], t = *prev; t && strcmp(t->name, name);
+	     prev = &t->next, t = *prev);
 
 	/* (Re)allocate tuple */
-	if (!(u = BCMINIT(_nvram_realloc)(t, name, value)))
+	if (!(u = _nvram_realloc(t, name, value)))
 		return -12; /* -ENOMEM */
 
 	/* Value reallocated */
@@ -167,8 +172,8 @@
 	}
 
 	/* Add new tuple to the hash table */
-	u->next = BCMINIT(nvram_hash)[i];
-	BCMINIT(nvram_hash)[i] = u;
+	u->next = nvram_hash[i];
+	nvram_hash[i] = u;
 
 	return 0;
 }
@@ -184,10 +189,11 @@
 		return 0;
 
 	/* Hash the name */
-	i = hash(name) % ARRAYSIZE(BCMINIT(nvram_hash));
+	i = hash(name) % ARRAYSIZE(nvram_hash);
 
 	/* Find the associated tuple in the hash table */
-	for (prev = &BCMINIT(nvram_hash)[i], t = *prev; t && strcmp(t->name, name); prev = &t->next, t = *prev);
+	for (prev = &nvram_hash[i], t = *prev; t && strcmp(t->name, name);
+	     prev = &t->next, t = *prev);
 
 	/* Move it to the dead table */
 	if (t) {
@@ -201,7 +207,7 @@
 
 /* Get all NVRAM variables. Should be locked. */
 int 
-BCMINITFN(_nvram_getall)(char *buf, int count)
+_nvram_getall(char *buf, int count)
 {
 	uint i;
 	struct nvram_tuple *t;
@@ -210,8 +216,8 @@
 	bzero(buf, count);
 
 	/* Write name=value\0 ... \0\0 */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = t->next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = t->next) {
 			if ((count - len) > (strlen(t->name) + 1 + strlen(t->value) + 1))
 				len += sprintf(buf + len, "%s=%s", t->name, t->value) + 1;
 			else
@@ -230,16 +236,14 @@
 	char *ptr, *end;
 	int i;
 	struct nvram_tuple *t;
-	struct nvram_header tmp;
-	uint8 crc;
 
 	/* Regenerate header */
 	header->magic = NVRAM_MAGIC;
 	header->crc_ver_init = (NVRAM_VERSION << 8);
-	if (!(init = BCMINIT(_nvram_get)("sdram_init")) ||
-	    !(config = BCMINIT(_nvram_get)("sdram_config")) ||
-	    !(refresh = BCMINIT(_nvram_get)("sdram_refresh")) ||
-	    !(ncdl = BCMINIT(_nvram_get)("sdram_ncdl"))) {
+	if (!(init = _nvram_get("sdram_init")) ||
+	    !(config = _nvram_get("sdram_config")) ||
+	    !(refresh = _nvram_get("sdram_refresh")) ||
+	    !(ncdl = _nvram_get("sdram_ncdl"))) {
 		header->crc_ver_init |= SDRAM_INIT << 16;
 		header->config_refresh = SDRAM_CONFIG;
 		header->config_refresh |= SDRAM_REFRESH << 16;
@@ -259,8 +263,8 @@
 	end = (char *) header + NVRAM_SPACE - 2;
 
 	/* Write out all tuples */
-	for (i = 0; i < ARRAYSIZE(BCMINIT(nvram_hash)); i++) {
-		for (t = BCMINIT(nvram_hash)[i]; t; t = t->next) {
+	for (i = 0; i < ARRAYSIZE(nvram_hash); i++) {
+		for (t = nvram_hash[i]; t; t = t->next) {
 			if ((ptr + strlen(t->name) + 1 + strlen(t->value) + 1) > end)
 				break;
 			ptr += sprintf(ptr, "%s=%s", t->name, t->value) + 1;
@@ -273,43 +277,31 @@
 	/* Set new length */
 	header->len = ROUNDUP(ptr - (char *) header, 4);
 
-	/* Little-endian CRC8 over the last 11 bytes of the header */
-	tmp.crc_ver_init = htol32(header->crc_ver_init);
-	tmp.config_refresh = htol32(header->config_refresh);
-	tmp.config_ncdl = htol32(header->config_ncdl);
-	crc = hndcrc8((char *) &tmp + 9, sizeof(struct nvram_header) - 9, CRC8_INIT_VALUE);
-
-	/* Continue CRC8 over data bytes */
-	crc = hndcrc8((char *) &header[1], header->len - sizeof(struct nvram_header), crc);
-
 	/* Set new CRC8 */
-	header->crc_ver_init |= crc;
+	header->crc_ver_init |= nvram_calc_crc(header);
 
 	/* Reinitialize hash table */
-	return BCMINIT(nvram_rehash)(header);
+	return nvram_rehash(header);
 }
 
 /* Initialize hash table. Should be locked. */
 int 
-BCMINITFN(_nvram_init)(void)
+BCMINITFN(_nvram_init)(void *sb)
 {
 	struct nvram_header *header;
 	int ret;
-	void *osh;
 
-	/* get kernel osl handler */
-	osh = osl_attach(NULL);
 
-	if (!(header = (struct nvram_header *) MALLOC(osh, NVRAM_SPACE))) {
-		printf("nvram_init: out of memory, malloced %d bytes\n", MALLOCED(osh));
+	if (!(header = (struct nvram_header *) MALLOC(sb_osh(sb), NVRAM_SPACE))) {
+		printf("nvram_init: out of memory\n");
 		return -12; /* -ENOMEM */
 	}
 
-	if ((ret = BCMINIT(_nvram_read)(header)) == 0 &&
+	if ((ret = _nvram_read(header)) == 0 &&
 	    header->magic == NVRAM_MAGIC)
-		BCMINIT(nvram_rehash)(header);
+		nvram_rehash(header);
 
-	MFREE(osh, header, NVRAM_SPACE);
+	MFREE(sb_osh(sb), header, NVRAM_SPACE);
 	return ret;
 }
 
@@ -317,5 +309,27 @@
 void 
 BCMINITFN(_nvram_exit)(void)
 {
-	BCMINIT(nvram_free)();
+	nvram_free();
+}
+
+/* returns the CRC8 of the nvram */
+uint8
+BCMINITFN(nvram_calc_crc)(struct nvram_header * nvh)
+{
+	struct nvram_header tmp;
+	uint8 crc;
+
+	/* Little-endian CRC8 over the last 11 bytes of the header */
+	tmp.crc_ver_init = htol32((nvh->crc_ver_init & NVRAM_CRC_VER_MASK));
+	tmp.config_refresh = htol32(nvh->config_refresh);
+	tmp.config_ncdl = htol32(nvh->config_ncdl);
+
+	crc = hndcrc8((uint8 *) &tmp + NVRAM_CRC_START_POSITION,
+		sizeof(struct nvram_header) - NVRAM_CRC_START_POSITION,
+		CRC8_INIT_VALUE);
+
+	/* Continue CRC8 over data bytes */
+	crc = hndcrc8((uint8 *) &nvh[1], nvh->len - sizeof(struct nvram_header), crc);
+
+	return crc;
 }
--- src/shared.1927/nvram/nvram_ro.c	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/nvram_ro.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,229 +0,0 @@
-/*
- * Read-only support for NVRAM on flash and otp.
- *
- * Copyright 2004, Broadcom Corporation
- * All Rights Reserved.                
- *                                     
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;   
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior      
- * written permission of Broadcom Corporation.                            
- *
- * $Id$
- */
-
-#include <typedefs.h>
-#include <osl.h>
-#include <bcmnvram.h>
-#include <bcmendian.h>
-#include <bcmutils.h>
-#include <sflash.h>
-#include <sbconfig.h>
-#include <sbchipc.h>
-#include <sbutils.h>
-
-
-static char *fnv = NULL;
-static char *fnvlim = NULL;
-static char *otp = NULL;
-static char *otplim = NULL;
-static char *otp2 = NULL;
-static char *otp2lim = NULL;
-
-
-static struct nvram_header *
-find_flash_nvram(uint32 base, uint32 lim)
-{
-	struct nvram_header *nvh;
-	uint32 off = FLASH_MIN;
-
-	nvh = NULL;
-	while (off <= lim) {
-		nvh = (struct nvram_header *) (base + off - NVRAM_SPACE);
-		if (nvh->magic == NVRAM_MAGIC)
-			return nvh;
-		off <<= 1;
-	};
-
-	/* Try embedded NVRAM at 4 KB and 1 KB as last resorts */
-	nvh = (struct nvram_header *) (base + 4096);
-	if (nvh->magic == NVRAM_MAGIC)
-		return nvh;
-
-	nvh = (struct nvram_header *) (base + 1024);
-	if (nvh->magic == NVRAM_MAGIC)
-		return nvh;
-
-	return NULL;
-}
-
-int
-BCMINITFN(nvram_init)(void *sbh)
-{
-	uint idx;
-	chipcregs_t *cc;
-	struct sflash *info;
-	struct nvram_header *nvh = NULL;
-	uint32 cap = 0, base, lim;
-
-
-	/* Make sure */
-	fnv = NULL;
-	otp = NULL;
-	otp2 = NULL;
-
-	/* Check for flash */
-	idx = sb_coreidx(sbh);
-	if ((cc = sb_setcore(sbh, SB_CC, 0)) != NULL) {
-		base = KSEG1ADDR(SB_FLASH2);
-		lim = 0;
-		cap = R_REG(&cc->capabilities);
-		switch (cap & CAP_FLASH_MASK) {
-		case PFLASH:
-			lim = SB_FLASH2_SZ;
-			break;
-
-		case SFLASH_ST:
-		case SFLASH_AT:
-			if ((info = sflash_init(cc)) == NULL)
-				break;
-			lim = info->size;
-			break;
-
-		case FLASH_NONE:
-		default:
-			break;
-		}
-	} else {
-		base = KSEG1ADDR(SB_FLASH1);
-		lim = SB_FLASH1_SZ;
-	}
-
-	if (lim != 0)
-		nvh = find_flash_nvram(base, lim);
-
-	if (nvh != NULL) {
-		fnv = (char *)&nvh[1];
-		fnvlim = (char *)((uint32)nvh + NVRAM_SPACE);
-	}
-
-	/* Check for otp */
-	if ((cc != NULL) && ((lim = cap & CAP_OTPSIZE) != 0)) {
-		uint32 bound;
-		uint16 *otpw, *d16;
-		int i;
-
-		otpw = (uint16 *)((uint32)cc + CC_OTP);
-		lim = 1 << ((lim >> CAP_OTPSIZE_SHIFT) + 5);
-		if ((otpw[OTP_HWSIGN] == OTP_SIGNATURE) &&
-		    (otpw[0] == OTP_MAGIC)) {
-			bound = otpw[OTP_BOUNDARY];
-			if (bound >= lim) {
-				printf("Bad boundary value in otp (%d >= %d)\n", bound, lim);
-				goto out;
-			}
-			/* OK, we like otp, copy to ram, skipping the magic word */
-			if ((otp = MALLOC(NULL,bound - 2)) == NULL) {
-				printf("Out of memory for otp\n");
-				goto out;
-			}
-			d16 = (uint16 *)otp;
-			for (i = 1; i < (bound / 2); i++)
-				*d16++ = otpw[i];
-			otplim = otp + bound - 2;
-			printf ("otp size = %d, hwsign = 0x%x, magic = 0x%x,  boundary = 0x%x\n",
-				lim, otpw[OTP_HWSIGN], otpw[0], bound);
-
-			/* Now do it again for the "second" part of the otp */
-			if (otpw[OTP_SWSIGN] == OTP_SIGNATURE) {
-				if ((otp2 = MALLOC(NULL, lim - bound)) == NULL) {
-					printf("Out of memory for otp2\n");
-					goto out;
-				}
-				d16 = (uint16 *)otp2;
-				while (i < (lim / 2))
-					*d16++ = otpw[i++];
-				otp2lim = otp2 + lim - bound;
-			}
-		}
-	}
-
-out:	/* All done */
-	sb_setcoreidx(sbh, idx);
-
-	return 0;
-}
-
-void
-BCMINITFN(nvram_exit)(void)
-{
-	if (otp) {
-		MFREE(NULL, otp, otplim - otp);
-		otp = NULL;
-	}
-
-	if (otp2) {
-		MFREE(NULL, otp2, otp2lim - otp2);
-		otp2 = NULL;
-	}
-}
-
-static char *
-findvar(char *vars, char *lim, const char *name)
-{
-	char *s;
-	int len;
-
-	len = strlen(name);
-
-	for (s = vars; (s < lim) && *s; ) {
-		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len+1]);
-
-		while (*s++)
-			;
-	}
-
-	return NULL;
-}
-
-char *
-BCMINITFN(nvram_get)(const char *name)
-{
-	char *v = NULL;
-
-	if ((fnv != NULL) && ((v = findvar(fnv, fnvlim, name)) != NULL))
-		return v;
-
-	if ((otp2 != NULL) && ((v = findvar(otp2, otp2lim, name)) != NULL))
-		return v;
-
-	if (otp != NULL)
-		v = findvar(otp, otplim, name);
-
-	return v;
-}
-
-int
-BCMINITFN(nvram_set)(const char *name, const char *value)
-{
-	return 0;
-}
-
-int
-BCMINITFN(nvram_unset)(const char *name)
-{
-	return 0;
-}
-
-int
-BCMINITFN(nvram_commit)(void)
-{
-	return 0;
-}
-
-int
-BCMINITFN(nvram_getall)(char *buf, int count)
-{
-	return 0;
-}
--- src/shared.1927/nvram/nvram_rw.c	1970-01-01 03:00:00.000000000 +0300
+++ src/shared/nvram/nvram_rw.c	2007-11-19 06:40:26.000000000 +0300
@@ -0,0 +1,342 @@
+/*
+ * NVRAM variable manipulation (direct mapped flash)
+ *
+ * Copyright 2007, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
+#include <mipsinc.h>
+#include <bcmnvram.h>
+#include <bcmendian.h>
+#include <flashutl.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+
+struct nvram_tuple * _nvram_realloc(struct nvram_tuple *t, const char *name, const char *value);
+void  _nvram_free(struct nvram_tuple *t);
+int  _nvram_read(void *buf);
+
+extern char *_nvram_get(const char *name);
+extern int _nvram_set(const char *name, const char *value);
+extern int _nvram_unset(const char *name);
+extern int _nvram_getall(char *buf, int count);
+extern int _nvram_commit(struct nvram_header *header);
+extern int _nvram_init(void *sb);
+extern void _nvram_exit(void);
+
+static struct nvram_header *nvram_header = NULL;
+static bool nvram_do_reset = FALSE;
+
+#define NVRAM_LOCK()	do {} while (0)
+#define NVRAM_UNLOCK()	do {} while (0)
+
+/* Convenience */
+#define KB * 1024
+#define MB * 1024 * 1024
+
+char *
+nvram_get(const char *name)
+{
+	char *value;
+
+	NVRAM_LOCK();
+	value = _nvram_get(name);
+	NVRAM_UNLOCK();
+
+	return value;
+}
+
+int
+nvram_getall(char *buf, int count)
+{
+	int ret;
+
+	NVRAM_LOCK();
+	ret = _nvram_getall(buf, count);
+	NVRAM_UNLOCK();
+
+	return ret;
+}
+
+int
+BCMINITFN(nvram_set)(const char *name, const char *value)
+{
+	int ret;
+
+	NVRAM_LOCK();
+	ret = _nvram_set(name, value);
+	NVRAM_UNLOCK();
+
+	return ret;
+}
+
+int
+BCMINITFN(nvram_unset)(const char *name)
+{
+	int ret;
+
+	NVRAM_LOCK();
+	ret = _nvram_unset(name);
+	NVRAM_UNLOCK();
+
+	return ret;
+}
+
+int
+BCMINITFN(nvram_resetgpio_init)(void *sb)
+{
+	char *value;
+	int gpio;
+	sb_t *sbh;
+
+	sbh = (sb_t *)sb;
+
+	value = nvram_get("reset_gpio");
+	if (!value)
+		return -1;
+
+	gpio = (int) bcm_atoi(value);
+	if (gpio > 7)
+		return -1;
+
+	/* Setup GPIO input */
+	sb_gpioouten(sbh, ((uint32) 1 << gpio), 0, GPIO_DRV_PRIORITY);
+
+	return gpio;
+}
+
+bool
+BCMINITFN(nvram_reset)(void  *sb)
+{
+	int gpio;
+	uint msec;
+	sb_t * sbh = (sb_t *)sb;
+
+	if ((gpio = nvram_resetgpio_init((void *)sbh)) < 0)
+		return FALSE;
+
+	/* GPIO reset is asserted low */
+	for (msec = 0; msec < 5000; msec++) {
+		if (sb_gpioin(sbh) & ((uint32) 1 << gpio))
+			return FALSE;
+		OSL_DELAY(1000);
+	}
+
+	nvram_do_reset = TRUE;
+	return TRUE;
+}
+
+extern unsigned char embedded_nvram[];
+
+static struct nvram_header *
+BCMINITFN(find_nvram)(bool embonly, bool *isemb)
+{
+	struct nvram_header *nvh;
+	uint32 off, lim;
+
+
+	if (!embonly) {
+		*isemb = FALSE;
+		lim = SB_FLASH2_SZ;
+		off = FLASH_MIN;
+		while (off <= lim) {
+			nvh = (struct nvram_header *)KSEG1ADDR(SB_FLASH2 + off - NVRAM_SPACE);
+			if (nvh->magic == NVRAM_MAGIC)
+				/* if (nvram_calc_crc(nvh) == (uint8) nvh->crc_ver_init) */{
+					return (nvh);
+				}
+			off <<= 1;
+		};
+	}
+
+	/* Now check embedded nvram */
+	*isemb = TRUE;
+	nvh = (struct nvram_header *)KSEG1ADDR(SB_FLASH2 + (4 * 1024));
+	if (nvh->magic == NVRAM_MAGIC)
+		return (nvh);
+	nvh = (struct nvram_header *)KSEG1ADDR(SB_FLASH2 + 1024);
+	if (nvh->magic == NVRAM_MAGIC)
+		return (nvh);
+#ifdef _CFE_
+	nvh = (struct nvram_header *)embedded_nvram;
+	if (nvh->magic == NVRAM_MAGIC)
+		return (nvh);
+#endif
+	printf("find_nvram: no nvram found\n");
+	return (NULL);
+}
+
+int
+BCMINITFN(nvram_init)(void *sb)
+{
+	bool isemb;
+	int ret;
+	sb_t *sbh;
+	static int nvram_status = -1;
+
+	/* Check for previous 'restore defaults' condition */
+	if (nvram_status == 1)
+		return 1;
+
+	/* Check whether nvram already initilized */
+	if (nvram_status == 0 && !nvram_do_reset)
+		return 0;
+
+	sbh = (sb_t *)sb;
+
+	/* Restore defaults from embedded NVRAM if button held down */
+	if (nvram_do_reset) {
+		/* Initialize with embedded NVRAM */
+		nvram_header = find_nvram(TRUE, &isemb);
+		ret = _nvram_init(sb);
+		if (ret == 0) {
+			nvram_status = 1;
+			return 1;
+		}
+		nvram_status = -1;
+		_nvram_exit();
+	}
+
+	/* Find NVRAM */
+	nvram_header = find_nvram(FALSE, &isemb);
+	ret = _nvram_init(sb);
+	if (ret == 0) {
+		/* Restore defaults if embedded NVRAM used */
+		if (nvram_header && isemb) {
+			ret = 1;
+		}
+	}
+	nvram_status = ret;
+	return ret;
+}
+
+int
+BCMINITFN(nvram_append)(void *sb, char *vars, uint varsz)
+{
+	return 0;
+}
+
+void
+BCMINITFN(nvram_exit)(void *sb)
+{
+	sb_t *sbh;
+
+	sbh = (sb_t *)sb;
+
+	_nvram_exit();
+}
+
+int
+BCMINITFN(_nvram_read)(void *buf)
+{
+	uint32 *src, *dst;
+	uint i;
+
+	if (!nvram_header)
+		return -19; /* -ENODEV */
+
+	src = (uint32 *) nvram_header;
+	dst = (uint32 *) buf;
+
+	for (i = 0; i < sizeof(struct nvram_header); i += 4)
+		*dst++ = *src++;
+
+	for (; i < nvram_header->len && i < NVRAM_SPACE; i += 4)
+		*dst++ = ltoh32(*src++);
+
+	return 0;
+}
+
+struct nvram_tuple *
+BCMINITFN(_nvram_realloc)(struct nvram_tuple *t, const char *name, const char *value)
+{
+	if (!(t = MALLOC(NULL, sizeof(struct nvram_tuple) + strlen(name) + 1 +
+	                 strlen(value) + 1))) {
+		printf("_nvram_realloc: our of memory\n");
+		return NULL;
+	}
+
+	/* Copy name */
+	t->name = (char *) &t[1];
+	strcpy(t->name, name);
+
+	/* Copy value */
+	t->value = t->name + strlen(name) + 1;
+	strcpy(t->value, value);
+
+	return t;
+}
+
+void
+BCMINITFN(_nvram_free)(struct nvram_tuple *t)
+{
+	if (t)
+		MFREE(NULL, t, sizeof(struct nvram_tuple) + strlen(t->name) + 1 +
+		      strlen(t->value) + 1);
+}
+
+int
+BCMINITFN(nvram_commit)(void)
+{
+	struct nvram_header *header;
+	int ret;
+	uint32 *src, *dst;
+	uint i;
+
+	if (!(header = (struct nvram_header *) MALLOC(NULL, NVRAM_SPACE))) {
+		printf("nvram_commit: out of memory\n");
+		return -12; /* -ENOMEM */
+	}
+
+	NVRAM_LOCK();
+
+	/* Regenerate NVRAM */
+	ret = _nvram_commit(header);
+	if (ret)
+		goto done;
+
+	src = (uint32 *) &header[1];
+	dst = src;
+
+	for (i = sizeof(struct nvram_header); i < header->len && i < NVRAM_SPACE; i += 4)
+		*dst++ = htol32(*src++);
+
+#ifdef _CFE_
+	if ((ret = cfe_open("flash0.nvram")) >= 0) {
+		cfe_writeblk(ret, 0, (unsigned char *) header, header->len);
+		cfe_close(ret);
+	}
+#else
+	if (sysFlashInit(NULL) == 0) {
+		/* set/write invalid MAGIC # (in case writing image fails/is interrupted)
+			 write the NVRAM image to flash(with invalid magic)
+			 set/write valid MAGIC #
+		*/
+		header->magic = NVRAM_CLEAR_MAGIC;
+		nvWriteChars((unsigned char *)&header->magic, sizeof(header->magic));
+
+		header->magic = NVRAM_INVALID_MAGIC;
+		nvWrite((unsigned short *) header, NVRAM_SPACE);
+
+		header->magic = NVRAM_MAGIC;
+		nvWriteChars((unsigned char *)&header->magic, sizeof(header->magic));
+	}
+#endif /* ifdef _CFE_ */
+
+done:
+	NVRAM_UNLOCK();
+	MFREE(NULL, header, NVRAM_SPACE);
+	return ret;
+}
--- src/shared.1927/nvram/nvram_vx.c	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/nvram_vx.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,308 +0,0 @@
-/*
- * NVRAM variable manipulation (direct mapped flash)
- *
- * Copyright 2004, Broadcom Corporation
- * All Rights Reserved.
- * 
- * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * $Id$
- */
-
-#include <typedefs.h>
-#include <osl.h>
-#include <mipsinc.h>
-#include <bcmnvram.h>
-#include <bcmendian.h>
-#include <bcmutils.h>
-#include <flashutl.h>
-#include <sbconfig.h>
-#include <sbchipc.h>
-#include <sbutils.h>
-
-struct nvram_tuple * BCMINIT(_nvram_realloc)(struct nvram_tuple *t, const char *name, const char *value);
-void  BCMINIT(_nvram_free)(struct nvram_tuple *t);
-int  BCMINIT(_nvram_read)(void *buf);
-
-extern char * BCMINIT(_nvram_get)(const char *name);
-extern int BCMINIT(_nvram_set)(const char *name, const char *value);
-extern int BCMINIT(_nvram_unset)(const char *name);
-extern int BCMINIT(_nvram_getall)(char *buf, int count);
-extern int BCMINIT(_nvram_commit)(struct nvram_header *header);
-extern int BCMINIT(_nvram_init)(void);
-extern void BCMINIT(_nvram_exit)(void);
-
-static struct nvram_header *nvram_header = NULL;
-static 	ulong flash_base = 0;
-
-#define NVRAM_LOCK()	do {} while (0)
-#define NVRAM_UNLOCK()	do {} while (0)
-
-/* Convenience */
-#define KB * 1024
-#define MB * 1024 * 1024
-
-char *  
-BCMINITFN(nvram_get)(const char *name)
-{
-	char *value;
-
-	NVRAM_LOCK();
-	value = BCMINIT(_nvram_get)(name);
-	NVRAM_UNLOCK();
-
-	return value;
-}
-
-int  
-BCMINITFN(nvram_getall)(char *buf, int count)
-{
-	int ret;
-
-	NVRAM_LOCK();
-	ret = BCMINIT(_nvram_getall)(buf, count);
-	NVRAM_UNLOCK();
-
-	return ret;
-}
-
-int  
-BCMINITFN(nvram_set)(const char *name, const char *value)
-{
-	int ret;
-
-	NVRAM_LOCK();
-	ret = BCMINIT(_nvram_set)(name, value);
-	NVRAM_UNLOCK();
-
-	return ret;
-}
-
-int  				 
-BCMINITFN(nvram_unset)(const char *name)
-{
-	int ret;
-
-	NVRAM_LOCK();
-	ret = BCMINIT(_nvram_unset)(name);
-	NVRAM_UNLOCK();
-
-	return ret;
-}
-
-static bool  
-BCMINITFN(nvram_reset)(void *sbh)
-{
-	chipcregs_t *cc;
-	char *value;
-	uint32 watchdog = 0, gpio;
-	uint idx, msec;
-
-	idx = sb_coreidx(sbh);
-
-	/* Check if we were soft reset */
-	if ((cc = sb_setcore(sbh, SB_CC, 0))) {
-		watchdog = R_REG(&cc->intstatus) & CI_WDRESET;
-		sb_setcoreidx(sbh, idx);
-	}
-	if (watchdog)
-		return FALSE;
-
-	value = BCMINIT(nvram_get)("reset_gpio");
-	if (!value)
-		return FALSE;
-
-	gpio = (uint32) bcm_atoi(value);
-	if (gpio > 7)
-		return FALSE;
-
-	/* Setup GPIO input */
-	sb_gpioouten(sbh, (1 << gpio), 0);
-
-	/* GPIO reset is asserted low */
-	for (msec = 0; msec < 5000; msec++) {
-		if (sb_gpioin(sbh) & (1 << gpio))
-			return FALSE;
-		OSL_DELAY(1000);
-	}
-
-	return TRUE;
-}
-	
-extern unsigned char embedded_nvram[];
-
-static struct nvram_header *  
-BCMINITFN(find_nvram)(bool embonly, bool *isemb)
-{
-	struct nvram_header *nvh;
-	uint32 off, lim;
-
-
-	if (!embonly) {
-		*isemb = FALSE;
-		if (flash_base == SB_FLASH1)
-			lim = SB_FLASH1_SZ;
-		else
-			lim = SB_FLASH2_SZ;
-		off = FLASH_MIN;
-		while (off <= lim) {
-			nvh = (struct nvram_header *)KSEG1ADDR(flash_base + off - NVRAM_SPACE);
-			if (nvh->magic == NVRAM_MAGIC)
-				return (nvh);
-			off <<= 1;
-		};
-	}
-
-	/* Now check embedded nvram */
-	*isemb = TRUE;
-	nvh = (struct nvram_header *)KSEG1ADDR(flash_base + (4 * 1024));
-	if (nvh->magic == NVRAM_MAGIC)
-		return (nvh);
-	nvh = (struct nvram_header *)KSEG1ADDR(flash_base + 1024);
-	if (nvh->magic == NVRAM_MAGIC)
-		return (nvh);
-#ifdef _CFE_
-	nvh = (struct nvram_header *)embedded_nvram;
-	if (nvh->magic == NVRAM_MAGIC)
-		return (nvh);
-#endif
-	return (NULL);
-}
-
-int 
-BCMINITFN(nvram_init)(void *sbh)
-{
-	uint idx;
-	bool isemb;
-	int ret;
-
-
-	idx = sb_coreidx(sbh);
-	if (sb_setcore(sbh, SB_CC, 0) != NULL) {
-		flash_base = SB_FLASH2;
-		sb_setcoreidx(sbh, idx);
-	} else
-		flash_base = SB_FLASH1;
-
-	/* Temporarily initialize with embedded NVRAM */
-	nvram_header = BCMINIT(find_nvram)(TRUE, &isemb);
-	ret = BCMINIT(_nvram_init)();
-	if (ret == 0) {
-		/* Restore defaults from embedded NVRAM if button held down */
-		if (BCMINIT(nvram_reset)(sbh)) {
-			return 1;
-		}
-
-		BCMINIT(_nvram_exit)();
-	}
-
-	/* Find NVRAM */
-	nvram_header = BCMINIT(find_nvram)(FALSE, &isemb);
-	ret = BCMINIT(_nvram_init)();
-	if (ret == 0) {
-		/* Restore defaults if embedded NVRAM used */
-		if (nvram_header && isemb) {
-			ret = 1;
-		}
-	}
-	return ret;
-}
-
-void  
-BCMINITFN(nvram_exit)(void)
-{
-	BCMINIT(_nvram_exit)();
-}
-
-int  
-BCMINITFN(_nvram_read)(void *buf)
-{
-	uint32 *src, *dst;
-	uint i;
-
-	if (!nvram_header)
-		return -19; /* -ENODEV */
-
-	src = (uint32 *) nvram_header;
-	dst = (uint32 *) buf;
-
-	for (i = 0; i < sizeof(struct nvram_header); i += 4)
-		*dst++ = *src++;
-
-	for (; i < nvram_header->len && i < NVRAM_SPACE; i += 4)
-		*dst++ = ltoh32(*src++);
-
-	return 0;
-}
-
-struct nvram_tuple *  
-BCMINITFN(_nvram_realloc)(struct nvram_tuple *t, const char *name, const char *value)
-{
-	if (!(t = MALLOC(NULL, sizeof(struct nvram_tuple) + strlen(name) + 1 + strlen(value) + 1))) {
-		printf("_nvram_realloc: our of memory\n");
-		return NULL;
-	}
-
-	/* Copy name */
-	t->name = (char *) &t[1];
-	strcpy(t->name, name);
-
-	/* Copy value */
-	t->value = t->name + strlen(name) + 1;
-	strcpy(t->value, value);
-
-	return t;
-}
-
-void  
-BCMINITFN(_nvram_free)(struct nvram_tuple *t)
-{
-	if (t)
-		MFREE(NULL, t, sizeof(struct nvram_tuple) + strlen(t->name) + 1 + strlen(t->value) + 1);
-}
-
-int 
-BCMINITFN(nvram_commit)(void)
-{
-	struct nvram_header *header;
-	int ret;
-	uint32 *src, *dst;
-	uint i;
-
-	if (!(header = (struct nvram_header *) MALLOC(NULL, NVRAM_SPACE))) {
-		printf("nvram_commit: out of memory\n");
-		return -12; /* -ENOMEM */
-	}
-
-	NVRAM_LOCK();
-
-	/* Regenerate NVRAM */
-	ret = BCMINIT(_nvram_commit)(header);
-	if (ret)
-		goto done;
-	
-	src = (uint32 *) &header[1];
-	dst = src;
-
-	for (i = sizeof(struct nvram_header); i < header->len && i < NVRAM_SPACE; i += 4)
-		*dst++ = htol32(*src++);
-
-#ifdef _CFE_
-	if ((ret = cfe_open("flash0.nvram")) >= 0) {
-		cfe_writeblk(ret, 0, (unsigned char *) header, header->len);
-		cfe_close(ret);
-	}
-#else
-	if (sysFlashInit(NULL) == 0)
-		nvWrite((unsigned short *) header, NVRAM_SPACE);
-#endif
-
- done:
-	NVRAM_UNLOCK();
-	MFREE(NULL, header, NVRAM_SPACE);
-	return ret;
-}
-
--- src/shared.1927/nvram/README	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/nvram/README	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-# Copyright 2004, Broadcom Corporation
+# Copyright 2007, Broadcom Corporation
 # All Rights Reserved.
 # 
 # THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
--- src/shared.1927/nvramstubs.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/nvramstubs.c	2007-11-19 06:40:26.000000000 +0300
@@ -12,7 +12,10 @@
  * $Id$
  */
 
-#include <osl.h>
+#include <typedefs.h>
+#include <bcmutils.h>
+#undef strcmp
+#define strcmp(s1,s2)	0	/* always match */
 #include <bcmnvram.h>
 
 int
@@ -21,8 +24,14 @@
 	return 0;
 }
 
+int
+nvram_append(void *sb, char *vars, uint varsz)
+{
+	return 0;
+}
+
 void
-nvram_exit(void)
+nvram_exit(void *sbh)
 {
 }
 
@@ -53,5 +62,9 @@
 int
 nvram_getall(char *buf, int count)
 {
+	/* add null string as terminator */
+	if (count < 1)
+		return BCME_BUFTOOSHORT;
+	*buf = '\0';
 	return 0;
 }
--- src/shared.1927/sbmips.c	2004-12-03 22:15:43.000000000 +0300
+++ src/shared/sbmips.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,967 +0,0 @@
-/*
- * BCM47XX Sonics SiliconBackplane MIPS core routines
- *
- * Copyright 2004, Broadcom Corporation
- * All Rights Reserved.
- * 
- * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * $Id$
- */
-
-#include <typedefs.h>
-#include <osl.h>
-#include <sbutils.h>
-#include <bcmdevs.h>
-#include <bcmnvram.h>
-#include <bcmutils.h>
-#include <hndmips.h>
-#include <sbconfig.h>
-#include <sbextif.h>
-#include <sbchipc.h>
-#include <sbmemc.h>
-#include <mipsinc.h>
-
-/* 
- * Returns TRUE if an external UART exists at the given base
- * register.
- */
-static bool	
-BCMINITFN(serial_exists)(uint8 *regs)
-{
-	uint8 save_mcr, status1;
-
-	save_mcr = R_REG(&regs[UART_MCR]);
-	W_REG(&regs[UART_MCR], UART_MCR_LOOP | 0x0a);
-	status1 = R_REG(&regs[UART_MSR]) & 0xf0;
-	W_REG(&regs[UART_MCR], save_mcr);
-
-	return (status1 == 0x90);
-}
-
-/* 
- * Initializes UART access. The callback function will be called once
- * per found UART.
- */
-void 
-BCMINITFN(sb_serial_init)(void *sbh, void (*add)(void *regs, uint irq, uint baud_base, uint reg_shift))
-{
-	void *regs;
-	ulong base;
-	uint irq;
-	int i, n;
-
-	if ((regs = sb_setcore(sbh, SB_EXTIF, 0))) {
-		extifregs_t *eir = (extifregs_t *) regs;
-		sbconfig_t *sb;
-
-		/* Determine external UART register base */
-		sb = (sbconfig_t *)((ulong) eir + SBCONFIGOFF);
-		base = EXTIF_CFGIF_BASE(sb_base(R_REG(&sb->sbadmatch1)));
-
-		/* Determine IRQ */
-		irq = sb_irq(sbh);
-
-		/* Disable GPIO interrupt initially */
-		W_REG(&eir->gpiointpolarity, 0);
-		W_REG(&eir->gpiointmask, 0);
-
-		/* Search for external UARTs */
-		n = 2;
-		for (i = 0; i < 2; i++) {
-			regs = (void *) REG_MAP(base + (i * 8), 8);
-			if (BCMINIT(serial_exists)(regs)) {
-				/* Set GPIO 1 to be the external UART IRQ */
-				W_REG(&eir->gpiointmask, 2);
-				if (add)
-					add(regs, irq, 13500000, 0);
-			}
-		}
-
-		/* Add internal UART if enabled */
-		if (R_REG(&eir->corecontrol) & CC_UE)
-			if (add)
-				add((void *) &eir->uartdata, irq, sb_clock(sbh), 2);
-	} else if ((regs = sb_setcore(sbh, SB_CC, 0))) {
-		chipcregs_t *cc = (chipcregs_t *) regs;
-		uint32 rev, cap, pll, baud_base, div;
-
-		/* Determine core revision and capabilities */
-		rev = sb_corerev(sbh);
-		cap = R_REG(&cc->capabilities);
-		pll = cap & CAP_PLL_MASK;
-
-		/* Determine IRQ */
-		irq = sb_irq(sbh);
-
-		if (pll == PLL_TYPE1) {
-			/* PLL clock */
-			baud_base = sb_clock_rate(pll,
-						  R_REG(&cc->clockcontrol_n),
-						  R_REG(&cc->clockcontrol_m2));
-			div = 1;
-		} else if (rev >= 3) {
-			if (pll == PLL_TYPE6) {
-				/* Fixed ALP clock on 4320 */
-				baud_base = 20000000;
-				/* Set the override bit so we don't divide it */
-				W_REG(&cc->corecontrol, CC_UARTCLKO);
-			} else {
-				/* Internal backplane clock */
-				baud_base = sb_clock(sbh);
-			}
-			div = 2;	/* Minimum divisor */
-			W_REG(&cc->clkdiv, ((R_REG(&cc->clkdiv) & ~CLKD_UART) | div));
-		} else {
-			/* Fixed internal backplane clock */
-			baud_base = 88000000;
-			div = 48;
-		}
-
-		/* Clock source depends on strapping if UartClkOverride is unset */
-		if ((rev > 0) && ((R_REG(&cc->corecontrol) & CC_UARTCLKO) == 0)) {
-			if ((cap & CAP_UCLKSEL) == CAP_UINTCLK) {
-				/* Internal divided backplane clock */
-				baud_base /= div;
-			} else {
-				/* Assume external clock of 1.8432 MHz */
-				baud_base = 1843200;
-			}
-		}
-
-		/* Add internal UARTs */
-		n = cap & CAP_UARTS_MASK;
-		for (i = 0; i < n; i++) {
-			/* Register offset changed after revision 0 */
-			if (rev)
-				regs = (void *)((ulong) &cc->uart0data + (i * 256));
-			else
-				regs = (void *)((ulong) &cc->uart0data + (i * 8));
-
-			if (add)
-				add(regs, irq, baud_base, 0);
-		}
-	}
-}
-
-/*
- * Initialize jtag master and return handle for
- * jtag_rwreg. Returns NULL on failure.
- */
-void *
-sb_jtagm_init(void *sbh, uint clkd, bool exttap)
-{
-	void *regs;
-
-	if ((regs = sb_setcore(sbh, SB_CC, 0)) != NULL) {
-		chipcregs_t *cc = (chipcregs_t *) regs;
-		uint32 tmp;
-
-		/*
-		 * Determine jtagm availability from
-		 * core revision and capabilities.
-		 */
-		tmp = sb_corerev(sbh);
-		/*
-		 * Corerev 10 has jtagm, but the only chip
-		 * with it does not have a mips, and
-		 * the layout of the jtagcmd register is
-		 * different. We'll only accept >= 11.
-		 */
-		if (tmp < 11)
-			return (NULL);
-
-		tmp = R_REG(&cc->capabilities);
-		if ((tmp & CAP_JTAGP) == 0)
-			return (NULL);
-
-		/* Set clock divider if requested */
-		if (clkd != 0) {
-			tmp = R_REG(&cc->clkdiv);
-			tmp = (tmp & ~CLKD_JTAG) |
-				((clkd << CLKD_JTAG_SHIFT) & CLKD_JTAG);
-			W_REG(&cc->clkdiv, tmp);
-		}
-
-		/* Enable jtagm */
-		tmp = JCTRL_EN | (exttap ? JCTRL_EXT_EN : 0);
-		W_REG(&cc->jtagctrl, tmp);
-	}
-
-	return (regs);
-}
-
-void
-sb_jtagm_disable(void *h)
-{
-	chipcregs_t *cc = (chipcregs_t *)h;
-
-	W_REG(&cc->jtagctrl, R_REG(&cc->jtagctrl) & ~JCTRL_EN);
-}
-
-/*
- * Read/write a jtag register. Assumes a target with
- * 8 bit IR and 32 bit DR.
- */
-#define	IRWIDTH		8
-#define	DRWIDTH		32
-uint32
-jtag_rwreg(void *h, uint32 ir, uint32 dr)
-{
-	chipcregs_t *cc = (chipcregs_t *) h;
-	uint32 tmp;
-
-	W_REG(&cc->jtagir, ir);
-	W_REG(&cc->jtagdr, dr);
-	tmp = JCMD_START | JCMD_ACC_IRDR |
-		((IRWIDTH - 1) << JCMD_IRW_SHIFT) |
-		(DRWIDTH - 1);
-	W_REG(&cc->jtagcmd, tmp);
-	while (((tmp = R_REG(&cc->jtagcmd)) & JCMD_BUSY) == JCMD_BUSY) {
-		/* OSL_DELAY(1); */
-	}
-
-	tmp = R_REG(&cc->jtagdr);
-	return (tmp);
-}
-
-/* Returns the SB interrupt flag of the current core. */
-uint32
-sb_flag(void *sbh)
-{
-	void *regs;
-	sbconfig_t *sb;
-
-	regs = sb_coreregs(sbh);
-	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-
-	return (R_REG(&sb->sbtpsflag) & SBTPS_NUM0_MASK);
-}
-
-static const uint32 sbips_int_mask[] = {
-	0,
-	SBIPS_INT1_MASK,
-	SBIPS_INT2_MASK,
-	SBIPS_INT3_MASK,
-	SBIPS_INT4_MASK
-};
-
-static const uint32 sbips_int_shift[] = {
-	0,
-	0,
-	SBIPS_INT2_SHIFT,
-	SBIPS_INT3_SHIFT,
-	SBIPS_INT4_SHIFT
-};
-
-/* 
- * Returns the MIPS IRQ assignment of the current core. If unassigned,
- * 0 is returned.
- */
-uint
-sb_irq(void *sbh)
-{
-	uint idx;
-	void *regs;
-	sbconfig_t *sb;
-	uint32 flag, sbipsflag;
-	uint irq = 0;
-
-	flag = sb_flag(sbh);
-
-	idx = sb_coreidx(sbh);
-
-	if ((regs = sb_setcore(sbh, SB_MIPS, 0)) ||
-	    (regs = sb_setcore(sbh, SB_MIPS33, 0))) {
-		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-
-		/* sbipsflag specifies which core is routed to interrupts 1 to 4 */
-		sbipsflag = R_REG(&sb->sbipsflag);
-		for (irq = 1; irq <= 4; irq++) {
-			if (((sbipsflag & sbips_int_mask[irq]) >> sbips_int_shift[irq]) == flag)
-				break;
-		}
-		if (irq == 5)
-			irq = 0;
-	}
-
-	sb_setcoreidx(sbh, idx);
-
-	return irq;
-}
-
-/* Clears the specified MIPS IRQ. */
-static void 
-BCMINITFN(sb_clearirq)(void *sbh, uint irq)
-{
-	void *regs;
-	sbconfig_t *sb;
-
-	if (!(regs = sb_setcore(sbh, SB_MIPS, 0)) &&
-	    !(regs = sb_setcore(sbh, SB_MIPS33, 0)))
-		ASSERT(regs);
-	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-
-	if (irq == 0)
-		W_REG(&sb->sbintvec, 0);
-	else
-		OR_REG(&sb->sbipsflag, sbips_int_mask[irq]);
-}
-
-/* 
- * Assigns the specified MIPS IRQ to the specified core. Shared MIPS
- * IRQ 0 may be assigned more than once.
- */
-static void 
-BCMINITFN(sb_setirq)(void *sbh, uint irq, uint coreid, uint coreunit)
-{
-	void *regs;
-	sbconfig_t *sb;
-	uint32 flag;
-
-	regs = sb_setcore(sbh, coreid, coreunit);
-	ASSERT(regs);
-	flag = sb_flag(sbh);
-
-	if (!(regs = sb_setcore(sbh, SB_MIPS, 0)) &&
-	    !(regs = sb_setcore(sbh, SB_MIPS33, 0)))
-		ASSERT(regs);
-	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-
-	if (irq == 0)
-		OR_REG(&sb->sbintvec, 1 << flag);
-	else {
-		flag <<= sbips_int_shift[irq];
-		ASSERT(!(flag & ~sbips_int_mask[irq]));
-		flag |= R_REG(&sb->sbipsflag) & ~sbips_int_mask[irq];
-		W_REG(&sb->sbipsflag, flag);
-	}
-}	
-
-/* 
- * Initializes clocks and interrupts. SB and NVRAM access must be
- * initialized prior to calling.
- */
-void 
-BCMINITFN(sb_mips_init)(void *sbh)
-{
-	ulong hz, ns, tmp;
-	extifregs_t *eir;
-	chipcregs_t *cc;
-	char *value;
-	uint irq;
-
-	/* Figure out current SB clock speed */
-	if ((hz = sb_clock(sbh)) == 0)
-		hz = 100000000;
-	ns = 1000000000 / hz;
-
-	/* Setup external interface timing */
-	if ((eir = sb_setcore(sbh, SB_EXTIF, 0))) {
-		/* Initialize extif so we can get to the LEDs and external UART */
-		W_REG(&eir->prog_config, CF_EN);
-
-		/* Set timing for the flash */
-		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
-		tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
-		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
-		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
-
-		/* Set programmable interface timing for external uart */
-		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
-		tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
-		tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
-		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
-		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
-	} else if ((cc = sb_setcore(sbh, SB_CC, 0))) {
-		/* Set timing for the flash */
-		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
-		tmp |= CEIL(10, ns) << FW_W1_SHIFT;	/* W1 = 10nS */
-		tmp |= CEIL(120, ns);			/* W0 = 120nS */
-
-		// Added by Chen-I for 5365
-		if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
-		{
-			W_REG(&cc->flash_waitcount, tmp);
-			W_REG(&cc->pcmcia_memwait, tmp);
-		}
-		else
-		{
-			if (sb_corerev(sbh) < 9)  
-				W_REG(&cc->flash_waitcount, tmp);
-	
-			if ( (sb_corerev(sbh) < 9) || 
-			     ((BCMINIT(sb_chip)(sbh) == BCM5350_DEVICE_ID) && BCMINIT(sb_chiprev)(sbh) == 0) ) {
-				W_REG(&cc->pcmcia_memwait, tmp);
-			}
-		}
-	}
-
-	/* Chip specific initialization */
-	switch (BCMINIT(sb_chip)(sbh)) {
-	case BCM4710_DEVICE_ID:
-		/* Clear interrupt map */
-		for (irq = 0; irq <= 4; irq++)
-			BCMINIT(sb_clearirq)(sbh, irq);
-		BCMINIT(sb_setirq)(sbh, 0, SB_CODEC, 0);
-		BCMINIT(sb_setirq)(sbh, 0, SB_EXTIF, 0);
-		BCMINIT(sb_setirq)(sbh, 2, SB_ENET, 1);
-		BCMINIT(sb_setirq)(sbh, 3, SB_ILINE20, 0);
-		BCMINIT(sb_setirq)(sbh, 4, SB_PCI, 0);
-		ASSERT(eir);
-		value = BCMINIT(nvram_get)("et0phyaddr");
-		if (value && !strcmp(value, "31")) {
-			/* Enable internal UART */
-			W_REG(&eir->corecontrol, CC_UE);
-			/* Give USB its own interrupt */
-			BCMINIT(sb_setirq)(sbh, 1, SB_USB, 0);
-		} else {
-			/* Disable internal UART */
-			W_REG(&eir->corecontrol, 0);
-			/* Give Ethernet its own interrupt */
-			BCMINIT(sb_setirq)(sbh, 1, SB_ENET, 0);
-			BCMINIT(sb_setirq)(sbh, 0, SB_USB, 0);
-		}
-		break;
-	case BCM4310_DEVICE_ID:
-		MTC0(C0_BROADCOM, 0, MFC0(C0_BROADCOM, 0) & ~(1 << 22));
-		break;
-        case BCM5350_DEVICE_ID:
-                /* Clear interrupt map */
-                for (irq = 0; irq <= 4; irq++)
-                        BCMINIT(sb_clearirq)(sbh, irq);
-                BCMINIT(sb_setirq)(sbh, 0, SB_CC, 0);
-                BCMINIT(sb_setirq)(sbh, 1, SB_D11, 0);
-                BCMINIT(sb_setirq)(sbh, 2, SB_ENET, 0);
-	        BCMINIT(sb_setirq)(sbh, 3, SB_IPSEC, 0);
-                BCMINIT(sb_setirq)(sbh, 4, SB_USB, 0);
-		break;
-	}
-}
-
-uint32
-BCMINITFN(sb_mips_clock)(void *sbh)
-{
-	extifregs_t *eir;
-	chipcregs_t *cc;
-	uint32 n, m;
-	uint idx;
-	uint32 pll_type, rate = 0;
-
-	/* get index of the current core */
-	idx = sb_coreidx(sbh);
-	pll_type = PLL_TYPE1;
-
-	/* switch to extif or chipc core */
-	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
-		n = R_REG(&eir->clockcontrol_n);
-		m = R_REG(&eir->clockcontrol_sb);
-	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
-		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
-		n = R_REG(&cc->clockcontrol_n);
-		if ((pll_type == PLL_TYPE2) ||
-		    (pll_type == PLL_TYPE4) ||
-		    (pll_type == PLL_TYPE6))
-			m = R_REG(&cc->clockcontrol_mips);
-		else if (pll_type == PLL_TYPE5) {
-			rate = 200000000;
-			goto out;
-		}
-		else if (pll_type == PLL_TYPE3) {
-			if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID) { /* 5365 is also type3 */
-				rate = 200000000;
-				goto out;
-			} else
-				m = R_REG(&cc->clockcontrol_m2); /* 5350 uses m2 to control mips */
-		} else
-			m = R_REG(&cc->clockcontrol_sb);
-	} else
-		goto out;
-
-	// Added by Chen-I for 5365 
-	if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
-		rate = 100000000;
-	else
-		/* calculate rate */
-		rate = sb_clock_rate(pll_type, n, m);
-
-	if (pll_type == PLL_TYPE6)
-		rate = SB2MIPS_T6(rate);
-
-out:
-	/* switch back to previous core */
-	sb_setcoreidx(sbh, idx);
-
-	return rate;
-}
-
-#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4)
-
-static void 
-BCMINITFN(handler)(void)
-{
-	/* Step 11 */
-	__asm__ (
-		".set\tmips32\n\t"
-		"ssnop\n\t"
-		"ssnop\n\t"
-	/* Disable interrupts */
-	/*	MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~(ALLINTS | STO_IE)); */
-		"mfc0 $15, $12\n\t"
-	/* Just a Hack to not to use reg 'at' which was causing problems on 4704 A2 */
-		"li $14, -31746\n\t"
-		"and $15, $15, $14\n\t"
-		"mtc0 $15, $12\n\t"
-		"eret\n\t"
-		"nop\n\t"
-		"nop\n\t"
-		".set\tmips0"
-	);
-}
-
-/* The following MUST come right after handler() */
-static void 
-BCMINITFN(afterhandler)(void)
-{
-}
-
-/*
- * Set the MIPS, backplane and PCI clocks as closely as possible.
- */
-bool 
-BCMINITFN(sb_mips_setclock)(void *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock)
-{
-	extifregs_t *eir = NULL;
-	chipcregs_t *cc = NULL;
-	mipsregs_t *mipsr = NULL;
-	volatile uint32 *clockcontrol_n, *clockcontrol_sb, *clockcontrol_pci, *clockcontrol_m2;
-	uint32 orig_n, orig_sb, orig_pci, orig_m2, orig_mips, orig_ratio_parm, new_ratio;
-	uint32 pll_type, sync_mode;
-	uint ic_size, ic_lsize;
-	uint idx, i;
-	typedef struct {
-		uint32 mipsclock;
-		uint16 n;
-		uint32 sb;
-		uint32 pci33;
-		uint32 pci25;
-	} n3m_table_t;
-	static n3m_table_t BCMINITDATA(type1_table)[] = {
-		{  96000000, 0x0303, 0x04020011, 0x11030011, 0x11050011 }, /*  96.000 32.000 24.000 */
-		{ 100000000, 0x0009, 0x04020011, 0x11030011, 0x11050011 }, /* 100.000 33.333 25.000 */
-		{ 104000000, 0x0802, 0x04020011, 0x11050009, 0x11090009 }, /* 104.000 31.200 24.960 */
-		{ 108000000, 0x0403, 0x04020011, 0x11050009, 0x02000802 }, /* 108.000 32.400 24.923 */
-		{ 112000000, 0x0205, 0x04020011, 0x11030021, 0x02000403 }, /* 112.000 32.000 24.889 */
-		{ 115200000, 0x0303, 0x04020009, 0x11030011, 0x11050011 }, /* 115.200 32.000 24.000 */
-		{ 120000000, 0x0011, 0x04020011, 0x11050011, 0x11090011 }, /* 120.000 30.000 24.000 */
-		{ 124800000, 0x0802, 0x04020009, 0x11050009, 0x11090009 }, /* 124.800 31.200 24.960 */
-		{ 128000000, 0x0305, 0x04020011, 0x11050011, 0x02000305 }, /* 128.000 32.000 24.000 */
-		{ 132000000, 0x0603, 0x04020011, 0x11050011, 0x02000305 }, /* 132.000 33.000 24.750 */
-		{ 136000000, 0x0c02, 0x04020011, 0x11090009, 0x02000603 }, /* 136.000 32.640 24.727 */
-		{ 140000000, 0x0021, 0x04020011, 0x11050021, 0x02000c02 }, /* 140.000 30.000 24.706 */
-		{ 144000000, 0x0405, 0x04020011, 0x01020202, 0x11090021 }, /* 144.000 30.857 24.686 */
-		{ 150857142, 0x0605, 0x04020021, 0x02000305, 0x02000605 }, /* 150.857 33.000 24.000 */
-		{ 152000000, 0x0e02, 0x04020011, 0x11050021, 0x02000e02 }, /* 152.000 32.571 24.000 */
-		{ 156000000, 0x0802, 0x04020005, 0x11050009, 0x11090009 }, /* 156.000 31.200 24.960 */
-		{ 160000000, 0x0309, 0x04020011, 0x11090011, 0x02000309 }, /* 160.000 32.000 24.000 */
-		{ 163200000, 0x0c02, 0x04020009, 0x11090009, 0x02000603 }, /* 163.200 32.640 24.727 */
-		{ 168000000, 0x0205, 0x04020005, 0x11030021, 0x02000403 }, /* 168.000 32.000 24.889 */
-		{ 176000000, 0x0602, 0x04020003, 0x11050005, 0x02000602 }, /* 176.000 33.000 24.000 */
-	};
-	typedef struct {
-		uint32 mipsclock;
-		uint16 n;
-		uint32 m2; /* that is the clockcontrol_m2 */
-	} type3_table_t;
-	static type3_table_t type3_table[] = { /* for 5350, mips clock is always double sb clock */
-		{ 150000000, 0x311, 0x4020005 }, 
-//		{ 180000000, 0x, 0x },  /* later we may want this frequency */
-		{ 200000000, 0x311, 0x4020003 }, 
-	};
-	typedef struct {
-		uint32 mipsclock;
-		uint32 sbclock;
-		uint16 n;
-		uint32 sb;
-		uint32 pci33;
-		uint32 m2;
-		uint32 m3;
-		uint32 ratio;
-		uint32 ratio_parm;
-	} n4m_table_t;
-
-	static n4m_table_t BCMINITDATA(type2_table)[] = {
-		{ 180000000,  80000000, 0x0403, 0x01010000, 0x01020300, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 180000000,  90000000, 0x0403, 0x01000100, 0x01020300, 0x01000100, 0x05000100, 0x21, 0x0aaa0555 },
-		{ 200000000, 100000000, 0x0303, 0x01000000, 0x01000600, 0x01000000, 0x05000000, 0x21, 0x0aaa0555 },
-		{ 211200000, 105600000, 0x0902, 0x01000200, 0x01030400, 0x01000200, 0x05000200, 0x21, 0x0aaa0555 },
-		{ 220800000, 110400000, 0x1500, 0x01000200, 0x01030400, 0x01000200, 0x05000200, 0x21, 0x0aaa0555 },
-		{ 230400000, 115200000, 0x0604, 0x01000200, 0x01020600, 0x01000200, 0x05000200, 0x21, 0x0aaa0555 },
-		{ 234000000, 104000000, 0x0b01, 0x01010000, 0x01010700, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 240000000, 120000000,	0x0803,	0x01000200, 0x01020600,	0x01000200, 0x05000200, 0x21, 0x0aaa0555 },
-		{ 252000000, 126000000,	0x0504,	0x01000100, 0x01020500,	0x01000100, 0x05000100, 0x21, 0x0aaa0555 },
-		{ 264000000, 132000000, 0x0903, 0x01000200, 0x01020700, 0x01000200, 0x05000200, 0x21, 0x0aaa0555 },
-		{ 270000000, 120000000, 0x0703, 0x01010000, 0x01030400, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 276000000, 122666666, 0x1500, 0x01010000, 0x01030400, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 280000000, 140000000, 0x0503, 0x01000000, 0x01010600, 0x01000000, 0x05000000, 0x21, 0x0aaa0555 },
-		{ 288000000, 128000000, 0x0604, 0x01010000, 0x01030400, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 288000000, 144000000, 0x0404, 0x01000000, 0x01010600, 0x01000000, 0x05000000, 0x21, 0x0aaa0555 },
-		{ 300000000, 133333333, 0x0803, 0x01010000, 0x01020600, 0x01020600, 0x05000100, 0x94, 0x012a00a9 },
-		{ 300000000, 150000000, 0x0803, 0x01000100, 0x01020600, 0x01000100, 0x05000100, 0x21, 0x0aaa0555 }
-	};
-
-	static n4m_table_t BCMINITDATA(type4_table)[] = {
-		{ 192000000,  96000000, 0x0702,	0x04020011, 0x11030011, 0x04020011, 0x04020003, 0x21, 0x0aaa0555 },
-		{ 200000000, 100000000, 0x0009,	0x04020011, 0x11030011, 0x04020011, 0x04020003, 0x21, 0x0aaa0555 },
-		{ 216000000, 108000000, 0x0111, 0x11020005, 0x01030303, 0x11020005, 0x04000005, 0x21, 0x0aaa0555 },
-		{ 228000000, 101333333, 0x0e02, 0x11030003, 0x11210005, 0x11030305, 0x04000005, 0x94, 0x012a00a9 },
-		{ 228000000, 114000000, 0x0e02, 0x11020005, 0x11210005, 0x11020005, 0x04000005, 0x21, 0x0aaa0555 },
-		{ 240000000, 120000000,	0x0109,	0x11030002, 0x01050203,	0x11030002, 0x04000003, 0x21, 0x0aaa0555 },
-		{ 252000000, 126000000,	0x0203,	0x04000005, 0x11050005,	0x04000005, 0x04000002, 0x21, 0x0aaa0555 },
-		{ 264000000, 132000000, 0x0602, 0x04000005, 0x11050005, 0x04000005, 0x04000002, 0x21, 0x0aaa0555 },
-		{ 272000000, 116571428, 0x0c02, 0x04000021, 0x02000909, 0x02000221, 0x04000003, 0x73, 0x254a14a9 },
-		{ 280000000, 120000000, 0x0209, 0x04000021, 0x01030303, 0x02000221, 0x04000003, 0x73, 0x254a14a9 },
-		{ 288000000, 123428571, 0x0111, 0x04000021, 0x01030303, 0x02000221, 0x04000003, 0x73, 0x254a14a9 },
-		{ 300000000, 120000000, 0x0009, 0x04000009, 0x01030203, 0x02000902, 0x04000002, 0x52, 0x02520129 }
-	};
-	ulong start, end, dst;
-	bool ret = FALSE;
-	
-	/* get index of the current core */
-	idx = sb_coreidx(sbh);
-	clockcontrol_m2 = NULL;
-
-	/* switch to extif or chipc core */
-	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
-		pll_type = PLL_TYPE1;
-		clockcontrol_n = &eir->clockcontrol_n;
-		clockcontrol_sb = &eir->clockcontrol_sb;
-		clockcontrol_pci = &eir->clockcontrol_pci;
-		clockcontrol_m2 = &cc->clockcontrol_m2;
-	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
-		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
-		if (pll_type == PLL_TYPE6) {
-			clockcontrol_n = NULL;
-			clockcontrol_sb = NULL;
-			clockcontrol_pci = NULL;
-		} else {
-			clockcontrol_n = &cc->clockcontrol_n;
-			clockcontrol_sb = &cc->clockcontrol_sb;
-			clockcontrol_pci = &cc->clockcontrol_pci;
-		clockcontrol_m2 = &cc->clockcontrol_m2;
-		}
-	} else
-		goto done;
-
-	if (pll_type == PLL_TYPE6) {
-		/* Silence compilers */
-		orig_n = orig_sb = orig_pci = 0;
-	} else {
-		/* Store the current clock register values */
-		orig_n = R_REG(clockcontrol_n);
-		orig_sb = R_REG(clockcontrol_sb);
-		orig_pci = R_REG(clockcontrol_pci);
-	}
-
-	if (pll_type == PLL_TYPE1) {
-		/* Keep the current PCI clock if not specified */
-		if (pciclock == 0) {
-			pciclock = sb_clock_rate(pll_type, R_REG(clockcontrol_n), R_REG(clockcontrol_pci));
-			pciclock = (pciclock <= 25000000) ? 25000000 : 33000000;
-		}
-
-		/* Search for the closest MIPS clock less than or equal to a preferred value */
-		for (i = 0; i < ARRAYSIZE(BCMINIT(type1_table)); i++) {
-			ASSERT(BCMINIT(type1_table)[i].mipsclock ==
-			       sb_clock_rate(pll_type, BCMINIT(type1_table)[i].n, BCMINIT(type1_table)[i].sb));
-			if (BCMINIT(type1_table)[i].mipsclock > mipsclock)
-				break;
-		}
-		if (i == 0) {
-			ret = FALSE;
-			goto done;
-		} else {
-			ret = TRUE;
-			i--;
-		}
-		ASSERT(BCMINIT(type1_table)[i].mipsclock <= mipsclock);
-
-		/* No PLL change */
-		if ((orig_n == BCMINIT(type1_table)[i].n) &&
-		    (orig_sb == BCMINIT(type1_table)[i].sb) &&
-		    (orig_pci == BCMINIT(type1_table)[i].pci33))
-			goto done;
-
-		/* Set the PLL controls */
-		W_REG(clockcontrol_n, BCMINIT(type1_table)[i].n);
-		W_REG(clockcontrol_sb, BCMINIT(type1_table)[i].sb);
-		if (pciclock == 25000000)
-			W_REG(clockcontrol_pci, BCMINIT(type1_table)[i].pci25);
-		else
-			W_REG(clockcontrol_pci, BCMINIT(type1_table)[i].pci33);
-
-		/* Reset */
-		sb_watchdog(sbh, 1);
-
-		while (1);
-	} else if ((pll_type == PLL_TYPE3) &&
-		   (BCMINIT(sb_chip)(sbh) != BCM5365_DEVICE_ID)) {
-		/* 5350 */
-		/* Search for the closest MIPS clock less than or equal to a preferred value */
-
-		for (i = 0; i < ARRAYSIZE(type3_table); i++) {
-			if (type3_table[i].mipsclock > mipsclock)
-				break;
-		}
-		if (i == 0) {
-			ret = FALSE;
-			goto done;
-		} else {
-			ret = TRUE;
-			i--;
-		}
-		ASSERT(type3_table[i].mipsclock <= mipsclock);
-
-		/* No PLL change */
-		orig_m2 = R_REG(&cc->clockcontrol_m2);
-		if ((orig_n == type3_table[i].n) &&
-		    (orig_m2 == type3_table[i].m2))  {
-			goto done;
-		}
-		
-		/* Set the PLL controls */
-		W_REG(clockcontrol_n, type3_table[i].n);
-		W_REG(clockcontrol_m2, type3_table[i].m2);
-
-		/* Reset */
-		sb_watchdog(sbh, 1);
-		while (1);
-	} else if ((pll_type == PLL_TYPE2) ||
-		   (pll_type == PLL_TYPE4) ||
-		   (pll_type == PLL_TYPE6)) {
-		n4m_table_t *table = NULL;
-		uint tabsz = 0;
-
-		ASSERT(cc);
-
-		orig_mips = R_REG(&cc->clockcontrol_mips);
-
-		if (pll_type == PLL_TYPE6) {
-			uint32 new_mips = 0;
-
-			ret = TRUE;
-			if (mipsclock <= SB2MIPS_T6(CC_T6_M1))
-				new_mips = CC_T6_MMASK;
-
-			if (orig_mips == new_mips)
-				goto done;
-
-			W_REG(&cc->clockcontrol_mips, new_mips);
-			goto end_fill;
-		}
-
-		table = (pll_type == PLL_TYPE2) ? BCMINIT(type2_table) : BCMINIT(type4_table);
-		tabsz = (pll_type == PLL_TYPE2) ? ARRAYSIZE(BCMINIT(type2_table)) :
-			ARRAYSIZE(BCMINIT(type4_table));
-
-		/* Store the current clock register values */
-		orig_m2 = R_REG(&cc->clockcontrol_m2);
-		orig_ratio_parm = 0;
-
-		/* Look up current ratio */
-		for (i = 0; i < tabsz; i++) {
-			if ((orig_n == table[i].n) &&
-			    (orig_sb == table[i].sb) &&
-			    (orig_pci == table[i].pci33) &&
-			    (orig_m2 == table[i].m2) &&
-			    (orig_mips == table[i].m3)) {
-				orig_ratio_parm = table[i].ratio_parm;
-				break;
-			}
-		}
-
-		/* Search for the closest MIPS clock greater or equal to a preferred value */
-		for (i = 0; i < tabsz; i++) {
-			ASSERT(table[i].mipsclock ==
-			       sb_clock_rate(pll_type, table[i].n, table[i].m3));
-			if ((mipsclock <= table[i].mipsclock) &&
-			    ((sbclock == 0) || (sbclock <= table[i].sbclock)))
-				break;
-		}
-		if (i == tabsz) {
-			ret = FALSE;
-			goto done;
-		} else {
-			ret = TRUE;
-		}
-
-		/* No PLL change */
-		if ((orig_n == table[i].n) &&
-		    (orig_sb == table[i].sb) &&
-		    (orig_pci == table[i].pci33) &&
-		    (orig_m2 == table[i].m2) &&
-		    (orig_mips == table[i].m3))
-			goto done;
-
-		/* Set the PLL controls */
-		W_REG(clockcontrol_n, table[i].n);
-		W_REG(clockcontrol_sb, table[i].sb);
-		W_REG(clockcontrol_pci, table[i].pci33);
-		W_REG(&cc->clockcontrol_m2, table[i].m2);
-		W_REG(&cc->clockcontrol_mips, table[i].m3);
-
-		/* No ratio change */
-		if (orig_ratio_parm == table[i].ratio_parm)
-			goto end_fill;
-
-		new_ratio = table[i].ratio_parm;
-
-		icache_probe(MFC0(C0_CONFIG, 1), &ic_size, &ic_lsize);
-
-		/* Preload the code into the cache */
-		start = ((ulong) &&start_fill) & ~(ic_lsize - 1);
-		end = ((ulong) &&end_fill + (ic_lsize - 1)) & ~(ic_lsize - 1);
-		while (start < end) {
-			cache_unroll(start, Fill_I);
-			start += ic_lsize;
-		}
-
-		/* Copy the handler */
-		start = (ulong) &BCMINIT(handler);
-		end = (ulong) &BCMINIT(afterhandler);
-		dst = KSEG1ADDR(0x180);
-		for (i = 0; i < (end - start); i += 4)
-			*((ulong *)(dst + i)) = *((ulong *)(start + i));
-		
-		/* Preload handler into the cache one line at a time */
-		for (i = 0; i < (end - start); i += 4)
-			cache_unroll(dst + i, Fill_I);
-
-		/* Clear BEV bit */
-		MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~ST0_BEV);
-
-		/* Enable interrupts */
-		MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) | (ALLINTS | ST0_IE));
-
-		/* Enable MIPS timer interrupt */
-		if (!(mipsr = sb_setcore(sbh, SB_MIPS, 0)) &&
-		    !(mipsr = sb_setcore(sbh, SB_MIPS33, 0)))
-			ASSERT(mipsr);
-		W_REG(&mipsr->intmask, 1);
-
-	start_fill:
-		/* step 1, set clock ratios */
-		MTC0(C0_BROADCOM, 3, new_ratio);
-		MTC0(C0_BROADCOM, 1, 8);
-
-		/* step 2: program timer intr */
-		W_REG(&mipsr->timer, 100);
-		(void) R_REG(&mipsr->timer);
-
-		/* step 3, switch to async */
-		sync_mode = MFC0(C0_BROADCOM, 4);
-		MTC0(C0_BROADCOM, 4, 1 << 22);
-
-		/* step 4, set cfg active */
-		MTC0(C0_BROADCOM, 2, 0x9);
-
-
-		/* steps 5 & 6 */ 
-		__asm__ __volatile__ (
-			".set\tmips3\n\t"
-			"wait\n\t"
-			".set\tmips0"
-		);
-
-		/* step 7, clear cfg_active */
-		MTC0(C0_BROADCOM, 2, 0);
-		
-		/* Additional Step: set back to orig sync mode */
-		MTC0(C0_BROADCOM, 4, sync_mode);
-
-		/* step 8, fake soft reset */
-		MTC0(C0_BROADCOM, 5, MFC0(C0_BROADCOM, 5) | 4);
-
-	end_fill:
-		/* step 9 set watchdog timer */
-		sb_watchdog(sbh, 20);
-		(void) R_REG(&cc->chipid);
-
-		/* step 11 */
-		__asm__ __volatile__ (
-			".set\tmips3\n\t"
-			"sync\n\t"
-			"wait\n\t"
-			".set\tmips0"
-		);
-		while (1);
-	}
-
-done:
-	/* switch back to previous core */
-	sb_setcoreidx(sbh, idx);
-
-	return ret;
-}
-
-
-/* returns the ncdl value to be programmed into sdram_ncdl for calibration */
-uint32
-BCMINITFN(sb_memc_get_ncdl)(void *sbh)
-{
-	sbmemcregs_t *memc;
-	uint32 ret = 0;
-	uint32 config, rd, wr, misc, dqsg, cd, sm, sd;
-	uint idx, rev;
-
-	idx = sb_coreidx(sbh);
-
-	memc = (sbmemcregs_t *)sb_setcore(sbh, SB_MEMC, 0);
-	if (memc == 0)
-		goto out;
-
-	rev = sb_corerev(sbh);
-
-	config = R_REG(&memc->config);
-	wr = R_REG(&memc->wrncdlcor);
-	rd = R_REG(&memc->rdncdlcor);
-	misc = R_REG(&memc->miscdlyctl);
-	dqsg = R_REG(&memc->dqsgatencdl);
-
-	rd &= MEMC_RDNCDLCOR_RD_MASK;
-	wr &= MEMC_WRNCDLCOR_WR_MASK; 
-	dqsg &= MEMC_DQSGATENCDL_G_MASK;
-
-	if (config & MEMC_CONFIG_DDR) {
-		ret = (wr << 16) | (rd << 8) | dqsg;
-	} else {
-		if ( (rev > 0)  || (sb_chip(sbh) == BCM5365_DEVICE_ID))
-
-			cd = rd;
-		else
-			cd = (rd == MEMC_CD_THRESHOLD) ? rd : (wr + MEMC_CD_THRESHOLD);
-		sm = (misc & MEMC_MISC_SM_MASK) >> MEMC_MISC_SM_SHIFT;
-		sd = (misc & MEMC_MISC_SD_MASK) >> MEMC_MISC_SD_SHIFT;
-		ret = (sm << 16) | (sd << 8) | cd;
-	}
-
-out:
-	/* switch back to previous core */
-	sb_setcoreidx(sbh, idx);
-
-	return ret;
-}
-
-/* returns the PFC values to be used based on the chip ID*/
-
-uint32
-BCMINITFN(sb_mips_get_pfc)(void *sbh)
-{
-	if (BCMINIT(sb_chip)(sbh) == BCM5350_DEVICE_ID) 
-		return 0x11;
-	else 
-		return 0x15;
-}
--- src/shared.1927/sbpci.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/sbpci.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,562 +0,0 @@
-/*
- * Low-Level PCI and SB support for BCM47xx
- *
- * Copyright 2004, Broadcom Corporation
- * All Rights Reserved.
- * 
- * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * $Id$
- */
-
-#include <typedefs.h>
-#include <pcicfg.h>
-#include <bcmdevs.h>
-#include <sbconfig.h>
-#include <sbpci.h>
-#include <osl.h>
-#include <bcmendian.h>
-#include <bcmutils.h>
-#include <sbutils.h>
-#include <bcmnvram.h>
-#include <hndmips.h>
-
-/* Can free sbpci_init() memory after boot */
-#ifndef linux
-#define __init
-#endif
-
-/* Emulated configuration space */
-static pci_config_regs sb_config_regs[SB_MAXCORES];
-
-/* Banned cores */
-static uint16 pci_ban[32] = { 0 };
-static uint pci_banned = 0;
-
-/* CardBus mode */
-static bool cardbus = FALSE;
-
-/* Disable PCI host core */
-static bool pci_disabled = FALSE;
-
-/*
- * Functions for accessing external PCI configuration space
- */
-
-/* Assume one-hot slot wiring */
-#define PCI_SLOT_MAX 16
-
-static uint32
-config_cmd(void *sbh, uint bus, uint dev, uint func, uint off)
-{
-	uint coreidx;
-	sbpciregs_t *regs;
-	uint32 addr = 0;
-
-	/* CardBusMode supports only one device */
-	if (cardbus && dev > 1)
-		return 0;
-
-	coreidx = sb_coreidx(sbh);
-	regs = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0);
-
-	/* Type 0 transaction */
-	if (bus == 1) {
-		/* Skip unwired slots */
-		if (dev < PCI_SLOT_MAX) {
-			/* Slide the PCI window to the appropriate slot */
-			W_REG(&regs->sbtopci1, SBTOPCI_CFG0 | ((1 << (dev + 16)) & SBTOPCI1_MASK));
-			addr = SB_PCI_CFG | ((1 << (dev + 16)) & ~SBTOPCI1_MASK) |
-				(func << 8) | (off & ~3);
-		}
-	}
-
-	/* Type 1 transaction */
-	else {
-		W_REG(&regs->sbtopci1, SBTOPCI_CFG1);
-		addr = SB_PCI_CFG | (bus << 16) | (dev << 11) | (func << 8) | (off & ~3);
-	}
-
-	sb_setcoreidx(sbh, coreidx);
-
-	return addr;
-}
-
-static int
-extpci_read_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	uint32 addr, *reg = NULL, val;
-	int ret = 0;
-
-	if (pci_disabled ||
-	    !(addr = config_cmd(sbh, bus, dev, func, off)) ||
-	    !(reg = (uint32 *) REG_MAP(addr, len)) ||
-	    BUSPROBE(val, reg))
-		val = 0xffffffff;
-
-	val >>= 8 * (off & 3);
-	if (len == 4)
-		*((uint32 *) buf) = val;
-	else if (len == 2)
-		*((uint16 *) buf) = (uint16) val;
-	else if (len == 1)
-		*((uint8 *) buf) = (uint8) val;
-	else
-		ret = -1;
-
-	if (reg)
-		REG_UNMAP(reg);
-
-	return ret;
-}
-
-static int
-extpci_write_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	uint32 addr, *reg = NULL, val;
-	int ret = 0;
-
-	if (pci_disabled ||
-	    !(addr = config_cmd(sbh, bus, dev, func, off)) ||
-	    !(reg = (uint32 *) REG_MAP(addr, len)) ||
-	    BUSPROBE(val, reg))
-		goto done;
-
-	if (len == 4)
-		val = *((uint32 *) buf);
-	else if (len == 2) {
-		val &= ~(0xffff << (8 * (off & 3)));
-		val |= *((uint16 *) buf) << (8 * (off & 3));
-	} else if (len == 1) {
-		val &= ~(0xff << (8 * (off & 3)));
-		val |= *((uint8 *) buf) << (8 * (off & 3));
-	} else
-		ret = -1;
-
-	W_REG(reg, val);
-
- done:
-	if (reg)
-		REG_UNMAP(reg);
-
-	return ret;
-}
-
-/*
- * Functions for accessing translated SB configuration space
- */
-
-static int
-sb_read_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	pci_config_regs *cfg;
-
-	if (dev >= SB_MAXCORES || (off + len) > sizeof(pci_config_regs))
-		return -1;
-	cfg = &sb_config_regs[dev];
-
-	ASSERT(ISALIGNED(off, len));
-	ASSERT(ISALIGNED((uintptr)buf, len));
-
-	if (len == 4)
-		*((uint32 *) buf) = ltoh32(*((uint32 *)((ulong) cfg + off)));
-	else if (len == 2)
-		*((uint16 *) buf) = ltoh16(*((uint16 *)((ulong) cfg + off)));
-	else if (len == 1)
-		*((uint8 *) buf) = *((uint8 *)((ulong) cfg + off));
-	else
-		return -1;
-
-	return 0;
-}
-
-static int
-sb_write_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	uint coreidx, n;
-	void *regs;
-	sbconfig_t *sb;
-	pci_config_regs *cfg;
-
-	if (dev >= SB_MAXCORES || (off + len) > sizeof(pci_config_regs))
-		return -1;
-	cfg = &sb_config_regs[dev];
-
-	ASSERT(ISALIGNED(off, len));
-	ASSERT(ISALIGNED((uintptr)buf, len));
-
-	/* Emulate BAR sizing */
-	if (off >= OFFSETOF(pci_config_regs, base[0]) && off <= OFFSETOF(pci_config_regs, base[3]) &&
-	    len == 4 && *((uint32 *) buf) == ~0) {
-		coreidx = sb_coreidx(sbh);
-		if ((regs = sb_setcoreidx(sbh, dev))) {
-			sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-			/* Highest numbered address match register */
-			n = (R_REG(&sb->sbidlow) & SBIDL_AR_MASK) >> SBIDL_AR_SHIFT;
-			if (off == OFFSETOF(pci_config_regs, base[0]))
-				cfg->base[0] = ~(sb_size(R_REG(&sb->sbadmatch0)) - 1);
-			else if (off == OFFSETOF(pci_config_regs, base[1]) && n >= 1)
-				cfg->base[1] = ~(sb_size(R_REG(&sb->sbadmatch1)) - 1);
-			else if (off == OFFSETOF(pci_config_regs, base[2]) && n >= 2)
-				cfg->base[2] = ~(sb_size(R_REG(&sb->sbadmatch2)) - 1);
-			else if (off == OFFSETOF(pci_config_regs, base[3]) && n >= 3)
-				cfg->base[3] = ~(sb_size(R_REG(&sb->sbadmatch3)) - 1);
-		}
-		sb_setcoreidx(sbh, coreidx);
-		return 0;
-	}
-
-	if (len == 4)
-		*((uint32 *)((ulong) cfg + off)) = htol32(*((uint32 *) buf));
-	else if (len == 2)
-		*((uint16 *)((ulong) cfg + off)) = htol16(*((uint16 *) buf));
-	else if (len == 1)
-		*((uint8 *)((ulong) cfg + off)) = *((uint8 *) buf);
-	else
-		return -1;
-
-	return 0;
-}
-
-int
-sbpci_read_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	if (bus == 0)
-		return sb_read_config(sbh, bus, dev, func, off, buf, len);
-	else
-		return extpci_read_config(sbh, bus, dev, func, off, buf, len);
-}
-
-int
-sbpci_write_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
-{
-	if (bus == 0)
-		return sb_write_config(sbh, bus, dev, func, off, buf, len);
-	else
-		return extpci_write_config(sbh, bus, dev, func, off, buf, len);
-}
-
-void
-sbpci_ban(uint16 core)
-{
-	if (pci_banned < ARRAYSIZE(pci_ban))
-		pci_ban[pci_banned++] = core;
-}
-
-int __init
-sbpci_init(void *sbh)
-{
-	uint chip, chiprev, chippkg, coreidx, host, i;
-	uint32 boardflags;
-	sbpciregs_t *pci;
-	sbconfig_t *sb;
-	pci_config_regs *cfg;
-	void *regs;
-	char varname[8];
-	uint wlidx = 0;
-	uint16 vendor, core;
-	uint8 class, subclass, progif;
-	uint32 val;
-	uint32 sbips_int_mask[] = { 0, SBIPS_INT1_MASK, SBIPS_INT2_MASK, SBIPS_INT3_MASK, SBIPS_INT4_MASK };
-	uint32 sbips_int_shift[] = { 0, 0, SBIPS_INT2_SHIFT, SBIPS_INT3_SHIFT, SBIPS_INT4_SHIFT };
-
-	chip = sb_chip(sbh);
-	chiprev = sb_chiprev(sbh);
-	chippkg = sb_chippkg(sbh);
-	coreidx = sb_coreidx(sbh);
-
-	if (!(pci = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0)))
-		return -1;
-	sb_core_reset(sbh, 0);
-
-	boardflags = (uint32) getintvar(NULL, "boardflags");
-
-	if ((chip == BCM4310_DEVICE_ID) && (chiprev == 0))
-		pci_disabled = TRUE;
-
-	/*
-	 * The 200-pin BCM4712 package does not bond out PCI. Even when
-	 * PCI is bonded out, some boards may leave the pins
-	 * floating.
-	 */
-	if (((chip == BCM4712_DEVICE_ID) &&
-	     ((chippkg == BCM4712SMALL_PKG_ID) ||
-	      (chippkg == BCM4712MID_PKG_ID))) ||
-	    (boardflags & BFL_NOPCI))
-		pci_disabled = TRUE;
-
-	/*
-	 * If the PCI core should not be touched (disabled, not bonded
-	 * out, or pins floating), do not even attempt to access core
-	 * registers. Otherwise, try to determine if it is in host
-	 * mode.
-	 */
-	if (pci_disabled)
-		host = 0;
-	else
-		host = !BUSPROBE(val, &pci->control);
-
-	if (!host) {
-		/* Disable PCI interrupts in client mode */
-		sb = (sbconfig_t *)((ulong) pci + SBCONFIGOFF);
-		W_REG(&sb->sbintvec, 0);
-
-		/* Disable the PCI bridge in client mode */
-		sbpci_ban(SB_PCI);
-		printf("PCI: Disabled\n");
-	} else {
-		/* Reset the external PCI bus and enable the clock */
-		W_REG(&pci->control, 0x5);		/* enable the tristate drivers */
-		W_REG(&pci->control, 0xd);		/* enable the PCI clock */
-		OSL_DELAY(150);				/* delay > 100 us */
-		W_REG(&pci->control, 0xf);		/* deassert PCI reset */
-		W_REG(&pci->arbcontrol, PCI_INT_ARB);	/* use internal arbiter */
-		OSL_DELAY(1);				/* delay 1 us */
-
-		/* Enable CardBusMode */
-		cardbus = nvram_match("cardbus", "1");
-		if (cardbus) {
-			printf("PCI: Enabling CardBus\n");
-			/* GPIO 1 resets the CardBus device on bcm94710ap */
-			sb_gpioout(sbh, 1, 1);
-			sb_gpioouten(sbh, 1, 1);
-			W_REG(&pci->sprom[0], R_REG(&pci->sprom[0]) | 0x400);
-		}
-
-		/* 64 MB I/O access window */
-		W_REG(&pci->sbtopci0, SBTOPCI_IO);
-		/* 64 MB configuration access window */
-		W_REG(&pci->sbtopci1, SBTOPCI_CFG0);
-		/* 1 GB memory access window */
-		W_REG(&pci->sbtopci2, SBTOPCI_MEM | SB_PCI_DMA);
-
-		/* Enable PCI bridge BAR0 prefetch and burst */
-		val = 6;
-		sbpci_write_config(sbh, 1, 0, 0, PCI_CFG_CMD, &val, sizeof(val));
-
-		/* Enable PCI interrupts */
-		W_REG(&pci->intmask, PCI_INTA);
-	}
-
-	/* Scan the SB bus */
-	bzero(sb_config_regs, sizeof(sb_config_regs));
-	for (cfg = sb_config_regs; cfg < &sb_config_regs[SB_MAXCORES]; cfg++) {
-		cfg->vendor = 0xffff;
-		if (!(regs = sb_setcoreidx(sbh, cfg - sb_config_regs)))
-			continue;
-		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-
-		/* Read ID register and parse vendor and core */
-		val = R_REG(&sb->sbidhigh);
-		vendor = (val & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT;
-		core = (val & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT;
-		progif = 0;
-
-		/* Check if this core is banned */
-		for (i = 0; i < pci_banned; i++)
-			if (core == pci_ban[i])
-				break;
-		if (i < pci_banned)
-			continue;
-
-		/* Known vendor translations */
-		switch (vendor) {
-		case SB_VEND_BCM:
-			vendor = VENDOR_BROADCOM;
-			break;
-		}
-
-		/* Determine class based on known core codes */
-		switch (core) {
-		case SB_ILINE20:
-			class = PCI_CLASS_NET;
-			subclass = PCI_NET_ETHER;
-			core = BCM47XX_ILINE_ID;
-			break;
-		case SB_ILINE100:
-			class = PCI_CLASS_NET;
-			subclass = PCI_NET_ETHER;
-			core = BCM4610_ILINE_ID;
-			break;
-		case SB_ENET:
-			class = PCI_CLASS_NET;
-			subclass = PCI_NET_ETHER;
-			core = BCM47XX_ENET_ID;
-			break;
-		case SB_SDRAM:
-		case SB_MEMC:
-			class = PCI_CLASS_MEMORY;
-			subclass = PCI_MEMORY_RAM;
-			break;
-		case SB_PCI:
-			class = PCI_CLASS_BRIDGE;
-			subclass = PCI_BRIDGE_PCI;
-			break;
-		case SB_MIPS:
-		case SB_MIPS33:
-			class = PCI_CLASS_CPU;
-			subclass = PCI_CPU_MIPS;
-			break;
-		case SB_CODEC:
-			class = PCI_CLASS_COMM;
-			subclass = PCI_COMM_MODEM;
-			core = BCM47XX_V90_ID;
-			break;
-		case SB_USB:
-			class = PCI_CLASS_SERIAL;
-			subclass = PCI_SERIAL_USB;
-			progif = 0x10; /* OHCI */
-			core = BCM47XX_USB_ID;
-			break;
-		case SB_USB11H:
-			class = PCI_CLASS_SERIAL;
-			subclass = PCI_SERIAL_USB;
-			progif = 0x10; /* OHCI */
-			core = BCM47XX_USBH_ID;
-			break;
-		case SB_USB11D:
-			class = PCI_CLASS_SERIAL;
-			subclass = PCI_SERIAL_USB;
-			core = BCM47XX_USBD_ID;
-			break;
-		case SB_IPSEC:
-			class = PCI_CLASS_CRYPT;
-			subclass = PCI_CRYPT_NETWORK;
-			core = BCM47XX_IPSEC_ID;
-			break;
-		case SB_ROBO:
-			class = PCI_CLASS_NET;
-			subclass = PCI_NET_OTHER;
-			core = BCM47XX_ROBO_ID;
-			break;
-		case SB_EXTIF:
-		case SB_CC:
-			class = PCI_CLASS_MEMORY;
-			subclass = PCI_MEMORY_FLASH;
-			break;
-		case SB_D11:
-			class = PCI_CLASS_NET;
-			subclass = PCI_NET_OTHER;
-			/* Let an nvram variable override this */
-			sprintf(varname, "wl%did", wlidx);
-			wlidx++;
-			if ((core = getintvar(NULL, varname)) == 0) {
-				if (chip == BCM4712_DEVICE_ID) {
-					if (chippkg == BCM4712SMALL_PKG_ID)
-						core = BCM4306_D11G_ID;
-					else
-						core = BCM4306_D11DUAL_ID;
-				} else {
-					/* 4310 */
-					core = BCM4310_D11B_ID;
-				}
-			}
-			break;
-
-		default:
-			class = subclass = progif = 0xff;
-			break;
-		}
-
-		/* Supported translations */
-		cfg->vendor = htol16(vendor);
-		cfg->device = htol16(core);
-		cfg->rev_id = chiprev;
-		cfg->prog_if = progif;
-		cfg->sub_class = subclass;
-		cfg->base_class = class;
-		cfg->base[0] = htol32(sb_base(R_REG(&sb->sbadmatch0)));
-		cfg->base[1] = htol32(sb_base(R_REG(&sb->sbadmatch1)));
-		cfg->base[2] = htol32(sb_base(R_REG(&sb->sbadmatch2)));
-		cfg->base[3] = htol32(sb_base(R_REG(&sb->sbadmatch3)));
-		cfg->base[4] = 0;
-		cfg->base[5] = 0;
-		if (class == PCI_CLASS_BRIDGE && subclass == PCI_BRIDGE_PCI)
-			cfg->header_type = PCI_HEADER_BRIDGE;
-		else
-			cfg->header_type = PCI_HEADER_NORMAL;
-		/* Save core interrupt flag */
-		cfg->int_pin = R_REG(&sb->sbtpsflag) & SBTPS_NUM0_MASK;
-		/* Default to MIPS shared interrupt 0 */
-		cfg->int_line = 0;
-		/* MIPS sbipsflag maps core interrupt flags to interrupts 1 through 4 */
-		if ((regs = sb_setcore(sbh, SB_MIPS, 0)) ||
-		    (regs = sb_setcore(sbh, SB_MIPS33, 0))) {
-			sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
-			val = R_REG(&sb->sbipsflag);
-			for (cfg->int_line = 1; cfg->int_line <= 4; cfg->int_line++) {
-				if (((val & sbips_int_mask[cfg->int_line]) >> sbips_int_shift[cfg->int_line]) == cfg->int_pin)
-					break;
-			}
-			if (cfg->int_line > 4)
-				cfg->int_line = 0;
-		}
-		/* Emulated core */
-		*((uint32 *) &cfg->sprom_control) = 0xffffffff;
-	}
-
-	sb_setcoreidx(sbh, coreidx);
-	return 0;
-}
-
-void
-sbpci_check(void *sbh)
-{
-	uint coreidx;
-	sbpciregs_t *pci;
-	uint32 sbtopci1;
-	uint32 buf[64], *ptr, i;
-	ulong pa;
-	volatile uint j;
-
-	coreidx = sb_coreidx(sbh);
-	pci = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0);
-
-	/* Clear the test array */
-	pa = (ulong) DMA_MAP(NULL, buf, sizeof(buf), DMA_RX, NULL);
-	ptr = (uint32 *) OSL_UNCACHED(&buf[0]);
-	memset(ptr, 0, sizeof(buf));
-
-	/* Point PCI window 1 to memory */
-	sbtopci1 = R_REG(&pci->sbtopci1);
-	W_REG(&pci->sbtopci1, SBTOPCI_MEM | (pa & SBTOPCI1_MASK));
-
-	/* Fill the test array via PCI window 1 */
-	ptr = (uint32 *) REG_MAP(SB_PCI_CFG + (pa & ~SBTOPCI1_MASK), sizeof(buf));
-	for (i = 0; i < ARRAYSIZE(buf); i++) {
-		for (j = 0; j < 2; j++);
-		W_REG(&ptr[i], i);
-	}
-	REG_UNMAP(ptr);
-
-	/* Restore PCI window 1 */
-	W_REG(&pci->sbtopci1, sbtopci1);
-
-	/* Check the test array */
-	DMA_UNMAP(NULL, pa, sizeof(buf), DMA_RX, NULL);
-	ptr = (uint32 *) OSL_UNCACHED(&buf[0]);
-	for (i = 0; i < ARRAYSIZE(buf); i++) {
-		if (ptr[i] != i)
-			break;
-	}
-
-	/* Change the clock if the test fails */
-	if (i < ARRAYSIZE(buf)) {
-		uint32 req, cur;
-
-		cur = sb_clock(sbh);
-		printf("PCI: Test failed at %d MHz\n", (cur + 500000) / 1000000);
-		for (req = 104000000; req < 176000000; req += 4000000) {
-			printf("PCI: Resetting to %d MHz\n", (req + 500000) / 1000000);
-			/* This will only reset if the clocks are valid and have changed */
-			sb_mips_setclock(sbh, req, 0, 0);
-		}
-		/* Should not reach here */
-		ASSERT(0);
-	}
-
-	sb_setcoreidx(sbh, coreidx);
-}
--- src/shared.1927/sbsdram.S	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/sbsdram.S	2007-11-19 06:40:26.000000000 +0300
@@ -78,6 +78,9 @@
  */
 
 
+	.text
+	.set	mips32
+
 	LEAF(board_draminit)
 	.set	noreorder
 
@@ -112,7 +115,7 @@
 1:	li	t0,PHYSADDR_MASK
 	and	t0,t0,ra
 	li	t1,SB_FLASH1
-	blt	t0,t1,szmem
+	blt	t0,t1,memprio_szmem
 	nop
 
 	/* For socram we don't need any nvram parms, just do a core reset */
@@ -121,7 +124,7 @@
 	bal	sb_core_reset
 	li	a2,0
 	/* and size memory */
-	b	szmem
+	b	memprio_szmem
 	nop
 
 read_nvram:
@@ -134,15 +137,19 @@
 	nop
 
 	/* It is a chipcommon core: */
-	/* 1: Isolate corerev in v1 */
+	/* 1: Isolate memc's corerev in v1 */
+	and	t2,v1,SBIDH_RCE_MASK
+	srl	t2,t2,SBIDH_RCE_SHIFT
 	and	v1,v1,SBIDH_RC_MASK
+	or	v1,t2
 
 	/* 1.5: 5365a0 lies about its revision, it is really 1 */
 	bnez	v1,1f
 	nop
-	lw	t1,0(t0)		# Check chipid
-	andi	t1,CID_ID_MASK
-	bne	t1,BCM5365_DEVICE_ID,1f
+
+	lw	t1,CC_CHIPID(t0)		# Get chipid
+	andi	t1,CID_ID_MASK			# Check chipid
+	bne	t1,BCM5365_CHIP_ID,1f
 	nop
 	li	v1,1
 
@@ -159,11 +166,11 @@
 
 find_nvram:
 	li	t3,FLASH_MIN 
-	li	t0, NVRAM_MAGIC
+	li	t0,NVRAM_MAGIC
 
 1:
 	add	a2,t2,t3
-	lw	t1, 0(a2)
+	lw	t1,0(a2)
 	beq	t0,t1,read_parms
 	nop
 
@@ -261,7 +268,7 @@
 	TRACE(1, dll)
 	andi	dll,dll,0xfe
 	srl	dll,dll,1
-	beqz	dll,szmem		/* If zero, leave the default values */
+	beqz	dll,memprio_szmem		/* If zero, leave the default values */
 	nop
 
 	move	wrlim,dll		/* dll value is lim for wr, rd and g */
@@ -387,7 +394,7 @@
 	bal	ddr_do_init
 	nop
 
-	b	szmem
+	b	memprio_szmem
 	nop
 
 memc_sdr_init:
@@ -535,7 +542,7 @@
 	bal	sdr_do_init
 	nop
 
-	b	szmem
+	b	memprio_szmem
 	nop
 
 sdram_init:
@@ -570,30 +577,71 @@
 	sw	t2, 8(a0)		# SDRAM refresh
 
 
+	/* Change the memory priority inversion counter value */
 	/* Determine memory size and return */
-szmem:
-	lw	t0,(SBCONFIGOFF + SBIDHIGH)(a0)
-	and	t0,t0,SBIDH_CC_MASK
-	srl	t0,t0,SBIDH_CC_SHIFT
-	bne	t0,SB_SOCRAM,szmem_alias
+memprio_szmem:
+
+#ifdef APPLE
+	lw	t0, MEMC_PRIORINV(a0) 
+	li 	t1, 0xFFFF0000
+	and     t0, t0, t1
+	ori	t0, t0, 0x1
+	sw      t0, MEMC_PRIORINV(a0)
+#else
+	li	t0,KSEG1ADDR(SB_ENUM_BASE)	# is there a chipcommon core?
+	lw	t1,(SBCONFIGOFF + SBIDHIGH)(t0)
+	and	t1,t1,SBIDH_CC_MASK
+	srl	t1,t1,SBIDH_CC_SHIFT
+	bne	t1,SB_CC,0f
+	nop
+	lw	t1,CC_CHIPID(t0)		# is this BCM4785 chip?
+	and	t1,t1,CID_ID_MASK
+	bne	t1,BCM4785_CHIP_ID,0f
+	nop
+	lw	t0,MEMC_PRIORINV(a0)		# change PriorInvTim to 2
+	and     t0,t0,0xFFFF0000
+	ori	t0,t0,0x02
+	sw      t0,MEMC_PRIORINV(a0)
+#endif
+0:	lw	t0,(SBCONFIGOFF + SBIDHIGH)(a0)
+	and	t1,t0,SBIDH_CC_MASK
+	srl	t1,t1,SBIDH_CC_SHIFT
+	bne	t1,SB_SOCRAM,szmem_alias
 	nop
 
 	/* The socram core tells us how much memory there is */
-	lw	t0,SOCRAM_MEMSIZE(a0)
-	addi	t0,SOCRAM_MEMSIZE_BASESHIFT
+	lw	t1,SR_COREINFO(a0)
+	and	t0,t0,SBIDH_RC_MASK		/* Find corerev */
+	beq	t0,zero,crev0
+
+	/* Its corerev >= 1 */
+	and	t2,t1,SRCI_SRNB_MASK		/* Find number of blocks */
+	srl	t2,t2,SRCI_SRNB_SHIFT
+	and	t1,t1,SRCI_SRBSZ_MASK		/* Find block size */
+	addi	t1,t1,SR_BSZ_BASE
+	li	t0,1
+	sll	t0,t0,t1
+	mul	v0,t0,t2
+	jr	t6
+	nop
+
+crev0:
+	and	t1,t1,SRCI_MS0_MASK
+	add	t1,t1,SR_MS0_BASE
 	li	v0,1
-	sll	v0,v0,t0
+	sll	v0,v0,t1
 	jr	t6
 	nop
 	
 szmem_alias:
 	li	t0,KSEG1
 	li	t2,0xaa55beef
-	sw	t2,0(t0)
+	sw	zero,0(t0)
 	li	v0,(1 << 20)
 
-1:
-	or	t0,v0,KSEG1
+1:	or	t0,v0,KSEG1
+	sw	t2,0(t0)
+	li	t0,KSEG1
 	lw	t1,0(t0)
 	beq	t1,t2,done
 	nop
@@ -711,7 +759,7 @@
 	 *	t3:	memc rd ncdl value
 	 *	t4:	memc g ncdl value
 	 *
-	 * Uses a1, t7, t8, t9 (here and by calling sb_core_reset)
+	 * Uses a1, a2, t7, t8, t9 (here and by calling sb_core_reset)
 	 */
 ddr_do_init:
 
@@ -723,6 +771,8 @@
 
 	li	a1,MEMC_CONFIG_INIT
 	or	a1,a1,t0
+	lui	a2, 0x8			# set DQMGate for memc rev 4 or more
+	or	a1, a1, a2
 	sw	a1,MEMC_CONFIG(a0)
 
 	li	a1,MEMC_DRAMTIM25_INIT	# Assume CAS latency of 2.5
@@ -733,7 +783,48 @@
 1:	
 	sw	a1,MEMC_DRAMTIM(a0)
 
-	andi	t8,t3,0xff
+#ifndef	BCM_ATE
+	li	t8,KSEG1ADDR(SB_ENUM_BASE)	# Get package options
+	lw	a1,CC_CHIPID(t8)		# Get chipid
+	li	t9,CID_PKG_MASK			# Check package options
+	and	a1,a1,t9
+	srl	a1,a1,CID_PKG_SHIFT
+	addi	t8,SBCONFIGOFF			# Get corerev for chipcommon
+	lw	a2,SBIDHIGH(t8)
+	li	t8,SBIDH_RCE_MASK
+	and	t8,t8,a2
+	srl	t8,SBIDH_RCE_SHIFT
+	li	t9,SBIDH_RC_MASK
+	and	t9,t9,a2
+	or	t8,t8,t9
+	bge	t8,10,1f			# If ccrev is >= 10 use 4bit pkg opt
+	nop
+	ori	a1,8				#  else add a bit to the 3bit field
+1:
+	beq	a1,HDLSIM_PKG_ID,hdlsim		# Special case for hdl sim:
+	nop
+
+	li	t8,KSEG1ADDR(SB_ENUM_BASE)	# Get chipid again
+	lw	a2,CC_CHIPID(t8)
+	li	t9,BCM5350_CHIP_ID		# 5350 ChipID
+	li	t8,CID_ID_MASK
+	and	t8,t8,a2
+	bne	t8,t9,notsim			# if not 5350keep going
+	nop
+
+	bne	a1,(8 | HDLSIM5350_PKG_ID),notsim	# If 5350, is it (3/4-bit) vsim?
+	nop
+#endif	/* !BCM_ATE */
+
+hdlsim:
+	li	a1,MEMC_RDNCDLCOR_SIMINIT	#  Fixed 0xf6 rdncdl and no inits
+	sw	a1,MEMC_RDNCDLCOR(a0)		#  of wrncdl, dqsgate and miscdly.
+
+#ifndef	BCM_ATE
+	b	simskip
+	nop
+
+notsim:	andi	t8,t3,0xff
 	sll	a1,t8,8			# Replicate rd ncdl 4 times
 	or	a1,a1,t8
 	sll	t8,a1,16
@@ -764,7 +855,9 @@
 	li	a1,MEMC_MISCDLYCTL_INIT
 2:
 	sw	a1,MEMC_MISCDLYCTL(a0)
+#endif	/* !BCM_ATE */
 
+simskip:
 	li	a1,MEMC_NCDLCTL_INIT
 	sw	a1,MEMC_NCDLCTL(a0)
 
--- src/shared.1927/sbutils.c	2004-12-03 22:05:11.000000000 +0300
+++ src/shared/sbutils.c	2007-11-19 06:57:06.000000000 +0300
@@ -13,36 +13,43 @@
  */
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 #include <osl.h>
 #include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmdevs.h>
 #include <sbconfig.h>
 #include <sbchipc.h>
 #include <sbpci.h>
+#include <sbpcie.h>
 #include <pcicfg.h>
 #include <sbpcmcia.h>
-#include <sbextif.h>
-#include <sbutils.h>
+#include <sbsocram.h>
+#include <bcmnvram.h>
 #include <bcmsrom.h>
+#include <hndpmu.h>
 
 /* debug/trace */
 #define	SB_ERROR(args)
 
-
-#define CLOCK_BASE_5350		12500000 /* Specific to 5350*/
+#define	SB_MSG(args)
 
 typedef uint32 (*sb_intrsoff_t)(void *intr_arg);
 typedef void (*sb_intrsrestore_t)(void *intr_arg, uint32 arg);
 typedef bool (*sb_intrsenabled_t)(void *intr_arg);
 
+typedef struct gpioh_item {
+	void			*arg;
+	bool			level;
+	gpio_handler_t		handler;
+	uint32			event;
+	struct gpioh_item	*next;
+} gpioh_item_t;
+
 /* misc sb info needed by some of the routines */
 typedef struct sb_info {
-	uint	chip;			/* chip number */
-	uint	chiprev;		/* chip revision */
-	uint	chippkg;		/* chip package option */
-	uint	boardtype;		/* board type */
-	uint	boardvendor;		/* board vendor id */
-	uint	bustype;		/* what bus type we are going through */
+
+	struct sb_pub  	sb;		/* back plane public state (must be first field) */
 
 	void	*osh;			/* osl os handle */
 	void	*sdh;			/* bcmsdh handle */
@@ -52,49 +59,97 @@
 
 	uint	curidx;			/* current core index */
 	uint	dev_coreid;		/* the core provides driver functions */
-	uint	pciidx;			/* pci core index */
-	uint	pcirev;			/* pci core rev */
 
-	uint	pcmciaidx;		/* pcmcia core index */
-	uint	pcmciarev;		/* pcmcia core rev */
 	bool	memseg;			/* flag to toggle MEM_SEG register */
 
-	uint	ccrev;			/* chipc core rev */
-
-	uint	gpioidx;		/* gpio control core index */
-	uint	gpioid;			/* gpio control coretype */
-
 	uint	numcores;		/* # discovered cores */
 	uint	coreid[SB_MAXCORES];	/* id of each core */
+	uint32	coresba[SB_MAXCORES];	/* backplane address of each core */
 
 	void	*intr_arg;		/* interrupt callback function arg */
-	sb_intrsoff_t		intrsoff_fn;		/* function turns chip interrupts off */
-	sb_intrsrestore_t	intrsrestore_fn;	/* function restore chip interrupts */
-	sb_intrsenabled_t	intrsenabled_fn;	/* function to check if chip interrupts are enabled */
+	sb_intrsoff_t intrsoff_fn;	/* turns chip interrupts off */
+	sb_intrsrestore_t intrsrestore_fn; /* restore chip interrupts */
+	sb_intrsenabled_t intrsenabled_fn; /* check if interrupts are enabled */
+
+	uint8	pciecap_lcreg_offset; /* PCIE capability LCreg offset in the config space */
+	bool	pr42767_war; 
+	uint8	pcie_polarity; 
+	bool pcie_war_ovr; /* Override ASPM/Clkreq settings */
+
+	uint8 pmecap_offset;	/* PM Capability offset in the config space */
+	bool pmecap;		/* Capable of generating PME */
+
+	gpioh_item_t *gpioh_head; 	/* GPIO event handlers list */
+
+	char *vars;
+	uint varsz;
 } sb_info_t;
 
 /* local prototypes */
-static void* BCMINIT(sb_doattach)(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
-static void BCMINIT(sb_scan)(sb_info_t *si);
-static uint sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val);
-static uint _sb_coreidx(void *sbh);
-static uint sb_findcoreidx(void *sbh, uint coreid, uint coreunit);
-static uint BCMINIT(sb_pcidev2chip)(uint pcidev);
-static uint BCMINIT(sb_chip2numcores)(uint chip);
-
-#define	SB_INFO(sbh)	(sb_info_t*)sbh
-#define	SET_SBREG(sbh, r, mask, val)	W_SBREG((sbh), (r), ((R_SBREG((sbh), (r)) & ~(mask)) | (val)))
-#define	GOODCOREADDR(x)	(((x) >= SB_ENUM_BASE) && ((x) <= SB_ENUM_LIM) && ISALIGNED((x), SB_CORE_SIZE))
+static sb_info_t * sb_doattach(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+                               uint bustype, void *sdh, char **vars, uint *varsz);
+static void sb_scan(sb_info_t *si, void *regs, uint devid);
+static uint _sb_coreidx(sb_info_t *si, uint32 sba);
+static uint _sb_scan(sb_info_t *si, uint32 sba, void *regs, uint bus, uint32 sbba,
+                     uint ncores);
+static uint32 _sb_coresba(sb_info_t *si);
+static void *_sb_setcoreidx(sb_info_t *si, uint coreidx);
+static uint sb_chip2numcores(uint chip);
+static bool sb_ispcie(sb_info_t *si);
+static uint8 sb_find_pci_capability(sb_info_t *si, uint8 req_cap_id,
+                                    uchar *buf, uint32 *buflen);
+static int sb_pci_fixcfg(sb_info_t *si);
+/* routines to access mdio slave device registers */
+static int sb_pcie_mdiowrite(sb_info_t *si,  uint physmedia, uint readdr, uint val);
+static int sb_pcie_mdioread(sb_info_t *si,  uint physmedia, uint readdr, uint *ret_val);
+
+/* dev path concatenation util */
+static char *sb_devpathvar(sb_t *sbh, char *var, int len, const char *name);
+
+/* WARs */
+static void sb_war43448(sb_t *sbh);
+static void sb_war43448_aspm(sb_t *sbh);
+static void sb_war32414_forceHT(sb_t *sbh, bool forceHT);
+static void sb_war30841(sb_info_t *si);
+static void sb_war42767(sb_t *sbh);
+static void sb_war42767_clkreq(sb_t *sbh);
+
+/* delay needed between the mdio control/ mdiodata register data access */
+#define PR28829_DELAY() OSL_DELAY(10)
+
+/* size that can take bitfielddump */
+#define BITFIELD_DUMP_SIZE  32
+
+/* global variable to indicate reservation/release of gpio's */
+static uint32 sb_gpioreservation = 0;
+
+/* global flag to prevent shared resources from being initialized multiple times in sb_attach() */
+static bool sb_onetimeinit = FALSE;
+
+#define	SB_INFO(sbh)	(sb_info_t*)(uintptr)sbh
+#define	SET_SBREG(si, r, mask, val)	\
+		W_SBREG((si), (r), ((R_SBREG((si), (r)) & ~(mask)) | (val)))
+#define	GOODCOREADDR(x, b) (((x) >= (b)) && ((x) < ((b) + SB_MAXCORES * SB_CORE_SIZE)) && \
+		ISALIGNED((x), SB_CORE_SIZE))
 #define	GOODREGS(regs)	((regs) && ISALIGNED((uintptr)(regs), SB_CORE_SIZE))
 #define	REGS2SB(va)	(sbconfig_t*) ((int8*)(va) + SBCONFIGOFF)
+#define BADCOREADDR	0
 #define	GOODIDX(idx)	(((uint)idx) < SB_MAXCORES)
 #define	BADIDX		(SB_MAXCORES+1)
-#define	NOREV		(SBIDH_RC_MASK + 1)
+#define	NOREV		-1		/* Invalid rev */
 
-#define	R_SBREG(sbh, sbr)	sb_read_sbreg((sbh), (sbr))
-#define	W_SBREG(sbh, sbr, v)	sb_write_sbreg((sbh), (sbr), (v))
-#define	AND_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) & (v)))
-#define	OR_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) | (v)))
+#define PCI(si)		((BUSTYPE(si->sb.bustype) == PCI_BUS) && (si->sb.buscoretype == SB_PCI))
+#define PCIE(si)	((BUSTYPE(si->sb.bustype) == PCI_BUS) && (si->sb.buscoretype == SB_PCIE))
+#define PCMCIA(si)	((BUSTYPE(si->sb.bustype) == PCMCIA_BUS) && (si->memseg == TRUE))
+
+/* sonicsrev */
+#define	SONICS_2_2	(SBIDL_RV_2_2 >> SBIDL_RV_SHIFT)
+#define	SONICS_2_3	(SBIDL_RV_2_3 >> SBIDL_RV_SHIFT)
+
+#define	R_SBREG(si, sbr)	sb_read_sbreg((si), (sbr))
+#define	W_SBREG(si, sbr, v)	sb_write_sbreg((si), (sbr), (v))
+#define	AND_SBREG(si, sbr, v)	W_SBREG((si), (sbr), (R_SBREG((si), (sbr)) & (v)))
+#define	OR_SBREG(si, sbr, v)	W_SBREG((si), (sbr), (R_SBREG((si), (sbr)) | (v)))
 
 /*
  * Macros to disable/restore function core(D11, ENET, ILINE20, etc) interrupts before/
@@ -107,27 +162,37 @@
 	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
 		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
 
-/* power control defines */
+/* dynamic clock control defines */
 #define	LPOMINFREQ	25000			/* low power oscillator min */
 #define	LPOMAXFREQ	43000			/* low power oscillator max */
-#define	XTALMINFREQ	19800000		/* 20mhz - 1% */
-#define	XTALMAXFREQ	20200000		/* 20mhz + 1% */
-#define	PCIMINFREQ	25000000		/* 25mhz */
-#define	PCIMAXFREQ	34000000		/* 33mhz + fudge */
-#define SCC_DEF_DIV	0			/* default slow clock divider */
+#define	XTALMINFREQ		19800000	/* 20 MHz - 1% */
+#define	XTALMAXFREQ		20200000	/* 20 MHz + 1% */
+#define	PCIMINFREQ		25000000	/* 25 MHz */
+#define	PCIMAXFREQ		34000000	/* 33 MHz + fudge */
+
+#define	ILP_DIV_5MHZ		0		/* ILP = 5 MHz */
+#define	ILP_DIV_1MHZ		4		/* ILP = 1 MHz */
+
+/* force HT war check */
+#define FORCEHT_WAR32414(si)	\
+	(((PCIE(si)) && (si->sb.chip == BCM4311_CHIP_ID) && ((si->sb.chiprev <= 1))) || \
+	((PCI(si) || PCIE(si)) && (si->sb.chip == BCM4321_CHIP_ID) && (si->sb.chiprev <= 3)))
+
+#define PCIE_ASPMWARS(si)	\
+	((PCIE(si)) && ((si->sb.buscorerev >= 3) && (si->sb.buscorerev <= 5)))
+
+/* GPIO Based LED powersave defines */
+#define DEFAULT_GPIO_ONTIME	10		/* Default: 10% on */
+#define DEFAULT_GPIO_OFFTIME	90		/* Default: 10% on */
 
-#define XTAL_ON_DELAY		1000	/* Xtal power on delay in us */
-
-#define SCC_LOW2FAST_LIMIT	5000	/* turn on fast clock time, in unit of ms */
+#define DEFAULT_GPIOTIMERVAL  ((DEFAULT_GPIO_ONTIME << GPIO_ONTIME_SHIFT) | DEFAULT_GPIO_OFFTIME)
 
 static uint32
-sb_read_sbreg(void *sbh, volatile uint32 *sbr)
+sb_read_sbreg(sb_info_t *si, volatile uint32 *sbr)
 {
-	sb_info_t *si;
 	uint8 tmp;
 	uint32 val, intr_val = 0;
 
-	si = SB_INFO(sbh);
 
 	/*
 	 * compact flash only has 11 bits address, while we needs 12 bits address.
@@ -135,16 +200,16 @@
 	 * so we program MEM_SEG with 12th bit when necessary(access sb regsiters).
 	 * For normal PCMCIA bus(CFTable_regwinsz > 2k), do nothing special
 	 */
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		INTR_OFF(si, intr_val);
 		tmp = 1;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
-		(uintptr)sbr &= ~(1 << 11);	/* mask out bit 11*/
+		sbr = (volatile uint32 *)((uintptr)sbr & ~(1 << 11)); /* mask out bit 11 */
 	}
 
-	val = R_REG(sbr);
+	val = R_REG(si->osh, sbr);
 
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		tmp = 0;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
 		INTR_RESTORE(si, intr_val);
@@ -154,14 +219,12 @@
 }
 
 static void
-sb_write_sbreg(void *sbh, volatile uint32 *sbr, uint32 v)
+sb_write_sbreg(sb_info_t *si, volatile uint32 *sbr, uint32 v)
 {
-	sb_info_t *si;
 	uint8 tmp;
 	volatile uint32 dummy;
 	uint32 intr_val = 0;
 
-	si = SB_INFO(sbh);
 
 	/*
 	 * compact flash only has 11 bits address, while we needs 12 bits address.
@@ -169,29 +232,29 @@
 	 * so we program MEM_SEG with 12th bit when necessary(access sb regsiters).
 	 * For normal PCMCIA bus(CFTable_regwinsz > 2k), do nothing special
 	 */
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		INTR_OFF(si, intr_val);
 		tmp = 1;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
-		(uintptr)sbr &= ~(1 << 11);	/* mask out bit 11 */
+		sbr = (volatile uint32 *)((uintptr)sbr & ~(1 << 11)); /* mask out bit 11 */
 	}
 
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
 #ifdef IL_BIGENDIAN
-		dummy = R_REG(sbr);
-		W_REG(((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
-		dummy = R_REG(sbr);
-		W_REG((volatile uint16 *)sbr, (uint16)(v & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, ((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, (volatile uint16 *)sbr, (uint16)(v & 0xffff));
 #else
-		dummy = R_REG(sbr);
-		W_REG((volatile uint16 *)sbr, (uint16)(v & 0xffff));
-		dummy = R_REG(sbr);
-		W_REG(((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
-#endif
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, (volatile uint16 *)sbr, (uint16)(v & 0xffff));
+		dummy = R_REG(si->osh, sbr);
+		W_REG(si->osh, ((volatile uint16 *)sbr + 1), (uint16)((v >> 16) & 0xffff));
+#endif	/* IL_BIGENDIAN */
 	} else
-		W_REG(sbr, v);
+		W_REG(si->osh, sbr, v);
 
-	if(si->memseg) {
+	if (PCMCIA(si)) {
 		tmp = 0;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, MEM_SEG, &tmp, 1);
 		INTR_RESTORE(si, intr_val);
@@ -207,8 +270,9 @@
  * vars - pointer to a pointer area for "environment" variables
  * varsz - pointer to int to return the size of the vars
  */
-void* 
-BCMINITFN(sb_attach)(uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz)
+sb_t *
+BCMINITFN(sb_attach)(uint devid, osl_t *osh, void *regs,
+                     uint bustype, void *sdh, char **vars, uint *varsz)
 {
 	sb_info_t *si;
 
@@ -218,11 +282,14 @@
 		return (NULL);
 	}
 
-	if (BCMINIT(sb_doattach)(si, devid, osh, regs, bustype, sdh, vars, varsz) == NULL) {
-		MFREE(osh, si, sizeof (sb_info_t));
+	if (sb_doattach(si, devid, osh, regs, bustype, sdh, vars, varsz) == NULL) {
+		MFREE(osh, si, sizeof(sb_info_t));
 		return (NULL);
 	}
-	return si;
+	si->vars = vars ? *vars : NULL;
+	si->varsz = varsz ? *varsz : 0;
+
+	return (sb_t *)si;
 }
 
 /* Using sb_kattach depends on SB_BUS support, either implicit  */
@@ -233,201 +300,318 @@
 static sb_info_t ksi;
 
 /* generic kernel variant of sb_attach() */
-void* 
-BCMINITFN(sb_kattach)()
+sb_t *
+BCMINITFN(sb_kattach)(osl_t *osh)
 {
-	uint32 *regs;
-	char *unused;
-	int varsz;
-
-	if (ksi.curmap == NULL) {
-		uint32 cid;
-
-		regs = (uint32 *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
-		cid = R_REG((uint32 *)regs);
-		if (((cid & CID_ID_MASK) == BCM4712_DEVICE_ID) &&
-		    ((cid & CID_PKG_MASK) != BCM4712LARGE_PKG_ID) &&
-		    ((cid & CID_REV_MASK) <= 0x00020000)) {
-			uint32 *scc, val;
-
-			scc = (uint32 *)((uchar*)regs + OFFSETOF(chipcregs_t, slow_clk_ctl));
-			val = R_REG(scc);
-			SB_ERROR(("    initial scc = 0x%x\n", val));
-			val |= SCC_SS_XTAL;
-			W_REG(scc, val);
-		}
+	static bool ksi_attached = FALSE;
+
+	if (!ksi_attached) {
+		void *regs = (void *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
 
-		if (BCMINIT(sb_doattach)(&ksi, BCM4710_DEVICE_ID, NULL, (void*)regs,
-			SB_BUS, NULL, &unused, &varsz) == NULL) {
+		if (sb_doattach(&ksi, BCM4710_DEVICE_ID, osh, regs,
+		                SB_BUS, NULL,
+		                osh != SB_OSH ? &ksi.vars : NULL,
+		                osh != SB_OSH ? &ksi.varsz : NULL) == NULL) {
+			SB_ERROR(("sb_kattach: sb_doattach failed\n"));
 			return NULL;
 		}
+
+		ksi_attached = TRUE;
 	}
 
-	return &ksi;
+	return &ksi.sb;
 }
-#endif
+#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SB_BUS) */
 
-static void* 
-BCMINITFN(sb_doattach)(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz)
+static sb_info_t *
+BCMINITFN(sb_doattach)(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+                       uint bustype, void *sdh, char **vars, uint *varsz)
 {
 	uint origidx;
 	chipcregs_t *cc;
+	sbconfig_t *sb;
 	uint32 w;
-	int res;
+	char *pvars;
 
 	ASSERT(GOODREGS(regs));
 
-	bzero((uchar*)si, sizeof (sb_info_t));
+	bzero((uchar*)si, sizeof(sb_info_t));
 
-	si->pciidx = si->gpioidx = BADIDX;
+	si->sb.buscoreidx = BADIDX;
 
-	si->osh = osh;
 	si->curmap = regs;
 	si->sdh = sdh;
+	si->osh = osh;
 
 	/* check to see if we are a sb core mimic'ing a pci core */
 	if (bustype == PCI_BUS) {
-		if (OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof (uint32)) == 0xffffffff)
+		if (OSL_PCI_READ_CONFIG(si->osh, PCI_SPROM_CONTROL, sizeof(uint32)) == 0xffffffff) {
+			SB_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SB "
+			          "devid:0x%x\n", __FUNCTION__, devid));
 			bustype = SB_BUS;
-		else
-			bustype = PCI_BUS;
 	}
-
-	si->bustype = bustype;
-	if (si->bustype != BUSTYPE(si->bustype)) {
+	}
+	si->sb.bustype = bustype;
+	if (si->sb.bustype != BUSTYPE(si->sb.bustype)) {
 		SB_ERROR(("sb_doattach: bus type %d does not match configured bus type %d\n",
-			  si->bustype, BUSTYPE(si->bustype)));
+		          si->sb.bustype, BUSTYPE(si->sb.bustype)));
 		return NULL;
 	}
 
 	/* need to set memseg flag for CF card first before any sb registers access */
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS)
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS)
 		si->memseg = TRUE;
 
 	/* kludge to enable the clock on the 4306 which lacks a slowclock */
-	if (BUSTYPE(si->bustype) == PCI_BUS)
-		sb_pwrctl_xtal((void*)si, XTAL|PLL, ON);
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS && !sb_ispcie(si))
+		sb_clkctl_xtal(&si->sb, XTAL|PLL, ON);
 
-	/* initialize current core index value */
-	si->curidx = _sb_coreidx((void*)si);
-	if (si->curidx == BADIDX) {
-		return NULL;
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32));
+		if (!GOODCOREADDR(w, SB_ENUM_BASE))
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32), SB_ENUM_BASE);
 	}
 
-	/* keep and reuse the initial register mapping */
-	origidx = si->curidx;
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		si->regs[origidx] = regs;
 
-	/* is core-0 a chipcommon core? */
-	si->numcores = 1;
-	cc = (chipcregs_t*) sb_setcoreidx((void*)si, 0);
-	if (sb_coreid((void*)si) != SB_CC)
-		cc = NULL;
-
-	/* determine chip id and rev */
-	if (cc) {
-		/* chip common core found! */
-		si->chip = R_REG(&cc->chipid) & CID_ID_MASK;
-		si->chiprev = (R_REG(&cc->chipid) & CID_REV_MASK) >> CID_REV_SHIFT;
-		si->chippkg = (R_REG(&cc->chipid) & CID_PKG_MASK) >> CID_PKG_SHIFT;
-	} else {
-		/* The only pcmcia chip without a chipcommon core is a 4301 */
-		if (BUSTYPE(si->bustype) == PCMCIA_BUS)
-			devid = BCM4301_DEVICE_ID;
-
-		/* no chip common core -- must convert device id to chip id */
-		if ((si->chip = BCMINIT(sb_pcidev2chip)(devid)) == 0) {
-			SB_ERROR(("sb_attach: unrecognized device id 0x%04x\n", devid));
+	/* get sonics backplane revision */
+	sb = REGS2SB(regs);
+	si->sb.sonicsrev = (R_SBREG(si, &sb->sbidlow) & SBIDL_RV_MASK) >> SBIDL_RV_SHIFT;
+
+	/* scan for cores */
+	sb_scan(si, regs, devid);
+
+	/* no cores found, bail out */
+	if (si->numcores == 0) {
+		SB_ERROR(("sb_doattach: could not find any cores\n"));
 			return NULL;
 		}
-	}
 
-	/* get chipcommon rev */
-	si->ccrev = cc ? sb_corerev((void*)si) : NOREV;
+	/* save the current core index */
+	origidx = si->curidx;
 
-	/* determine numcores */
-	if (cc && ((si->ccrev == 4) || (si->ccrev >= 6)))
-		si->numcores = (R_REG(&cc->chipid) & CID_CC_MASK) >> CID_CC_SHIFT;
-	else
-		si->numcores = BCMINIT(sb_chip2numcores)(si->chip);
+	/* don't go beyond if there is no chipc core in the chip */
+	if (!(cc = sb_setcore(&si->sb, SB_CC, 0)))
+		return si;
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS &&
+	    (si->sb.chip == BCM4712_CHIP_ID) &&
+	    (si->sb.chippkg != BCM4712LARGE_PKG_ID) &&
+	    (si->sb.chiprev <= 3))
+		OR_REG(si->osh, &cc->slow_clk_ctl, SCC_SS_XTAL);
+
+	/* fixup necessary chip/core configurations */
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS && sb_pci_fixcfg(si)) {
+		SB_ERROR(("sb_doattach: sb_pci_fixcfg failed\n"));
+		return NULL;
+	}
 
-	/* return to original core */
-	sb_setcoreidx((void*)si, origidx);
 
-	/* sanity checks */
-	ASSERT(si->chip);
+	/* Switch back to the original core, nvram/srom init needs it */
+	sb_setcoreidx(&si->sb, origidx);
 
-	/* scan for cores */
-	BCMINIT(sb_scan)(si);
+	/* Init nvram from flash if it exists */
+	//nvram_init((void *)&si->sb);
 
-	/* srom_var_init() depends on sb_scan() info */
-	if ((res = srom_var_init(si, si->bustype, si->curmap, osh, vars, varsz))) {
-		SB_ERROR(("sb_attach: srom_var_init failed: bad srom\n"));
+	/* Init nvram from sprom/otp if they exist */
+	if (srom_var_init(&si->sb, BUSTYPE(si->sb.bustype), regs, si->osh, vars, varsz)) {
+		SB_ERROR(("sb_doattach: srom_var_init failed: bad srom\n"));
 		return (NULL);
 	}
+	pvars = vars ? *vars : NULL;
 	
-	if (cc == NULL) {
-		/*
-		 * The chip revision number is hardwired into all
-		 * of the pci function config rev fields and is
-		 * independent from the individual core revision numbers.
-		 * For example, the "A0" silicon of each chip is chip rev 0.
-		 * For PCMCIA we get it from the CIS instead.
-		 */
-		if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-			ASSERT(vars);
-			si->chiprev = getintvar(*vars, "chiprev");
-		} else if (BUSTYPE(si->bustype) == PCI_BUS) {
-			w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_REV, sizeof (uint32));
-			si->chiprev = w & 0xff;
-		} else
-			si->chiprev = 0;
+	/* PMU specific initializations */
+	if ((si->sb.cccaps & CC_CAP_PMU) && !sb_onetimeinit) {
+		sb_pmu_init(&si->sb, si->osh);
+		/* Find out Crystal frequency and init PLL */
+		sb_pmu_pll_init(&si->sb, si->osh, getintvar(pvars, "xtalfreq"));
+		/* Initialize PMU resources (up/dn timers, dep masks, etc.) */
+		sb_pmu_res_init(&si->sb, si->osh);
 	}
 
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-		w = getintvar(*vars, "regwindowsz");
+	if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+		w = getintvar(pvars, "regwindowsz");
 		si->memseg = (w <= CFTABLE_REGWIN_2K) ? TRUE : FALSE;
 	}
 
-	/* gpio control core is required */
-	if (!GOODIDX(si->gpioidx)) {
-		SB_ERROR(("sb_attach: gpio control core not found\n"));
-		return NULL;
-	}
-
 	/* get boardtype and boardrev */
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 	case PCI_BUS:
 		/* do a pci config read to get subsystem id and subvendor id */
-		w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_SVID, sizeof (uint32));
-		si->boardvendor = w & 0xffff;
-		si->boardtype = (w >> 16) & 0xffff;
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_SVID, sizeof(uint32));
+		/* Let nvram variables override subsystem Vend/ID */
+		if ((si->sb.boardvendor = (uint16)sb_getdevpathintvar(&si->sb, "boardvendor")) == 0)
+			si->sb.boardvendor = w & 0xffff;
+		else
+			SB_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n",
+			          si->sb.boardvendor, w & 0xffff));
+		if ((si->sb.boardtype = (uint16)sb_getdevpathintvar(&si->sb, "boardtype")) == 0)
+			si->sb.boardtype = (w >> 16) & 0xffff;
+		else
+			SB_ERROR(("Overriding boardtype: 0x%x instead of 0x%x\n",
+			          si->sb.boardtype, (w >> 16) & 0xffff));
 		break;
 
 	case PCMCIA_BUS:
-	case SDIO_BUS:
-		si->boardvendor = getintvar(*vars, "manfid");
-		si->boardtype = getintvar(*vars, "prodid");
+		si->sb.boardvendor = getintvar(pvars, "manfid");
+		si->sb.boardtype = getintvar(pvars, "prodid");
 		break;
 
 	case SB_BUS:
-		si->boardvendor = VENDOR_BROADCOM;
-		si->boardtype = 0xffff;
+	case JTAG_BUS:
+		si->sb.boardvendor = VENDOR_BROADCOM;
+		if (pvars == NULL || ((si->sb.boardtype = getintvar(pvars, "prodid")) == 0))
+			if ((si->sb.boardtype = getintvar(NULL, "boardtype")) == 0)
+				si->sb.boardtype = 0xffff;
 		break;
 	}
 
-	if (si->boardtype == 0) {
-		SB_ERROR(("sb_attach: unknown board type\n"));
-		ASSERT(si->boardtype);
+	if (si->sb.boardtype == 0) {
+		SB_ERROR(("sb_doattach: unknown board type\n"));
+		ASSERT(si->sb.boardtype);
+	}
+
+	si->sb.boardflags = getintvar(pvars, "boardflags");
+
+	/* setup the GPIO based LED powersave register */
+	if (si->sb.ccrev >= 16) {
+		if ((pvars == NULL) || ((w = getintvar(pvars, "leddc")) == 0))
+			w = DEFAULT_GPIOTIMERVAL;
+		sb_corereg(&si->sb, SB_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	}
+
+	/* Determine if this board needs override */
+	if (PCIE(si) && (si->sb.chip == BCM4321_CHIP_ID))
+		si->pcie_war_ovr = ((si->sb.boardvendor == VENDOR_APPLE) &&
+		                    ((uint8)getintvar(pvars, "sromrev") == 4) &&
+		                    ((uint8)getintvar(pvars, "boardrev") <= 0x71)) ||
+		        ((uint32)getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR);
+
+	if (PCIE_ASPMWARS(si)) {
+		sb_war43448_aspm((void *)si);
+		sb_war42767_clkreq((void *)si);
+	}
+
+	if (FORCEHT_WAR32414(si)) {
+		si->sb.pr32414 = TRUE;
+		sb_clkctl_init(&si->sb);
+		sb_war32414_forceHT(&si->sb, 1);
+	}
+
+	if (PCIE(si) && ((si->sb.buscorerev == 6) || (si->sb.buscorerev == 7)))
+		si->sb.pr42780 = TRUE;
+
+	if (PCIE_ASPMWARS(si))
+		sb_pcieclkreq(&si->sb, 1, 0);
+
+	if (PCIE(si) &&
+	    (((si->sb.chip == BCM4311_CHIP_ID) && (si->sb.chiprev == 2)) ||
+	     ((si->sb.chip == BCM4312_CHIP_ID) && (si->sb.chiprev == 0))))
+		sb_set_initiator_to(&si->sb, 0x3, sb_findcoreidx(&si->sb, SB_D11, 0));
+
+	/* Disable gpiopullup and gpiopulldown */
+	if (!sb_onetimeinit && si->sb.ccrev >= 20) {
+		cc = (chipcregs_t *)sb_setcore(&si->sb, SB_CC, 0);
+		W_REG(osh, &cc->gpiopullup, 0);
+		W_REG(osh, &cc->gpiopulldown, 0);
+		sb_setcoreidx(&si->sb, origidx);
 	}
 
 
-	return ((void*)si);
+#ifdef HNDRTE
+	sb_onetimeinit = TRUE;
+#endif
+
+	return (si);
+}
+
+/* Enable/Disable clkreq for PCIE (4311B0/4321B1) */
+void
+BCMINITFN(sb_war42780_clkreq)(sb_t *sbh, bool clkreq)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* Don't change clkreq value if serdespll war has not yet been applied */
+	if (!si->pr42767_war && PCIE_ASPMWARS(si))
+		return;
+
+	sb_pcieclkreq(sbh, 1, (int32)clkreq);
+}
+
+static void
+BCMINITFN(sb_war43448)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	/* Restore the polarity */
+	if (si->pcie_polarity != 0)
+		sb_pcie_mdiowrite((void *)(uintptr)&si->sb, MDIODATA_DEV_RX,
+		                  SERDES_RX_CTRL, si->pcie_polarity);
+}
+
+static void
+BCMINITFN(sb_war43448_aspm)(sb_t *sbh)
+{
+	uint32 w;
+	uint16 val16, *reg16;
+	sbpcieregs_t *pcieregs;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	/* no ASPM stuff on QT or VSIM */
+	if (si->sb.chippkg == HDLSIM_PKG_ID || si->sb.chippkg == HWSIM_PKG_ID)
+		return;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
+
+	/* Enable ASPM in the shadow SROM and Link control */
+	reg16 = &pcieregs->sprom[SRSH_ASPM_OFFSET];
+	val16 = R_REG(si->osh, reg16);
+	if (!si->pcie_war_ovr)
+		val16 |= SRSH_ASPM_ENB;
+	else
+		val16 &= ~SRSH_ASPM_ENB;
+	W_REG(si->osh, reg16, val16);
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+	if (!si->pcie_war_ovr)
+		w |= PCIE_ASPM_ENAB;
+	else
+		w &= ~PCIE_ASPM_ENAB;
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32), w);
+}
+
+static void
+BCMINITFN(sb_war32414_forceHT)(sb_t *sbh, bool forceHT)
+{
+	sb_info_t *si;
+	uint32 val = 0;
+
+	si = SB_INFO(sbh);
+
+	ASSERT(FORCEHT_WAR32414(si));
+
+
+	if (forceHT)
+		val = SYCC_HR;
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, system_clk_ctl),
+	           SYCC_HR, val);
 }
 
 uint
-sb_coreid(void *sbh)
+sb_coreid(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -435,37 +619,57 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
+	return ((R_SBREG(si, &sb->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
 }
 
 uint
-sb_coreidx(void *sbh)
+sb_flag(sb_t *sbh)
 {
 	sb_info_t *si;
+	sbconfig_t *sb;
 
 	si = SB_INFO(sbh);
-	return (si->curidx);
+	sb = REGS2SB(si->curmap);
+
+	return R_SBREG(si, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
 }
 
-/* return current index of core */
-static uint
-_sb_coreidx(void *sbh)
+uint
+sb_coreidx(sb_t *sbh)
 {
 	sb_info_t *si;
-	sbconfig_t *sb;
-	uint32 sbaddr = 0;
 
 	si = SB_INFO(sbh);
-	ASSERT(si);
+	return (si->curidx);
+}
 
-	switch (BUSTYPE(si->bustype)) {
-	case SB_BUS:
-		sb = REGS2SB(si->curmap);
-		sbaddr = sb_base(R_SBREG(sbh, &sb->sbadmatch0));
+/* return core index of the core with address 'sba' */
+static uint
+BCMINITFN(_sb_coreidx)(sb_info_t *si, uint32 sba)
+{
+	uint i;
+
+	for (i = 0; i < si->numcores; i ++)
+		if (sba == si->coresba[i])
+			return i;
+	return BADIDX;
+}
+
+/* return core address of the current core */
+static uint32
+BCMINITFN(_sb_coresba)(sb_info_t *si)
+{
+	uint32 sbaddr;
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case SB_BUS: {
+		sbconfig_t *sb = REGS2SB(si->curmap);
+		sbaddr = sb_base(R_SBREG(si, &sb->sbadmatch0));
 		break;
+	}
 
 	case PCI_BUS:
-		sbaddr = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof (uint32));
+		sbaddr = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof(uint32));
 		break;
 
 	case PCMCIA_BUS: {
@@ -470,27 +674,33 @@
 
 	case PCMCIA_BUS: {
 		uint8 tmp = 0;
-
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR0, &tmp, 1);
-		sbaddr  = (uint)tmp << 12;
+		sbaddr  = (uint32)tmp << 12;
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR1, &tmp, 1);
-		sbaddr |= (uint)tmp << 16;
+		sbaddr |= (uint32)tmp << 16;
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_ADDR2, &tmp, 1);
-		sbaddr |= (uint)tmp << 24;
+		sbaddr |= (uint32)tmp << 24;
 		break;
 	}
+
+
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		sbaddr = (uint32)(uintptr)si->curmap;
+		break;
+#endif	/* BCMJTAG */
+
 	default:
-		ASSERT(0);
+		sbaddr = BADCOREADDR;
+		break;
 	}
 
-	if (!GOODCOREADDR(sbaddr))
-		return BADIDX;
-
-	return ((sbaddr - SB_ENUM_BASE) / SB_CORE_SIZE);
+	SB_MSG(("_sb_coresba: current core is 0x%08x\n", sbaddr));
+	return sbaddr;
 }
 
 uint
-sb_corevendor(void *sbh)
+sb_corevendor(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -498,23 +708,25 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
+	return ((R_SBREG(si, &sb->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
 }
 
 uint
-sb_corerev(void *sbh)
+sb_corerev(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
+	uint sbidh;
 
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
+	sbidh = R_SBREG(si, &sb->sbidhigh);
 
-	return (R_SBREG(sbh, &(sb)->sbidhigh) & SBIDH_RC_MASK);
+	return (SBCOREREV(sbidh));
 }
 
 void *
-sb_osh(void *sbh)
+sb_osh(sb_t *sbh)
 {
 	sb_info_t *si;
 
@@ -522,11 +734,40 @@
 	return si->osh;
 }
 
-#define	SBTML_ALLOW	(SBTML_PE | SBTML_FGC | SBTML_FL_MASK)
+void
+sb_setosh(sb_t *sbh, osl_t *osh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	if (si->osh != NULL) {
+		SB_ERROR(("osh is already set....\n"));
+		ASSERT(!si->osh);
+	}
+	si->osh = osh;
+}
+
+/* set sbtmstatelow core-specific flags */
+void
+sb_coreflags_wo(sb_t *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint32 w;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	ASSERT((val & ~mask) == 0);
+
+	/* mask and set */
+	w = (R_SBREG(si, &sb->sbtmstatelow) & ~mask) | val;
+	W_SBREG(si, &sb->sbtmstatelow, w);
+}
 
 /* set/clear sbtmstatelow core-specific flags */
 uint32
-sb_coreflags(void *sbh, uint32 mask, uint32 val)
+sb_coreflags(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -536,21 +777,22 @@
 	sb = REGS2SB(si->curmap);
 
 	ASSERT((val & ~mask) == 0);
-	ASSERT((mask & ~SBTML_ALLOW) == 0);
 
 	/* mask and set */
 	if (mask || val) {
-		w = (R_SBREG(sbh, &sb->sbtmstatelow) & ~mask) | val;
-		W_SBREG(sbh, &sb->sbtmstatelow, w);
+		w = (R_SBREG(si, &sb->sbtmstatelow) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatelow, w);
 	}
 
-	/* return the new value */
-	return (R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_ALLOW);
+	/* return the new value
+	 * for write operation, the following readback ensures the completion of write opration.
+	 */
+	return (R_SBREG(si, &sb->sbtmstatelow));
 }
 
 /* set/clear sbtmstatehigh core-specific flags */
 uint32
-sb_coreflagshi(void *sbh, uint32 mask, uint32 val)
+sb_coreflagshi(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -564,16 +806,41 @@
 
 	/* mask and set */
 	if (mask || val) {
-		w = (R_SBREG(sbh, &sb->sbtmstatehigh) & ~mask) | val;
-		W_SBREG(sbh, &sb->sbtmstatehigh, w);
+		w = (R_SBREG(si, &sb->sbtmstatehigh) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatehigh, w);
 	}
 
 	/* return the new value */
-	return (R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_FL_MASK);
+	return (R_SBREG(si, &sb->sbtmstatehigh));
+}
+
+/* Run bist on current core. Caller needs to take care of core-specific bist hazards */
+int
+sb_corebist(sb_t *sbh)
+{
+	uint32 sblo;
+	sb_info_t *si;
+	sbconfig_t *sb;
+	int result = 0;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	sblo = R_SBREG(si, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (sblo | SBTML_FGC | SBTML_BE));
+
+	SPINWAIT(((R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BISTD) == 0), 100000);
+
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BISTF)
+		result = BCME_ERROR;
+
+	W_SBREG(si, &sb->sbtmstatelow, sblo);
+
+	return result;
 }
 
 bool
-sb_iscoreup(void *sbh)
+sb_iscoreup(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -581,7 +848,8 @@
 	si = SB_INFO(sbh);
 	sb = REGS2SB(si->curmap);
 
-	return ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK);
+	return ((R_SBREG(si, &sb->sbtmstatelow) &
+	         (SBTML_RESET | SBTML_REJ_MASK | SBTML_CLK)) == SBTML_CLK);
 }
 
 /*
@@ -587,172 +855,554 @@
 /*
  * Switch to 'coreidx', issue a single arbitrary 32bit register mask&set operation,
  * switch back to the original core, and return the new value.
+ *
+ * When using the silicon backplane, no fidleing with interrupts or core switches are needed.
+ *
+ * Also, when using pci/pcie, we can optimize away the core switching for pci registers
+ * and (on newer pci cores) chipcommon registers.
  */
-static uint
-sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val)
+uint
+sb_corereg(sb_t *sbh, uint coreidx, uint regoff, uint mask, uint val)
 {
-	sb_info_t *si;
-	uint origidx;
-	uint32 *r;
+	uint origidx = 0;
+	uint32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
+	bool fast = FALSE;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
 
 	ASSERT(GOODIDX(coreidx));
 	ASSERT(regoff < SB_CORE_SIZE);
 	ASSERT((val & ~mask) == 0);
 
-	si = SB_INFO(sbh);
+	if (BUSTYPE(si->sb.bustype) == SB_BUS) {
+		/* If internal bus, we can always get at everything */
+		fast = TRUE;
+		/* map if does not exist */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void*)REG_MAP(si->coresba[coreidx],
+			                                   SB_CORE_SIZE);
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		r = (uint32 *)((uchar *)si->regs[coreidx] + regoff);
+	} else if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		/* If pci/pcie, we can get at pci/pcie regs and on newer cores to chipc */
+
+		if ((si->coreid[coreidx] == SB_CC) &&
+		    ((si->sb.buscoretype == SB_PCIE) ||
+		     (si->sb.buscorerev >= 13))) {
+			/* Chipc registers are mapped at 12KB */
+
+			fast = TRUE;
+			r = (uint32 *)((char *)si->curmap + PCI_16KB0_CCREGS_OFFSET + regoff);
+		} else if (si->sb.buscoreidx == coreidx) {
+			/* pci registers are at either in the last 2KB of an 8KB window
+			 * or, in pcie and pci rev 13 at 8KB
+			 */
+			fast = TRUE;
+			if ((si->sb.buscoretype == SB_PCIE) ||
+			    (si->sb.buscorerev >= 13))
+				r = (uint32 *)((char *)si->curmap +
+				               PCI_16KB0_PCIREGS_OFFSET + regoff);
+			else
+				r = (uint32 *)((char *)si->curmap +
+				               ((regoff >= SBCONFIGOFF) ?
+				                PCI_BAR0_PCISBR_OFFSET : PCI_BAR0_PCIREGS_OFFSET) +
+				               regoff);
+		}
+	}
 
+	if (!fast) {
 	INTR_OFF(si, intr_val);
 
 	/* save current core index */
-	origidx = sb_coreidx(sbh);
+		origidx = sb_coreidx(&si->sb);
 
 	/* switch core */
-	r = (uint32*) ((uchar*) sb_setcoreidx(sbh, coreidx) + regoff);
+		r = (uint32*) ((uchar*) sb_setcoreidx(&si->sb, coreidx) + regoff);
+	}
+	ASSERT(r);
 
 	/* mask and set */
 	if (mask || val) {
 		if (regoff >= SBCONFIGOFF) {
-			w = (R_SBREG(sbh, r) & ~mask) | val;
-			W_SBREG(sbh, r, w);
+			w = (R_SBREG(si, r) & ~mask) | val;
+			W_SBREG(si, r, w);
 		} else {
-			w = (R_REG(r) & ~mask) | val;
-			W_REG(r, w);
+			w = (R_REG(si->osh, r) & ~mask) | val;
+			W_REG(si->osh, r, w);
 		}
 	}
 
 	/* readback */
 	if (regoff >= SBCONFIGOFF)
-		w = R_SBREG(sbh, r);
-	else
-		w = R_REG(r);
+		w = R_SBREG(si, r);
+	else {
+#if defined(CONFIG_BCM5354)
+		if ((si->sb.chip == BCM5354_CHIP_ID) &&
+		    (coreidx == SB_CC_IDX) &&
+		    (regoff == OFFSETOF(chipcregs_t, watchdog))) {
+			w = val;
+		} else
+#endif	/* BCM5354 */
+			w = R_REG(si->osh, r);
+	}
 
+	if (!fast) {
 	/* restore core index */
 	if (origidx != coreidx)
-		sb_setcoreidx(sbh, origidx);
+			sb_setcoreidx(&si->sb, origidx);
 
 	INTR_RESTORE(si, intr_val);
+	}
+
 	return (w);
 }
 
-/* scan the sb enumerated space to identify all cores */
-static void
-BCMINITFN(sb_scan)(sb_info_t *si)
+#define DWORD_ALIGN(x)  (x & ~(0x03))
+#define BYTE_POS(x) (x & 0x3)
+#define WORD_POS(x) (x & 0x1)
+
+#define BYTE_SHIFT(x)  (8 * BYTE_POS(x))
+#define WORD_SHIFT(x)  (16 * WORD_POS(x))
+
+#define BYTE_VAL(a, x) ((a >> BYTE_SHIFT(x)) & 0xFF)
+#define WORD_VAL(a, x) ((a >> WORD_SHIFT(x)) & 0xFFFF)
+
+#define read_pci_cfg_byte(a) \
+	(BYTE_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xff)
+
+#define read_pci_cfg_word(a) \
+	(WORD_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xffff)
+
+
+/* return cap_offset if requested capability exists in the PCI config space */
+static uint8
+sb_find_pci_capability(sb_info_t *si, uint8 req_cap_id, uchar *buf, uint32 *buflen)
 {
-	void *sbh;
-	uint origidx;
-	uint i;
+	uint8 cap_id;
+	uint8 cap_ptr = 0;
+	uint32 	bufsize;
+	uint8 byte_val;
 
-	sbh = (void*) si;
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+	       goto end;
 
-	/* numcores should already be set */
-	ASSERT((si->numcores > 0) && (si->numcores <= SB_MAXCORES));
+	/* check for Header type 0 */
+	byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
+	if ((byte_val & 0x7f) != PCI_HEADER_NORMAL)
+		goto end;
 
-	/* save current core index */
-	origidx = sb_coreidx(sbh);
+	/* check if the capability pointer field exists */
+	byte_val = read_pci_cfg_byte(PCI_CFG_STAT);
+	if (!(byte_val & PCI_CAPPTR_PRESENT))
+		goto end;
 
-	si->pciidx = si->pcmciaidx = si->gpioidx = BADIDX;
-	si->pcirev = si->pcmciarev = NOREV;
+	cap_ptr = read_pci_cfg_byte(PCI_CFG_CAPPTR);
+	/* check if the capability pointer is 0x00 */
+	if (cap_ptr == 0x00)
+		goto end;
 
-	for (i = 0; i < si->numcores; i++) {
-		sb_setcoreidx(sbh, i);
-		si->coreid[i] = sb_coreid(sbh);
+	/* loop thr'u the capability list and see if the pcie capabilty exists */
 
-		if (si->coreid[i] == SB_PCI) {
-			si->pciidx = i;
-			si->pcirev = sb_corerev(sbh);
+	cap_id = read_pci_cfg_byte(cap_ptr);
 
-		} else if (si->coreid[i] == SB_PCMCIA) {
-			si->pcmciaidx = i;
-			si->pcmciarev = sb_corerev(sbh);
+	while (cap_id != req_cap_id) {
+		cap_ptr = read_pci_cfg_byte((cap_ptr+1));
+		if (cap_ptr == 0x00) break;
+		cap_id = read_pci_cfg_byte(cap_ptr);
 		}
+	if (cap_id != req_cap_id) {
+		goto end;
 	}
+	/* found the caller requested capability */
+	if ((buf != NULL) && (buflen != NULL)) {
+		uint8 cap_data;
 
-	/*
-	 * Find the gpio "controlling core" type and index.
-	 * Precedence:
-	 * - if there's a chip common core - use that
-	 * - else if there's a pci core (rev >= 2) - use that
-	 * - else there had better be an extif core (4710 only)
-	 */
-	if (GOODIDX(sb_findcoreidx(sbh, SB_CC, 0))) {
-		si->gpioidx = sb_findcoreidx(sbh, SB_CC, 0);
-		si->gpioid = SB_CC;
-	} else if (GOODIDX(si->pciidx) && (si->pcirev >= 2)) {
-		si->gpioidx = si->pciidx;
-		si->gpioid = SB_PCI;
-	} else if (sb_findcoreidx(sbh, SB_EXTIF, 0)) {
-		si->gpioidx = sb_findcoreidx(sbh, SB_EXTIF, 0);
-		si->gpioid = SB_EXTIF;
-	} else
-		ASSERT(si->gpioidx != BADIDX);
-
-	/* return to original core index */
-	sb_setcoreidx(sbh, origidx);
+		bufsize = *buflen;
+		if (!bufsize) goto end;
+		*buflen = 0;
+		/* copy the cpability data excluding cap ID and next ptr */
+		cap_data = cap_ptr + 2;
+		if ((bufsize + cap_data)  > SZPCR)
+			bufsize = SZPCR - cap_data;
+		*buflen = bufsize;
+		while (bufsize--) {
+			*buf = read_pci_cfg_byte(cap_data);
+			cap_data++;
+			buf++;
+		}
+	}
+end:
+	return cap_ptr;
 }
 
-/* may be called with core in reset */
-void
-sb_detach(void *sbh)
+uint8
+sb_pcieclkreq(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
-	uint idx;
+	uint32 reg_val;
+	uint8 offset;
 
 	si = SB_INFO(sbh);
 
-	if (si == NULL)
-		return;
+	offset = si->pciecap_lcreg_offset;
+	if (!offset)
+		return 0;
 
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		for (idx = 0; idx < SB_MAXCORES; idx++)
-			if (si->regs[idx]) {
-				REG_UNMAP(si->regs[idx]);
-				si->regs[idx] = NULL;
+	reg_val = OSL_PCI_READ_CONFIG(si->osh, offset, sizeof(uint32));
+	/* set operation */
+	if (mask) {
+		if (val)
+			reg_val |= PCIE_CLKREQ_ENAB;
+		else
+			reg_val &= ~PCIE_CLKREQ_ENAB;
+		OSL_PCI_WRITE_CONFIG(si->osh, offset, sizeof(uint32), reg_val);
+		reg_val = OSL_PCI_READ_CONFIG(si->osh, offset, sizeof(uint32));
 			}
-
-	MFREE(si->osh, si, sizeof (sb_info_t));
+	if (reg_val & PCIE_CLKREQ_ENAB)
+		return 1;
+	else
+		return 0;
 }
 
-/* use pci dev id to determine chip id for chips not having a chipcommon core */
-static uint
-BCMINITFN(sb_pcidev2chip)(uint pcidev)
+
+
+/* return TRUE if PCIE capability exists in the pci config space */
+static bool
+sb_ispcie(sb_info_t *si)
 {
-	if ((pcidev >= BCM4710_DEVICE_ID) && (pcidev <= BCM47XX_USB_ID))
-		return (BCM4710_DEVICE_ID);
-	if ((pcidev >= BCM4610_DEVICE_ID) && (pcidev <= BCM4610_USB_ID))
-		return (BCM4610_DEVICE_ID);
-	if ((pcidev >= BCM4402_DEVICE_ID) && (pcidev <= BCM4402_V90_ID))
-		return (BCM4402_DEVICE_ID);
-	if (pcidev == BCM4401_ENET_ID)
-		return (BCM4402_DEVICE_ID);
-	if ((pcidev >= BCM4307_V90_ID) && (pcidev <= BCM4307_D11B_ID))
-		return (BCM4307_DEVICE_ID);
-	if (pcidev == BCM4301_DEVICE_ID)
-		return (BCM4301_DEVICE_ID);
+	uint8 cap_ptr;
 
-	return (0);
+	cap_ptr = sb_find_pci_capability(si, PCI_CAP_PCIECAP_ID, NULL, NULL);
+	if (!cap_ptr)
+	    return FALSE;
+
+	si->pciecap_lcreg_offset = cap_ptr + PCIE_CAP_LINKCTRL_OFFSET;
+
+	return TRUE;
 }
 
-/* convert chip number to number of i/o cores */
-static uint
-BCMINITFN(sb_chip2numcores)(uint chip)
+/* Wake-on-wireless-LAN (WOWL) support functions */
+/* return TRUE if PM capability exists in the pci config space */
+bool
+sb_pci_pmecap(sb_t *sbh)
 {
-	if (chip == 0x4710)
-		return (9);
-	if (chip == 0x4610)
-		return (9);
-	if (chip == 0x4402)
-		return (3);
-	if ((chip == 0x4307) || (chip == 0x4301))
-		return (5);
-	if (chip == 0x4310)
-		return (8);
-	if (chip == 0x4306)	/* < 4306c0 */
+	uint8 cap_ptr;
+	uint32 pmecap;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL || !(PCI(si) || PCIE(si)))
+		return FALSE;
+
+	if (!si->pmecap_offset) {
+		cap_ptr = sb_find_pci_capability(si, PCI_CAP_POWERMGMTCAP_ID, NULL, NULL);
+		if (!cap_ptr)
+			return FALSE;
+
+		si->pmecap_offset = cap_ptr;
+
+		pmecap = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset, sizeof(uint32));
+
+		/* At least one state can generate PME */
+		si->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
+	}
+
+	return (si->pmecap);
+}
+
+/* Enable PME generation and disable clkreq */
+void
+sb_pci_pmeen(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	si = SB_INFO(sbh);
+
+	/* if not pmecapable return */
+	if (!sb_pci_pmecap(sbh))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32));
+	w |= (PME_CSR_PME_EN);
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32), w);
+
+	/* Disable clkreq */
+	if (si->pr42767_war) {
+		sb_pcieclkreq(sbh, 1, 0);
+		si->pr42767_war = FALSE;
+	} else if (si->sb.pr42780) {
+		sb_pcieclkreq(sbh, 1, 1);
+	}
+}
+
+/* Disable PME generation, clear the PME status bit if set and
+ * return TRUE if PME status set
+ */
+bool
+sb_pci_pmeclr(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	bool ret = FALSE;
+
+	si = SB_INFO(sbh);
+
+	if (!sb_pci_pmecap(sbh))
+		return ret;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32));
+
+	SB_ERROR(("sb_pci_pmeclr PMECSR : 0x%x\n", w));
+	ret = (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
+
+	/* PMESTAT is cleared by writing 1 to it */
+	w &= ~(PME_CSR_PME_EN);
+
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pmecap_offset + PME_CSR_OFFSET, sizeof(uint32), w);
+
+	return ret;
+}
+
+/* Scan the enumeration space to find all cores starting from the given
+ * bus 'sbba'. Append coreid and other info to the lists in 'si'. 'sba'
+ * is the default core address at chip POR time and 'regs' is the virtual
+ * address that the default core is mapped at. 'ncores' is the number of
+ * cores expected on bus 'sbba'. It returns the total number of cores
+ * starting from bus 'sbba', inclusive.
+ */
+#define SB_MAXBUSES	2
+static uint
+BCMINITFN(_sb_scan)(sb_info_t *si, uint32 sba, void *regs, uint bus, uint32 sbba, uint numcores)
+{
+	uint next;
+	uint ncc = 0;
+	uint i;
+
+	if (bus >= SB_MAXBUSES) {
+		SB_ERROR(("_sb_scan: bus 0x%08x at level %d is too deep to scan\n", sbba, bus));
+		return 0;
+	}
+	SB_MSG(("_sb_scan: scan bus 0x%08x assume %u cores\n", sbba, numcores));
+
+	/* Scan all cores on the bus starting from core 0.
+	 * Core addresses must be contiguous on each bus.
+	 */
+	for (i = 0, next = si->numcores; i < numcores && next < SB_MAXCORES; i++, next++) {
+		si->coresba[next] = sbba + i * SB_CORE_SIZE;
+
+		/* keep and reuse the initial register mapping */
+		if (BUSTYPE(si->sb.bustype) == SB_BUS && si->coresba[next] == sba) {
+			SB_MSG(("_sb_scan: reuse mapped regs %p for core %u\n", regs, next));
+			si->regs[next] = regs;
+		}
+
+		/* change core to 'next' and read its coreid */
+		si->curmap = _sb_setcoreidx(si, next);
+		si->curidx = next;
+
+		si->coreid[next] = sb_coreid(&si->sb);
+
+		/* core specific processing... */
+		/* chipc on bus SB_ENUM_BASE provides # cores in the chip and lots of
+		 * other stuff.
+		 */
+		if (sbba == SB_ENUM_BASE && si->coreid[next] == SB_CC) {
+			chipcregs_t *cc = (chipcregs_t *)si->curmap;
+
+			/* get chip id and rev */
+			si->sb.chip = R_REG(si->osh, &cc->chipid) & CID_ID_MASK;
+			si->sb.chiprev = (R_REG(si->osh, &cc->chipid) & CID_REV_MASK) >>
+			        CID_REV_SHIFT;
+			si->sb.chippkg = (R_REG(si->osh, &cc->chipid) & CID_PKG_MASK) >>
+			        CID_PKG_SHIFT;
+
+			/* get chipcommon rev */
+			si->sb.ccrev = (int)sb_corerev(&si->sb);
+
+			/* get chipcommon chipstatus */
+			if (si->sb.ccrev >= 11)
+				si->sb.chipst = R_REG(si->osh, &cc->chipstatus);
+
+			/* get chipcommon capabilites */
+			si->sb.cccaps = R_REG(si->osh, &cc->capabilities);
+
+			/* get pmu rev and caps */
+			if ((si->sb.cccaps & CC_CAP_PMU)) {
+				si->sb.pmucaps = R_REG(si->osh, &cc->pmucapabilities);
+				si->sb.pmurev = si->sb.pmucaps & PCAP_REV_MASK;
+			}
+
+			/* determine numcores - this is the total # cores in the chip */
+			if (((si->sb.ccrev == 4) || (si->sb.ccrev >= 6)))
+				numcores = (R_REG(si->osh, &cc->chipid) & CID_CC_MASK) >>
+				        CID_CC_SHIFT;
+			else
+				numcores = sb_chip2numcores(si->sb.chip);
+			SB_MSG(("_sb_scan: there are %u cores in the chip\n", numcores));
+		}
+		/* scan bridged SB(s) and add results to the end of the list */
+		else if (si->coreid[next] == SB_OCP) {
+			sbconfig_t *sb = REGS2SB(si->curmap);
+			uint32 nsbba = R_SBREG(si, &sb->sbadmatch1);
+			uint nsbcc;
+
+			si->numcores = next + 1;
+
+			if ((nsbba & 0xfff00000) != SB_ENUM_BASE)
+				continue;
+			nsbba &= 0xfffff000;
+			if (_sb_coreidx(si, nsbba) != BADIDX)
+				continue;
+
+			nsbcc = (R_SBREG(si, &sb->sbtmstatehigh) & 0x000f0000) >> 16;
+			nsbcc = _sb_scan(si, sba, regs, bus + 1, nsbba, nsbcc);
+			if (sbba == SB_ENUM_BASE)
+				numcores -= nsbcc;
+			ncc += nsbcc;
+		}
+	}
+
+	SB_MSG(("_sb_scan: found %u cores on bus 0x%08x\n", i, sbba));
+
+	si->numcores = i + ncc;
+	return si->numcores;
+}
+
+/* scan the sb enumerated space to identify all cores */
+static void
+BCMINITFN(sb_scan)(sb_info_t *si, void *regs, uint devid)
+{
+	uint origidx;
+	uint32 origsba;
+	uint i;
+	bool pci;
+	bool pcie;
+	uint pciidx;
+	uint pcieidx;
+	uint pcirev;
+	uint pcierev;
+	uint numcores;
+
+	/* Save the current core info and validate it later till we know
+	 * for sure what is good and what is bad.
+	 */
+	origsba = _sb_coresba(si);
+	origidx = BADIDX;
+
+	/* Use devid as initial chipid and we'll update it later in _sb_scan */
+	si->sb.chip = devid;
+
+	/* Support chipcommon-less chips for a little while longer so the old
+	 * sdio host fpga continues to work until we can get the new one working
+	 * reliably. This particular chip has 2 cores - codec/sdio and pci.
+	 */
+	if (devid == SDIOH_FPGA_ID)
+		numcores = 2;
+	/* Expect at least one core on 0x18000000 and it must be chipcommon where
+	 * the core count for the whole chip is kept.
+	 */
+	else
+		numcores = 1;
+
+	/* scan all SB(s) starting from SB_ENUM_BASE */
+	si->numcores = _sb_scan(si, origsba, regs, 0, SB_ENUM_BASE, numcores);
+	if (si->numcores == 0)
+		return;
+
+	/* figure out bus/orignal core idx */
+	si->sb.buscorerev = NOREV;
+	si->sb.buscoreidx = BADIDX;
+
+	pci = pcie = FALSE;
+	pcirev = pcierev = NOREV;
+	pciidx = pcieidx = BADIDX;
+
+	for (i = 0; i < si->numcores; i++) {
+		sb_setcoreidx(&si->sb, i);
+
+		if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+			if (si->coreid[i] == SB_PCI) {
+				pciidx = i;
+				pcirev = sb_corerev(&si->sb);
+				pci = TRUE;
+			} else if (si->coreid[i] == SB_PCIE) {
+				pcieidx = i;
+				pcierev = sb_corerev(&si->sb);
+				pcie = TRUE;
+			}
+		} else if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+			if (si->coreid[i] == SB_PCMCIA) {
+				si->sb.buscorerev = sb_corerev(&si->sb);
+				si->sb.buscoretype = si->coreid[i];
+				si->sb.buscoreidx = i;
+			}
+		}
+
+		/* find the core idx before entering this func. */
+		if (origsba == si->coresba[i])
+			origidx = i;
+	}
+
+	if (pci && pcie) {
+		if (sb_ispcie(si))
+			pci = FALSE;
+		else
+			pcie = FALSE;
+	}
+	if (pci) {
+		si->sb.buscoretype = SB_PCI;
+		si->sb.buscorerev = pcirev;
+		si->sb.buscoreidx = pciidx;
+	} else if (pcie) {
+		si->sb.buscoretype = SB_PCIE;
+		si->sb.buscorerev = pcierev;
+		si->sb.buscoreidx = pcieidx;
+	}
+
+	/* return to the original core */
+	if (origidx != BADIDX)
+		sb_setcoreidx(&si->sb, origidx);
+	ASSERT(origidx != BADIDX);
+}
+
+/* may be called with core in reset */
+void
+sb_detach(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL)
+		return;
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS)
+		for (idx = 0; idx < SB_MAXCORES; idx++)
+			if (si->regs[idx]) {
+				REG_UNMAP(si->regs[idx]);
+				si->regs[idx] = NULL;
+			}
+#if !defined(CONFIG_BCMBUSTYPE) || (BCMBUSTYPE == SB_BUS)
+	if (si != &ksi)
+#endif	/* !BCMBUSTYPE || (BCMBUSTYPE == SB_BUS) */
+		MFREE(si->osh, si, sizeof(sb_info_t));
+}
+
+/* convert chip number to number of i/o cores */
+static uint
+BCMINITFN(sb_chip2numcores)(uint chip)
+{
+	if (chip == BCM4306_CHIP_ID)	/* < 4306c0 */
 		return (6);
-	if (chip == 0x4704)
+	if (chip == BCM4704_CHIP_ID)
 		return (9);
-	if (chip == 0x5365)
+	if (chip == BCM5365_CHIP_ID)
 		return (7);
 
 	SB_ERROR(("sb_chip2numcores: unsupported chip 0x%x\n", chip));
@@ -761,8 +1411,8 @@
 }
 
 /* return index of coreid or BADIDX if not found */
-static uint
-sb_findcoreidx(void *sbh, uint coreid, uint coreunit)
+uint
+sb_findcoreidx(sb_t *sbh, uint coreid, uint coreunit)
 {
 	sb_info_t *si;
 	uint found;
@@ -787,11 +1438,9 @@
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
 void*
-sb_setcoreidx(void *sbh, uint coreidx)
+sb_setcoreidx(sb_t *sbh, uint coreidx)
 {
 	sb_info_t *si;
-	uint32 sbaddr;
-	uint8 tmp;
 
 	si = SB_INFO(sbh);
 
@@ -804,36 +1453,66 @@
 	 */
 	ASSERT((si->intrsenabled_fn == NULL) || !(*(si)->intrsenabled_fn)((si)->intr_arg));
 
-	sbaddr = SB_ENUM_BASE + (coreidx * SB_CORE_SIZE);
+	si->curmap = _sb_setcoreidx(si, coreidx);
+	si->curidx = coreidx;
+
+	return (si->curmap);
+}
+
+/* This function changes the logical "focus" to the indiciated core.
+ * Return the current core's virtual address.
+ */
+static void *
+_sb_setcoreidx(sb_info_t *si, uint coreidx)
+{
+	uint32 sbaddr = si->coresba[coreidx];
+	void *regs;
 
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 	case SB_BUS:
 		/* map new one */
 		if (!si->regs[coreidx]) {
 			si->regs[coreidx] = (void*)REG_MAP(sbaddr, SB_CORE_SIZE);
 			ASSERT(GOODREGS(si->regs[coreidx]));
 		}
-		si->curmap = si->regs[coreidx];
+		regs = si->regs[coreidx];
 		break;
 
 	case PCI_BUS:
 		/* point bar0 window */
 		OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, 4, sbaddr);
+		regs = si->curmap;
 		break;
 
-	case PCMCIA_BUS:
-		tmp = (sbaddr >> 12) & 0x0f;
+	case PCMCIA_BUS: {
+		uint8 tmp = (sbaddr >> 12) & 0x0f;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR0, &tmp, 1);
 		tmp = (sbaddr >> 16) & 0xff;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR1, &tmp, 1);
 		tmp = (sbaddr >> 24) & 0xff;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_ADDR2, &tmp, 1);
+		regs = si->curmap;
 		break;
 	}
 
-	si->curidx = coreidx;
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		/* map new one */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void *)(uintptr)sbaddr;
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		regs = si->regs[coreidx];
+		break;
+#endif	/* BCMJTAG */
 
-	return (si->curmap);
+	default:
+		ASSERT(0);
+		regs = NULL;
+		break;
+	}
+
+	return regs;
 }
 
 /* 
@@ -842,13 +1521,10 @@
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
 void*
-sb_setcore(void *sbh, uint coreid, uint coreunit)
+sb_setcore(sb_t *sbh, uint coreid, uint coreunit)
 {
-	sb_info_t *si;
 	uint idx;
 
-	si = SB_INFO(sbh);
-
 	idx = sb_findcoreidx(sbh, coreid, coreunit);
 	if (!GOODIDX(idx))
 		return (NULL);
@@ -858,140 +1534,175 @@
 
 /* return chip number */
 uint
-BCMINITFN(sb_chip)(void *sbh)
+BCMINITFN(sb_chip)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chip);
+	return (si->sb.chip);
 }
 
 /* return chip revision number */
 uint
-BCMINITFN(sb_chiprev)(void *sbh)
+BCMINITFN(sb_chiprev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chiprev);
+	return (si->sb.chiprev);
 }
 
 /* return chip common revision number */
 uint
-BCMINITFN(sb_chipcrev)(void *sbh)
+BCMINITFN(sb_chipcrev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->ccrev);
+	return (si->sb.ccrev);
 }
 
 /* return chip package option */
 uint
-BCMINITFN(sb_chippkg)(void *sbh)
+BCMINITFN(sb_chippkg)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->chippkg);
+	return (si->sb.chippkg);
 }
 
 /* return PCI core rev. */
 uint
-BCMINITFN(sb_pcirev)(void *sbh)
+BCMINITFN(sb_pcirev)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.buscorerev);
+}
+
+bool
+BCMINITFN(sb_war16165)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->pcirev);
+
+	return (PCI(si) && (si->sb.buscorerev <= 10));
+}
+
+static void
+BCMINITFN(sb_war30841)(sb_info_t *si)
+{
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_TIMER1, 0x8128);
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_CDR, 0x0100);
+	sb_pcie_mdiowrite(si, MDIODATA_DEV_RX, SERDES_RX_CDRBW, 0x1466);
 }
 
 /* return PCMCIA core rev. */
 uint
-BCMINITFN(sb_pcmciarev)(void *sbh)
+BCMINITFN(sb_pcmciarev)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->pcmciarev);
+	return (si->sb.buscorerev);
 }
 
 /* return board vendor id */
 uint
-BCMINITFN(sb_boardvendor)(void *sbh)
+BCMINITFN(sb_boardvendor)(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->boardvendor);
+	return (si->sb.boardvendor);
 }
 
 /* return boardtype */
 uint
-BCMINITFN(sb_boardtype)(void *sbh)
+BCMINITFN(sb_boardtype)(sb_t *sbh)
 {
 	sb_info_t *si;
 	char *var;
 
 	si = SB_INFO(sbh);
 
-	if (BUSTYPE(si->bustype) == SB_BUS && si->boardtype == 0xffff) {
+	if (BUSTYPE(si->sb.bustype) == SB_BUS && si->sb.boardtype == 0xffff) {
 		/* boardtype format is a hex string */
-		si->boardtype = getintvar(NULL, "boardtype");
+		si->sb.boardtype = getintvar(NULL, "boardtype");
 
 		/* backward compatibility for older boardtype string format */
-		if ((si->boardtype == 0) && (var = getvar(NULL, "boardtype"))) {
+		if ((si->sb.boardtype == 0) && (var = getvar(NULL, "boardtype"))) {
 			if (!strcmp(var, "bcm94710dev"))
-				si->boardtype = BCM94710D_BOARD;
+				si->sb.boardtype = BCM94710D_BOARD;
 			else if (!strcmp(var, "bcm94710ap"))
-				si->boardtype = BCM94710AP_BOARD;
-			else if (!strcmp(var, "bcm94310u"))
-				si->boardtype = BCM94310U_BOARD;
-			else if (!strcmp(var, "bu4711"))
-				si->boardtype = BU4711_BOARD;
+				si->sb.boardtype = BCM94710AP_BOARD;
 			else if (!strcmp(var, "bu4710"))
-				si->boardtype = BU4710_BOARD;
+				si->sb.boardtype = BU4710_BOARD;
 			else if (!strcmp(var, "bcm94702mn"))
-				si->boardtype = BCM94702MN_BOARD;
+				si->sb.boardtype = BCM94702MN_BOARD;
 			else if (!strcmp(var, "bcm94710r1"))
-				si->boardtype = BCM94710R1_BOARD;
+				si->sb.boardtype = BCM94710R1_BOARD;
 			else if (!strcmp(var, "bcm94710r4"))
-				si->boardtype = BCM94710R4_BOARD;
+				si->sb.boardtype = BCM94710R4_BOARD;
 			else if (!strcmp(var, "bcm94702cpci"))
-				si->boardtype = BCM94702CPCI_BOARD;
+				si->sb.boardtype = BCM94702CPCI_BOARD;
 			else if (!strcmp(var, "bcm95380_rr"))
-				si->boardtype = BCM95380RR_BOARD;
+				si->sb.boardtype = BCM95380RR_BOARD;
 		}
 	}
 
-	return (si->boardtype);
+	return (si->sb.boardtype);
+}
+
+/* return bus type of sbh device */
+uint
+sb_bus(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.bustype);
 }
 
-/* return bus type of sdh device */
+/* return bus core type */
 uint
-sb_bus(void *sbh)
+sb_buscoretype(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
-	return (si->bustype);
+
+	return (si->sb.buscoretype);
+}
+
+/* return bus core revision */
+uint
+sb_buscorerev(sb_t *sbh)
+{
+	sb_info_t *si;
+	si = SB_INFO(sbh);
+
+	return (si->sb.buscorerev);
 }
 
 /* return list of found cores */
 uint
-sb_corelist(void *sbh, uint coreid[])
+sb_corelist(sb_t *sbh, uint coreid[])
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
 
-	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof (uint)));
+	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof(uint)));
 	return (si->numcores);
 }
 
 /* return current register mapping */
 void *
-sb_coreregs(void *sbh)
+sb_coreregs(sb_t *sbh)
 {
 	sb_info_t *si;
 
@@ -1001,10 +1712,148 @@
 	return (si->curmap);
 }
 
+#if defined(CONFIG_BCMDBG_ASSERT)
+/* traverse all cores to find and clear source of serror */
+static void
+sb_serr_clear(sb_info_t *si)
+{
+	sbconfig_t *sb;
+	uint origidx;
+	uint i, intr_val = 0;
+	void * corereg = NULL;
+
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(&si->sb);
+
+	for (i = 0; i < si->numcores; i++) {
+		corereg = sb_setcoreidx(&si->sb, i);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+			if ((R_SBREG(si, &sb->sbtmstatehigh)) & SBTMH_SERR) {
+				AND_SBREG(si, &sb->sbtmstatehigh, ~SBTMH_SERR);
+				SB_ERROR(("sb_serr_clear: SError at core 0x%x\n",
+				          sb_coreid(&si->sb)));
+			}
+		}
+	}
+
+	sb_setcoreidx(&si->sb, origidx);
+	INTR_RESTORE(si, intr_val);
+}
+
+/*
+ * Check if any inband, outband or timeout errors has happened and clear them.
+ * Must be called with chip clk on !
+ */
+bool
+sb_taclear(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint origidx;
+	uint intr_val = 0;
+	bool rc = FALSE;
+	uint32 inband = 0, serror = 0, timeout = 0;
+	void *corereg = NULL;
+	volatile uint32 imstate, tmstate;
+
+	si = SB_INFO(sbh);
+
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		volatile uint32 stcmd;
+
+		/* inband error is Target abort for PCI */
+		stcmd = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_CMD, sizeof(uint32));
+		inband = stcmd & PCI_CFG_CMD_STAT_TA;
+		if (inband) {
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_CFG_CMD, sizeof(uint32), stcmd);
+		}
+
+		/* serror */
+		stcmd = OSL_PCI_READ_CONFIG(si->osh, PCI_INT_STATUS, sizeof(uint32));
+		serror = stcmd & PCI_SBIM_STATUS_SERR;
+		if (serror) {
+			sb_serr_clear(si);
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_INT_STATUS, sizeof(uint32), stcmd);
+		}
+
+		/* timeout */
+		imstate = sb_corereg(sbh, si->sb.buscoreidx,
+		                     SBCONFIGOFF + OFFSETOF(sbconfig_t, sbimstate), 0, 0);
+		if ((imstate != 0xffffffff) && (imstate & (SBIM_IBE | SBIM_TO))) {
+			sb_corereg(sbh, si->sb.buscoreidx,
+			           SBCONFIGOFF + OFFSETOF(sbconfig_t, sbimstate), ~0,
+			           (imstate & ~(SBIM_IBE | SBIM_TO)));
+			/* inband = imstate & SBIM_IBE; same as TA above */
+			timeout = imstate & SBIM_TO;
+			if (timeout) {
+			}
+		}
+
+		if (inband) {
+			/* dump errlog for sonics >= 2.3 */
+			if (si->sb.sonicsrev == SONICS_2_2)
+				;
+			else {
+				uint32 imerrlog, imerrloga;
+				imerrlog = sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOG, 0, 0);
+				if (imerrlog & SBTMEL_EC) {
+					imerrloga = sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOGA,
+						0, 0);
+					/* clear errlog */
+					sb_corereg(sbh, si->sb.buscoreidx, SBIMERRLOG, ~0, 0);
+					SB_ERROR(("sb_taclear: ImErrLog 0x%x, ImErrLogA 0x%x\n",
+						imerrlog, imerrloga));
+				}
+			}
+		}
+
+
+	} else if (BUSTYPE(si->sb.bustype) == PCMCIA_BUS) {
+
+		INTR_OFF(si, intr_val);
+		origidx = sb_coreidx(sbh);
+
+		corereg = sb_setcore(sbh, SB_PCMCIA, 0);
+		if (NULL != corereg) {
+			sb = REGS2SB(corereg);
+
+			imstate = R_SBREG(si, &sb->sbimstate);
+			/* handle surprise removal */
+			if ((imstate != 0xffffffff) && (imstate & (SBIM_IBE | SBIM_TO))) {
+				AND_SBREG(si, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+				inband = imstate & SBIM_IBE;
+				timeout = imstate & SBIM_TO;
+			}
+			tmstate = R_SBREG(si, &sb->sbtmstatehigh);
+			if ((tmstate != 0xffffffff) && (tmstate & SBTMH_INT_STATUS)) {
+				if (!inband) {
+					serror = 1;
+					sb_serr_clear(si);
+				}
+				OR_SBREG(si, &sb->sbtmstatelow, SBTML_INT_ACK);
+				AND_SBREG(si, &sb->sbtmstatelow, ~SBTML_INT_ACK);
+			}
+		}
+		sb_setcoreidx(sbh, origidx);
+		INTR_RESTORE(si, intr_val);
+
+	}
+
+
+	if (inband | timeout | serror) {
+		rc = TRUE;
+		SB_ERROR(("sb_taclear: inband 0x%x, serror 0x%x, timeout 0x%x!\n",
+		          inband, serror, timeout));
+	}
+
+	return (rc);
+}
+#endif	
 
 /* do buffered registers update */
 void
-sb_commit(void *sbh)
+sb_commit(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1018,30 +1867,33 @@
 	INTR_OFF(si, intr_val);
 
 	/* switch over to chipcommon core if there is one, else use pci */
-	if (si->ccrev != NOREV) {
+	if (si->sb.ccrev != NOREV) {
 		chipcregs_t *ccregs = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
 
 		/* do the buffer registers update */
-		W_REG(&ccregs->broadcastaddress, SB_COMMIT);
-		W_REG(&ccregs->broadcastdata, 0x0);
-	} else if (si->pciidx != BADIDX) {
+		W_REG(si->osh, &ccregs->broadcastaddress, SB_COMMIT);
+		W_REG(si->osh, &ccregs->broadcastdata, 0x0);
+	} else if (PCI(si)) {
 		sbpciregs_t *pciregs = (sbpciregs_t *)sb_setcore(sbh, SB_PCI, 0);
 
 		/* do the buffer registers update */
-		W_REG(&pciregs->bcastaddr, SB_COMMIT);
-		W_REG(&pciregs->bcastdata, 0x0);
-	} else {
-		ASSERT((si->ccrev != NOREV) && (si->pciidx != BADIDX));
-	}
+		W_REG(si->osh, &pciregs->bcastaddr, SB_COMMIT);
+		W_REG(si->osh, &pciregs->bcastdata, 0x0);
+	} else
+		ASSERT(0);
 
 	/* restore core index */
 	sb_setcoreidx(sbh, origidx);
 	INTR_RESTORE(si, intr_val);
 }
 
-/* reset and re-enable a core */
+/* reset and re-enable a core
+ * inputs:
+ * bits - core specific bits that are set during and after reset sequence
+ * resetbits - core specific bits that are set only during reset sequence
+ */
 void
-sb_core_reset(void *sbh, uint32 bits)
+sb_core_reset(sb_t *sbh, uint32 bits, uint32 resetbits)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -1054,158 +1906,346 @@
 	/*
 	 * Must do the disable sequence first to work for arbitrary current core state.
 	 */
-	sb_core_disable(sbh, bits);
+	sb_core_disable(sbh, (bits | resetbits));
 
 	/*
 	 * Now do the initialization sequence.
 	 */
 
 	/* set reset while enabling the clock and forcing them on throughout the core */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | SBTML_RESET | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
-
-	if (sb_coreid(sbh) == SB_ILINE100) {
-		bcm_mdelay(50);
-	} else {
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | SBTML_RESET | bits | resetbits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 		OSL_DELAY(1);
-	}
 
-	if (R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_SERR) {
-		W_SBREG(sbh, &sb->sbtmstatehigh, 0);
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_SERR) {
+		W_SBREG(si, &sb->sbtmstatehigh, 0);
 	}
-	if ((dummy = R_SBREG(sbh, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
-		AND_SBREG(sbh, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+	if ((dummy = R_SBREG(si, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
+		AND_SBREG(si, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
 	}
 
 	/* clear reset and allow it to propagate throughout the core */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
 
 	/* leave clock enabled */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_CLK | bits));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
 }
 
 void
-sb_core_tofixup(void *sbh)
+sb_core_tofixup(sb_t *sbh)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
 
 	si = SB_INFO(sbh);
 
-	if ((si->pciidx == BADIDX) || (si->pcirev >= 5))
+	if ((BUSTYPE(si->sb.bustype) != PCI_BUS) || PCIE(si) ||
+	    (PCI(si) && (si->sb.buscorerev >= 5)))
 		return;
 
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
 
-	if (BUSTYPE(si->bustype) == SB_BUS) {
-		SET_SBREG(sbh, &sb->sbimconfiglow,
+	if (BUSTYPE(si->sb.bustype) == SB_BUS) {
+		SET_SBREG(si, &sb->sbimconfiglow,
 			  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 			  (0x5 << SBIMCL_RTO_SHIFT) | 0x3);
 	} else {
 		if (sb_coreid(sbh) == SB_PCI) {
-			SET_SBREG(sbh, &sb->sbimconfiglow,
+			SET_SBREG(si, &sb->sbimconfiglow,
 				  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 				  (0x3 << SBIMCL_RTO_SHIFT) | 0x2);
 		} else {
-			SET_SBREG(sbh, &sb->sbimconfiglow, (SBIMCL_RTO_MASK | SBIMCL_STO_MASK), 0);
+			SET_SBREG(si, &sb->sbimconfiglow, (SBIMCL_RTO_MASK | SBIMCL_STO_MASK), 0);
 		}
 	}
 
 	sb_commit(sbh);
 }
 
-void
-sb_core_disable(void *sbh, uint32 bits)
-{
-	sb_info_t *si;
-	volatile uint32 dummy;
-	sbconfig_t *sb;
+/*
+ * Set the initiator timeout for the "master core".
+ * The master core is defined to be the core in control
+ * of the chip and so it issues accesses to non-memory
+ * locations (Because of dma *any* core can access memeory).
+ *
+ * The routine uses the bus to decide who is the master:
+ *	SB_BUS => mips
+ *	JTAG_BUS => chipc
+ *	PCI_BUS => pci or pcie
+ *	PCMCIA_BUS => pcmcia
+ *	SDIO_BUS => pcmcia
+ *
+ * This routine exists so callers can disable initiator
+ * timeouts so accesses to very slow devices like otp
+ * won't cause an abort. The routine allows arbitrary
+ * settings of the service and request timeouts, though.
+ *
+ * Returns the timeout state before changing it or -1
+ * on error.
+ */
 
-	si = SB_INFO(sbh);
+#define	TO_MASK	(SBIMCL_RTO_MASK | SBIMCL_STO_MASK)
+
+uint32
+sb_set_initiator_to(sb_t *sbh, uint32 to, uint idx)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+	uint32 tmp, ret = 0xffffffff;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+
+	if ((to & ~TO_MASK) != 0)
+		return ret;
+
+	/* Figure out the master core */
+	if (idx == BADIDX) {
+		switch (BUSTYPE(si->sb.bustype)) {
+		case PCI_BUS:
+			idx = si->sb.buscoreidx;
+			break;
+		case JTAG_BUS:
+			idx = SB_CC_IDX;
+			break;
+		case PCMCIA_BUS:
+			idx = sb_findcoreidx(sbh, SB_PCMCIA, 0);
+			break;
+		case SB_BUS:
+			idx = sb_findcoreidx(sbh, SB_MIPS33, 0);
+			break;
+		default:
+			ASSERT(0);
+		}
+		if (idx == BADIDX)
+			return ret;
+	}
+
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(sbh);
+
+	sb = REGS2SB(sb_setcoreidx(sbh, idx));
+
+	tmp = R_SBREG(si, &sb->sbimconfiglow);
+	ret = tmp & TO_MASK;
+	W_SBREG(si, &sb->sbimconfiglow, (tmp & ~TO_MASK) | to);
+
+	sb_commit(sbh);
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return ret;
+}
+
+void
+sb_core_disable(sb_t *sbh, uint32 bits)
+{
+	sb_info_t *si;
+	volatile uint32 dummy;
+	uint32 rej;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
 
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
 
 	/* if core is already in reset, just return */
-	if (R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_RESET)
+	if (R_SBREG(si, &sb->sbtmstatelow) & SBTML_RESET)
 		return;
 
+	/* reject value changed between sonics 2.2 and 2.3 */
+	if (si->sb.sonicsrev == SONICS_2_2)
+		rej = (1 << SBTML_REJ_SHIFT);
+	else
+		rej = (2 << SBTML_REJ_SHIFT);
+
 	/* if clocks are not enabled, put into reset and return */
-	if ((R_SBREG(sbh, &sb->sbtmstatelow) & SBTML_CLK) == 0)
+	if ((R_SBREG(si, &sb->sbtmstatelow) & SBTML_CLK) == 0)
 		goto disable;
 
-	/* set the target reject bit and spin until busy is clear */
-	W_SBREG(sbh, &sb->sbtmstatelow, (SBTML_CLK | SBTML_REJ));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	/* set target reject and spin until busy is clear (preserve core-specific bits) */
+	OR_SBREG(si, &sb->sbtmstatelow, rej);
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(1);
-	SPINWAIT((R_SBREG(sbh, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
-
- 	if (R_SBREG(sbh, &sb->sbidlow) & SBIDL_INIT) {
-		OR_SBREG(sbh, &sb->sbimstate, SBIM_RJ);
-		dummy = R_SBREG(sbh, &sb->sbimstate);
+	SPINWAIT((R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BUSY)
+		SB_ERROR(("%s: target state still busy\n", __FUNCTION__));
+
+	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT) {
+		OR_SBREG(si, &sb->sbimstate, SBIM_RJ);
+		dummy = R_SBREG(si, &sb->sbimstate);
 		OSL_DELAY(1);
-		SPINWAIT((R_SBREG(sbh, &sb->sbimstate) & SBIM_BY), 100000);
+		SPINWAIT((R_SBREG(si, &sb->sbimstate) & SBIM_BY), 100000);
 	}
 
 	/* set reset and reject while enabling the clocks */
-	W_SBREG(sbh, &sb->sbtmstatelow, (bits | SBTML_FGC | SBTML_CLK | SBTML_REJ | SBTML_RESET));
-	dummy = R_SBREG(sbh, &sb->sbtmstatelow);
+	W_SBREG(si, &sb->sbtmstatelow, (bits | SBTML_FGC | SBTML_CLK | rej | SBTML_RESET));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
 	OSL_DELAY(10);
 
 	/* don't forget to clear the initiator reject bit */
-	if (R_SBREG(sbh, &sb->sbidlow) & SBIDL_INIT)
-		AND_SBREG(sbh, &sb->sbimstate, ~SBIM_RJ);
+	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT)
+		AND_SBREG(si, &sb->sbimstate, ~SBIM_RJ);
 
 disable:
 	/* leave reset and reject asserted */
-	W_SBREG(sbh, &sb->sbtmstatelow, (bits | SBTML_REJ | SBTML_RESET));
+	W_SBREG(si, &sb->sbtmstatelow, (bits | rej | SBTML_RESET));
 	OSL_DELAY(1);
 }
 
+/* set chip watchdog reset timer to fire in 'ticks' backplane cycles */
 void
-sb_watchdog(void *sbh, uint ticks)
+sb_watchdog(sb_t *sbh, uint ticks)
 {
-	sb_info_t *si = SB_INFO(sbh);
+	/* make sure we come up in fast clock mode; or if clearing, clear clock */
+	if (ticks)
+		sb_clkctl_clk(sbh, CLK_FAST);
+	else
+		sb_clkctl_clk(sbh, CLK_DYNAMIC);
+
+#if defined(CONFIG_BCM4328)
+	if (sbh->chip == BCM4328_CHIP_ID && ticks != 0)
+		sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, min_res_mask),
+		           PMURES_BIT(RES4328_ROM_SWITCH),
+		           PMURES_BIT(RES4328_ROM_SWITCH));
+#endif
 
 	/* instant NMI */
-	switch (si->gpioid) {
-	case SB_CC:
-		sb_corereg(sbh, si->gpioidx, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
-		break;
-	case SB_EXTIF:
-		sb_corereg(sbh, si->gpioidx, OFFSETOF(extifregs_t, watchdog), ~0, ticks);
-		break;
-	}
+	sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
 }
 
 /* initialize the pcmcia core */
 void
-sb_pcmcia_init(void *sbh)
+sb_pcmcia_init(sb_t *sbh)
 {
 	sb_info_t *si;
-	uint8 cor;
+	uint8 cor = 0;
 
 	si = SB_INFO(sbh);
 
 	/* enable d11 mac interrupts */
-	if (si->chip == BCM4301_DEVICE_ID) {
-		/* Have to use FCR2 in 4301 */
-		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_FCR2 + PCMCIA_COR, &cor, 1);
-		cor |= COR_IRQEN | COR_FUNEN;
-		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_FCR2 + PCMCIA_COR, &cor, 1);
-	} else {
 		OSL_PCMCIA_READ_ATTR(si->osh, PCMCIA_FCR0 + PCMCIA_COR, &cor, 1);
 		cor |= COR_IRQEN | COR_FUNEN;
 		OSL_PCMCIA_WRITE_ATTR(si->osh, PCMCIA_FCR0 + PCMCIA_COR, &cor, 1);
+
+}
+
+
+void
+BCMINITFN(sb_pci_up)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+		return;
+
+	if (FORCEHT_WAR32414(si))
+		sb_war32414_forceHT(sbh, 1);
+
+	if (PCIE_ASPMWARS(si) || si->sb.pr42780)
+		sb_pcieclkreq(sbh, 1, 0);
+
+	if (PCIE(si) &&
+	    (((si->sb.chip == BCM4311_CHIP_ID) && (si->sb.chiprev == 2)) ||
+	     ((si->sb.chip == BCM4312_CHIP_ID) && (si->sb.chiprev == 0))))
+		sb_set_initiator_to((void *)si, 0x3, sb_findcoreidx((void *)si, SB_D11, 0));
+
+}
+
+/* Unconfigure and/or apply various WARs when system is going to sleep mode */
+void
+BCMUNINITFN(sb_pci_sleep)(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint32 w;
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+	w &= ~PCIE_CAP_LCREG_ASPML1;
+	OSL_PCI_WRITE_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32), w);
+}
+
+/* Unconfigure and/or apply various WARs when going down */
+void
+BCMINITFN(sb_pci_down)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+		return;
+
+	if (FORCEHT_WAR32414(si))
+		sb_war32414_forceHT(sbh, 0);
+
+	if (si->pr42767_war) {
+		sb_pcieclkreq(sbh, 1, 1);
+		si->pr42767_war = FALSE;
+	} else if (si->sb.pr42780) {
+		sb_pcieclkreq(sbh, 1, 1);
 	}
+}
+
+static void
+BCMINITFN(sb_war42767_clkreq)(sb_t *sbh)
+{
+	sbpcieregs_t *pcieregs;
+	uint16 val16, *reg16;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
+	reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET];
+	val16 = R_REG(si->osh, reg16);
+	/* if clockreq is not advertized advertize it */
+	if (!si->pcie_war_ovr) {
+		val16 |= SRSH_CLKREQ_ENB;
+		si->pr42767_war = TRUE;
 
+		si->sb.pr42780 = TRUE;
+	} else
+		val16 &= ~SRSH_CLKREQ_ENB;
+	W_REG(si->osh, reg16, val16);
 }
 
+static void
+BCMINITFN(sb_war42767)(sb_t *sbh)
+{
+	uint32 w = 0;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	/* if not pcie bus, we're done */
+	if (!PCIE(si) || !PCIE_ASPMWARS(si))
+		return;
+
+	sb_pcie_mdioread(si, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, &w);
+	if (w & PLL_CTRL_FREQDET_EN) {
+		w &= ~PLL_CTRL_FREQDET_EN;
+		sb_pcie_mdiowrite(si, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, w);
+	}
+}
 
 /*
  * Configure the pci core for pci client (NIC) action
@@ -1213,7 +2252,7 @@
  * coremask is the bitvec of cores by index to be enabled.
  */
 void
-sb_pci_setup(void *sbh, uint32 *dmaoffset, uint coremask)
+BCMINITFN(sb_pci_setup)(sb_t *sbh, uint coremask)
 {
 	sb_info_t *si;
 	sbconfig_t *sb;
@@ -1224,14 +2263,12 @@
 
 	si = SB_INFO(sbh);
 
-	if (dmaoffset)
-		*dmaoffset = 0;
-
 	/* if not pci bus, we're done */
-	if (BUSTYPE(si->bustype) != PCI_BUS)
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
 		return;
 
-	ASSERT(si->pciidx != BADIDX);
+	ASSERT(PCI(si) || PCIE(si));
+	ASSERT(si->sb.buscoreidx != BADIDX);
 
 	/* get current core index */
 	idx = si->curidx;
@@ -1239,45 +2276,81 @@
 	/* we interrupt on this backplane flag number */
 	ASSERT(GOODREGS(si->curmap));
 	sb = REGS2SB(si->curmap);
-	sbflag = R_SBREG(sbh, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
+	sbflag = R_SBREG(si, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
 
 	/* switch over to pci core */
-	pciregs = (sbpciregs_t*) sb_setcoreidx(sbh, si->pciidx);
+	pciregs = (sbpciregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
 	sb = REGS2SB(pciregs);
 
 	/*
 	 * Enable sb->pci interrupts.  Assume
 	 * PCI rev 2.3 support was added in pci core rev 6 and things changed..
 	 */
-	if (si->pcirev < 6) {
-		/* set sbintvec bit for our flag number */
-		OR_SBREG(sbh, &sb->sbintvec, (1 << sbflag));
-	} else {
+	if (PCIE(si) || (PCI(si) && ((si->sb.buscorerev) >= 6))) {
 		/* pci config write to set this core bit in PCIIntMask */
 		w = OSL_PCI_READ_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32));
 		w |= (coremask << PCI_SBIM_SHIFT);
 		OSL_PCI_WRITE_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32), w);
+	} else {
+		/* set sbintvec bit for our flag number */
+		OR_SBREG(si, &sb->sbintvec, (1 << sbflag));
 	}
 
-	/* enable prefetch and bursts for dma big window */
-	OR_REG(&pciregs->sbtopci2, (SBTOPCI_PREF|SBTOPCI_BURST));
-
-	/* enable read multiple for dma big window */
-	if (si->pcirev >= 11)
-		OR_REG(&pciregs->sbtopci2, SBTOPCI_RC_READMULTI);
-
-	if (si->pcirev < 5) {
-		SET_SBREG(sbh, &sb->sbimconfiglow, SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
+	if (PCI(si)) {
+		OR_REG(si->osh, &pciregs->sbtopci2, (SBTOPCI_PREF|SBTOPCI_BURST));
+		if (si->sb.buscorerev >= 11)
+			OR_REG(si->osh, &pciregs->sbtopci2, SBTOPCI_RC_READMULTI);
+		if (si->sb.buscorerev < 5) {
+			SET_SBREG(si, &sb->sbimconfiglow, SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
 			(0x3 << SBIMCL_RTO_SHIFT) | 0x2);
 		sb_commit(sbh);
 	}
+	}
+
+	/* PCIE workarounds */
+	if (PCIE(si)) {
+		if ((si->sb.buscorerev == 0) || (si->sb.buscorerev == 1)) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_TLP_WORKAROUNDSREG);
+			w |= 0x8;
+			sb_pcie_writereg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_TLP_WORKAROUNDSREG, w);
+		}
+
+		if (si->sb.buscorerev == 1) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_LCREG);
+			w |= (0x40);
+			sb_pcie_writereg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS, PCIE_DLLP_LCREG, w);
+		}
+
+		if (si->sb.buscorerev == 0)
+			sb_war30841(si);
+
+		if ((si->sb.buscorerev >= 3) && (si->sb.buscorerev <= 5)) {
+			w = sb_pcie_readreg((void *)(uintptr)sbh,
+				(void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_PMTHRESHREG);
+			w &= ~(PCIE_L1THRESHOLDTIME_MASK);
+			w |= (PCIE_L1THRESHOLD_WARVAL << PCIE_L1THRESHOLDTIME_SHIFT);
+			sb_pcie_writereg((void *)(uintptr)sbh, (void *)(uintptr)PCIE_PCIEREGS,
+				PCIE_DLLP_PMTHRESHREG, w);
+
+			sb_war43448(sbh);
+
+			sb_war42767(sbh);
+
+			sb_war43448_aspm(sbh);
+			sb_war42767_clkreq(sbh);
+		}
+	}
 
 	/* switch back to previous core */
 	sb_setcoreidx(sbh, idx);
-
-	/* use large sb pci dma window */
-	if (dmaoffset)
-		*dmaoffset = SB_PCI_DMA;
 }
 
 uint32
@@ -1330,7 +2403,7 @@
 
 /* return the core-type instantiation # of the current core */
 uint
-sb_coreunit(void *sbh)
+sb_coreunit(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint idx;
@@ -1354,8 +2427,8 @@
 	return (coreunit);
 }
 
-static INLINE uint32
-factor6(uint32 x)
+static uint32
+BCMINITFN(factor6)(uint32 x)
 {
 	switch (x) {
 	case CC_F6_2:	return 2;
@@ -1370,7 +2443,7 @@
 
 /* calculate the speed the SB would run at given a set of clockcontrol values */
 uint32
-sb_clock_rate(uint32 pll_type, uint32 n, uint32 m)
+BCMINITFN(sb_clock_rate)(uint32 pll_type, uint32 n, uint32 m)
 {
 	uint32 n1, n2, clock, m1, m2, m3, mc;
 
@@ -1382,7 +2455,10 @@
 			return CC_T6_M1;
 		else
 			return CC_T6_M0;
-	} else if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE4)|| (pll_type == PLL_TYPE3)) {
+	} else if ((pll_type == PLL_TYPE1) ||
+	           (pll_type == PLL_TYPE3) ||
+	           (pll_type == PLL_TYPE4) ||
+	           (pll_type == PLL_TYPE7)) {
 		n1 = factor6(n1);
 		n2 += CC_F5_BIAS;
 	} else if (pll_type == PLL_TYPE2) {
@@ -1393,13 +2469,13 @@
 	} else if (pll_type == PLL_TYPE5) {
 		return (100000000);
 	} else
-		ASSERT((pll_type >= PLL_TYPE1) && (pll_type <= PLL_TYPE4));
-
-	/* Special case for 5350 */
-	if (pll_type == PLL_TYPE3) 
-		clock =  CLOCK_BASE_5350 * n1 * n2;
-	else 
-		clock = CC_CLOCK_BASE * n1 * n2;
+		ASSERT(0);
+	/* PLL types 3 and 7 use BASE2 (25Mhz) */
+	if ((pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE7)) {
+		clock =  CC_CLOCK_BASE2 * n1 * n2;
+	} else
+		clock = CC_CLOCK_BASE1 * n1 * n2;
 
 	if (clock == 0)
 		return 0;
@@ -1409,7 +2485,10 @@
 	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
 	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;
 
-	if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE3)) {
+	if ((pll_type == PLL_TYPE1) ||
+	    (pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE4) ||
+	    (pll_type == PLL_TYPE7)) {
 		m1 = factor6(m1);
 		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
 			m2 += CC_F5_BIAS;
@@ -1442,16 +2521,15 @@
 		if ((mc & CC_T2MC_M3BYP) == 0)
 			clock /= m3;
 
-		return(clock);
+		return (clock);
 	}
 }
 
 /* returns the current speed the SB is running at */
 uint32
-sb_clock(void *sbh)
+BCMINITFN(sb_clock)(sb_t *sbh)
 {
 	sb_info_t *si;
-	extifregs_t *eir;
 	chipcregs_t *cc;
 	uint32 n, m;
 	uint idx;
@@ -1464,41 +2542,30 @@
 
 	INTR_OFF(si, intr_val);
 
-	/* switch to extif or chipc core */
-	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
-		n = R_REG(&eir->clockcontrol_n);
-		m = R_REG(&eir->clockcontrol_sb);
-	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
-		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
-		n = R_REG(&cc->clockcontrol_n);
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	if (sbh->cccaps & CC_CAP_PMU) {
+		rate = sb_pmu_cpu_clock(sbh, si->osh);
+		goto exit;
+	}
+
+	pll_type = sbh->cccaps & CC_CAP_PLL_MASK;
+	n = R_REG(si->osh, &cc->clockcontrol_n);
 		if (pll_type == PLL_TYPE6)
-			m = R_REG(&cc->clockcontrol_mips);
+		m = R_REG(si->osh, &cc->clockcontrol_m3);
 		else if (pll_type == PLL_TYPE3)
-		{
-			// Added by Chen-I for 5365 
-			if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID) 	
-				m = R_REG(&cc->clockcontrol_sb);
-			else m = R_REG(&cc->clockcontrol_m2);
-		}
+		m = R_REG(si->osh, &cc->clockcontrol_m2);
 		else
-			m = R_REG(&cc->clockcontrol_sb);
-	} else {
-		INTR_RESTORE(si, intr_val);
-		return 0;
-	}
+		m = R_REG(si->osh, &cc->clockcontrol_sb);
 
-	// Added by Chen-I for 5365 
-	if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
-	{
-		rate = 100000000;	
-	}
-	else
-	{
 		/* calculate rate */
 		rate = sb_clock_rate(pll_type, n, m);
-		if (pll_type == PLL_TYPE3) rate = rate / 2;
-	}
 
+	if (pll_type == PLL_TYPE3)
+		rate = rate / 2;
+
+exit:
 	/* switch back to previous core */
 	sb_setcoreidx(sbh, idx);
 
@@ -1507,20 +2574,31 @@
 	return rate;
 }
 
+uint32
+BCMINITFN(sb_alp_clock)(sb_t *sbh)
+{
+	uint32 clock = ALP_CLOCK;
+
+	if (sbh->cccaps & CC_CAP_PMU)
+		clock = sb_pmu_alp_clock(sbh, sb_osh(sbh));
+
+	return clock;
+}
+
 /* change logical "focus" to the gpio core for optimized access */
 void*
-sb_gpiosetcore(void *sbh)
+sb_gpiosetcore(sb_t *sbh)
 {
 	sb_info_t *si;
 
 	si = SB_INFO(sbh);
 
-	return (sb_setcoreidx(sbh, si->gpioidx));
+	return (sb_setcoreidx(sbh, SB_CC_IDX));
 }
 
 /* mask&set gpiocontrol bits */
 uint32
-sb_gpiocontrol(void *sbh, uint32 mask, uint32 val)
+sb_gpiocontrol(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1528,25 +2606,23 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiocontrol);
-		break;
-
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpiocontrol);
-		break;
-
-	case SB_EXTIF:
-		return (0);
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio output enable bits */
 uint32
-sb_gpioouten(void *sbh, uint32 mask, uint32 val)
+sb_gpioouten(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1554,26 +2630,23 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpioouten);
-		break;
-
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioouten);
-		break;
-
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpio[0].outen);
-		break;
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpioouten);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio output bits */
 uint32
-sb_gpioout(void *sbh, uint32 mask, uint32 val)
+sb_gpioout(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1581,53 +2654,89 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
 		regoff = OFFSETOF(chipcregs_t, gpioout);
-		break;
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
+}
 
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioout);
-		break;
+/* reserve one gpio */
+uint32
+sb_gpioreserve(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
+{
+	sb_info_t *si;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpio[0].out);
-		break;
+	si = SB_INFO(sbh);
+
+	/* only cores on SB_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
 	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
+
+	/* already reserved */
+	if (sb_gpioreservation & gpio_bitmask)
+		return -1;
+	/* set reservation */
+	sb_gpioreservation |= gpio_bitmask;
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	return sb_gpioreservation;
 }
 
-/* return the current gpioin register value */
+/* release one gpio */
+/* 
+ * releasing the gpio doesn't change the current value on the GPIO last write value
+ * persists till some one overwrites it
+*/
+
 uint32
-sb_gpioin(void *sbh)
+sb_gpiorelease(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
 {
 	sb_info_t *si;
-	uint regoff;
 
 	si = SB_INFO(sbh);
-	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpioin);
-		break;
+	/* only cores on SB_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
 
-	case SB_PCI:
-		regoff = OFFSETOF(sbpciregs_t, gpioin);
-		break;
+	/* already released */
+	if (!(sb_gpioreservation & gpio_bitmask))
+		return -1;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpioin);
-		break;
-	}
+	/* clear reservation */
+	sb_gpioreservation &= ~gpio_bitmask;
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, 0, 0));
+	return sb_gpioreservation;
 }
 
-/* mask&set gpio interrupt polarity bits */
+/* return the current gpioin register value */
 uint32
-sb_gpiointpolarity(void *sbh, uint32 mask, uint32 val)
+sb_gpioin(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1635,27 +2744,34 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
-		break;
+	regoff = OFFSETOF(chipcregs_t, gpioin);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, 0, 0));
+}
 
-	case SB_PCI:
-		/* pci gpio implementation does not support interrupt polarity */
-		ASSERT(0);
-		break;
+/* mask&set gpio interrupt polarity bits */
+uint32
+sb_gpiointpolarity(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
 
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpiointpolarity);
-		break;
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
 /* mask&set gpio interrupt mask bits */
 uint32
-sb_gpiointmask(void *sbh, uint32 mask, uint32 val)
+sb_gpiointmask(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
 {
 	sb_info_t *si;
 	uint regoff;
@@ -1663,186 +2779,275 @@
 	si = SB_INFO(sbh);
 	regoff = 0;
 
-	switch (si->gpioid) {
-	case SB_CC:
-		regoff = OFFSETOF(chipcregs_t, gpiointmask);
-		break;
-
-	case SB_PCI:
-		/* pci gpio implementation does not support interrupt mask */
-		ASSERT(0);
-		break;
-
-	case SB_EXTIF:
-		regoff = OFFSETOF(extifregs_t, gpiointmask);
-		break;
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
 	}
 
-	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+	regoff = OFFSETOF(chipcregs_t, gpiointmask);
+	return (sb_corereg(sbh, SB_CC_IDX, regoff, mask, val));
 }
 
-
-/*
- * Return the slow clock source.
- * Three sources of SLOW CLOCK: LPO, Xtal, PCI
- */
-static uint
-sb_slowclk_src(void *sbh)
+/* assign the gpio to an led */
+uint32
+sb_gpioled(sb_t *sbh, uint32 mask, uint32 val)
 {
 	sb_info_t *si;
-	chipcregs_t *cc;
-	uint32 v;
 
 	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 16)
+		return -1;
 
-	ASSERT(sb_coreid(sbh) == SB_CC);
-
-	if (si->ccrev < 6) {
-		switch (BUSTYPE(si->bustype)) {
-			case PCMCIA_BUS: return (SCC_SS_XTAL);
-			case PCI_BUS:
-				v = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32));
-				if (v & PCI_CFG_GPIO_SCS)
-					return (SCC_SS_PCI);
-				else
-					return (SCC_SS_XTAL);
-			default: return (SCC_SS_XTAL);
-		}
-	} else if (si->ccrev < 10) {
-		cc = (chipcregs_t*) sb_setcoreidx(sbh, si->curidx);
-		v = R_REG(&cc->slow_clk_ctl) & SCC_SS_MASK;
-		return (v);
-	} else {
-		return (SCC_SS_XTAL);
-	}
+	/* gpio led powersave reg */
+	return (sb_corereg(sbh, SB_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask, val));
 }
 
-/*
- * Return the slowclock min or max frequency.
- * Three sources of SLOW CLOCK:
- *	1. On Chip LPO		-	32khz or 160khz
- *	2. On Chip Xtal OSC	-	20mhz/4*(divider+1)
- *	3. External PCI clock	-	66mhz/4*(divider+1)
- */
-static uint
-sb_slowclk_freq(void *sbh, bool max)
+/* mask&set gpio timer val */
+uint32
+sb_gpiotimerval(sb_t *sbh, uint32 mask, uint32 gpiotimerval)
 {
 	sb_info_t *si;
-	chipcregs_t *cc;
-	uint32 slowclk;
-	uint div;
+	si = SB_INFO(sbh);
+
+	if (si->sb.ccrev < 16)
+		return -1;
+
+	return (sb_corereg(sbh, SB_CC_IDX,
+		OFFSETOF(chipcregs_t, gpiotimerval), mask, gpiotimerval));
+}
+
+uint32
+sb_gpiopull(sb_t *sbh, bool updown, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint offs;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 20)
+		return -1;
+
+	offs = (updown ? OFFSETOF(chipcregs_t, gpiopulldown) : OFFSETOF(chipcregs_t, gpiopullup));
+	return (sb_corereg(sbh, SB_CC_IDX, offs, mask, val));
+}
+
+uint32
+sb_gpioevent(sb_t *sbh, uint regtype, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint offs;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return -1;
+
+	if (regtype == GPIO_REGEVT)
+		offs = OFFSETOF(chipcregs_t, gpioevent);
+	else if (regtype == GPIO_REGEVT_INTMSK)
+		offs = OFFSETOF(chipcregs_t, gpioeventintmask);
+	else if (regtype == GPIO_REGEVT_INTPOL)
+		offs = OFFSETOF(chipcregs_t, gpioeventintpolarity);
+	else
+		return -1;
+
+	return (sb_corereg(sbh, SB_CC_IDX, offs, mask, val));
+}
+
+void*
+BCMINITFN(sb_gpio_handler_register)(sb_t *sbh, uint32 event,
+	bool level, gpio_handler_t cb, void *arg)
+{
+	sb_info_t *si;
+	gpioh_item_t *gi;
+
+	ASSERT(event);
+	ASSERT(cb);
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return NULL;
+
+	if ((gi = MALLOC(si->osh, sizeof(gpioh_item_t))) == NULL)
+		return NULL;
+
+	bzero(gi, sizeof(gpioh_item_t));
+	gi->event = event;
+	gi->handler = cb;
+	gi->arg = arg;
+	gi->level = level;
+
+	gi->next = si->gpioh_head;
+	si->gpioh_head = gi;
+
+	return (void*)(gi);
+}
+
+void
+BCMINITFN(sb_gpio_handler_unregister)(sb_t *sbh, void* gpioh)
+{
+	sb_info_t *si;
+	gpioh_item_t *p, *n;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return;
+
+	ASSERT(si->gpioh_head);
+	if ((void*)si->gpioh_head == gpioh) {
+		si->gpioh_head = si->gpioh_head->next;
+		MFREE(si->osh, gpioh, sizeof(gpioh_item_t));
+		return;
+	}
+	else {
+		p = si->gpioh_head;
+		n = p->next;
+		while (n) {
+			if ((void*)n == gpioh) {
+				p->next = n->next;
+				MFREE(si->osh, gpioh, sizeof(gpioh_item_t));
+				return;
+			}
+			p = n;
+			n = n->next;
+		}
+	}
+
+	ASSERT(0); /* Not found in list */
+}
+
+void
+sb_gpio_handler_process(sb_t *sbh)
+{
+	sb_info_t *si;
+	gpioh_item_t *h;
+	uint32 status;
+	uint32 level = sb_gpioin(sbh);
+	uint32 edge = sb_gpioevent(sbh, GPIO_REGEVT, 0, 0);
 
 	si = SB_INFO(sbh);
+	for (h = si->gpioh_head; h != NULL; h = h->next) {
+		if (h->handler) {
+			status = (h->level ? level : edge);
+
+			if (status & h->event)
+				h->handler(status, h->arg);
+		}
+	}
+
+	sb_gpioevent(sbh, GPIO_REGEVT, edge, edge); /* clear edge-trigger status */
+}
+
+uint32
+sb_gpio_int_enable(sb_t *sbh, bool enable)
+{
+	sb_info_t *si;
+	uint offs;
 
-	ASSERT(sb_coreid(sbh) == SB_CC);
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 11)
+		return -1;
 
-	cc = (chipcregs_t*) sb_setcoreidx(sbh, si->curidx);
+	offs = OFFSETOF(chipcregs_t, intmask);
+	return (sb_corereg(sbh, SB_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
+}
 
-	/* shouldn't be here unless we've established the chip has dynamic power control */
-	ASSERT(R_REG(&cc->capabilities) & CAP_PWR_CTL);
 
-	slowclk = sb_slowclk_src(sbh);
-	if (si->ccrev < 6) {
+/* return the slow clock source - LPO, XTAL, or PCI */
+static uint
+sb_slowclk_src(sb_info_t *si)
+{
+	chipcregs_t *cc;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	if (si->sb.ccrev < 6) {
+		if ((BUSTYPE(si->sb.bustype) == PCI_BUS) &&
+		    (OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32)) &
+		     PCI_CFG_GPIO_SCS))
+			return (SCC_SS_PCI);
+		else
+			return (SCC_SS_XTAL);
+	} else if (si->sb.ccrev < 10) {
+		cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+		return (R_REG(si->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
+	} else	/* Insta-clock */
+		return (SCC_SS_XTAL);
+}
+
+/* return the ILP (slowclock) min or max frequency */
+static uint
+sb_slowclk_freq(sb_info_t *si, bool max_freq)
+{
+	chipcregs_t *cc;
+	uint32 slowclk;
+	uint div;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+
+	/* shouldn't be here unless we've established the chip has dynamic clk control */
+	ASSERT(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL);
+
+	slowclk = sb_slowclk_src(si);
+	if (si->sb.ccrev < 6) {
 		if (slowclk == SCC_SS_PCI)
-			return (max? (PCIMAXFREQ/64) : (PCIMINFREQ/64));
+			return (max_freq ? (PCIMAXFREQ / 64) : (PCIMINFREQ / 64));
 		else
-			return (max? (XTALMAXFREQ/32) : (XTALMINFREQ/32));
-	} else if (si->ccrev < 10) {
-		div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHF) + 1);
+			return (max_freq ? (XTALMAXFREQ / 32) : (XTALMINFREQ / 32));
+	} else if (si->sb.ccrev < 10) {
+		div = 4 * (((R_REG(si->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
 		if (slowclk == SCC_SS_LPO)
-			return (max? LPOMAXFREQ : LPOMINFREQ);
+			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
 		else if (slowclk == SCC_SS_XTAL)
-			return (max? (XTALMAXFREQ/div) : (XTALMINFREQ/div));
+			return (max_freq ? (XTALMAXFREQ / div) : (XTALMINFREQ / div));
 		else if (slowclk == SCC_SS_PCI)
-			return (max? (PCIMAXFREQ/div) : (PCIMINFREQ/div));
+			return (max_freq ? (PCIMAXFREQ / div) : (PCIMINFREQ / div));
 		else
 			ASSERT(0);
 	} else {
 		/* Chipc rev 10 is InstaClock */
-		div = R_REG(&cc->system_clk_ctl) >> SYCC_CD_SHF;
+		div = R_REG(si->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
 		div = 4 * (div + 1);
-		return (max ? XTALMAXFREQ : (XTALMINFREQ/div));
+		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
 	}
 	return (0);
 }
 
 static void
-sb_pwrctl_setdelay(void *sbh, void *chipcregs)
+BCMINITFN(sb_clkctl_setdelay)(sb_info_t *si, void *chipcregs)
 {
-	sb_info_t *si;
 	chipcregs_t * cc;
 	uint slowmaxfreq, pll_delay, slowclk;
 	uint pll_on_delay, fref_sel_delay;
 
-	si = SB_INFO(sbh);
 	pll_delay = PLL_DELAY;
 
 	/* If the slow clock is not sourced by the xtal then add the xtal_on_delay
-	 * since the xtal will also be powered down by dynamic power control logic.
+	 * since the xtal will also be powered down by dynamic clk control logic.
 	 */
-	slowclk = sb_slowclk_src(sbh);
+
+	slowclk = sb_slowclk_src(si);
 	if (slowclk != SCC_SS_XTAL)
 		pll_delay += XTAL_ON_DELAY;
 
 	/* Starting with 4318 it is ILP that is used for the delays */
-	slowmaxfreq = sb_slowclk_freq(sbh, (si->ccrev >= 10) ? FALSE : TRUE);
+	slowmaxfreq = sb_slowclk_freq(si, (si->sb.ccrev >= 10) ? FALSE : TRUE);
 
 	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
 	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
 
 	cc = (chipcregs_t *)chipcregs;
-	W_REG(&cc->pll_on_delay, pll_on_delay);
-	W_REG(&cc->fref_sel_delay, fref_sel_delay);
-}
-
-/* set or get slow clock divider */
-int
-sb_pwrctl_slowclk(void *sbh, bool set, uint *div)
-{
-	sb_info_t *si;
-	uint origidx;
-	chipcregs_t *cc;
-	uint intr_val = 0;
-	uint err = 0;
-	
-	si = SB_INFO(sbh);
-
-	/* chipcommon cores prior to rev6 don't support slowclkcontrol */
-	if (si->ccrev < 6)
-		return 1;
-
-	/* chipcommon cores rev10 are a whole new ball game */
-	if (si->ccrev >= 10)
-		return 1;
-
-	if (set && ((*div % 4) || (*div < 4)))
-		return 2;
-	
-	INTR_OFF(si, intr_val);
-	origidx = si->curidx;
-	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
-	ASSERT(cc != NULL);
-	
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL)) {
-		err = 3;
-		goto done;
-	}
-
-	if (set) {
-		SET_REG(&cc->slow_clk_ctl, SCC_CD_MASK, ((*div / 4 - 1) << SCC_CD_SHF));
-		sb_pwrctl_setdelay(sbh, (void *)cc);
-	} else
-		*div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHF) + 1);
-
-done:
-	sb_setcoreidx(sbh, origidx);
-	INTR_RESTORE(si, intr_val);
-	return err;
+	W_REG(si->osh, &cc->pll_on_delay, pll_on_delay);
+	W_REG(si->osh, &cc->fref_sel_delay, fref_sel_delay);
 }
 
 /* initialize power control delay registers */
 void
-sb_pwrctl_init(void *sbh)
+BCMINITFN(sb_clkctl_init)(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1855,16 +3060,19 @@
 	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
 		return;
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if ((si->sb.chip == BCM4321_CHIP_ID) && (si->sb.chiprev < 2))
+		W_REG(si->osh, &cc->chipcontrol,
+		      (si->sb.chiprev == 0) ? CHIPCTRL_4321A0_DEFAULT : CHIPCTRL_4321A1_DEFAULT);
+
+	if (!(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL))
 		goto done;
 
-	/* 4317pc does not work with SlowClock less than 5Mhz */
-	if (BUSTYPE(si->bustype) == PCMCIA_BUS) {
-		if ((si->ccrev >= 6) && (si->ccrev < 10))
-			SET_REG(&cc->slow_clk_ctl, SCC_CD_MASK, (SCC_DEF_DIV << SCC_CD_SHF));
-	}
+	/* set all Instaclk chip ILP to 1 MHz */
+	if (si->sb.ccrev >= 10)
+		SET_REG(si->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
+		        (ILP_DIV_1MHZ << SYCC_CD_SHIFT));
 	
-	sb_pwrctl_setdelay(sbh, (void *)cc);
+	sb_clkctl_setdelay(si, (void *)(uintptr)cc);
 
 done:
 	sb_setcoreidx(sbh, origidx);
@@ -1872,7 +3080,7 @@
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
 uint16
-sb_pwrctl_fast_pwrup_delay(void *sbh)
+BCMINITFN(sb_clkctl_fast_pwrup_delay)(sb_t *sbh)
 {
 	sb_info_t *si;
 	uint origidx;
@@ -1885,19 +3093,22 @@
 	fpdelay = 0;
 	origidx = si->curidx;
 
-	if (BUSTYPE(si->bustype) == SB_BUS)
-		goto done;
-
 	INTR_OFF(si, intr_val);
 
 	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
 		goto done;
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if (sbh->cccaps & CC_CAP_PMU) {
+		fpdelay = sb_pmu_fast_pwrup_delay(sbh, si->osh);
+		goto done;
+	}
+
+	if (!(sbh->cccaps & CC_CAP_PWR_CTL))
 		goto done;
 
-	slowminfreq = sb_slowclk_freq(sbh, FALSE);
-	fpdelay = (((R_REG(&cc->pll_on_delay) + 2) * 1000000) + (slowminfreq - 1)) / slowminfreq;
+	slowminfreq = sb_slowclk_freq(si, FALSE);
+	fpdelay = (((R_REG(si->osh, &cc->pll_on_delay) + 2) * 1000000) +
+	           (slowminfreq - 1)) / slowminfreq;
 
 done:
 	sb_setcoreidx(sbh, origidx);
@@ -1907,14 +3118,14 @@
 
 /* turn primary xtal and/or pll off/on */
 int
-sb_pwrctl_xtal(void *sbh, uint what, bool on)
+sb_clkctl_xtal(sb_t *sbh, uint what, bool on)
 {
 	sb_info_t *si;
 	uint32 in, out, outen;
 
 	si = SB_INFO(sbh);
 
-	switch (BUSTYPE(si->bustype)) {
+	switch (BUSTYPE(si->sb.bustype)) {
 
 
 		case PCMCIA_BUS:
@@ -1923,9 +3134,13 @@
 
 		case PCI_BUS:
 
-			in = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_IN, sizeof (uint32));
-			out = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32));
-			outen = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32));
+			/* pcie core doesn't have any mapping to control the xtal pu */
+			if (PCIE(si))
+				return -1;
+
+			in = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_IN, sizeof(uint32));
+			out = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32));
+			outen = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof(uint32));
 
 			/*
 			 * Avoid glitching the clock if GPRS is already using it.
@@ -1946,15 +3161,18 @@
 					out |= PCI_CFG_GPIO_XTAL;
 					if (what & PLL)
 						out |= PCI_CFG_GPIO_PLL;
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT,
+					                     sizeof(uint32), out);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN,
+					                     sizeof(uint32), outen);
 					OSL_DELAY(XTAL_ON_DELAY);
 				}
 
 				/* turn pll on */
 				if (what & PLL) {
 					out &= ~PCI_CFG_GPIO_PLL;
-					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT,
+					                     sizeof(uint32), out);
 					OSL_DELAY(2000);
 				}
 			} else {
@@ -1962,8 +3180,9 @@
 					out &= ~PCI_CFG_GPIO_XTAL;
 				if (what & PLL)
 					out |= PCI_CFG_GPIO_PLL;
-				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
-				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof(uint32), out);
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof(uint32),
+				                     outen);
 			}
 
 		default:
@@ -1973,79 +3192,100 @@
 	return (0);
 }
 
-/* set dynamic power control mode (forceslow, forcefast, dynamic) */
-/*   returns true if ignore pll off is set and false if it is not */
+/* set dynamic clk control mode (forceslow, forcefast, dynamic) */
+/*   returns true if we are forcing fast clock */
 bool
-sb_pwrctl_clk(void *sbh, uint mode)
+sb_clkctl_clk(sb_t *sbh, uint mode)
 {
 	sb_info_t *si;
 	uint origidx;
 	chipcregs_t *cc;
 	uint32 scc;
-	bool forcefastclk=FALSE;
 	uint intr_val = 0;
 
 	si = SB_INFO(sbh);
 
-	/* chipcommon cores prior to rev6 don't support slowclkcontrol */
-	if (si->ccrev < 6)
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (si->sb.ccrev < 6)
 		return (FALSE);
 
-	/* chipcommon cores rev10 are a whole new ball game */
-	if (si->ccrev >= 10)
-		return (FALSE);
+
+	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
+	ASSERT(si->sb.ccrev != 10);
 
 	INTR_OFF(si, intr_val);
 
 	origidx = si->curidx;
 
+	if (sb_setcore(sbh, SB_MIPS33, 0) && (sb_corerev(&si->sb) <= 7) &&
+	    (BUSTYPE(si->sb.bustype) == SB_BUS) && (si->sb.ccrev >= 10))
+		goto done;
+
+	if (FORCEHT_WAR32414(si))
+		goto done;
+
 	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
 	ASSERT(cc != NULL);
 
-	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+	if (!(R_REG(si->osh, &cc->capabilities) & CC_CAP_PWR_CTL) && (si->sb.ccrev < 20))
 		goto done;
 
 	switch (mode) {
 	case CLK_FAST:	/* force fast (pll) clock */
+		if (si->sb.ccrev < 10) {
 		/* don't forget to force xtal back on before we clear SCC_DYN_XTAL.. */
-		sb_pwrctl_xtal(sbh, XTAL, ON);
+			sb_clkctl_xtal(&si->sb, XTAL, ON);
 
-		SET_REG(&cc->slow_clk_ctl, (SCC_XC | SCC_FS | SCC_IP), SCC_IP);
-		break;
-
-	case CLK_SLOW:	/* force slow clock */
-		if ((BUSTYPE(si->bustype) == SDIO_BUS) || (BUSTYPE(si->bustype) == PCMCIA_BUS))
-			return (-1);
+			SET_REG(si->osh, &cc->slow_clk_ctl, (SCC_XC | SCC_FS | SCC_IP), SCC_IP);
+		} else if (si->sb.ccrev < 20) {
+			OR_REG(si->osh, &cc->system_clk_ctl, SYCC_HR);
+		} else {
+			OR_REG(si->osh, &cc->clk_ctl_st, CCS_FORCEHT);
+		}
 
-		if (si->ccrev >= 6)
-			OR_REG(&cc->slow_clk_ctl, SCC_FS);
+		/* wait for the PLL */
+		if (R_REG(si->osh, &cc->capabilities) & CC_CAP_PMU) {
+			SPINWAIT(((R_REG(si->osh, &cc->clk_ctl_st) & CCS_HTAVAIL) == 0),
+			         PMU_MAX_TRANSITION_DLY);
+			ASSERT(R_REG(si->osh, &cc->clk_ctl_st) & CCS_HTAVAIL);
+		} else {
+			OSL_DELAY(PLL_DELAY);
+		}
 		break;
 
-	case CLK_DYNAMIC:	/* enable dynamic power control */
-		scc = R_REG(&cc->slow_clk_ctl);
+	case CLK_DYNAMIC:	/* enable dynamic clock control */
+		if (si->sb.ccrev < 10) {
+			scc = R_REG(si->osh, &cc->slow_clk_ctl);
 		scc &= ~(SCC_FS | SCC_IP | SCC_XC);
 		if ((scc & SCC_SS_MASK) != SCC_SS_XTAL)
 			scc |= SCC_XC;
-		W_REG(&cc->slow_clk_ctl, scc);
+			W_REG(si->osh, &cc->slow_clk_ctl, scc);
 
 		/* for dynamic control, we have to release our xtal_pu "force on" */
 		if (scc & SCC_XC)
-			sb_pwrctl_xtal(sbh, XTAL, OFF);
-		break;
+				sb_clkctl_xtal(&si->sb, XTAL, OFF);
+		} else if (si->sb.ccrev < 20) {
+			/* Instaclock */
+			AND_REG(si->osh, &cc->system_clk_ctl, ~SYCC_HR);
+		} else {
+			AND_REG(si->osh, &cc->clk_ctl_st, ~CCS_FORCEHT);
 	}
+		break;
 
-	/* Is the h/w forcing the use of the fast clk */
-	forcefastclk = (bool)((R_REG(&cc->slow_clk_ctl) & SCC_IP) == SCC_IP);
+	default:
+		ASSERT(0);
+	}
 
 done:
 	sb_setcoreidx(sbh, origidx);
 	INTR_RESTORE(si, intr_val);
-	return (forcefastclk);
+	return (mode == CLK_FAST);
 }
 
 /* register driver interrupt disabling and restoring callback functions */
 void
-sb_register_intr_callback(void *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intrsenabled_fn, void *intr_arg)
+sb_register_intr_callback(sb_t *sbh, void *intrsoff_fn, void *intrsrestore_fn,
+                          void *intrsenabled_fn, void *intr_arg)
 {
 	sb_info_t *si;
 
@@ -2060,4 +3300,624 @@
 	si->dev_coreid = si->coreid[si->curidx];
 }
 
+void
+sb_deregister_intr_callback(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	si->intrsoff_fn = NULL;
+}
+
+
+uint16
+BCMINITFN(sb_d11_devid)(sb_t *sbh)
+{
+	sb_info_t *si = SB_INFO(sbh);
+	uint16 device;
+
+#if defined(CONFIG_BCM4328)
+	/* Fix device id for dual band BCM4328 */
+	if (sbh->chip == BCM4328_CHIP_ID &&
+	    (sbh->chippkg == BCM4328USBDUAL_PKG_ID || sbh->chippkg == BCM4328SDIODUAL_PKG_ID))
+		device = BCM4328_D11DUAL_ID;
+	else
+#endif	/* BCM4328 */
+	/* Let an nvram variable with devpath override devid */
+	if ((device = (uint16)sb_getdevpathintvar(sbh, "devid")) != 0)
+		;
+	/* Get devid from OTP/SPROM depending on where the SROM is read */
+	else if ((device = (uint16)getintvar(si->vars, "devid")) != 0)
+		;
+	/*
+	 * no longer support wl0id, but keep the code
+	 * here for backward compatibility.
+	 */
+	else if ((device = (uint16)getintvar(si->vars, "wl0id")) != 0)
+		;
+	/* Chip specific conversion */
+	else if (sbh->chip == BCM4712_CHIP_ID) {
+		if (sbh->chippkg == BCM4712SMALL_PKG_ID)
+			device = BCM4306_D11G_ID;
+		else
+			device = BCM4306_D11DUAL_ID;
+	}
+	/* ignore it */
+	else
+		device = 0xffff;
+
+	return device;
+}
+
+int
+BCMINITFN(sb_corepciid)(sb_t *sbh, uint func, uint16 *pcivendor, uint16 *pcidevice,
+                        uint8 *pciclass, uint8 *pcisubclass, uint8 *pciprogif,
+                        uint8 *pciheader)
+{
+	uint16 vendor = 0xffff, device = 0xffff;
+	uint8 class, subclass, progif = 0;
+	uint8 header = PCI_HEADER_NORMAL;
+	uint32 core = sb_coreid(sbh);
+
+	/* Verify whether the function exists for the core */
+	if (func >= (uint)(core == SB_USB20H ? 2 : 1))
+		return BCME_ERROR;
+
+	/* Known vendor translations */
+	switch (sb_corevendor(sbh)) {
+	case SB_VEND_BCM:
+		vendor = VENDOR_BROADCOM;
+		break;
+	default:
+		return BCME_ERROR;
+	}
+
+	/* Determine class based on known core codes */
+	switch (core) {
+	case SB_ILINE20:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_ILINE_ID;
+		break;
+	case SB_ENET:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_ENET_ID;
+		break;
+	case SB_GIGETH:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		device = BCM47XX_GIGETH_ID;
+		break;
+	case SB_SDRAM:
+	case SB_MEMC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_RAM;
+		device = (uint16)core;
+		break;
+	case SB_PCI:
+	case SB_PCIE:
+		class = PCI_CLASS_BRIDGE;
+		subclass = PCI_BRIDGE_PCI;
+		device = (uint16)core;
+		header = PCI_HEADER_BRIDGE;
+		break;
+	case SB_MIPS33:
+		class = PCI_CLASS_CPU;
+		subclass = PCI_CPU_MIPS;
+		device = (uint16)core;
+		break;
+	case SB_CODEC:
+		class = PCI_CLASS_COMM;
+		subclass = PCI_COMM_MODEM;
+		device = BCM47XX_V90_ID;
+		break;
+	case SB_USB:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		device = BCM47XX_USB_ID;
+		break;
+	case SB_USB11H:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		device = BCM47XX_USBH_ID;
+		break;
+	case SB_USB20H:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = func == 0 ? 0x10 : 0x20; /* OHCI/EHCI */
+		device = BCM47XX_USB20H_ID;
+		header = 0x80; /* multifunction */
+		break;
+	case SB_IPSEC:
+		class = PCI_CLASS_CRYPT;
+		subclass = PCI_CRYPT_NETWORK;
+		device = BCM47XX_IPSEC_ID;
+		break;
+	case SB_ROBO:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		device = BCM47XX_ROBO_ID;
+		break;
+	case SB_CC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_FLASH;
+		device = (uint16)core;
+		break;
+	case SB_SATAXOR:
+		class = PCI_CLASS_XOR;
+		subclass = PCI_XOR_QDMA;
+		device = BCM47XX_SATAXOR_ID;
+		break;
+	case SB_ATA100:
+		class = PCI_CLASS_DASDI;
+		subclass = PCI_DASDI_IDE;
+		device = BCM47XX_ATA100_ID;
+		break;
+	case SB_USB11D:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		device = BCM47XX_USBD_ID;
+		break;
+	case SB_USB20D:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		device = BCM47XX_USB20D_ID;
+		break;
+	case SB_D11:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		device = sb_d11_devid(sbh);
+		break;
+
+	default:
+		class = subclass = progif = 0xff;
+		device = (uint16)core;
+		break;
+	}
+
+	*pcivendor = vendor;
+	*pcidevice = device;
+	*pciclass = class;
+	*pcisubclass = subclass;
+	*pciprogif = progif;
+	*pciheader = header;
+
+	return 0;
+}
+
+/* use the mdio interface to read from mdio slaves */
+static int
+sb_pcie_mdioread(sb_info_t *si,  uint physmedia, uint regaddr, uint *regval)
+{
+	uint mdiodata;
+	uint i = 0;
+	sbpcieregs_t *pcieregs;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(&si->sb, si->sb.buscoreidx);
+	ASSERT(pcieregs);
+
+	/* enable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+	mdiodata = MDIODATA_START | MDIODATA_READ |
+	        (physmedia << MDIODATA_DEVADDR_SHF) |
+		(regaddr << MDIODATA_REGADDR_SHF) | MDIODATA_TA;
+
+	W_REG(si->osh, &pcieregs->mdiodata, mdiodata);
+
+	PR28829_DELAY();
+
+	/* retry till the transaction is complete */
+	while (i < 10) {
+		if (R_REG(si->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+			PR28829_DELAY();
+			*regval = (R_REG(si->osh, &(pcieregs->mdiodata)) & MDIODATA_MASK);
+			/* Disable mdio access to SERDES */
+			W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+			return 0;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	SB_ERROR(("sb_pcie_mdioread: timed out\n"));
+	/* Disable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+	return 1;
+}
+
+
+/* use the mdio interface to write to mdio slaves */
+static int
+sb_pcie_mdiowrite(sb_info_t *si,  uint physmedia, uint regaddr, uint val)
+{
+	uint mdiodata;
+	uint i = 0;
+	sbpcieregs_t *pcieregs;
+
+	pcieregs = (sbpcieregs_t*) sb_setcoreidx(&si->sb, si->sb.buscoreidx);
+	ASSERT(pcieregs);
+
+	/* enable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+	mdiodata = MDIODATA_START | MDIODATA_WRITE |
+		(physmedia << MDIODATA_DEVADDR_SHF) |
+		(regaddr << MDIODATA_REGADDR_SHF) | MDIODATA_TA | val;
+
+	W_REG(si->osh, (&pcieregs->mdiodata), mdiodata);
+
+	PR28829_DELAY();
+
+	/* retry till the transaction is complete */
+	while (i < 10) {
+		if (R_REG(si->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+			/* Disable mdio access to SERDES */
+			W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+			return 0;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	SB_ERROR(("sb_pcie_mdiowrite: timed out\n"));
+	/* Disable mdio access to SERDES */
+	W_REG(si->osh, (&pcieregs->mdiocontrol), 0);
+	return 1;
+
+}
+
+/* indirect way to read pcie config regs */
+uint
+sb_pcie_readreg(void *sb, void* arg1, uint offset)
+{
+	sb_info_t *si;
+	sb_t   *sbh;
+	uint retval = 0xFFFFFFFF;
+	sbpcieregs_t *pcieregs;
+	uint addrtype;
+
+	sbh = (sb_t *)sb;
+	si = SB_INFO(sbh);
+	ASSERT(PCIE(si));
+
+	pcieregs = (sbpcieregs_t *)sb_setcore(sbh, SB_PCIE, 0);
+	ASSERT(pcieregs);
+
+	addrtype = (uint)((uintptr)arg1);
+	switch (addrtype) {
+		case PCIE_CONFIGREGS:
+			W_REG(si->osh, (&pcieregs->configaddr), offset);
+			retval = R_REG(si->osh, &(pcieregs->configdata));
+			break;
+		case PCIE_PCIEREGS:
+			W_REG(si->osh, &(pcieregs->pcieindaddr), offset);
+			retval = R_REG(si->osh, &(pcieregs->pcieinddata));
+			break;
+		default:
+			ASSERT(0);
+			break;
+	}
+	return retval;
+}
+
+/* indirect way to write pcie config/mdio/pciecore regs */
+uint
+sb_pcie_writereg(sb_t *sbh, void *arg1,  uint offset, uint val)
+{
+	sb_info_t *si;
+	sbpcieregs_t *pcieregs;
+	uint addrtype;
+
+	si = SB_INFO(sbh);
+	ASSERT(PCIE(si));
+
+	pcieregs = (sbpcieregs_t *)sb_setcore(sbh, SB_PCIE, 0);
+	ASSERT(pcieregs);
+
+	addrtype = (uint)((uintptr)arg1);
+
+	switch (addrtype) {
+		case PCIE_CONFIGREGS:
+			W_REG(si->osh, (&pcieregs->configaddr), offset);
+			W_REG(si->osh, (&pcieregs->configdata), val);
+			break;
+		case PCIE_PCIEREGS:
+			W_REG(si->osh, (&pcieregs->pcieindaddr), offset);
+			W_REG(si->osh, (&pcieregs->pcieinddata), val);
+			break;
+		default:
+			ASSERT(0);
+			break;
+	}
+	return 0;
+}
+
+
+/* Build device path. Support SB, PCI, and JTAG for now. */
+int
+BCMINITFN(sb_devpath)(sb_t *sbh, char *path, int size)
+{
+	int slen;
+	ASSERT(path);
+	ASSERT(size >= SB_DEVPATH_BUFSZ);
+
+	if (!path || size <= 0)
+		return -1;
+
+	switch (BUSTYPE((SB_INFO(sbh))->sb.bustype)) {
+	case SB_BUS:
+	case JTAG_BUS:
+		slen = snprintf(path, (size_t)size, "sb/%u/", sb_coreidx(sbh));
+		break;
+	case PCI_BUS:
+		ASSERT((SB_INFO(sbh))->osh);
+		slen = snprintf(path, (size_t)size, "pci/%u/%u/",
+		                OSL_PCI_BUS((SB_INFO(sbh))->osh),
+		                OSL_PCI_SLOT((SB_INFO(sbh))->osh));
+		break;
+	case PCMCIA_BUS:
+		SB_ERROR(("sb_devpath: OSL_PCMCIA_BUS() not implemented, bus 1 assumed\n"));
+		SB_ERROR(("sb_devpath: OSL_PCMCIA_SLOT() not implemented, slot 1 assumed\n"));
+		slen = snprintf(path, (size_t)size, "pc/1/1/");
+		break;
+	default:
+		slen = -1;
+		ASSERT(0);
+		break;
+	}
 
+	if (slen < 0 || slen >= size) {
+		path[0] = '\0';
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+char *
+BCMINITFN(sb_getdevpathvar)(sb_t *sbh, const char *name)
+{
+	char varname[SB_DEVPATH_BUFSZ + 32];
+
+	sb_devpathvar(sbh, varname, sizeof(varname), name);
+
+	return (getvar(NULL, varname));
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+int
+BCMINITFN(sb_getdevpathintvar)(sb_t *sbh, const char *name)
+{
+	char varname[SB_DEVPATH_BUFSZ + 32];
+
+	sb_devpathvar(sbh, varname, sizeof(varname), name);
+
+	return (getintvar(NULL, varname));
+}
+
+/* Concatenate the dev path with a varname into the given 'var' buffer
+ * and return the 'var' pointer.
+ * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
+ * On overflow, the first char will be set to '\0'.
+ */
+static char *
+BCMINITFN(sb_devpathvar)(sb_t *sbh, char *var, int len, const char *name)
+{
+	uint path_len;
+
+	if (!var || len <= 0)
+		return var;
+
+	if (sb_devpath(sbh, var, len) == 0) {
+		path_len = strlen(var);
+
+		if (strlen(name) + 1 > (uint)(len - path_len))
+			var[0] = '\0';
+		else
+			strncpy(var + path_len, name, len - path_len - 1);
+	}
+
+	return var;
+}
+
+
+/*
+ * Fixup SROMless PCI device's configuration.
+ * The current core may be changed upon return.
+ */
+static int
+sb_pci_fixcfg(sb_info_t *si)
+{
+	uint origidx, pciidx;
+	sbpciregs_t *pciregs;
+	sbpcieregs_t *pcieregs = NULL;
+	uint16 val16, *reg16;
+	uint32 w;
+
+	ASSERT(BUSTYPE(si->sb.bustype) == PCI_BUS);
+
+	/* Fixup PI in SROM shadow area to enable the correct PCI core access */
+	/* save the current index */
+	origidx = sb_coreidx(&si->sb);
+
+	/* check 'pi' is correct and fix it if not */
+	if (si->sb.buscoretype == SB_PCIE) {
+		pcieregs = (sbpcieregs_t *)sb_setcore(&si->sb, SB_PCIE, 0);
+		ASSERT(pcieregs);
+		reg16 = &pcieregs->sprom[SRSH_PI_OFFSET];
+	} else if (si->sb.buscoretype == SB_PCI) {
+		pciregs = (sbpciregs_t *)sb_setcore(&si->sb, SB_PCI, 0);
+		ASSERT(pciregs);
+		reg16 = &pciregs->sprom[SRSH_PI_OFFSET];
+	} else {
+		ASSERT(0);
+		return -1;
+	}
+	pciidx = sb_coreidx(&si->sb);
+	val16 = R_REG(si->osh, reg16);
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16)pciidx) {
+		val16 = (uint16)(pciidx << SRSH_PI_SHIFT) | (val16 & ~SRSH_PI_MASK);
+		W_REG(si->osh, reg16, val16);
+	}
+
+	if (PCIE_ASPMWARS(si)) {
+		w = sb_pcie_readreg((void *)(uintptr)&si->sb, (void *)PCIE_PCIEREGS,
+		                    PCIE_PLP_STATUSREG);
+
+		/* Detect the current polarity at attach and force that polarity and
+		 * disable changing the polarity
+		 */
+		if ((w & PCIE_PLP_POLARITYINV_STAT) == 0) {
+			si->pcie_polarity = (SERDES_RX_CTRL_FORCE);
+		} else {
+			si->pcie_polarity = (SERDES_RX_CTRL_FORCE |
+			                     SERDES_RX_CTRL_POLARITY);
+		}
+
+		w = OSL_PCI_READ_CONFIG(si->osh, si->pciecap_lcreg_offset, sizeof(uint32));
+		if (w & PCIE_CLKREQ_ENAB) {
+			reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET];
+			val16 = R_REG(si->osh, reg16);
+			/* if clockreq is not advertized clkreq should not be enabled */
+			if (!(val16 & SRSH_CLKREQ_ENB))
+				SB_ERROR(("WARNING: CLK REQ enabled already  0x%x\n", w));
+		}
+
+		sb_war43448(&si->sb);
+
+		sb_war42767(&si->sb);
+
+	}
+
+	/* restore the original index */
+	sb_setcoreidx(&si->sb, origidx);
+
+	return 0;
+}
+
+/* Return ADDR64 capability of the backplane */
+bool
+sb_backplane64(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return ((si->sb.cccaps & CC_CAP_BKPLN64) != 0);
+}
+
+void
+sb_btcgpiowar(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+	chipcregs_t *cc;
+	si = SB_INFO(sbh);
+
+	/* Make sure that there is ChipCommon core present &&
+	 * UART_TX is strapped to 1
+	 */
+	if (!(si->sb.cccaps & CC_CAP_UARTGPIO))
+		return;
+
+	/* sb_corereg cannot be used as we have to guarantee 8-bit read/writes */
+	INTR_OFF(si, intr_val);
+
+	origidx = sb_coreidx(sbh);
+
+	cc = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc);
+
+	W_REG(si->osh, &cc->uart0mcr, R_REG(si->osh, &cc->uart0mcr) | 0x04);
+
+	/* restore the original index */
+	sb_setcoreidx(sbh, origidx);
+
+	INTR_RESTORE(si, intr_val);
+}
+
+/* check if the device is removed */
+bool
+sb_deviceremoved(sb_t *sbh)
+{
+	uint32 w;
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case PCI_BUS:
+		ASSERT(si->osh);
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_CFG_VID, sizeof(uint32));
+		if ((w & 0xFFFF) != VENDOR_BROADCOM)
+			return TRUE;
+		else
+			return FALSE;
+	default:
+		return FALSE;
+	}
+	return FALSE;
+}
+
+/* Return the RAM size of the SOCRAM core */
+uint32
+BCMINITFN(sb_socram_size)(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+
+	sbsocramregs_t *regs;
+	bool wasup;
+	uint corerev;
+	uint32 coreinfo;
+	uint memsize = 0;
+
+	si = SB_INFO(sbh);
+	ASSERT(si);
+
+	/* Block ints and save current core */
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(sbh);
+
+	/* Switch to SOCRAM core */
+	if (!(regs = sb_setcore(sbh, SB_SOCRAM, 0)))
+		goto done;
+
+	/* Get info for determining size */
+	if (!(wasup = sb_iscoreup(sbh)))
+		sb_core_reset(sbh, 0, 0);
+	corerev = sb_corerev(sbh);
+	coreinfo = R_REG(si->osh, &regs->coreinfo);
+
+	/* Calculate size from coreinfo based on rev */
+	if (corerev == 0)
+		memsize = 1 << (16 + (coreinfo & SRCI_MS0_MASK));
+	else if (corerev < 3) {
+		memsize = 1 << (SR_BSZ_BASE + (coreinfo & SRCI_SRBSZ_MASK));
+		memsize *= (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+	}
+	else {
+		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+		uint bsz = (coreinfo & SRCI_SRBSZ_MASK);
+		uint lss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;
+		if (lss != 0)
+			nb --;
+		memsize = nb * (1 << (bsz + SR_BSZ_BASE));
+		if (lss != 0)
+			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
+	}
+	/* Return to previous state and core */
+	if (!wasup)
+		sb_core_disable(sbh, 0);
+	sb_setcoreidx(sbh, origidx);
+
+done:
+	INTR_RESTORE(si, intr_val);
+	return memsize;
+}
--- src/shared.1927/sflash.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/sflash.c	2007-11-19 07:12:47.000000000 +0300
@@ -18,6 +18,7 @@
 #include <sbchipc.h>
 #include <mipsinc.h>
 #include <bcmutils.h>
+#include <bcmdevs.h>
 #include <sflash.h>
 
 /* Private global state */
@@ -27,8 +28,8 @@
 static INLINE void
 sflash_cmd(chipcregs_t *cc, uint opcode)
 {
-	W_REG(&cc->flashcontrol, SFLASH_START | opcode);
-	while (R_REG(&cc->flashcontrol) & SFLASH_BUSY);
+	W_REG(NULL, &cc->flashcontrol, SFLASH_START | opcode);
+	while (R_REG(NULL, &cc->flashcontrol) & SFLASH_BUSY);
 }
 
 /* Initialize serial flash access */
@@ -39,14 +40,14 @@
 
 	bzero(&sflash, sizeof(sflash));
 
-	sflash.type = R_REG(&cc->capabilities) & CAP_FLASH_MASK;
+	sflash.type = R_REG(NULL, &cc->capabilities) & CC_CAP_FLASH_MASK;
 
 	switch (sflash.type) {
 	case SFLASH_ST:
 		/* Probe for ST chips */
 		sflash_cmd(cc, SFLASH_ST_DP);
 		sflash_cmd(cc, SFLASH_ST_RES);
-		id = R_REG(&cc->flashdata);
+		id = R_REG(NULL, &cc->flashdata);
 		switch (id) {
 		case 0x11:
 			/* ST M25P20 2 Mbit Serial Flash */
@@ -73,10 +74,15 @@
 			sflash.blocksize = 64 * 1024;
 			sflash.numblocks = 64;
 			break;
+		case 0x16:
+			/* ST M25P64 64 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 128;
+			break;
 		case 0xbf:
-			W_REG(&cc->flashaddress, 1);
+			W_REG(NULL, &cc->flashaddress, 1);
 			sflash_cmd(cc, SFLASH_ST_RES);
-			id2 = R_REG(&cc->flashdata);
+			id2 = R_REG(NULL, &cc->flashdata);
 			if (id2 == 0x44) {
 				/* SST M25VF80 4 Mbit Serial Flash */
 				sflash.blocksize = 64 * 1024;
@@ -89,7 +95,7 @@
 	case SFLASH_AT:
 		/* Probe for Atmel chips */
 		sflash_cmd(cc, SFLASH_AT_STATUS);
-		id = R_REG(&cc->flashdata) & 0x3c;
+		id = R_REG(NULL, &cc->flashdata) & 0x3c;
 		switch (id) {
 		case 0xc:
 			/* Atmel AT45DB011 1Mbit Serial Flash */
@@ -181,11 +187,11 @@
 	case SFLASH_ST:
 		/* Check for ST Write In Progress bit */
 		sflash_cmd(cc, SFLASH_ST_RDSR);
-		return R_REG(&cc->flashdata) & SFLASH_ST_WIP;
+		return R_REG(NULL, &cc->flashdata) & SFLASH_ST_WIP;
 	case SFLASH_AT:
 		/* Check for Atmel Ready bit */
 		sflash_cmd(cc, SFLASH_AT_STATUS);
-		return !(R_REG(&cc->flashdata) & SFLASH_AT_READY);
+		return !(R_REG(NULL, &cc->flashdata) & SFLASH_AT_READY);
 	}
 
 	return 0;
@@ -199,6 +205,7 @@
 {
 	struct sflash *sfl;
 	int ret = 0;
+	bool is4712b0;
 	uint32 page, byte, mask;
 
 	if (!len)
@@ -210,35 +217,77 @@
 	sfl = &sflash;
 	switch (sfl->type) {
 	case SFLASH_ST:
-		ret = 1;
+		mask = R_REG(NULL, &cc->chipid);
+		is4712b0 = (((mask & CID_ID_MASK) == BCM4712_CHIP_ID) &&
+		            ((mask & CID_REV_MASK) == (3 << CID_REV_SHIFT)));
 		/* Enable writes */
 		sflash_cmd(cc, SFLASH_ST_WREN);
-		W_REG(&cc->flashaddress, offset);
-		W_REG(&cc->flashdata, *buf);
+		if (is4712b0) {
+			mask = 1 << 14;
+			W_REG(NULL, &cc->flashaddress, offset);
+			W_REG(NULL, &cc->flashdata, *buf++);
+			/* Set chip select */
+			OR_REG(NULL, &cc->gpioout, mask);
+			/* Issue a page program with the first byte */
+			sflash_cmd(cc, SFLASH_ST_PP);
+			ret = 1;
+			offset++;
+			len--;
+			while (len > 0) {
+				if ((offset & 255) == 0) {
+					/* Page boundary, drop cs and return */
+					AND_REG(NULL, &cc->gpioout, ~mask);
+					if (!sflash_poll(cc, offset)) {
+						/* Flash rejected command */
+						return -11;
+					}
+					return ret;
+				} else {
+					/* Write single byte */
+					sflash_cmd(cc, *buf++);
+				}
+				ret++;
+				offset++;
+				len--;
+			}
+			/* All done, drop cs if needed */
+			if ((offset & 255) != 1) {
+				/* Drop cs */
+				AND_REG(NULL, &cc->gpioout, ~mask);
+				if (!sflash_poll(cc, offset)) {
+					/* Flash rejected command */
+					return -12;
+				}
+			}
+		} else {
+			ret = 1;
+			W_REG(NULL, &cc->flashaddress, offset);
+			W_REG(NULL, &cc->flashdata, *buf);
 		/* Page program */
 		sflash_cmd(cc, SFLASH_ST_PP);
+		}
 		break;
 	case SFLASH_AT:
 		mask = sfl->blocksize - 1;
 		page = (offset & ~mask) << 1;
 		byte = offset & mask;
 		/* Read main memory page into buffer 1 */
-		if (byte || len < sfl->blocksize) {
-			W_REG(&cc->flashaddress, page);
+		if (byte || (len < sfl->blocksize)) {
+			W_REG(NULL, &cc->flashaddress, page);
 			sflash_cmd(cc, SFLASH_AT_BUF1_LOAD);
 			/* 250 us for AT45DB321B */
 			SPINWAIT(sflash_poll(cc, offset), 1000);
 			ASSERT(!sflash_poll(cc, offset));
 		}
 		/* Write into buffer 1 */
-		for (ret = 0; ret < len && byte < sfl->blocksize; ret++) {
-			W_REG(&cc->flashaddress, byte++);
-			W_REG(&cc->flashdata, *buf++);
+		for (ret = 0; (ret < (int)len) && (byte < sfl->blocksize); ret++) {
+			W_REG(NULL, &cc->flashaddress, byte++);
+			W_REG(NULL, &cc->flashdata, *buf++);
 			sflash_cmd(cc, SFLASH_AT_BUF1_WRITE);
 		}
 		/* Write buffer 1 into main memory page */
-		W_REG(&cc->flashaddress, page);
-		sflash_cmd(cc, SFLASH_AT_BUF1_ERASE_PROGRAM);
+		W_REG(NULL, &cc->flashaddress, page);
+		sflash_cmd(cc, SFLASH_AT_BUF1_PROGRAM);
 		break;
 	}
 
@@ -260,11 +309,11 @@
 	switch (sfl->type) {
 	case SFLASH_ST:
 		sflash_cmd(cc, SFLASH_ST_WREN);
-		W_REG(&cc->flashaddress, offset);
+		W_REG(NULL, &cc->flashaddress, offset);
 		sflash_cmd(cc, SFLASH_ST_SE);
 		return sfl->blocksize;
 	case SFLASH_AT:
-		W_REG(&cc->flashaddress, offset << 1);
+		W_REG(NULL, &cc->flashaddress, offset << 1);
 		sflash_cmd(cc, SFLASH_AT_PAGE_ERASE);
 		return sfl->blocksize;
 	}
@@ -284,7 +333,6 @@
 	uint blocksize = 0, mask, cur_offset, cur_length, cur_retlen, remainder;
 	uint blk_offset, blk_len, copied;
 	int bytes, ret = 0;
-	void *osh;
 
 	/* Check address range */
 	if (len <= 0)
@@ -297,11 +345,8 @@
 	blocksize = sfl->blocksize;
 	mask = blocksize - 1;
 
-	/* get kernel osl handler */
-	osh = osl_attach(NULL);
-
 	/* Allocate a block of mem */
-	if (!(block = MALLOC(osh, blocksize)))
+	if (!(block = MALLOC(NULL, blocksize)))
 		return -1;
 
 	while (len) {
@@ -325,7 +370,7 @@
 				blk_ptr = cur_ptr;
 
 				/* Copy entire block */
-				while(blk_len) {
+				while (blk_len) {
 					copied = sflash_read(cc, blk_offset, blk_len, blk_ptr); 
 					blk_offset += copied;
 					blk_len -= copied;
@@ -372,7 +417,6 @@
 	ret = len;
 done:
 	if (block)
-		MFREE(osh, block, blocksize);
+		MFREE(NULL, block, blocksize);
 	return ret;
 }
-
--- src/shared.1927/sromstubs.c	2004-12-03 05:50:00.000000000 +0300
+++ src/shared/sromstubs.c	2007-11-19 06:40:26.000000000 +0300
@@ -6,22 +16,24 @@
 
 #include <typedefs.h>
 #include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
 #include <bcmsrom.h>
 
 int
-srom_var_init(void *sbh, uint bus, void *curmap, void *osh, char **vars, int *count)
+srom_var_init(sb_t *sbh, uint bus, void *curmap, osl_t *osh, char **vars, uint *count)
 {
 	return 0;
 }
 
 int
-srom_read(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_read(sb_t *sbh, uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
 {
 	return 0;
 }
 
 int
-srom_write(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf)
+srom_write(sb_t *sbh, uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
 {
 	return 0;
 }
--- src/shared.1927/xip.lds.in	2004-11-17 23:52:36.000000000 +0300
+++ src/shared/xip.lds.in	2007-11-19 06:40:26.000000000 +0300
@@ -1,4 +1,4 @@
-OUTPUT_ARCH(mips)
+OUTPUT_ARCH(TARGET_ARCH)
 ENTRY(startup)
 SECTIONS {
 	. = TEXT_START;
@@ -9,8 +9,13 @@
 		*(.text)
 		*(.text.*)
 		*(.fini)
+		*(.glue_7t)
+		*(.glue_7)
+		*(.rdata)
+		*(.rdata.*)
 		*(.rodata)
 		*(.rodata.*)
+		. = ALIGN(16);
 		_etext = .;
 		text_end = .;
 	}
@@ -20,7 +25,6 @@
 	{
 		data_start = .;
 		_fdata = .;
-		*(.rdata)
 		*(.data)
 		*(.data.*)
 		*(.sdata)
@@ -34,6 +38,7 @@
 		*(.sbss)
 		*(.scommon)
 		*(.bss)
+		*(.bss.*)
 		*(COMMON)
 		bss_end = .;
 	}
