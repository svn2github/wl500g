--- src/include.1927/bcmdevs.h	2004-10-14 23:11:36.000000000 +0400
+++ src/include/bcmdevs.h	2007-11-19 06:40:31.000000000 +0300
@@ -14,8 +14,7 @@
 #ifndef	_BCMDEVS_H
 #define	_BCMDEVS_H
 
-
-/* Known PCI vendor Id's */
+/* PCI vendor IDs */
 #define	VENDOR_EPIGRAM		0xfeda
 #define	VENDOR_BROADCOM		0x14e4
 #define	VENDOR_3COM		0x10b7
@@ -24,24 +23,63 @@
 #define	VENDOR_DELL		0x1028
 #define	VENDOR_HP		0x0e11
 #define	VENDOR_APPLE		0x106b
+#define VENDOR_SI_IMAGE		0x1095		/* Silicon Image, used by Arasan SDIO Host */
+#define VENDOR_BUFFALO		0x1154		/* Buffalo vendor id */
+#define VENDOR_TI		0x104c		/* Texas Instruments */
+
+/* PCMCIA vendor IDs */
+#define	VENDOR_BROADCOM_PCMCIA	0x02d0
 
-/* PCI Device Id's */
+/* SDIO vendor IDs */
+#define	VENDOR_BROADCOM_SDIO	0x00BF
+
+/* PCI Device IDs */
 #define	BCM4210_DEVICE_ID	0x1072		/* never used */
-#define	BCM4211_DEVICE_ID	0x4211
 #define	BCM4230_DEVICE_ID	0x1086		/* never used */
+#define	BCM4401_ENET_ID		0x170c		/* 4401b0 production enet cards */
+#define	BCM3352_DEVICE_ID	0x3352		/* bcm3352 device id */
+#define	BCM3360_DEVICE_ID	0x3360		/* bcm3360 device id */
+#define	BCM4211_DEVICE_ID	0x4211
 #define	BCM4231_DEVICE_ID	0x4231
-
+#define	BCM4303_D11B_ID		0x4303		/* 4303 802.11b */
+#define	BCM4311_D11G_ID		0x4311		/* 4311 802.11b/g id */
+#define	BCM4311_D11DUAL_ID	0x4312		/* 4311 802.11a/b/g id */
+#define	BCM4311_D11A_ID		0x4313		/* 4311 802.11a id */
+#define	BCM4328_D11DUAL_ID	0x4314		/* 4328 802.11a/g id */
+#define	BCM4328_D11G_ID		0x4315		/* 4328 802.11g 2.4Ghz band id */
+#define	BCM4328_D11A_ID		0x4316		/* 4328 802.11a 5Ghz band id */
+#define	BCM4318_D11G_ID		0x4318		/* 4318 802.11b/g id */
+#define	BCM4318_D11DUAL_ID	0x4319		/* 4318 802.11a/b/g id */
+#define	BCM4318_D11A_ID		0x431a		/* 4318 802.11a id */
+#define	BCM4325_D11DUAL_ID	0x431b		/* 4325 802.11a/g id */
+#define	BCM4325_D11G_ID		0x431c		/* 4325 802.11g 2.4Ghz band id */
+#define	BCM4325_D11A_ID		0x431d		/* 4325 802.11a 5Ghz band id */
+#define	BCM4306_D11G_ID		0x4320		/* 4306 802.11g */
+#define	BCM4306_D11A_ID		0x4321		/* 4306 802.11a */
+#define	BCM4306_UART_ID		0x4322		/* 4306 uart */
+#define	BCM4306_V90_ID		0x4323		/* 4306 v90 codec */
+#define	BCM4306_D11DUAL_ID	0x4324		/* 4306 dual A+B */
+#define	BCM4306_D11G_ID2	0x4325		
+#define	BCM4321_D11N_ID		0x4328		/* 4321 802.11n dualband id */
+#define	BCM4321_D11N2G_ID	0x4329		/* 4321 802.11n 2.4Ghz band id */
+#define	BCM4321_D11N5G_ID	0x432a		/* 4321 802.11n 5Ghz band id */
+#define	BCMGPRS_UART_ID		0x4333		/* Uart id used by 4306/gprs card */
+#define	BCMGPRS2_UART_ID	0x4344		/* Uart id used by 4306/gprs card */
+#define FPGA_JTAGM_ID		0x43f0		/* FPGA jtagm device id */
+#define BCM_JTAGM_ID		0x43f1		/* BCM jtagm device id */
+#define SDIOH_FPGA_ID		0x43f2		/* sdio host fpga */
+#define BCM_SDIOH_ID		0x43f3		/* BCM sdio host id */
+#define SDIOD_FPGA_ID		0x43f4		/* sdio device fpga */
+#define SPIH_FPGA_ID		0x43f5		/* PCI SPI Host Controller FPGA */
+#define MIMO_FPGA_ID		0x43f8		/* FPGA mimo minimacphy device id */
+#define	BCM4402_ENET_ID		0x4402		/* 4402 enet */
+#define	BCM4402_V90_ID		0x4403		/* 4402 v90 codec */
 #define	BCM4410_DEVICE_ID	0x4410		/* bcm44xx family pci iline */
-#define	BCM4430_DEVICE_ID	0x4430		/* bcm44xx family cardbus iline */
 #define	BCM4412_DEVICE_ID	0x4412		/* bcm44xx family pci enet */
+#define	BCM4430_DEVICE_ID	0x4430		/* bcm44xx family cardbus iline */
 #define	BCM4432_DEVICE_ID	0x4432		/* bcm44xx family cardbus enet */
-
-#define	BCM3352_DEVICE_ID	0x3352		/* bcm3352 device id */
-#define	BCM3360_DEVICE_ID	0x3360		/* bcm3360 device id */
-
-#define	EPI41210_DEVICE_ID	0xa0fa		/* bcm4210 */
-#define	EPI41230_DEVICE_ID	0xa10e		/* bcm4230 */
-
+#define	BCM4704_ENET_ID		0x4706		/* 4704 enet (Use 47XX_ENET_ID instead!) */
+#define	BCM4710_DEVICE_ID	0x4710		/* 4710 primary function 0 */
 #define	BCM47XX_ILINE_ID	0x4711		/* 47xx iline20 */
 #define	BCM47XX_V90_ID		0x4712		/* 47xx v90 codec */
 #define	BCM47XX_ENET_ID		0x4713		/* 47xx enet */
@@ -53,127 +91,106 @@
 #define	BCM47XX_ROBO_ID		0x4719		/* 47xx/53xx roboswitch core */
 #define	BCM47XX_USB20H_ID	0x471a		/* 47xx usb 2.0 host */
 #define	BCM47XX_USB20D_ID	0x471b		/* 47xx usb 2.0 device */
+#define	BCM47XX_ATA100_ID	0x471d		/* 47xx parallel ATA */
+#define	BCM47XX_SATAXOR_ID	0x471e		/* 47xx serial ATA & XOR DMA */
+#define	BCM47XX_GIGETH_ID	0x471f		/* 47xx GbE (5700) */
+#define	BCM4712_MIPS_ID		0x4720		/* 4712 base devid */
+#define BCM47XX_SMBUS_EMU_ID	0x47fe		/* 47xx emulated SMBus device */
+#define	BCM47XX_XOR_EMU_ID	0x47ff		/* 47xx emulated XOR engine */
+#define	EPI41210_DEVICE_ID	0xa0fa		/* bcm4210 */
+#define	EPI41230_DEVICE_ID	0xa10e		/* bcm4230 */
+#define JINVANI_SDIOH_ID	0x4743		/* Jinvani SDIO Gold Host */
+#define BCM27XX_SDIOH_ID	0x2702		/* BCM27xx Standard SDIO Host */
+#define PCIXX21_FLASHMEDIA_ID	0x803b		/* TI PCI xx21 Standard Host Controller */
+#define PCIXX21_SDIOH_ID	0x803c		/* TI PCI xx21 Standard Host Controller */
+
+/* Chip IDs */
+#define	BCM4710_CHIP_ID		0x4710		/* 4710 chipid returned by sb_chip() */
+#define	BCM4402_CHIP_ID		0x4402		/* 4402 chipid */
+#define	BCM4306_CHIP_ID		0x4306		/* 4306 chipcommon chipid */
+#define	BCM4311_CHIP_ID		0x4311		/* 4311 PCIe 802.11a/b/g */
+#define	BCM4704_CHIP_ID		0x4704		/* 4704 chipcommon chipid */
+#define	BCM4312_CHIP_ID		0x4312		/* 4312 chip common chipid */
+#define	BCM4318_CHIP_ID		0x4318		/* 4318 chip common chipid */
+#define	BCM4321_CHIP_ID		0x4321		/* 4321 chip common chipid */
+#define	BCM4328_CHIP_ID		0x4328		/* 4328 chip common chipid */
+#define	BCM4325_CHIP_ID		0x4325		/* 4325 chip common chipid */
+#define	BCM4712_CHIP_ID		0x4712		/* 4712 chipcommon chipid */
+#define BCM5365_CHIP_ID		0x5365          /* 5365 chipcommon chipid */
+#define	BCM5350_CHIP_ID		0x5350		/* bcm5350 chipcommon chipid */
+#define	BCM5352_CHIP_ID		0x5352		/* bcm5352 chipcommon chipid */
+#define	BCM5354_CHIP_ID		0x5354		/* bcm5354 chipcommon chipid */
+#define	BCM4320_CHIP_ID		0x4320		/* bcm4320 chipcommon chipid */
+#define BCM4785_CHIP_ID		0x4785		/* 4785 chipcommon chipid */
 
-#define	BCM4710_DEVICE_ID	0x4710		/* 4710 primary function 0 */
-
-#define	BCM4610_DEVICE_ID	0x4610		/* 4610 primary function 0 */
-#define	BCM4610_ILINE_ID	0x4611		/* 4610 iline100 */
-#define	BCM4610_V90_ID		0x4612		/* 4610 v90 codec */
-#define	BCM4610_ENET_ID		0x4613		/* 4610 enet */
-#define	BCM4610_EXT_ID		0x4614		/* 4610 external i/f */
-#define	BCM4610_USB_ID		0x4615		/* 4610 usb */
-
-#define	BCM4402_DEVICE_ID	0x4402		/* 4402 primary function 0 */
-#define	BCM4402_ENET_ID		0x4402		/* 4402 enet */
-#define	BCM4402_V90_ID		0x4403		/* 4402 v90 codec */
-#define	BCM4401_ENET_ID		0x170c		/* 4401b0 production enet cards */
-
-#define	BCM4301_DEVICE_ID	0x4301		/* 4301 primary function 0 */
-#define	BCM4301_D11B_ID		0x4301		/* 4301 802.11b */
-
-#define	BCM4307_DEVICE_ID	0x4307		/* 4307 primary function 0 */
-#define	BCM4307_V90_ID		0x4305		/* 4307 v90 codec */
-#define	BCM4307_ENET_ID		0x4306		/* 4307 enet */
-#define	BCM4307_D11B_ID		0x4307		/* 4307 802.11b */
-
-#define	BCM4306_DEVICE_ID	0x4306		/* 4306 chipcommon chipid */
-#define	BCM4306_D11G_ID		0x4320		/* 4306 802.11g */
-#define	BCM4306_D11G_ID2	0x4325		
-#define	BCM4306_D11A_ID		0x4321		/* 4306 802.11a */
-#define	BCM4306_UART_ID		0x4322		/* 4306 uart */
-#define	BCM4306_V90_ID		0x4323		/* 4306 v90 codec */
-#define	BCM4306_D11DUAL_ID	0x4324		/* 4306 dual A+B */
-
-#define	BCM4309_PKG_ID		1		/* 4309 package id */
-
-#define	BCM4303_D11B_ID		0x4303		/* 4303 802.11b */
+/* Package IDs */
 #define	BCM4303_PKG_ID		2		/* 4303 package id */
-
-#define	BCM4310_DEVICE_ID	0x4310		/* 4310 chipcommon chipid */
-#define	BCM4310_D11B_ID		0x4311		/* 4310 802.11b */
-#define	BCM4310_UART_ID		0x4312		/* 4310 uart */
-#define	BCM4310_ENET_ID		0x4313		/* 4310 enet */
-#define	BCM4310_USB_ID		0x4315		/* 4310 usb */
-
-#define	BCMGPRS_UART_ID		0x4333		/* Uart id used by 4306/gprs card */
-
-#define	BCM4704_DEVICE_ID	0x4704		/* 4704 chipcommon chipid */
-#define	BCM4704_ENET_ID		0x4706		/* 4704 enet (Use 47XX_ENET_ID instead!) */
-
-#define	BCM4317_DEVICE_ID	0x4317		/* 4317 chip common chipid */
-
-#define	BCM4318_DEVICE_ID	0x4318		/* 4318 chip common chipid */
-#define	BCM4318_D11G_ID		0x4318		/* 4318 801.11b/g id */
-#define	BCM4318_D11DUAL_ID	0x4319		/* 4318 801.11a/b/g id */
-#define BCM4318_JTAGM_ID	0x4331		/* 4318 jtagm device id */
-
-#define FPGA_JTAGM_ID		0x4330		/* ??? */
-
-#define	BCM4712_DEVICE_ID	0x4712		/* 4712 chipcommon chipid */
-#define	BCM4712_MIPS_ID		0x4720		/* 4712 base devid */
+#define	BCM4309_PKG_ID		1		/* 4309 package id */
 #define	BCM4712LARGE_PKG_ID	0		/* 340pin 4712 package id */
 #define	BCM4712SMALL_PKG_ID	1		/* 200pin 4712 package id */
 #define	BCM4712MID_PKG_ID	2		/* 225pin 4712 package id */
+#define BCM4328USBD11G_PKG_ID	2		/* 4328 802.11g USB package id */
+#define BCM4328USBDUAL_PKG_ID	3		/* 4328 802.11a/g USB package id */
+#define BCM4328SDIOD11G_PKG_ID	4		/* 4328 802.11g SDIO package id */
+#define BCM4328SDIODUAL_PKG_ID	5		/* 4328 802.11a/g SDIO package id */
+#define BCM5354E_PKG_ID		1		/* 5354E package id */
+#define HDLSIM5350_PKG_ID	1		/* HDL simulator package id for a 5350 */
+#define HDLSIM_PKG_ID		14		/* HDL simulator package id */
+#define HWSIM_PKG_ID		15		/* Hardware simulator package id */
 
-#define	SDIOH_FPGA_ID		0x4380		/* sdio host fpga */
-
-#define BCM5365_DEVICE_ID       0x5365          /* 5365 chipcommon chipid */
-#define	BCM5350_DEVICE_ID	0x5350		/* bcm5350 chipcommon chipid */
-
-
-/* PCMCIA vendor Id's */
-
-#define	VENDOR_BROADCOM_PCMCIA	0x02d0
-
-/* SDIO vendor Id's */
-#define	VENDOR_BROADCOM_SDIO	0x00BF
-
-
+#define PCIXX21_FLASHMEDIA0_ID	0x8033		/* TI PCI xx21 Standard Host Controller */
+#define PCIXX21_SDIOH0_ID	0x8034		/* TI PCI xx21 Standard Host Controller */
 /* boardflags */
-#define	BFL_BTCOEXIST		0x0001	/* This board implements Bluetooth coexistance */
-#define	BFL_PACTRL		0x0002	/* This board has gpio 9 controlling the PA */
-#define	BFL_AIRLINEMODE		0x0004	/* This board implements gpio13 radio disable indication */
-#define	BFL_ENETROBO		0x0010	/* This board has robo switch or core */
-#define	BFL_CCKHIPWR		0x0040	/* Can do high-power CCK transmission */
-#define	BFL_ENETADM		0x0080	/* This board has ADMtek switch */
-#define	BFL_ENETVLAN		0x0100	/* This board has vlan capability */
-#define	BFL_AFTERBURNER		0x0200	/* This board supports Afterburner mode */
-#define BFL_NOPCI		0x0400	/* This board leaves PCI floating */
-#define BFL_FEM			0x0800  /* This board supports the Front End Module */
-#define BFL_EXTLNA		0x1000	/* This board has an external LNA */
-#define BFL_HGPA		0x2000	/* This board has a high gain PA */
+#define	BFL_BTCOEXIST		0x00000001	/* This board implements Bluetooth coexistance */
+#define	BFL_PACTRL		0x00000002	/* This board has gpio 9 controlling the PA */
+#define	BFL_AIRLINEMODE	0x00000004	/* This board implements gpio13 radio disable indication */
+#define	BFL_ENETROBO		0x00000010	/* This board has robo switch or core */
+#define	BFL_CCKHIPWR		0x00000040	/* Can do high-power CCK transmission */
+#define	BFL_ENETADM		0x00000080	/* This board has ADMtek switch */
+#define	BFL_ENETVLAN		0x00000100	/* This board has vlan capability */
+#define	BFL_AFTERBURNER		0x00000200	/* This board supports Afterburner mode */
+#define BFL_NOPCI		0x00000400	/* This board leaves PCI floating */
+#define BFL_FEM			0x00000800  /* This board supports the Front End Module */
+#define BFL_EXTLNA		0x00001000	/* This board has an external LNA */
+#define BFL_HGPA		0x00002000	/* This board has a high gain PA */
+#define	BFL_BTCMOD	0x00004000	/* This board' BTCOEXIST is in the alternate gpios */
+#define	BFL_ALTIQ		0x00008000	/* Alternate I/Q settings */
+#define BFL_NOPA	0x00010000	/* This board has no PA */
+#define BFL_RSSIINV		0x00020000	/* This board's RSSI uses positive slope */
+#define BFL_PAREF		0x00040000	/* This board uses the PARef LDO */
+#define BFL_3TSWITCH	0x00080000	/* This board uses a triple throw switch shared with BT */
+#define BFL_PHASESHIFTER	0x00100000	/* This board can support phase shifter */
+#define BFL_BUCKBOOST	0x00200000	/* This board has buck/booster */
+/* boardflags2 */
+#define BFL2_RXBB_INT_REG_DIS	0x00000001	/* This board has an external rxbb regulator */
+#define BFL2_DEPRECIATED_STUB	0x00000002	/* This board flag is depreciated */
+#define BFL2_TXPWRCTRL_EN	0x00000004	/* This board permits enabling TX Power Control */
+#define BFL2_2X4_DIV		0x00000008	/* This board supports the 2X4 diversity switch */
+#define BFL2_5G_PWRGAIN		0x00000010	/* This board supports 5G band power gain */
+#define BFL2_PCIEWAR_OVR	0x00000020	/* This board overrides ASPM and Clkreq settings */
+#define BFL2_CAESERS_BRD	0x00000040	/* This board is Dell Caeser's brd (unused by sw) */
 
 /* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
-#define BOARD_GPIO_HWRAD_B	0x010	/* bit 4 is HWRAD input on 4301 */
+#define	BOARD_GPIO_BTCMOD_IN	0x010	/* bit 4 is the alternate BT Coexistance Input */
+#define	BOARD_GPIO_BTCMOD_OUT	0x020	/* bit 5 is the alternate BT Coexistance Out */
 #define	BOARD_GPIO_BTC_IN	0x080	/* bit 7 is BT Coexistance Input */
 #define	BOARD_GPIO_BTC_OUT	0x100	/* bit 8 is BT Coexistance Out */
 #define	BOARD_GPIO_PACTRL	0x200	/* bit 9 controls the PA on new 4306 boards */
+#define BOARD_GPIO_ANT0_SEL	0x100	/* With BFL2_2X4_DIV */
+#define BOARD_GPIO_ANT1_SEL	0x200	/* With BFL2_2X4_DIV */
+
 #define	PCI_CFG_GPIO_SCS	0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
 #define PCI_CFG_GPIO_HWRAD	0x20	/* PCI config space GPIO 13 for hw radio disable */
 #define PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal powerup */
 #define PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL powerdown */
 
-/* Bus types */
-#define	SB_BUS			0	/* Silicon Backplane */
-#define	PCI_BUS			1	/* PCI target */
-#define	PCMCIA_BUS		2	/* PCMCIA target */
-#define SDIO_BUS		3	/* SDIO target */
-#define JTAG_BUS		4	/* JTAG */
-
-/* Allows optimization for single-bus support */
-#ifdef BCMBUSTYPE
-#define BUSTYPE(bus) (BCMBUSTYPE)
-#else
-#define BUSTYPE(bus) (bus)
-#endif
-
 /* power control defines */
-#define PLL_DELAY		150		/* 150us pll on delay */
-#define FREF_DELAY		200		/* 200us fref change delay */
-#define MIN_SLOW_CLK		32		/* 32us Slow clock period */
+#define PLL_DELAY		150		/* us pll on delay */
+#define FREF_DELAY		200		/* us fref change delay */
+#define MIN_SLOW_CLK		32		/* us Slow clock period */
+#define	XTAL_ON_DELAY		1000		/* us crystal power-on delay */
 
 /* Reference Board Types */
-
 #define	BU4710_BOARD		0x0400
 #define	VSIM4710_BOARD		0x0401
 #define	QT4710_BOARD		0x0402
@@ -178,16 +195,6 @@
 #define	VSIM4710_BOARD		0x0401
 #define	QT4710_BOARD		0x0402
 
-#define	BU4610_BOARD		0x0403
-#define	VSIM4610_BOARD		0x0404
-
-#define	BU4307_BOARD		0x0405
-#define	BCM94301CB_BOARD	0x0406
-#define	BCM94301PC_BOARD	0x0406		/* Pcmcia 5v card */
-#define	BCM94301MP_BOARD	0x0407
-#define	BCM94307MP_BOARD	0x0408
-#define	BCMAP4307_BOARD		0x0409
-
 #define	BU4309_BOARD		0x040a
 #define	BCM94309CB_BOARD	0x040b
 #define	BCM94309MP_BOARD	0x040c
@@ -195,12 +202,6 @@
 
 #define	BCM94302MP_BOARD	0x040e
 
-#define	VSIM4310_BOARD		0x040f
-#define	BU4711_BOARD		0x0410
-#define	BCM94310U_BOARD		0x0411
-#define	BCM94310AP_BOARD	0x0412
-#define	BCM94310MP_BOARD	0x0414
-
 #define	BU4306_BOARD		0x0416
 #define	BCM94306CB_BOARD	0x0417
 #define	BCM94306MP_BOARD	0x0418
@@ -216,15 +216,11 @@
 
 #define	BCM94309G_BOARD		0x0421
 
-#define	BCM94301PC3_BOARD	0x0422		/* Pcmcia 3.3v card */
-
 #define	BU4704_BOARD		0x0423
 #define	BU4702_BOARD		0x0424
 
 #define	BCM94306PC_BOARD	0x0425		/* pcmcia 3.3v 4306 card */
 
-#define	BU4317_BOARD		0x0426
-
 
 #define	BCM94702MN_BOARD	0x0428
 
@@ -237,9 +233,6 @@
 /* cb4306 with SiGe PA */
 #define	BCM94306CBSG_BOARD	0x042b
 
-/* mp4301 with 2050 radio */
-#define	BCM94301MPL_BOARD	0x042c
-
 /* cb4306 with SiGe PA */
 #define	PCSG94306_BOARD		0x042d
 
@@ -254,12 +247,6 @@
 
 
 
-/* BCM94317 boards */
-#define BCM94317CB_BOARD	0x0440
-#define BCM94317MP_BOARD	0x0441
-#define BCM94317PCMCIA_BOARD	0x0442
-#define BCM94317SDIO_BOARD	0x0443
-
 #define BU4712_BOARD		0x0444
 #define	BU4712SD_BOARD		0x045d
 #define	BU4712L_BOARD		0x045f
@@ -275,12 +262,14 @@
 #define MP4318_BOARD		0x044a
 #define SD4318_BOARD		0x044b
 
+/* BCM63XX boards */
+#define BCM96338_BOARD		0x6338
+#define BCM96348_BOARD		0x6348
+#define BCM96358_BOARD		0x6358
+
 /* Another mp4306 with SiGe */
 #define	BCM94306P_BOARD		0x044c
 
-/* CF-like 4317 modules */
-#define	BCM94317CF_BOARD	0x044d
-
 /* mp4303 */
 #define	BCM94303MP_BOARD	0x044e
 
@@ -294,9 +283,6 @@
 /* 4712agr */
 #define	BCM94712AGR_BOARD	0x0451
 
-/* The real CF 4317 board */
-#define	CFI4317_BOARD		0x0452
-
 /* pcmcia 4303 */
 #define	PC4303_BOARD		0x0454
 
@@ -309,6 +295,10 @@
 /* 4306mplna */
 #define	BCM94306MPLNA_BOARD	0x0457
 
+/* 4320 boards */
+#define	BU4320_BOARD		0x0458
+#define	BU4320S_BOARD		0x0459
+#define	BCM94320PH_BOARD	0x045a
 
 /* 4306mph */
 #define	BCM94306MPH_BOARD	0x045b
@@ -318,11 +308,85 @@
 
 #define	BU4712SD_BOARD		0x045d
 
+#define	BCM94320PFLSH_BOARD	0x045e
 
 #define	BU4712L_BOARD		0x045f
 #define	BCM94712LGR_BOARD	0x0460
+#define	BCM94320R_BOARD		0x0461
+
+#define	BU5352_BOARD		0x0462
+
+#define	BCM94318MPGH_BOARD	0x0463
+
+#define	BU4311_BOARD		0x0464
+#define	BCM94311MC_BOARD	0x0465
+#define	BCM94311MCAG_BOARD	0x0466
+
+#define	BCM95352GR_BOARD	0x0467
+
+/* bcm95351agr */
+#define	BCM95351AGR_BOARD	0x0470
+
+/* bcm94704mpcb */
+#define	BCM94704MPCB_BOARD	0x0472
+
+/* 4785 boards */
+#define BU4785_BOARD		0x0478
+
+/* 4321 boards */
+#define BU4321_BOARD		0x046b
+#define BU4321E_BOARD		0x047c
+#define MP4321_BOARD		0x046c
+#define CB2_4321_BOARD		0x046d
+#define MC4321_BOARD		0x046e
+
+/* 4328 boards */
+#define BU4328_BOARD		0x0481
+#define BCM4328SDG_BOARD	0x0482
+#define BCM4328SDAG_BOARD	0x0483
+#define BCM4328UG_BOARD		0x0484
+#define BCM4328UAG_BOARD	0x0485
+#define BCM4328PC_BOARD		0x0486
+#define BCM4328CF_BOARD		0x0487
+
+/* 4325 boards */
+#define BU4325_BOARD		0x0490
 
 /* # of GPIO pins */
 #define GPIO_NUMPINS		16
 
+/* radio ID codes */
+#define	NORADIO_ID		0xe4f5
+#define	NORADIO_IDCODE		0x4e4f5246
+
+#define	BCM2050_ID		0x2050
+#define	BCM2050_IDCODE		0x02050000
+#define	BCM2050A0_IDCODE	0x1205017f
+#define	BCM2050A1_IDCODE	0x2205017f
+#define	BCM2050R8_IDCODE	0x8205017f
+
+#define BCM2055_ID		0x2055
+#define BCM2055_IDCODE		0x02055000
+#define BCM2055A0_IDCODE	0x1205517f
+
+#define	BCM2060_ID		0x2060
+#define	BCM2060_IDCODE		0x02060000
+#define	BCM2060WW_IDCODE	0x1206017f
+
+#define BCM2062_ID		0x2062
+#define BCM2062_IDCODE		0x02062000
+#define BCM2062A0_IDCODE	0x0206217f
+
+#define BCM2063_ID		0x2063
+#define BCM2063_IDCODE		0x02063000
+#define BCM2063A0_IDCODE	0x0206317f
+
+/* parts of an idcode: */
+#define	IDCODE_MFG_MASK		0x00000fff
+#define	IDCODE_MFG_SHIFT	0
+#define	IDCODE_ID_MASK		0x0ffff000
+#define	IDCODE_ID_SHIFT		12
+#define	IDCODE_REV_MASK		0xf0000000
+#define	IDCODE_REV_SHIFT	28
+
 #endif /* _BCMDEVS_H */
--- src/include.1927/bcmendian.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmendian.h	2007-11-19 06:40:31.000000000 +0300
@@ -1,7 +1,7 @@
 /*
  * local version of endian.h - byte order defines
  *
- * Copyright 2004, Broadcom Corporation   
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.   
  *    
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY   
@@ -9,7 +9,7 @@
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS   
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.   
  *
- *  $Id$
+ *  $Id: bcmendian.h,v 1.1.1.10 2006/02/27 03:43:16 honor Exp $
 */
 
 #ifndef _BCMENDIAN_H_
@@ -19,17 +19,24 @@
 
 /* Byte swap a 16 bit value */
 #define BCMSWAP16(val) \
-	((uint16)( \
+	((uint16)(\
 		(((uint16)(val) & (uint16)0x00ffU) << 8) | \
-		(((uint16)(val) & (uint16)0xff00U) >> 8) ))
+		(((uint16)(val) & (uint16)0xff00U) >> 8)))
 	
 /* Byte swap a 32 bit value */
 #define BCMSWAP32(val) \
-	((uint32)( \
+	((uint32)(\
 		(((uint32)(val) & (uint32)0x000000ffUL) << 24) | \
 		(((uint32)(val) & (uint32)0x0000ff00UL) <<  8) | \
 		(((uint32)(val) & (uint32)0x00ff0000UL) >>  8) | \
-		(((uint32)(val) & (uint32)0xff000000UL) >> 24) ))
+		(((uint32)(val) & (uint32)0xff000000UL) >> 24)))
+
+/* 2 Byte swap a 32 bit value */
+#define BCMSWAP32BY16(val) \
+	((uint32)(\
+		(((uint32)(val) & (uint32)0x0000ffffUL) << 16) | \
+		(((uint32)(val) & (uint32)0xffff0000UL) >> 16)))
+
 
 static INLINE uint16
 bcmswap16(uint16 val)
@@ -43,6 +50,12 @@
 	return BCMSWAP32(val);
 }
 
+static INLINE uint32
+bcmswap32by16(uint32 val)
+{
+	return BCMSWAP32BY16(val);
+}
+
 /* buf	- start of buffer of shorts to swap */
 /* len  - byte length of buffer */
 static INLINE void
@@ -50,7 +63,7 @@
 {
 	len = len/2;
 
-	while(len--){
+	while (len--) {
 		*buf = bcmswap16(*buf);
 		buf++;
 	}
@@ -77,8 +90,8 @@
 #define	ltoh32(i) bcmswap32(i)
 #define htol16(i) bcmswap16(i)
 #define htol32(i) bcmswap32(i)
-#endif
-#endif
+#endif /* IL_BIGENDIAN */
+#endif /* hton16 */
 
 #ifndef IL_BIGENDIAN
 #define ltoh16_buf(buf, i)
@@ -86,83 +99,100 @@
 #else
 #define ltoh16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
 #define htol16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
-#endif
+#endif /* IL_BIGENDIAN */
+
+/*
+* store 16-bit value to unaligned little endian byte array.
+*/
+static INLINE void
+htol16_ua_store(uint16 val, uint8 *bytes)
+{
+	bytes[0] = val&0xff;
+	bytes[1] = val>>8;
+}
+
+/*
+* store 32-bit value to unaligned little endian byte array.
+*/
+static INLINE void
+htol32_ua_store(uint32 val, uint8 *bytes)
+{
+	bytes[0] = val&0xff;
+	bytes[1] = (val>>8)&0xff;
+	bytes[2] = (val>>16)&0xff;
+	bytes[3] = val>>24;
+}
+
+/*
+* store 16-bit value to unaligned network(big) endian byte array.
+*/
+static INLINE void
+hton16_ua_store(uint16 val, uint8 *bytes)
+{
+	bytes[1] = val&0xff;
+	bytes[0] = val>>8;
+}
+
+/*
+* store 32-bit value to unaligned network(big) endian byte array.
+*/
+static INLINE void
+hton32_ua_store(uint32 val, uint8 *bytes)
+{
+	bytes[3] = val&0xff;
+	bytes[2] = (val>>8)&0xff;
+	bytes[1] = (val>>16)&0xff;
+	bytes[0] = val>>24;
+}
 
 /*
 * load 16-bit value from unaligned little endian byte array.
 */
 static INLINE uint16
-ltoh16_ua(uint8 *bytes)
+ltoh16_ua(void *bytes)
 {
-	return (bytes[1]<<8)+bytes[0];
+	return (((uint8*)bytes)[1]<<8)+((uint8 *)bytes)[0];
 }
 
 /*
 * load 32-bit value from unaligned little endian byte array.
 */
 static INLINE uint32
-ltoh32_ua(uint8 *bytes)
+ltoh32_ua(void *bytes)
 {
-	return (bytes[3]<<24)+(bytes[2]<<16)+(bytes[1]<<8)+bytes[0];
+	return (((uint8*)bytes)[3]<<24)+(((uint8*)bytes)[2]<<16)+
+	       (((uint8*)bytes)[1]<<8)+((uint8*)bytes)[0];
 }
 
 /*
 * load 16-bit value from unaligned big(network) endian byte array.
 */
 static INLINE uint16
-ntoh16_ua(uint8 *bytes)
+ntoh16_ua(void *bytes)
 {
-	return (bytes[0]<<8)+bytes[1];
+	return (((uint8*)bytes)[0]<<8)+((uint8*)bytes)[1];
 }
 
 /*
 * load 32-bit value from unaligned big(network) endian byte array.
 */
 static INLINE uint32
-ntoh32_ua(uint8 *bytes)
+ntoh32_ua(void *bytes)
 {
-	return (bytes[0]<<24)+(bytes[1]<<16)+(bytes[2]<<8)+bytes[3];
+	return (((uint8*)bytes)[0]<<24)+(((uint8*)bytes)[1]<<16)+
+	       (((uint8*)bytes)[2]<<8)+((uint8*)bytes)[3];
 }
 
-/* get_ua adapted from Linux asm-mips/unaligned.h */
-#ifdef IL_BIGENDIAN
-#define get_ua(ptr)						\
-({									\
-	__typeof__(*(ptr)) __val;					\
-									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		__val = *(uint8 *)ptr;			\
-		break;							\
-	case 2:								\
-		__val = ntoh16_ua((uint8 *)ptr);		\
-		break;							\
-	case 4:								\
-		__val = ntoh32_ua((uint8 *)ptr);		\
-		break;							\
-	}								\
-									\
-	__val;								\
-})
-#else
-#define get_ua(ptr)						\
-({									\
-	__typeof__(*(ptr)) __val;					\
-									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		__val = *(uint8 *)ptr;			\
-		break;							\
-	case 2:								\
-		__val = ltoh16_ua((uint8 *)ptr);		\
-		break;							\
-	case 4:								\
-		__val = ltoh32_ua((uint8 *)ptr);		\
-		break;							\
-	}								\
-									\
-	__val;								\
-})
-#endif
+#define ltoh_ua(ptr) (\
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] : \
+	(((uint8 *)ptr)[3]<<24)+(((uint8 *)ptr)[2]<<16)+(((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] \
+)
+
+#define ntoh_ua(ptr) (\
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[0]<<8)+((uint8 *)ptr)[1] : \
+	(((uint8 *)ptr)[0]<<24)+(((uint8 *)ptr)[1]<<16)+(((uint8 *)ptr)[2]<<8)+((uint8 *)ptr)[3] \
+)
 
 #endif /* _BCMENDIAN_H_ */
--- src/include.1927/bcmenet47xx.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmenet47xx.h	2007-11-19 06:40:31.000000000 +0300
@@ -74,8 +74,8 @@
 	uint32	PAD[63];
 
 	/* DMA engine */
-	dmaregs_t	dmaregs;
-	dmafifo_t	dmafifo;
+	dma32regp_t	dmaregs;
+	dma32diag_t	dmafifo;
 	uint32	PAD[116];
 
 	/* EMAC Registers */
--- src/include.1927/bcmenetphy.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmenetphy.h	2007-11-19 06:40:31.000000000 +0300
@@ -16,7 +16,7 @@
 
 /* phy address */
 #define	MAXEPHY		32			/* mdio phy addresses are 5bit quantities */
-#define	EPHY_MASK	0x1f
+#define	EPHY_MASK	0x1f			/* phy mask */
 #define	EPHY_NONE	31			/* nvram: no phy present at all */
 #define	EPHY_NOREG	30			/* nvram: no local phy regs */
 
--- src/include.1927/bcmenetrxh.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmenetrxh.h	2007-11-19 06:40:31.000000000 +0300
@@ -28,7 +28,7 @@
 	uint16	pad[12];
 } bcmenetrxh_t;
 
-#define	RXHDR_LEN	28
+#define	RXHDR_LEN	28	/* Header length */
 
 #define	RXF_L		((uint16)1 << 11)	/* last buffer in a frame */
 #define	RXF_MISS	((uint16)1 << 7)	/* received due to promisc mode */
--- src/include.1927/bcmnvram.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmnvram.h	2007-11-19 06:40:31.000000000 +0300
@@ -18,12 +18,13 @@
 #ifndef _LANGUAGE_ASSEMBLY
 
 #include <typedefs.h>
+#include <bcmdefs.h>
 
 struct nvram_header {
 	uint32 magic;
 	uint32 len;
-	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:27 init, mem. test 28, 29-31 reserved */
-	uint32 config_refresh;	/* 0:15 config, 16:31 refresh */
+	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
 	uint32 config_ncdl;	/* ncdl values for memc */
 };
 
@@ -34,16 +35,31 @@
 };
 
 /*
+ * Get default value for an NVRAM variable
+ */
+extern char *nvram_default_get(const char *name);
+
+/*
  * Initialize NVRAM access. May be unnecessary or undefined on certain
  * platforms.
  */
-extern int BCMINIT(nvram_init)(void *sbh);
+extern int nvram_init(void *sbh);
+
+/*
+ * Append a chunk of nvram variables to the global list
+ */
+extern int nvram_append(void *sb, char *vars, uint varsz);
+
+/*
+ * Check for reset button press for restoring factory defaults.
+ */
+extern bool nvram_reset(void *sbh);
 
 /*
  * Disable NVRAM access. May be unnecessary or undefined on certain
  * platforms.
  */
-extern void BCMINIT(nvram_exit)(void);
+extern void nvram_exit(void *sbh);
 
 /*
  * Get the value of an NVRAM variable. The pointer returned may be
@@ -51,14 +67,20 @@
  * @param	name	name of variable to get
  * @return	value of variable or NULL if undefined
  */
-extern char * BCMINIT(nvram_get)(const char *name);
+extern char * nvram_get(const char *name);
+
+/* 
+ * Read the reset GPIO value from the nvram and set the GPIO
+ * as input
+ */
+extern int BCMINITFN(nvram_resetgpio_init)(void *sbh);
 
 /* 
  * Get the value of an NVRAM variable.
  * @param	name	name of variable to get
  * @return	value of variable or NUL if undefined
  */
-#define nvram_safe_get(name) (BCMINIT(nvram_get)(name) ? : "")
+#define nvram_safe_get(name) (nvram_get(name) ? : "")
 
 /*
  * Match an NVRAM variable.
@@ -69,8 +91,8 @@
  *		to match or FALSE otherwise
  */
 static INLINE int
-nvram_match(char *name, char *match) {
-	const char *value = BCMINIT(nvram_get)(name);
+nvram_match(const char *name, const char *match) {
+	const char *value = nvram_get(name);
 	return (value && !strcmp(value, match));
 }
 
@@ -82,8 +104,8 @@
  *		equal to invmatch or FALSE otherwise
  */
 static INLINE int
-nvram_invmatch(char *name, char *invmatch) {
-	const char *value = BCMINIT(nvram_get)(name);
+nvram_invmatch(const char *name, const char *invmatch) {
+	const char *value = nvram_get(name);
 	return (value && strcmp(value, invmatch));
 }
 
@@ -95,7 +117,7 @@
  * @param	value	value of variable
  * @return	0 on success and errno on failure
  */
-extern int BCMINIT(nvram_set)(const char *name, const char *value);
+extern int nvram_set(const char *name, const char *value);
 
 /*
  * Unset an NVRAM variable. Pointers to previously set values
@@ -104,7 +126,7 @@
  * @return	0 on success and errno on failure
  * NOTE: use nvram_commit to commit this change to flash.
  */
-extern int BCMINIT(nvram_unset)(const char *name);
+extern int nvram_unset(const char *name);
 
 /*
  * Commit NVRAM variables to permanent storage. All pointers to values
@@ -112,7 +134,7 @@
  * NVRAM values are undefined after a commit.
  * @return	0 on success and errno on failure
  */
-extern int BCMINIT(nvram_commit)(void);
+extern int nvram_commit(void);
 
 /*
  * Get all NVRAM variables (format name=value\0 ... \0\0).
@@ -120,13 +142,30 @@
  * @param	count	size of buffer in bytes
  * @return	0 on success and errno on failure
  */
-extern int BCMINIT(nvram_getall)(char *buf, int count);
+extern int nvram_getall(char *nvram_buf, int count);
+
+/*
+ * returns the crc value of the nvram
+ * @param	nvh	nvram header pointer
+ */
+uint8 nvram_calc_crc(struct nvram_header * nvh);
 
 #endif /* _LANGUAGE_ASSEMBLY */
 
+/* The NVRAM version number stored as an NVRAM variable */
+#define NVRAM_SOFTWARE_VERSION	"1"
+
 #define NVRAM_MAGIC		0x48534C46	/* 'FLSH' */
+#define NVRAM_CLEAR_MAGIC	0x0
+#define NVRAM_INVALID_MAGIC	0xFFFFFFFF
 #define NVRAM_VERSION		1
 #define NVRAM_HEADER_SIZE	20
 #define NVRAM_SPACE		0x8000
 
+#define NVRAM_MAX_VALUE_LEN 255
+#define NVRAM_MAX_PARAM_LEN 64
+
+#define NVRAM_CRC_START_POSITION	9 /* magic, len, crc8 to be skipped */
+#define NVRAM_CRC_VER_MASK	0xffffff00 /* for crc_ver_init */
+
 #endif /* _bcmnvram_h_ */
--- src/include.1927/bcmparams.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmparams.h	2007-11-19 06:40:31.000000000 +0300
@@ -20,4 +20,6 @@
 
 #define DEV_NUMIFS	16	/* Max. # of devices/interfaces supported */
 
+#define WL_MAXBSSCFG	16	/* maximum number of BSS Configs we can configure */
+
 #endif
--- src/include.1927/bcmsrom.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmsrom.h	2007-11-19 06:40:31.000000000 +0300
@@ -15,8 +15,296 @@
 #ifndef	_bcmsrom_h_
 #define	_bcmsrom_h_
 
-extern int srom_var_init(void *sbh, uint bus, void *curmap, void *osh, char **vars, int *count);
-extern int srom_read(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf);
-extern int srom_write(uint bus, void *curmap, void *osh, uint byteoff, uint nbytes, uint16 *buf);
+/* Maximum srom: 4 Kilobits == 512 bytes */
+#define	SROM_MAX		512
+
+
+#define	SROM_WORDS		64
+
+#define SROM3_SWRGN_OFF		28	/* s/w region offset in words */
+
+#define	SROM_SSID		2
+
+#define	SROM_WL1LHMAXP		29
+
+#define	SROM_WL1LPAB0		30
+#define	SROM_WL1LPAB1		31
+#define	SROM_WL1LPAB2		32
+
+#define	SROM_WL1HPAB0		33
+#define	SROM_WL1HPAB1		34
+#define	SROM_WL1HPAB2		35
+
+#define	SROM_MACHI_IL0		36
+#define	SROM_MACMID_IL0		37
+#define	SROM_MACLO_IL0		38
+#define	SROM_MACHI_ET0		39
+#define	SROM_MACMID_ET0		40
+#define	SROM_MACLO_ET0		41
+#define	SROM_MACHI_ET1		42
+#define	SROM_MACMID_ET1		43
+#define	SROM_MACLO_ET1		44
+#define	SROM3_MACHI		37
+#define	SROM3_MACMID		38
+#define	SROM3_MACLO		39
+
+#define	SROM_BXARSSI2G		40
+#define	SROM_BXARSSI5G		41
+
+#define	SROM_TRI52G		42
+#define	SROM_TRI5GHL		43
+
+#define	SROM_RXPO52G		45
+
+#define	SROM2_ENETPHY		45
+
+#define	SROM_AABREV		46
+/* Fields in AABREV */
+#define	SROM_BR_MASK		0x00ff
+#define	SROM_CC_MASK		0x0f00
+#define	SROM_CC_SHIFT		8
+#define	SROM_AA0_MASK		0x3000
+#define	SROM_AA0_SHIFT		12
+#define	SROM_AA1_MASK		0xc000
+#define	SROM_AA1_SHIFT		14
+
+#define	SROM_WL0PAB0		47
+#define	SROM_WL0PAB1		48
+#define	SROM_WL0PAB2		49
+
+#define	SROM_LEDBH10		50
+#define	SROM_LEDBH32		51
+
+#define	SROM_WL10MAXP		52
+
+#define	SROM_WL1PAB0		53
+#define	SROM_WL1PAB1		54
+#define	SROM_WL1PAB2		55
+
+#define	SROM_ITT		56
+
+#define	SROM_BFL		57
+#define	SROM_BFL2		28
+#define	SROM3_BFL2		61
+
+#define	SROM_AG10		58
+
+#define	SROM_CCODE		59
+
+#define	SROM_OPO		60
+
+#define	SROM3_LEDDC		62
+
+#define	SROM_CRCREV		63
+
+/* SROM Rev 4: Reallocate the software part of the srom to accomodate
+ * MIMO features. It assumes up to two PCIE functions and 440 bytes
+ * of useable srom i.e. the useable storage in chips with OTP that
+ * implements hardware redundancy.
+ */
+
+#define	SROM4_WORDS		220
+
+#define	SROM4_SIGN		32
+#define	SROM4_SIGNATURE		0x5372
+
+#define	SROM4_BREV		33
+
+#define	SROM4_BFL0		34
+#define	SROM4_BFL1		35
+#define	SROM4_BFL2		36
+#define	SROM4_BFL3		37
+#define	SROM5_BFL0		37
+#define	SROM5_BFL1		38
+#define	SROM5_BFL2		39
+#define	SROM5_BFL3		40
+
+#define	SROM4_MACHI		38
+#define	SROM4_MACMID		39
+#define	SROM4_MACLO		40
+#define	SROM5_MACHI		41
+#define	SROM5_MACMID		42
+#define	SROM5_MACLO		43
+
+#define	SROM4_CCODE		41
+#define	SROM4_REGREV		42
+#define	SROM5_CCODE		34
+#define	SROM5_REGREV		35
+
+#define	SROM4_LEDBH10		43
+#define	SROM4_LEDBH32		44
+#define	SROM5_LEDBH10		59
+#define	SROM5_LEDBH32		60
+
+#define	SROM4_LEDDC		45
+#define	SROM5_LEDDC		45
+
+#define	SROM4_AA		46
+#define	SROM4_AA2G_MASK		0x00ff
+#define	SROM4_AA2G_SHIFT	0
+#define	SROM4_AA5G_MASK		0xff00
+#define	SROM4_AA5G_SHIFT	8
+
+#define	SROM4_AG10		47
+#define	SROM4_AG32		48
+
+#define	SROM4_TXPID2G		49
+#define	SROM4_TXPID5G		51
+#define	SROM4_TXPID5GL		53
+#define	SROM4_TXPID5GH		55
+
+#define SROM4_TXRXC		61
+#define SROM4_TXCHAIN_MASK	0x000f
+#define SROM4_TXCHAIN_SHIFT	0
+#define SROM4_RXCHAIN_MASK	0x00f0
+#define SROM4_RXCHAIN_SHIFT	4
+#define SROM4_SWITCH_MASK	0xff00
+#define SROM4_SWITCH_SHIFT	8
+
+/* Per-path fields */
+#define	MAX_PATH		4
+#define	SROM4_PATH0		64
+#define	SROM4_PATH1		87
+#define	SROM4_PATH2		110
+#define	SROM4_PATH3		133
+
+#define	SROM4_2G_ITT_MAXP	0
+#define	SROM4_2G_PA		1
+#define	SROM4_5G_ITT_MAXP	5
+#define	SROM4_5GLH_MAXP		6
+#define	SROM4_5G_PA		7
+#define	SROM4_5GL_PA		11
+#define	SROM4_5GH_PA		15
+
+/* Fields in the ITT_MAXP and 5GLH_MAXP words */
+#define	B2G_MAXP_MASK		0xff
+#define	B2G_ITT_SHIFT		8
+#define	B5G_MAXP_MASK		0xff
+#define	B5G_ITT_SHIFT		8
+#define	B5GH_MAXP_MASK		0xff
+#define	B5GL_MAXP_SHIFT		8
+
+/* All the miriad power offsets */
+#define	SROM4_2G_CCKPO		156
+#define	SROM4_2G_OFDMPO		157
+#define	SROM4_5G_OFDMPO		159
+#define	SROM4_5GL_OFDMPO	161
+#define	SROM4_5GH_OFDMPO	163
+#define	SROM4_2G_MCSPO		165
+#define	SROM4_5G_MCSPO		173
+#define	SROM4_5GL_MCSPO		181
+#define	SROM4_5GH_MCSPO		189
+#define	SROM4_CDDPO		197
+#define	SROM4_STBCPO		198
+#define	SROM4_BW40PO		199
+#define	SROM4_BWDUPPO		200
+
+#define	SROM4_CRCREV		219
+
+
+/*SROM Rev 8: Make space for a 48word hardware header for PCIe rev >= 6.
+ * This is acombined srom for both MIMO and SISO boards, usable in
+ * the .130 4Kilobit OTP with hardware redundancy.
+ */
+
+#define	SROM8_SIGN		64
+
+#define	SROM8_BREV		65
+
+#define	SROM8_BFL0		66
+#define	SROM8_BFL1		67
+#define	SROM8_BFL2		68
+#define	SROM8_BFL3		69
+
+#define	SROM8_MACHI		70
+#define	SROM8_MACMID		71
+#define	SROM8_MACLO		72
+
+#define	SROM8_CCODE		73
+#define	SROM8_REGREV		74
+
+#define	SROM8_LEDBH10		75
+#define	SROM8_LEDBH32		76
+
+#define	SROM8_LEDDC		77
+
+#define	SROM8_AA		78
+
+#define	SROM8_AG10		79
+#define	SROM8_AG32		80
+
+#define	SROM8_TXRXC		81
+
+#define	SROM8_BXARSSI2G		82
+#define	SROM8_BXARSSI5G		83
+#define	SROM8_TRI52G		84
+#define	SROM8_TRI5GHL		85
+#define	SROM8_RXPO52G		86
+
+/* Per-path offsets & fields */
+#define	SROM8_PATH0		96
+#define	SROM8_PATH1		112
+#define	SROM8_PATH2		128
+#define	SROM8_PATH3		144
+
+#define	SROM8_2G_ITT_MAXP	0
+#define	SROM8_2G_PA		1
+#define	SROM8_5G_ITT_MAXP	4
+#define	SROM8_5GLH_MAXP		5
+#define	SROM8_5G_PA		6
+#define	SROM8_5GL_PA		9
+#define	SROM8_5GH_PA		12
+
+/* All the miriad power offsets */
+#define	SROM8_2G_CCKPO		160
+
+#define	SROM8_2G_OFDMPO		161
+#define	SROM8_5G_OFDMPO		163
+#define	SROM8_5GL_OFDMPO	165
+#define	SROM8_5GH_OFDMPO	167
+
+#define	SROM8_2G_MCSPO		169
+#define	SROM8_5G_MCSPO		177
+#define	SROM8_5GL_MCSPO		185
+#define	SROM8_5GH_MCSPO		193
+
+#define	SROM8_CDDPO		201
+#define	SROM8_STBCPO		202
+#define	SROM8_BW40PO		203
+#define	SROM8_BWDUPPO		204
+
+/* SISO PA parameters are in the path0 spaces */
+#define	SROM8_SISO		96
+
+/* Legacy names for SISO PA paramters */
+#define	SROM8_W0_ITTMAXP	(SROM8_SISO + SROM8_2G_ITT_MAXP)
+#define	SROM8_W0_PAB0		(SROM8_SISO + SROM8_2G_PA)
+#define	SROM8_W0_PAB1		(SROM8_SISO + SROM8_2G_PA + 1)
+#define	SROM8_W0_PAB2		(SROM8_SISO + SROM8_2G_PA + 2)
+#define	SROM8_W1_ITTMAXP	(SROM8_SISO + SROM8_5G_ITT_MAXP)
+#define	SROM8_W1_MAXP_LCHC	(SROM8_SISO + SROM8_5GLH_MAXP)
+#define	SROM8_W1_PAB0		(SROM8_SISO + SROM8_5G_PA)
+#define	SROM8_W1_PAB1		(SROM8_SISO + SROM8_5G_PA + 1)
+#define	SROM8_W1_PAB2		(SROM8_SISO + SROM8_5G_PA + 2)
+#define	SROM8_W1_PAB0_LC	(SROM8_SISO + SROM8_5GL_PA)
+#define	SROM8_W1_PAB1_LC	(SROM8_SISO + SROM8_5GL_PA + 1)
+#define	SROM8_W1_PAB2_LC	(SROM8_SISO + SROM8_5GL_PA + 2)
+#define	SROM8_W1_PAB0_HC	(SROM8_SISO + SROM8_5GH_PA)
+#define	SROM8_W1_PAB1_HC	(SROM8_SISO + SROM8_5GH_PA + 1)
+#define	SROM8_W1_PAB2_HC	(SROM8_SISO + SROM8_5GH_PA + 2)
+
+#define	SROM8_CRCREV		219
+
+/* Prototypes */
+extern int srom_var_init(sb_t *sbh, uint bus, void *curmap, osl_t *osh,
+                         char **vars, uint *count);
+
+extern int srom_read(sb_t *sbh, uint bus, void *curmap, osl_t *osh,
+                     uint byteoff, uint nbytes, uint16 *buf);
+extern int srom_write(sb_t *sbh, uint bus, void *curmap, osl_t *osh,
+                      uint byteoff, uint nbytes, uint16 *buf);
+
+extern int srom_parsecis(osl_t *osh, uint8 **pcis, uint ciscnt,
+                         char **vars, uint *count);
 	   
 #endif	/* _bcmsrom_h_ */
--- src/include.1927/bcmutils.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bcmutils.h	2007-11-19 06:40:31.000000000 +0300
@@ -14,10 +14,7 @@
 #ifndef	_bcmutils_h_
 #define	_bcmutils_h_
 
-/*** driver-only section ***/
-#ifdef BCMDRIVER
-#include <osl.h>
-
+/* ctype replacement */
 #define _BCM_U	0x01	/* upper */
 #define _BCM_L	0x02	/* lower */
 #define _BCM_D	0x04	/* digit */
@@ -27,7 +24,7 @@
 #define _BCM_X	0x40	/* hex digit */
 #define _BCM_SP	0x80	/* hard space (0x20) */
 
-extern unsigned char bcm_ctype[];
+extern const unsigned char bcm_ctype[];
 #define bcm_ismask(x) (bcm_ctype[(int)(unsigned char)(x)])
 
 #define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
@@ -41,6 +38,26 @@
 #define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
 #define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
 #define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+#define bcm_tolower(c)	(bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
+#define bcm_toupper(c)	(bcm_islower((c)) ? ((c) + 'A' - 'a') : (c))
+
+/* Buffer structure for collecting string-formatted data 
+* using bcm_bprintf() API.
+* Use bcm_binit() to initialize before use
+*/
+
+struct bcmstrbuf {
+	char *buf;	/* pointer to current position in origbuf */
+	unsigned int size;	/* current (residual) size in bytes */
+	char *origbuf;	/* unmodified pointer to orignal buffer */
+	unsigned int origsize;	/* unmodified orignal buffer size in bytes */
+};
+
+/* ** driver-only section ** */
+#ifdef BCMDRIVER
+#include <osl.h>
+
+#define GPIO_PIN_NOTDEFINED 	0x20	/* Pin not defined */
 
 /*
  * Spin at most 'us' microseconds while 'exp' is true.
@@ -55,79 +72,373 @@
 	} \
 }
 
-/* generic osl packet queue */
-struct pktq {
+
+/* osl multi-precedence packet queue */
+#ifndef PKTQ_LEN_DEFAULT
+#define PKTQ_LEN_DEFAULT        128	/* Max 128 packets */
+#endif
+#ifndef PKTQ_MAX_PREC
+#define PKTQ_MAX_PREC           16	/* Maximum precedence levels */
+#endif
+
+typedef struct pktq_prec {
 	void *head;	/* first packet to dequeue */
 	void *tail;	/* last packet to dequeue */
-	uint len;	/* number of queued packets */
-	uint maxlen;	/* maximum number of queued packets */
-	bool priority;	/* enqueue by packet priority */
-	bool prio_map[MAXPRIO+1]; /* user priority to packet enqueue policy map */
+	uint16 len;     /* number of queued packets */
+	uint16 max;     /* maximum number of queued packets */
+} pktq_prec_t;
+
+
+/* multi-priority pkt queue */
+struct pktq {
+	uint16 num_prec;        /* number of precedences in use */
+	uint16 hi_prec;         /* rapid dequeue hint (>= highest non-empty prec) */
+	uint16 max;             /* total max packets */
+	uint16 len;             /* total number of packets */
+	/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+	struct pktq_prec q[PKTQ_MAX_PREC];
+};
+
+/* simple, non-priority pkt queue */
+struct spktq {
+	uint16 num_prec;        /* number of precedences in use (always 1) */
+	uint16 hi_prec;         /* rapid dequeue hint (>= highest non-empty prec) */
+	uint16 max;             /* total max packets */
+	uint16 len;             /* total number of packets */
+	/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+	struct pktq_prec q[1];
 };
-#define DEFAULT_QLEN	128
 
-#define	pktq_len(q)	((q)->len)
-#define	pktq_avail(q)	((q)->maxlen - (q)->len)
-#define	pktq_head(q)	((q)->head)
-#define	pktq_full(q)	((q)->len >= (q)->maxlen)
-#define	_pktq_pri(q, pri)	((q)->prio_map[pri])
-#define	pktq_tailpri(q)	((q)->tail ? _pktq_pri(q, PKTPRIO((q)->tail)) : _pktq_pri(q, 0))
+#define PKTQ_PREC_ITER(pq, prec)        for (prec = (pq)->num_prec - 1; prec >= 0; prec--)
+
+/* forward definition of ether_addr structure used by some function prototypes */
+
+struct ether_addr;
+
+/* operations on a specific precedence in packet queue */
+
+#define pktq_psetmax(pq, prec, _max)    ((pq)->q[prec].max = (_max))
+#define pktq_plen(pq, prec)             ((pq)->q[prec].len)
+#define pktq_pavail(pq, prec)           ((pq)->q[prec].max - (pq)->q[prec].len)
+#define pktq_pfull(pq, prec)            ((pq)->q[prec].len >= (pq)->q[prec].max)
+#define pktq_pempty(pq, prec)           ((pq)->q[prec].len == 0)
+
+#define pktq_ppeek(pq, prec)            ((pq)->q[prec].head)
+#define pktq_ppeek_tail(pq, prec)       ((pq)->q[prec].tail)
+
+extern void *pktq_penq(struct pktq *pq, int prec, void *p);
+extern void *pktq_penq_head(struct pktq *pq, int prec, void *p);
+extern void *pktq_pdeq(struct pktq *pq, int prec);
+extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
+/* Empty the queue at particular precedence level */
+extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir);
+/* Remove a specified packet from its queue */
+extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
+
+/* operations on a set of precedences in packet queue */
+
+extern int pktq_mlen(struct pktq *pq, uint prec_bmp);
+extern void *pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out);
+
+/* operations on packet queue as a whole */
+
+#define pktq_len(pq)                    ((int)(pq)->len)
+#define pktq_max(pq)                    ((int)(pq)->max)
+#define pktq_avail(pq)                  ((int)((pq)->max - (pq)->len))
+#define pktq_full(pq)                   ((pq)->len >= (pq)->max)
+#define pktq_empty(pq)                  ((pq)->len == 0)
+
+/* operations for single precedence queues */
+#define pktenq(pq, p)		pktq_penq(((struct pktq *)pq), 0, (p))
+#define pktenq_head(pq, p)	pktq_penq_head(((struct pktq *)pq), 0, (p))
+#define pktdeq(pq)		pktq_pdeq(((struct pktq *)pq), 0)
+#define pktdeq_tail(pq)		pktq_pdeq_tail(((struct pktq *)pq), 0)
+#define pktqinit(pq, len) pktq_init(((struct pktq *)pq), 1, len)
+
+extern void pktq_init(struct pktq *pq, int num_prec, int max_len);
+/* prec_out may be NULL if caller is not interested in return value */
+extern void *pktq_deq(struct pktq *pq, int *prec_out);
+extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
+extern void *pktq_peek(struct pktq *pq, int *prec_out);
+extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
+extern void pktq_flush(osl_t *osh, struct pktq *pq, bool dir); /* Empty the entire queue */
+extern int pktq_setmax(struct pktq *pq, int max_len);
 
 /* externs */
 /* packet */
-extern uint pktcopy(void *drv, void *p, uint offset, int len, uchar *buf);
-extern uint pkttotlen(void *drv, void *);
-extern void pktq_init(struct pktq *q, uint maxlen, const bool prio_map[]);
-extern void pktenq(struct pktq *q, void *p, bool lifo);
-extern void *pktdeq(struct pktq *q);
-extern void *pktdeqtail(struct pktq *q);
+extern uint pktcopy(osl_t *osh, void *p, uint offset, int len, uchar *buf);
+extern uint pkttotlen(osl_t *osh, void *p);
+extern void *pktlast(osl_t *osh, void *p);
+
+/* Get priority from a packet and pass it back in scb (or equiv) */
+extern uint pktsetprio(void *pkt, bool update_vtag);
+#define	PKTPRIO_VDSCP	0x100		/* DSCP prio found after VLAN tag */
+#define	PKTPRIO_VLAN	0x200		/* VLAN prio found */
+#define	PKTPRIO_UPD	0x400		/* DSCP used to update VLAN prio */
+#define	PKTPRIO_DSCP	0x800		/* DSCP prio found */
+
 /* string */
-extern uint bcm_atoi(char *s);
-extern uchar bcm_toupper(uchar c);
-extern ulong bcm_strtoul(char *cp, char **endp, uint base);
-extern char *bcmstrstr(char *haystack, char *needle);
-extern char *bcmstrcat(char *dest, const char *src);
+extern int BCMROMFN(bcm_atoi)(char *s);
+extern ulong BCMROMFN(bcm_strtoul)(char *cp, char **endp, uint base);
+extern char *BCMROMFN(bcmstrstr)(char *haystack, char *needle);
+extern char *BCMROMFN(bcmstrcat)(char *dest, const char *src);
+extern char *BCMROMFN(bcmstrncat)(char *dest, const char *src, uint size);
 extern ulong wchar2ascii(char *abuf, ushort *wbuf, ushort wbuflen, ulong abuflen);
 /* ethernet address */
-extern char *bcm_ether_ntoa(char *ea, char *buf);
-extern int bcm_ether_atoe(char *p, char *ea);
+extern char *bcm_ether_ntoa(struct ether_addr *ea, char *buf);
+extern int BCMROMFN(bcm_ether_atoe)(char *p, struct ether_addr *ea);
+
+/* ip address */
+struct ipv4_addr;
+extern char *bcm_ip_ntoa(struct ipv4_addr *ia, char *buf);
+
 /* delay */
 extern void bcm_mdelay(uint ms);
 /* variable access */
-extern char *getvar(char *vars, char *name);
-extern int getintvar(char *vars, char *name);
+extern char *getvar(char *vars, const char *name);
+extern int getintvar(char *vars, const char *name);
 extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
+#ifdef BCMPERFSTATS
+extern void bcm_perf_enable(void);
+extern void bcmstats(char *fmt);
+extern void bcmlog(char *fmt, uint a1, uint a2);
+extern void bcmdumplog(char *buf, int size);
+extern int bcmdumplogent(char *buf, uint idx);
+#else
+#define bcm_perf_enable()
+#define bcmstats(fmt)
 #define	bcmlog(fmt, a1, a2)
 #define	bcmdumplog(buf, size)	*buf = '\0'
 #define	bcmdumplogent(buf, idx)	-1
-#endif	/* #ifdef BCMDRIVER */
+#endif /* BCMPERFSTATS */
+extern char *bcm_nvram_vars(uint *length);
+extern int bcm_nvram_cache(void *sbh);
+
+/* Support for sharing code across in-driver iovar implementations.
+ * The intent is that a driver use this structure to map iovar names
+ * to its (private) iovar identifiers, and the lookup function to
+ * find the entry.  Macros are provided to map ids and get/set actions
+ * into a single number space for a switch statement.
+ */
+
+/* iovar structure */
+typedef struct bcm_iovar {
+	const char *name;	/* name for lookup and display */
+	uint16 varid;		/* id for switch */
+	uint16 flags;		/* driver-specific flag bits */
+	uint16 type;		/* base type of argument */
+	uint16 minlen;		/* min length for buffer vars */
+} bcm_iovar_t;
+
+/* varid definitions are per-driver, may use these get/set bits */
+
+/* IOVar action bits for id mapping */
+#define IOV_GET 0 /* Get an iovar */
+#define IOV_SET 1 /* Set an iovar */
+
+/* Varid to actionid mapping */
+#define IOV_GVAL(id)		((id)*2)
+#define IOV_SVAL(id)		(((id)*2)+IOV_SET)
+#define IOV_ISSET(actionid)	((actionid & IOV_SET) == IOV_SET)
+
+/* flags are per-driver based on driver attributes */
+
+extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table, const char *name);
+extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg, int len, bool set);
+
+#endif	/* BCMDRIVER */
+
+/* Base type definitions */
+#define IOVT_VOID	0	/* no value (implictly set only) */
+#define IOVT_BOOL	1	/* any value ok (zero/nonzero) */
+#define IOVT_INT8	2	/* integer values are range-checked */
+#define IOVT_UINT8	3	/* unsigned int 8 bits */
+#define IOVT_INT16	4	/* int 16 bits */
+#define IOVT_UINT16	5	/* unsigned int 16 bits */
+#define IOVT_INT32	6	/* int 32 bits */
+#define IOVT_UINT32	7	/* unsigned int 32 bits */
+#define IOVT_BUFFER	8	/* buffer is size-checked as per minlen */
+#define BCM_IOVT_VALID(type) (((unsigned int)(type)) <= IOVT_BUFFER)
+
+/* Initializer for IOV type strings */
+#define BCM_IOV_TYPE_INIT { \
+	"void", \
+	"bool", \
+	"int8", \
+	"uint8", \
+	"int16", \
+	"uint16", \
+	"int32", \
+	"uint32", \
+	"buffer", \
+	"" }
+
+#define BCM_IOVT_IS_INT(type) (\
+	(type == IOVT_BOOL) || \
+	(type == IOVT_INT8) || \
+	(type == IOVT_UINT8) || \
+	(type == IOVT_INT16) || \
+	(type == IOVT_UINT16) || \
+	(type == IOVT_INT32) || \
+	(type == IOVT_UINT32))
+
+/* ** driver/apps-shared section ** */
+
+#define BCME_STRLEN 		64	/* Max string length for BCM errors */
+#define VALID_BCMERROR(e)  ((e <= 0) && (e >= BCME_LAST))
+
+
+/*
+ * error codes could be added but the defined ones shouldn't be changed/deleted
+ * these error codes are exposed to the user code
+ * when ever a new error code is added to this list
+ * please update errorstring table with the related error string and
+ * update osl files with os specific errorcode map
+*/
+
+#define BCME_OK				0	/* Success */
+#define BCME_ERROR			-1	/* Error generic */
+#define BCME_BADARG			-2	/* Bad Argument */
+#define BCME_BADOPTION			-3	/* Bad option */
+#define BCME_NOTUP			-4	/* Not up */
+#define BCME_NOTDOWN			-5	/* Not down */
+#define BCME_NOTAP			-6	/* Not AP */
+#define BCME_NOTSTA			-7	/* Not STA  */
+#define BCME_BADKEYIDX			-8	/* BAD Key Index */
+#define BCME_RADIOOFF 			-9	/* Radio Off */
+#define BCME_NOTBANDLOCKED		-10	/* Not  band locked */
+#define BCME_NOCLK			-11	/* No Clock */
+#define BCME_BADRATESET			-12	/* BAD Rate valueset */
+#define BCME_BADBAND			-13	/* BAD Band */
+#define BCME_BUFTOOSHORT		-14	/* Buffer too short */
+#define BCME_BUFTOOLONG			-15	/* Buffer too long */
+#define BCME_BUSY			-16	/* Busy */
+#define BCME_NOTASSOCIATED		-17	/* Not Associated */
+#define BCME_BADSSIDLEN			-18	/* Bad SSID len */
+#define BCME_OUTOFRANGECHAN		-19	/* Out of Range Channel */
+#define BCME_BADCHAN			-20	/* Bad Channel */
+#define BCME_BADADDR			-21	/* Bad Address */
+#define BCME_NORESOURCE			-22	/* Not Enough Resources */
+#define BCME_UNSUPPORTED		-23	/* Unsupported */
+#define BCME_BADLEN			-24	/* Bad length */
+#define BCME_NOTREADY			-25	/* Not Ready */
+#define BCME_EPERM			-26	/* Not Permitted */
+#define BCME_NOMEM			-27	/* No Memory */
+#define BCME_ASSOCIATED			-28	/* Associated */
+#define BCME_RANGE			-29	/* Not In Range */
+#define BCME_NOTFOUND			-30	/* Not Found */
+#define BCME_WME_NOT_ENABLED		-31	/* WME Not Enabled */
+#define BCME_TSPEC_NOTFOUND		-32	/* TSPEC Not Found */
+#define BCME_ACM_NOTSUPPORTED		-33	/* ACM Not Supported */
+#define BCME_NOT_WME_ASSOCIATION	-34	/* Not WME Association */
+#define BCME_SDIO_ERROR			-35	/* SDIO Bus Error */
+#define BCME_DONGLE_DOWN		-36	/* Dongle Not Accessible */
+#define BCME_VERSION			-37 /* Incorrect version */
+#define BCME_LAST			BCME_VERSION
+
+/* These are collection of BCME Error strings */
+#define BCMERRSTRINGTABLE {		\
+	"OK",				\
+	"Undefined error",		\
+	"Bad Argument",			\
+	"Bad Option",			\
+	"Not up",			\
+	"Not down",			\
+	"Not AP",			\
+	"Not STA",			\
+	"Bad Key Index",		\
+	"Radio Off",			\
+	"Not band locked",		\
+	"No clock",			\
+	"Bad Rate valueset",		\
+	"Bad Band",			\
+	"Buffer too short",		\
+	"Buffer too long",		\
+	"Busy",				\
+	"Not Associated",		\
+	"Bad SSID len",			\
+	"Out of Range Channel",		\
+	"Bad Channel",			\
+	"Bad Address",			\
+	"Not Enough Resources",		\
+	"Unsupported",			\
+	"Bad length",			\
+	"Not Ready",			\
+	"Not Permitted",		\
+	"No Memory",			\
+	"Associated",			\
+	"Not In Range",			\
+	"Not Found",			\
+	"WME Not Enabled",		\
+	"TSPEC Not Found",		\
+	"ACM Not Supported",		\
+	"Not WME Association",		\
+	"SDIO Bus Error",		\
+	"Dongle Not Accessible",	\
+	"Incorrect version"	\
+}
+
+#ifndef ABS
+#define	ABS(a)			(((a) < 0)?-(a):(a))
+#endif /* ABS */
 
-/*** driver/apps-shared section ***/
 #ifndef MIN
-#define	MIN(a, b)		(((a)<(b))?(a):(b))
-#endif
+#define	MIN(a, b)		(((a) < (b))?(a):(b))
+#endif /* MIN */
 
 #ifndef MAX
-#define	MAX(a, b)		(((a)>(b))?(a):(b))
-#endif
+#define	MAX(a, b)		(((a) > (b))?(a):(b))
+#endif /* MAX */
 
 #define CEIL(x, y)		(((x) + ((y)-1)) / (y))
 #define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
 #define	ISALIGNED(a, x)		(((a) & ((x)-1)) == 0)
-#define	ISPOWEROF2(x)		((((x)-1)&(x))==0)
+#define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
+#define VALID_MASK(mask)	!((mask) & ((mask) + 1))
+#ifndef OFFSETOF
 #define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
+#endif /* OFFSETOF */
+#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+#endif
 
 /* bit map related macros */
 #ifndef setbit
+#ifndef NBBY		    /* the BSD family defines NBBY */
 #define	NBBY	8	/* 8 bits per byte */
-#define	setbit(a,i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
-#define	clrbit(a,i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
-#define	isset(a,i)	(((uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
-#define	isclr(a,i)	((((uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
-#endif
-
-#define	NBITS(type)	(sizeof (type) * 8)
+#endif /* #ifndef NBBY */
+#define	setbit(a, i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	(((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	((((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif /* setbit */
+
+#define	NBITS(type)	(sizeof(type) * 8)
+#define NBITVAL(nbits)	(1 << (nbits))
+#define MAXBITVAL(nbits)	((1 << (nbits)) - 1)
+#define	NBITMASK(nbits)	MAXBITVAL(nbits)
+#define MAXNBVAL(nbyte)	MAXBITVAL((nbyte) * 8)
+
+/* basic mux operation - can be optimized on several architectures */
+#define MUX(pred, true, false) ((pred) ? (true) : (false))
+
+/* modulo inc/dec - assumes x E [0, bound - 1] */
+#define MODDEC(x, bound) MUX((x) == 0, (bound) - 1, (x) - 1)
+#define MODINC(x, bound) MUX((x) == (bound) - 1, 0, (x) + 1)
+
+/* modulo inc/dec, bound = 2^k */
+#define MODDEC_POW2(x, bound) (((x) - 1) & ((bound) - 1))
+#define MODINC_POW2(x, bound) (((x) + 1) & ((bound) - 1))
+
+/* modulo add/sub - assumes x, y E [0, bound - 1] */
+#define MODADD(x, y, bound) \
+    MUX((x) + (y) >= (bound), (x) + (y) - (bound), (x) + (y))
+#define MODSUB(x, y, bound) \
+    MUX(((int)(x)) - ((int)(y)) < 0, (x) - (y) + (bound), (x) - (y))
+
+/* module add/sub, bound = 2^k */
+#define MODADD_POW2(x, y, bound) (((x) + (y)) & ((bound) - 1))
+#define MODSUB_POW2(x, y, bound) (((x) - (y)) & ((bound) - 1))
 
 /* crc defines */
 #define CRC8_INIT_VALUE  0xff		/* Initial CRC8 checksum value */
@@ -140,7 +451,7 @@
 /* bcm_format_flags() bit description structure */
 typedef struct bcm_bit_desc {
 	uint32	bit;
-	char*	name;
+	const char* name;
 } bcm_bit_desc_t;
 
 /* tag_ID/length/value_buffer tuple */
@@ -151,10 +462,10 @@
 } bcm_tlv_t;
 
 /* Check that bcm_tlv_t fits into the given buflen */
-#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (buflen) >= 2 + (elt)->len)
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
 
 /* buffer length for ethernet address from bcm_ether_ntoa() */
-#define ETHER_ADDR_STR_LEN	18
+#define ETHER_ADDR_STR_LEN	18	/* 18-bytes of Ethernet address buffer length */
 
 /* unaligned load and store macros */
 #ifdef IL_BIGENDIAN
@@ -186,7 +497,7 @@
 	a[1] = v & 0xff;
 }
 
-#else
+#else /* IL_BIGENDIAN */
 
 static INLINE uint32
 load32_ua(uint8 *a)
@@ -216,24 +527,63 @@
 	a[0] = v & 0xff;
 }
 
-#endif
+#endif /* IL_BIGENDIAN */
 
 /* externs */
 /* crc */
-extern uint8 hndcrc8(uint8 *p, uint nbytes, uint8 crc);
-extern uint16 hndcrc16(uint8 *p, uint nbytes, uint16 crc);
-extern uint32 hndcrc32(uint8 *p, uint nbytes, uint32 crc);
+extern uint8 BCMROMFN(hndcrc8)(uint8 *p, uint nbytes, uint8 crc);
+extern uint16 BCMROMFN(hndcrc16)(uint8 *p, uint nbytes, uint16 crc);
+extern uint32 BCMROMFN(hndcrc32)(uint8 *p, uint nbytes, uint32 crc);
 /* format/print */
+extern char *bcm_brev_str(uint16 brev, char *buf);
+extern void printfbig(char *buf);
+
 /* IE parsing */
-extern bcm_tlv_t *bcm_next_tlv(bcm_tlv_t *elt, int *buflen);
-extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
-extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
+extern bcm_tlv_t *BCMROMFN(bcm_next_tlv)(bcm_tlv_t *elt, int *buflen);
+extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs)(void *buf, int buflen, uint key);
+extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs)(void *buf, int buflen, uint key);
+
+/* bcmerror */
+extern const char *bcmerrorstr(int bcmerror);
 
 /* multi-bool data type: set of bools, mbool is true if any is set */
 typedef uint32 mbool;
-#define mboolset(mb, bit)		(mb |= bit)		/* set one bool */
-#define mboolclr(mb, bit)		(mb &= ~bit)		/* clear one bool */
-#define mboolisset(mb, bit)		((mb & bit) != 0)	/* TRUE if one bool is set */
+#define mboolset(mb, bit)		((mb) |= (bit))		/* set one bool */
+#define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
+#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
 #define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
 
+/* power conversion */
+extern uint16 BCMROMFN(bcm_qdbm_to_mw)(uint8 qdbm);
+extern uint8 BCMROMFN(bcm_mw_to_qdbm)(uint16 mw);
+
+/* generic datastruct to help dump routines */
+struct fielddesc {
+	const char *nameandfmt;
+	uint32 	offset;
+	uint32 	len;
+};
+
+extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
+extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
+
+typedef  uint32 (*readreg_rtn)(void *arg0, void *arg1, uint32 offset);
+extern uint bcmdumpfields(readreg_rtn func_ptr, void *arg0, void *arg1, struct fielddesc *str,
+                          char *buf, uint32 bufsize);
+
+extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint len);
+extern uint BCMROMFN(bcm_bitcount)(uint8 *bitmap, uint bytelength);
+
+#ifdef BCMDBG_PKT      /* pkt logging for debugging */
+#define PKTLIST_SIZE 1000
+typedef struct {
+	void *list[PKTLIST_SIZE]; /* List of pointers to packets */
+	uint count; /* Total count of the packets */
+} pktlist_info_t;
+
+extern void pktlist_add(pktlist_info_t *pktlist, void *p);
+extern void pktlist_remove(pktlist_info_t *pktlist, void *p);
+extern char* pktlist_dump(pktlist_info_t *pktlist, char *buf);
+#endif  /* BCMDBG_PKT */
+
 #endif	/* _bcmutils_h_ */
--- src/include.1927/bitfuncs.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/bitfuncs.h	2007-11-19 06:40:31.000000000 +0300
@@ -42,7 +42,7 @@
         return msbit;
 }
 
-#else
+#else	/* !USE_PENTIUM_BSR || !__GNUC__ */
 
 /*
  * Generic Implementation
@@ -77,9 +77,9 @@
 	if (temp_x & DB_POW_MASK1) {
 		msbit += 1;
 	}
-	return(msbit);
+	return (msbit);
 }
 
-#endif
+#endif	/* USE_PENTIUM_BSR && __GNUC__ */
 
 #endif /* _BITFUNCS_H */
--- src/include.1927/cfe_osl.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/cfe_osl.h	2007-11-19 06:40:31.000000000 +0300
@@ -27,12 +27,21 @@
 
 #include <typedefs.h>
 
+/* pick up osl required snprintf/vsnprintf */
+#include <bcmstdlib.h>
+
 /* dump string */
 extern int (*xprinthook)(const char *str);
 #define puts(str) do { if (xprinthook) xprinthook(str); } while (0)
 
 /* assert and panic */
+#ifdef BCMDBG_ASSERT
+#define ASSERT(exp) \
+	do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(char *exp, char *file, int line);
+#else /* BCMDBG_ASSERT */
 #define	ASSERT(exp)		do {} while (0)
+#endif /* BCMDBG_ASSERT */
 
 /* PCMCIA attribute space access macros */
 #define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
@@ -46,6 +55,10 @@
 #define	OSL_PCI_WRITE_CONFIG(loc, offset, size, val) \
 	do {} while (0)
 
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	(0)
+#define OSL_PCI_SLOT(osh)	(0)
+
 /* register access macros */
 #define wreg32(r, v)		(*(volatile uint32*)(r) = (uint32)(v))
 #define rreg32(r)		(*(volatile uint32*)(r))
@@ -60,7 +73,7 @@
 #define wreg8(r, v)		(*(volatile uint8*)(r) = (uint8)(v))
 #define rreg8(r)		(*(volatile uint8*)(r))
 #endif
-#define R_REG(r) ({ \
+#define R_REG(osh, r) ({ \
 	__typeof(*(r)) __osl_v; \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	__osl_v = rreg8((r)); break; \
@@ -69,27 +82,39 @@
 	} \
 	__osl_v; \
 })
-#define W_REG(r, v) do { \
+#define W_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	wreg8((r), (v)); break; \
 	case sizeof(uint16):	wreg16((r), (v)); break; \
 	case sizeof(uint32):	wreg32((r), (v)); break; \
 	} \
 } while (0)
-#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
-#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
 
 /* bcopy, bcmp, and bzero */
 #define bcmp(b1, b2, len)	lib_memcmp((b1), (b2), (len))
 
-#define osl_attach(pdev)	(pdev)
-#define osl_detach(osh)		
+struct osl_info {
+	void *pdev;
+	pktfree_cb_fn_t tx_fn;
+	void *tx_ctx;
+};
+
+extern osl_t *osl_attach(void *pdev);
+extern void osl_detach(osl_t *osh);
+
+#define PKTFREESETCB(osh, _tx_fn, _tx_ctx) \
+	do { \
+	   osh->tx_fn = _tx_fn; \
+	   osh->tx_ctx = _tx_ctx; \
+	} while (0)
 
 /* general purpose memory allocation */
-#define	MALLOC(osh, size)	KMALLOC((size),0)
+#define	MALLOC(osh, size)	KMALLOC((size), 0)
 #define	MFREE(osh, addr, size)	KFREE((addr))
 #define	MALLOCED(osh)		(0)
-#define	MALLOC_DUMP(osh, buf, sz)
+#define	MALLOC_DUMP(osh, b)
 #define	MALLOC_FAILED(osh)	(0)
 
 /* uncached virtual address */
@@ -104,6 +129,8 @@
 /* microsecond delay */
 #define	OSL_DELAY(usec)		cfe_usleep((cfe_cpu_speed/CPUCFG_CYCLESPERCPUTICK/1000000*(usec)))
 
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+
 /* map/unmap physical to virtual I/O */
 #define	REG_MAP(pa, size)	((void*)UNCADDR((ulong)(pa)))
 #define	REG_UNMAP(va)		do {} while (0)
@@ -113,33 +140,36 @@
 extern int osl_busprobe(uint32 *val, uint32 addr);
 
 /* allocate/free shared (dma-able) consistent (uncached) memory */
-#define	DMA_CONSISTENT_ALIGN	4096
-#define	DMA_ALLOC_CONSISTENT(osh, size, pap) \
+#define	DMA_CONSISTENT_ALIGN	4096		/* 4k alignment */
+#define	DMA_ALLOC_CONSISTENT(osh, size, pap, dmah) \
 	osl_dma_alloc_consistent((size), (pap))
-#define	DMA_FREE_CONSISTENT(osh, va, size, pa) \
+#define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
 	osl_dma_free_consistent((void*)(va))
 extern void *osl_dma_alloc_consistent(uint size, ulong *pap);
 extern void osl_dma_free_consistent(void *va);
 
 /* map/unmap direction */
-#define	DMA_TX			1
-#define	DMA_RX			2
+#define	DMA_TX			1	/* TX direction for DMA */
+#define	DMA_RX			2	/* RX direction for DMA */
 
 /* map/unmap shared (dma-able) memory */
-#define	DMA_MAP(osh, va, size, direction, lb) ({ \
+#define	DMA_MAP(osh, va, size, direction, lb, dmah) ({ \
 	cfe_flushcache(CFE_CACHE_FLUSH_D); \
 	PHYSADDR((ulong)(va)); \
 })
-#define	DMA_UNMAP(osh, pa, size, direction, p) \
+#define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
 	do {} while (0)
 
+/* API for DMA addressing capability */
+#define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
+
 /* shared (dma-able) memory access macros */
 #define	R_SM(r)			*(r)
 #define	W_SM(r, v)		(*(r) = (v))
 #define	BZERO_SM(r, len)	lib_memset((r), '\0', (len))
 
 /* generic packet structure */
-#define LBUFSZ		4096
+#define LBUFSZ		4096		/* Size of Lbuf - 4k */
 #define LBDATASZ	(LBUFSZ - sizeof(struct lbuf))
 struct lbuf {	
 	struct lbuf	*next;		/* pointer to next lbuf if in a chain */
@@ -149,36 +179,43 @@
 	uchar		*data;		/* start of data */
 	uchar		*tail;		/* end of data */
 	uint		len;		/* nbytes of data */
-	void		*cookie;	/* generic cookie */
+	uchar		pkttag[OSL_PKTTAG_SZ]; /* pkttag area */
 };
 
-/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
-#define	PKTBUFSZ	2048
+#define	PKTBUFSZ	2048	/* largest reasonable packet buffer, driver uses for ethernet MTU */
 
 /* packet primitives */
-#define	PKTGET(drv, len, send)		((void*)osl_pktget((len)))
-#define	PKTFREE(drv, lb, send)		osl_pktfree((struct lbuf*)(lb))
-#define	PKTDATA(drv, lb)		(((struct lbuf*)(lb))->data)
-#define	PKTLEN(drv, lb)			(((struct lbuf*)(lb))->len)
-#define PKTHEADROOM(drv, lb)		(PKTDATA(drv,lb)-(((struct lbuf*)(lb))->head))
-#define PKTTAILROOM(drv, lb)		((((struct lbuf*)(lb))->end)-(((struct lbuf*)(lb))->tail))
-#define	PKTNEXT(drv, lb)		(((struct lbuf*)(lb))->next)
-#define	PKTSETNEXT(lb, x)		(((struct lbuf*)(lb))->next = (struct lbuf*)(x))
-#define	PKTSETLEN(drv, lb, len)		osl_pktsetlen((struct lbuf*)(lb), (len))
-#define	PKTPUSH(drv, lb, bytes)		osl_pktpush((struct lbuf*)(lb), (bytes))
-#define	PKTPULL(drv, lb, bytes)		osl_pktpull((struct lbuf*)(lb), (bytes))
-#define	PKTDUP(drv, lb)			osl_pktdup((struct lbuf*)(lb))
-#define	PKTCOOKIE(lb)			(((struct lbuf*)(lb))->cookie)
-#define	PKTSETCOOKIE(lb, x)		(((struct lbuf*)(lb))->cookie = (void*)(x))
+#define	PKTGET(osh, len, send)		((void*)osl_pktget((len)))
+#define	PKTFREE(osh, lb, send)		osl_pktfree((osh), (struct lbuf*)(lb), (send))
+#define	PKTDATA(osh, lb)		(((struct lbuf*)(lb))->data)
+#define	PKTLEN(osh, lb)			(((struct lbuf*)(lb))->len)
+#define PKTHEADROOM(osh, lb)		(PKTDATA(osh, lb)-(((struct lbuf*)(lb))->head))
+#define PKTTAILROOM(osh, lb)		((((struct lbuf*)(lb))->end)-(((struct lbuf*)(lb))->tail))
+#define	PKTNEXT(osh, lb)		(((struct lbuf*)(lb))->next)
+#define	PKTSETNEXT(osh, lb, x)		(((struct lbuf*)(lb))->next = (struct lbuf*)(x))
+#define	PKTSETLEN(osh, lb, len)		osl_pktsetlen((struct lbuf*)(lb), (len))
+#define	PKTPUSH(osh, lb, bytes)		osl_pktpush((struct lbuf*)(lb), (bytes))
+#define	PKTPULL(osh, lb, bytes)		osl_pktpull((struct lbuf*)(lb), (bytes))
+#define	PKTDUP(osh, lb)			osl_pktdup((struct lbuf*)(lb))
+#define	PKTTAG(lb)			(((void *) ((struct lbuf *)(lb))->pkttag))
 #define	PKTLINK(lb)			(((struct lbuf*)(lb))->link)
 #define	PKTSETLINK(lb, x)		(((struct lbuf*)(lb))->link = (struct lbuf*)(x))
 #define	PKTPRIO(lb)			(0)
 #define	PKTSETPRIO(lb, x)		do {} while (0)
+#define	PKTFRMNATIVE(buffer, lb)	osl_pkt_frmnative((buffer), (struct lbuf *)(lb))
+#define	PKTTONATIVE(lb, buffer)		osl_pkt_tonative((lb), (buffer))
+#define PKTSHARED(lb)                   (1)
+#define PKTALLOCED(osh)			(0)
+#define PKTLIST_DUMP(osh, buf)
+
+extern void osl_pkt_frmnative(iocb_buffer_t *buffer, struct lbuf *lb);
+extern void osl_pkt_tonative(struct lbuf* lb, iocb_buffer_t *buffer);
 extern struct lbuf *osl_pktget(uint len);
-extern void osl_pktfree(struct lbuf *lb);
+extern void osl_pktfree(osl_t *osh, struct lbuf *lb, bool send);
 extern void osl_pktsetlen(struct lbuf *lb, uint len);
 extern uchar *osl_pktpush(struct lbuf *lb, uint bytes);
 extern uchar *osl_pktpull(struct lbuf *lb, uint bytes);
 extern struct lbuf *osl_pktdup(struct lbuf *lb);
+extern int osl_error(int bcmerror);
 
 #endif	/* _cfe_osl_h_ */
--- src/include.1927/epivers.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/epivers.h	2007-11-19 06:40:31.000000000 +0300
@@ -14,56 +14,22 @@
 #ifndef _epivers_h_
 #define _epivers_h_
 
-#ifdef	linux
-#include <linux/config.h>
-#endif
+#define	EPI_MAJOR_VERSION	4
 
-/* Vendor Name, ASCII, 32 chars max */
-#ifdef COMPANYNAME
-#define	HPNA_VENDOR 		COMPANYNAME
-#else
-#define	HPNA_VENDOR 		"Broadcom Corporation"
-#endif
+#define	EPI_MINOR_VERSION	150
 
-/* Driver Date, ASCII, 32 chars max */
-#define HPNA_DRV_BUILD_DATE	__DATE__
+#define	EPI_RC_NUMBER		10
 
-/* Hardware Manufacture Date, ASCII, 32 chars max */
-#define HPNA_HW_MFG_DATE	"Not Specified"
-
-/* See documentation for Device Type values, 32 values max */
-#ifndef	HPNA_DEV_TYPE
-
-#if	defined(CONFIG_BRCM_VJ)
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_DISPLAY }
-
-#elif	defined(CONFIG_BCRM_93725)
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_CM_BRIDGE, CDCF_V0_DEVICE_DISPLAY }
-
-#else
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_PCINIC }
-
-#endif
-
-#endif	/* !HPNA_DEV_TYPE */
-
-
-#define	EPI_MAJOR_VERSION	3
-
-#define	EPI_MINOR_VERSION	90
-
-#define	EPI_RC_NUMBER		7
-
-#define	EPI_INCREMENTAL_NUMBER	0
+#define	EPI_INCREMENTAL_NUMBER	29
 
 #define	EPI_BUILD_NUMBER	0
 
-#define	EPI_VERSION		3,90,7,0
+#define	EPI_VERSION		4, 150, 10, 29
 
-#define	EPI_VERSION_NUM		0x035a0700
+#define	EPI_VERSION_NUM		0x04960a1d
 
 /* Driver Version String, ASCII, 32 chars max */
-#define	EPI_VERSION_STR		"3.90.7.0"
-#define	EPI_ROUTER_VERSION_STR	"3.91.7.0"
+#define	EPI_VERSION_STR		"4.150.10.29"
+#define	EPI_ROUTER_VERSION_STR	"4.151.10.29"
 
 #endif /* _epivers_h_ */
--- src/include.1927/epivers.h.in	2004-10-14 23:11:17.000000000 +0400
+++ src/include/epivers.h.in	2007-11-19 06:40:31.000000000 +0300
@@ -14,40 +14,6 @@
 #ifndef _epivers_h_
 #define _epivers_h_
 
-#ifdef	linux
-#include <linux/config.h>
-#endif
-
-/* Vendor Name, ASCII, 32 chars max */
-#ifdef COMPANYNAME
-#define	HPNA_VENDOR 		COMPANYNAME
-#else
-#define	HPNA_VENDOR 		"Broadcom Corporation"
-#endif
-
-/* Driver Date, ASCII, 32 chars max */
-#define HPNA_DRV_BUILD_DATE	__DATE__
-
-/* Hardware Manufacture Date, ASCII, 32 chars max */
-#define HPNA_HW_MFG_DATE	"Not Specified"
-
-/* See documentation for Device Type values, 32 values max */
-#ifndef	HPNA_DEV_TYPE
-
-#if	defined(CONFIG_BRCM_VJ)
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_DISPLAY }
-
-#elif	defined(CONFIG_BCRM_93725)
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_CM_BRIDGE, CDCF_V0_DEVICE_DISPLAY }
-
-#else
-#define HPNA_DEV_TYPE		{ CDCF_V0_DEVICE_PCINIC }
-
-#endif
-
-#endif	/* !HPNA_DEV_TYPE */
-
-
 #define	EPI_MAJOR_VERSION	@EPI_MAJOR_VERSION@
 
 #define	EPI_MINOR_VERSION	@EPI_MINOR_VERSION@
--- src/include.1927/flash.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/flash.h	2007-11-19 06:40:31.000000000 +0300
@@ -12,6 +12,8 @@
  * $Id$
  */
 
+/* FILE-CSTYLED Cannot figure out how to make the initialization continuation lines acceptable */
+
 /* Types of flashes we know about */
 typedef enum _flash_type {OLD, BSC, SCS, AMD, SST, SFLASH} flash_type_t;
 
@@ -31,7 +33,7 @@
 	uint16		read_array;
 } flash_cmds_t;
 
-#define	UNLOCK_CMD_WORDS	2
+#define	UNLOCK_CMD_WORDS	2	/* 2 words per command */
 
 typedef struct _unlock_cmd {
   uint		addr[UNLOCK_CMD_WORDS];
@@ -60,11 +62,17 @@
 	{ SFLASH,	0,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00 };
 
 flash_cmds_t flash_cmds[] = {
-/*	  type		needu	preera	eraseb	erasech	write	wbuf	clcsr	rdcsr	rdid	confrm	read */
-	{ BSC,		0,	0x00,	0x20,	0x00,	0x40,	0x00,	0x50,	0x70,	0x90,	0xd0,	0xff },
-	{ SCS,		0,	0x00,	0x20,	0x00,	0x40,	0xe8,	0x50,	0x70,	0x90,	0xd0,	0xff },
-	{ AMD,		1,	0x80,	0x30,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,	0x00,	0xf0 },
-	{ SST,		1,	0x80,	0x50,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,	0x00,	0xf0 },
+/*	  type	needu	preera	eraseb	erasech	write	wbuf	clcsr	rdcsr	rdid
+ *	  confrm	read
+ */
+	{ BSC,	0,	0x00,	0x20,	0x00,	0x40,	0x00,	0x50,	0x70,	0x90,
+	  0xd0,	0xff },
+	{ SCS,	0,	0x00,	0x20,	0x00,	0x40,	0xe8,	0x50,	0x70,	0x90,
+	  0xd0,	0xff },
+	{ AMD,	1,	0x80,	0x30,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,
+	  0x00,	0xf0 },
+	{ SST,	1,	0x80,	0x50,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,
+	  0x00,	0xf0 },
 	{ 0 }
 };
 
@@ -95,7 +103,8 @@
 
 /* Just eight blocks of 8KB byte each */
 
-uint blk8x8k[] = { 0x00000000,
+uint blk8x8k[] = {
+	0x00000000,
 		   0x00002000,
 		   0x00004000,
 		   0x00006000,
@@ -107,7 +116,8 @@
 };
 
 /* Funky AMD arrangement for 29xx800's */
-uint amd800[] = { 0x00000000,		/* 16KB */
+uint amd800[] = {
+	0x00000000,		/* 16KB */
 		  0x00004000,		/* 32KB */
 		  0x0000c000,		/* 8KB */
 		  0x0000e000,		/* 8KB */
@@ -119,13 +129,16 @@
 };
 
 /* AMD arrangement for 29xx160's */
-uint amd4112[] = { 0x00000000,		/* 32KB */
+uint amd4112[] = {
+	0x00000000,		/* 32KB */
 		   0x00008000,		/* 8KB */
 		   0x0000a000,		/* 8KB */
 		   0x0000c000,		/* 16KB */
 		   0x00010000
 };
-uint amd2114[] = { 0x00000000,		/* 16KB */
+
+uint amd2114[] = {
+	0x00000000,		/* 16KB */
 		   0x00004000,		/* 8KB */
 		   0x00006000,		/* 8KB */
 		   0x00008000,		/* 32KB */
@@ -137,52 +150,124 @@
 	{ 0, 0, 0, 0,	SFLASH, 0, 0,  0, 0,  0, NULL,    "SFLASH" };
 
 flash_desc_t flashes[] = {
-	{ 0x00b0, 0x00d0, 0x0200000, 2,	SCS, 0x10000, 32,  0, 31,  0, NULL,    "Intel 28F160S3/5 1Mx16" },
-	{ 0x00b0, 0x00d4, 0x0400000, 2,	SCS, 0x10000, 64,  0, 63,  0, NULL,    "Intel 28F320S3/5 2Mx16" },
-	{ 0x0089, 0x8890, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k, "Intel 28F160B3 1Mx16 TopB" },
-	{ 0x0089, 0x8891, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k, "Intel 28F160B3 1Mx16 BotB" },
-	{ 0x0089, 0x8896, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k, "Intel 28F320B3 2Mx16 TopB" },
-	{ 0x0089, 0x8897, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Intel 28F320B3 2Mx16 BotB" },
-	{ 0x0089, 0x8898, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k, "Intel 28F640B3 4Mx16 TopB" },
-	{ 0x0089, 0x8899, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k, "Intel 28F640B3 4Mx16 BotB" },
-	{ 0x0089, 0x88C2, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k, "Intel 28F160C3 1Mx16 TopB" },
-	{ 0x0089, 0x88C3, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k, "Intel 28F160C3 1Mx16 BotB" },
-	{ 0x0089, 0x88C4, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k, "Intel 28F320C3 2Mx16 TopB" },
-	{ 0x0089, 0x88C5, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Intel 28F320C3 2Mx16 BotB" },
-	{ 0x0089, 0x88CC, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k, "Intel 28F640C3 4Mx16 TopB" },
-	{ 0x0089, 0x88CD, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k, "Intel 28F640C3 4Mx16 BotB" },
-	{ 0x0089, 0x0014, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,    "Intel 28F320J5 2Mx16" },
-	{ 0x0089, 0x0015, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,    "Intel 28F640J5 4Mx16" },
-	{ 0x0089, 0x0016, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,    "Intel 28F320J3 2Mx16" },
-	{ 0x0089, 0x0017, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,    "Intel 28F640J3 4Mx16" },
-	{ 0x0089, 0x0018, 0x1000000, 2,	SCS, 0x20000, 128, 0, 127, 0, NULL,    "Intel 28F128J3 8Mx16" },
-	{ 0x00b0, 0x00e3, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Sharp 28F320BJE 2Mx16 BotB" },
-	{ 0x0001, 0x224a, 0x0100000, 2,	AMD, 0x10000, 16,  0, 13,  8, amd800,  "AMD 29DL800BT 512Kx16 TopB" },
-	{ 0x0001, 0x22cb, 0x0100000, 2,	AMD, 0x10000, 16,  2, 15,  8, amd800,  "AMD 29DL800BB 512Kx16 BotB" },
-	{ 0x0001, 0x22c4, 0x0200000, 2,	AMD, 0x10000, 32,  0, 30,  4, amd2114, "AMD 29lv160DT 1Mx16 TopB" },
-	{ 0x0001, 0x2249, 0x0200000, 2,	AMD, 0x10000, 32,  1, 31,  4, amd4112, "AMD 29lv160DB 1Mx16 BotB" },
-	{ 0x0001, 0x22f6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k, "AMD 29lv320DT 2Mx16 TopB" },
-	{ 0x0001, 0x22f9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k, "AMD 29lv320DB 2Mx16 BotB" },
-	{ 0x0001, 0x2201, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k, "AMD 29lv320MT 2Mx16 TopB" },
-	{ 0x0001, 0x2200, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k, "AMD 29lv320MB 2Mx16 BotB" },
-	{ 0x0020, 0x22CA, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "ST 29w320DT 2Mx16 TopB" },
-	{ 0x0020, 0x22CB, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "ST 29w320DB 2Mx16 BotB" },
-	{ 0x00C2, 0x00A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MX29LV320T 2Mx16 TopB" },
-	{ 0x00C2, 0x00A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MX29LV320B 2Mx16 BotB" },
-	{ 0x0004, 0x22F6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MBM29LV320TE 2Mx16 TopB" },
-	{ 0x0004, 0x22F9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MBM29LV320BE 2Mx16 BotB" },
-	{ 0x0098, 0x009A, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "TC58FVT321 2Mx16 TopB" },
-	{ 0x0098, 0x009C, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "TC58FVB321 2Mx16 BotB" }, 
-	{ 0x00C2, 0x22A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MX29LV320T 2Mx16 TopB" },
-	{ 0x00C2, 0x22A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MX29LV320B 2Mx16 BotB" },
-	{ 0x00BF, 0x2783, 0x0400000, 2,	SST, 0x10000, 64,  0, 63,  0, NULL,    "SST39VF320 2Mx16" },
-	{ 0,      0,      0,         0,	OLD, 0,       0,   0, 0,   0, NULL,    NULL },
+	{ 0x00b0, 0x00d0, 0x0200000, 2,	SCS, 0x10000, 32,  0, 31,  0, NULL,
+	  "Intel 28F160S3/5 1Mx16" },
+	{ 0x00b0, 0x00d4, 0x0400000, 2,	SCS, 0x10000, 64,  0, 63,  0, NULL,
+	  "Intel 28F320S3/5 2Mx16" },
+	{ 0x0089, 0x8890, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k,
+	  "Intel 28F160B3 1Mx16 TopB" },
+	{ 0x0089, 0x8891, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k,
+	  "Intel 28F160B3 1Mx16 BotB" },
+	{ 0x0089, 0x8896, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k,
+	  "Intel 28F320B3 2Mx16 TopB" },
+	{ 0x0089, 0x8897, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "Intel 28F320B3 2Mx16 BotB" },
+	{ 0x0089, 0x8898, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k,
+	  "Intel 28F640B3 4Mx16 TopB" },
+	{ 0x0089, 0x8899, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k,
+	  "Intel 28F640B3 4Mx16 BotB" },
+	{ 0x0089, 0x88C2, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k,
+	  "Intel 28F160C3 1Mx16 TopB" },
+	{ 0x0089, 0x88C3, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k,
+	  "Intel 28F160C3 1Mx16 BotB" },
+	{ 0x0089, 0x88C4, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k,
+	  "Intel 28F320C3 2Mx16 TopB" },
+	{ 0x0089, 0x88C5, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "Intel 28F320C3 2Mx16 BotB" },
+	{ 0x0089, 0x88CC, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k,
+	  "Intel 28F640C3 4Mx16 TopB" },
+	{ 0x0089, 0x88CD, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k,
+	  "Intel 28F640C3 4Mx16 BotB" },
+	{ 0x0089, 0x0014, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,
+	  "Intel 28F320J5 2Mx16" },
+	{ 0x0089, 0x0015, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,
+	  "Intel 28F640J5 4Mx16" },
+	{ 0x0089, 0x0016, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,
+	  "Intel 28F320J3 2Mx16" },
+	{ 0x0089, 0x0017, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,
+	  "Intel 28F640J3 4Mx16" },
+	{ 0x0089, 0x0018, 0x1000000, 2,	SCS, 0x20000, 128, 0, 127, 0, NULL,
+	  "Intel 28F128J3 8Mx16" },
+	{ 0x00b0, 0x00e3, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "Sharp 28F320BJE 2Mx16 BotB" },
+	{ 0x0001, 0x224a, 0x0100000, 2,	AMD, 0x10000, 16,  0, 13,  8, amd800,
+	  "AMD 29DL800BT 512Kx16 TopB" },
+	{ 0x0001, 0x22cb, 0x0100000, 2,	AMD, 0x10000, 16,  2, 15,  8, amd800,
+	  "AMD 29DL800BB 512Kx16 BotB" },
+	{ 0x0001, 0x22c4, 0x0200000, 2,	AMD, 0x10000, 32,  0, 30,  4, amd4112,
+	  "AMD 29W160ET 1Mx16 TopB" },
+	{ 0x0001, 0x2249, 0x0200000, 2,	AMD, 0x10000, 32,  1, 31,  4, amd2114,
+	  "AMD 29lv160DB 1Mx16 BotB" },
+	{ 0x0001, 0x22f6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k,
+	  "AMD 29LV320DT 2Mx16 TopB" },
+	{ 0x0001, 0x22f9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "AMD 29lv320DB 2Mx16 BotB" },
+	{ 0x0001, 0x00f9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "AMD 29lv320DB 2Mx16 BotB in BYTE mode" },
+	{ 0x0001, 0x0201, 0x0800000, 2,	AMD, 0x10000, 128,  1, 126,  8, blk8x8k,
+	  "AMD 29DL640D 4Mx16" },
+	{ 0x0001, 0x1200, 0x01000000, 2, AMD, 0x10000, 256,  0, 255,  0, NULL,
+	  "AMD 29LV128MH/L 8Mx16" },
+	{ 0x0001, 0x1301, 0x0800000, 2, AMD, 0x10000, 128,  0, 127,  0, NULL,
+	  "AMD 29LV641MT 4Mx16" },
+	{ 0x0001, 0x1a01, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k,
+	  "AMD 29lv320MT 2Mx16 TopB" },
+	{ 0x0001, 0x1a00, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "AMD 29lv320MB 2Mx16 BotB" },
+	{ 0x0001, 0x1001, 0x0800000, 2,	AMD, 0x10000, 128,  0, 126,  8, blk8x8k,
+	  "Spansion S29GL064A-R3 4Mx16 TopB" },
+	{ 0x0001, 0x1000, 0x0800000, 2,	AMD, 0x10000, 128,  1, 127,  8, blk8x8k,
+	  "Spansion S29GL064A-R4 4Mx16 BotB" },
+	{ 0x0001, 0x0c01, 0x0800000, 2,	AMD, 0x10000, 128,  0, 127,  0, NULL,
+	  "Spansion S29GL640A 8Mx16" },
+	{ 0x0020, 0x22CA, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112,
+	  "ST 29w320DT 2Mx16 TopB" },
+	{ 0x0020, 0x22CB, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114,
+	  "ST 29w320DB 2Mx16 BotB" },
+	{ 0x0020, 0x22c4, 0x0200000, 2,	AMD, 0x10000, 32,  0, 30,  4, amd4112,
+	  "ST 29w160ET 1Mx16 TopB" },
+	{ 0x0020, 0x2249, 0x0200000, 2,	AMD, 0x10000, 32,  1, 31,  4, amd2114,
+	  "ST 29w160ET 1Mx16 BotB" },
+	{ 0x0020, 0x225d, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "ST M29DW324DB 2Mx16 TopB" },
+	{ 0x007f, 0x22f9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "EON 29LV320CB 2Mx16 BotB" },
+	{ 0x00C2, 0x22c4, 0x0200000, 2,	AMD, 0x10000, 32,  0, 30,  4, amd4112,
+	  "MX 29LV160CT 1Mx16 TopB" },
+	{ 0x00C2, 0x2249, 0x0200000, 2,	AMD, 0x10000, 32,  1, 31,  4, amd2114, 
+	  "MX 29LV160CB 1Mx16 BotB" },
+	{ 0x00C2, 0x22a8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k, 
+	  "MX 29LV320CB 2Mx16 BotB" },
+	{ 0x00C2, 0x00A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112,
+	  "MX29LV320T 2Mx16 TopB" },
+	{ 0x00C2, 0x00A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114,
+	  "MX29LV320B 2Mx16 BotB" },
+	{ 0x0004, 0x22F6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112,
+	  "MBM29LV320TE 2Mx16 TopB" },
+	{ 0x0004, 0x22F9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114,
+	  "MBM29LV320BE 2Mx16 BotB" },
+	{ 0x0098, 0x009A, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112,
+	  "TC58FVT321 2Mx16 TopB" },
+	{ 0x0098, 0x009C, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114,
+	  "TC58FVB321 2Mx16 BotB" },
+	{ 0x00C2, 0x22A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112,
+	  "MX29LV320T 2Mx16 TopB" },
+	{ 0x00C2, 0x22A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114,
+	  "MX29LV320B 2Mx16 BotB" },
+	{ 0x00BF, 0x2783, 0x0400000, 2,	SST, 0x10000, 64,  0, 63,  0, NULL,
+	  "SST39VF320 2Mx16" },
+	{ 0x00ec, 0x22e2, 0x0800000, 2, AMD, 0x10000, 128,  1, 127,  8, blk8x8k,
+	  "Samsung K8D631UB 4Mx16 BotB" },
+	{ 0xddda, 0x0a00, 0x0400000, 2, AMD, 0x10000, 64,  1, 63,  8, blk8x8k,
+	  "Samsung K8D631UB 4Mx16 BotB" },
+	{ 0,      0,      0,         0,	OLD, 0,       0,   0, 0,   0, NULL,
+	  NULL },
 };
 
-#else
+#else	/* !DECLARE_FLASHES */
 
 extern flash_cmds_t flash_cmds[];
 extern unlock_cmd_t unlock_cmd;
 extern flash_desc_t flashes[];
 
-#endif
+#endif	/* DECLARE_FLASHES */
--- src/include.1927/flashutl.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/flashutl.h	2007-11-19 06:40:31.000000000 +0300
@@ -21,6 +21,7 @@
 int sysFlashRead(uint off, uchar *dst, uint bytes);
 int sysFlashWrite(uint off, uchar *src, uint bytes);
 void nvWrite(unsigned short *data, unsigned int len);
+void nvWriteChars(unsigned char *data, unsigned int len);
 
 #endif	/* _LANGUAGE_ASSEMBLY */
 
--- src/include.1927/hnddma.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/hnddma.h	2007-11-19 06:40:31.000000000 +0300
@@ -15,170 +15,141 @@
 #ifndef	_hnddma_h_
 #define	_hnddma_h_
 
-/*
- * Each DMA processor consists of a transmit channel and a receive channel.
- */
-typedef volatile struct {
-	/* transmit channel */
-	uint32	xmtcontrol;			/* enable, et al */
-	uint32	xmtaddr;			/* descriptor ring base address (4K aligned) */
-	uint32	xmtptr;				/* last descriptor posted to chip */
-	uint32	xmtstatus;			/* current active descriptor, et al */
-
-	/* receive channel */
-	uint32	rcvcontrol;			/* enable, et al */
-	uint32	rcvaddr;			/* descriptor ring base address (4K aligned) */
-	uint32	rcvptr;				/* last descriptor posted to chip */
-	uint32	rcvstatus;			/* current active descriptor, et al */
-} dmaregs_t;
-
-typedef volatile struct {
-	/* diag access */
-	uint32	fifoaddr;			/* diag address */
-	uint32	fifodatalow;			/* low 32bits of data */
-	uint32	fifodatahigh;			/* high 32bits of data */
-	uint32	pad;				/* reserved */
-} dmafifo_t;
-
-/* transmit channel control */
-#define	XC_XE		((uint32)1 << 0)	/* transmit enable */
-#define	XC_SE		((uint32)1 << 1)	/* transmit suspend request */
-#define	XC_LE		((uint32)1 << 2)	/* loopback enable */
-#define	XC_FL		((uint32)1 << 4)	/* flush request */
-
-/* transmit descriptor table pointer */
-#define	XP_LD_MASK	0xfff			/* last valid descriptor */
-
-/* transmit channel status */
-#define	XS_CD_MASK	0x0fff			/* current descriptor pointer */
-#define	XS_XS_MASK	0xf000			/* transmit state */
-#define	XS_XS_SHIFT	12
-#define	XS_XS_DISABLED	0x0000			/* disabled */
-#define	XS_XS_ACTIVE	0x1000			/* active */
-#define	XS_XS_IDLE	0x2000			/* idle wait */
-#define	XS_XS_STOPPED	0x3000			/* stopped */
-#define	XS_XS_SUSP	0x4000			/* suspend pending */
-#define	XS_XE_MASK	0xf0000			/* transmit errors */
-#define	XS_XE_SHIFT	16
-#define	XS_XE_NOERR	0x00000			/* no error */
-#define	XS_XE_DPE	0x10000			/* descriptor protocol error */
-#define	XS_XE_DFU	0x20000			/* data fifo underrun */
-#define	XS_XE_BEBR	0x30000			/* bus error on buffer read */
-#define	XS_XE_BEDA	0x40000			/* bus error on descriptor access */
-#define	XS_AD_MASK	0xfff00000		/* active descriptor */
-#define	XS_AD_SHIFT	20
-
-/* receive channel control */
-#define	RC_RE		((uint32)1 << 0)	/* receive enable */
-#define	RC_RO_MASK	0xfe			/* receive frame offset */
-#define	RC_RO_SHIFT	1
-#define	RC_FM		((uint32)1 << 8)	/* direct fifo receive (pio) mode */
-
-/* receive descriptor table pointer */
-#define	RP_LD_MASK	0xfff			/* last valid descriptor */
-
-/* receive channel status */
-#define	RS_CD_MASK	0x0fff			/* current descriptor pointer */
-#define	RS_RS_MASK	0xf000			/* receive state */
-#define	RS_RS_SHIFT	12
-#define	RS_RS_DISABLED	0x0000			/* disabled */
-#define	RS_RS_ACTIVE	0x1000			/* active */
-#define	RS_RS_IDLE	0x2000			/* idle wait */
-#define	RS_RS_STOPPED	0x3000			/* reserved */
-#define	RS_RE_MASK	0xf0000			/* receive errors */
-#define	RS_RE_SHIFT	16
-#define	RS_RE_NOERR	0x00000			/* no error */
-#define	RS_RE_DPE	0x10000			/* descriptor protocol error */
-#define	RS_RE_DFO	0x20000			/* data fifo overflow */
-#define	RS_RE_BEBW	0x30000			/* bus error on buffer write */
-#define	RS_RE_BEDA	0x40000			/* bus error on descriptor access */
-#define	RS_AD_MASK	0xfff00000		/* active descriptor */
-#define	RS_AD_SHIFT	20
-
-/* fifoaddr */
-#define	FA_OFF_MASK	0xffff			/* offset */
-#define	FA_SEL_MASK	0xf0000			/* select */
-#define	FA_SEL_SHIFT	16
-#define	FA_SEL_XDD	0x00000			/* transmit dma data */
-#define	FA_SEL_XDP	0x10000			/* transmit dma pointers */
-#define	FA_SEL_RDD	0x40000			/* receive dma data */
-#define	FA_SEL_RDP	0x50000			/* receive dma pointers */
-#define	FA_SEL_XFD	0x80000			/* transmit fifo data */
-#define	FA_SEL_XFP	0x90000			/* transmit fifo pointers */
-#define	FA_SEL_RFD	0xc0000			/* receive fifo data */
-#define	FA_SEL_RFP	0xd0000			/* receive fifo pointers */
+typedef const struct hnddma_pub hnddma_t;
 
-/*
- * DMA Descriptor
- * Descriptors are only read by the hardware, never written back.
- */
-typedef volatile struct {
-	uint32	ctrl;		/* misc control bits & bufcount */
-	uint32	addr;		/* data buffer address */
-} dmadd_t;
+/* dma function type */
+typedef void (*di_detach_t)(hnddma_t *dmah);
+typedef bool (*di_txreset_t)(hnddma_t *dmah);
+typedef bool (*di_rxreset_t)(hnddma_t *dmah);
+typedef bool (*di_rxidle_t)(hnddma_t *dmah);
+typedef void (*di_txinit_t)(hnddma_t *dmah);
+typedef bool (*di_txenabled_t)(hnddma_t *dmah);
+typedef void (*di_rxinit_t)(hnddma_t *dmah);
+typedef void (*di_txsuspend_t)(hnddma_t *dmah);
+typedef void (*di_txresume_t)(hnddma_t *dmah);
+typedef bool (*di_txsuspended_t)(hnddma_t *dmah);
+typedef bool (*di_txsuspendedidle_t)(hnddma_t *dmah);
+typedef int (*di_txfast_t)(hnddma_t *dmah, void *p, bool commit);
+typedef void (*di_fifoloopbackenable_t)(hnddma_t *dmah);
+typedef bool  (*di_txstopped_t)(hnddma_t *dmah);
+typedef bool  (*di_rxstopped_t)(hnddma_t *dmah);
+typedef bool  (*di_rxenable_t)(hnddma_t *dmah);
+typedef bool  (*di_rxenabled_t)(hnddma_t *dmah);
+typedef void* (*di_rx_t)(hnddma_t *dmah);
+typedef void (*di_rxfill_t)(hnddma_t *dmah);
+typedef void (*di_txreclaim_t)(hnddma_t *dmah, bool forceall);
+typedef void (*di_rxreclaim_t)(hnddma_t *dmah);
+typedef	uintptr	(*di_getvar_t)(hnddma_t *dmah, const char *name);
+typedef void* (*di_getnexttxp_t)(hnddma_t *dmah, bool forceall);
+typedef void* (*di_getnextrxp_t)(hnddma_t *dmah, bool forceall);
+typedef void* (*di_peeknexttxp_t)(hnddma_t *dmah);
+typedef void (*di_txblock_t)(hnddma_t *dmah);
+typedef void (*di_txunblock_t)(hnddma_t *dmah);
+typedef uint (*di_txactive_t)(hnddma_t *dmah);
+typedef void (*di_txrotate_t)(hnddma_t *dmah);
+typedef void (*di_counterreset_t)(hnddma_t *dmah);
+typedef char* (*di_dump_t)(hnddma_t *dmah, struct bcmstrbuf *b, bool dumpring);
+typedef char* (*di_dumptx_t)(hnddma_t *dmah, struct bcmstrbuf *b, bool dumpring);
+typedef char* (*di_dumprx_t)(hnddma_t *dmah, struct bcmstrbuf *b, bool dumpring);
+
+/* dma opsvec */
+typedef struct di_fcn_s {
+	di_detach_t		detach;
+	di_txinit_t             txinit;
+	di_txreset_t		txreset;
+	di_txenabled_t          txenabled;
+	di_txsuspend_t          txsuspend;
+	di_txresume_t           txresume;
+	di_txsuspended_t        txsuspended;
+	di_txsuspendedidle_t    txsuspendedidle;
+	di_txfast_t             txfast;
+	di_txstopped_t		txstopped;
+	di_txreclaim_t          txreclaim;
+	di_getnexttxp_t         getnexttxp;
+	di_peeknexttxp_t        peeknexttxp;
+	di_txblock_t            txblock;
+	di_txunblock_t          txunblock;
+	di_txactive_t           txactive;
+	di_txrotate_t           txrotate;
+
+	di_rxinit_t             rxinit;
+	di_rxreset_t            rxreset;
+	di_rxidle_t             rxidle;
+	di_rxstopped_t		rxstopped;
+	di_rxenable_t		rxenable;
+	di_rxenabled_t		rxenabled;
+	di_rx_t                 rx;
+	di_rxfill_t             rxfill;
+	di_rxreclaim_t          rxreclaim;
+	di_getnextrxp_t         getnextrxp;
+
+	di_fifoloopbackenable_t fifoloopbackenable;
+	di_getvar_t             d_getvar;
+	di_counterreset_t       counterreset;
+	di_dump_t		dump;
+	di_dumptx_t		dumptx;
+	di_dumprx_t		dumprx;
+	uint			endnum;
+} di_fcn_t;
 
 /*
- * Each descriptor ring must be 4096byte aligned
- * and fit within a single 4096byte page.
+ * Exported data structure (read-only)
  */
-#define	DMAMAXRINGSZ	4096
-#define	DMARINGALIGN	4096
-
-/* control flags */
-#define	CTRL_BC_MASK	0x1fff			/* buffer byte count */
-#define	CTRL_EOT	((uint32)1 << 28)	/* end of descriptor table */
-#define	CTRL_IOC	((uint32)1 << 29)	/* interrupt on completion */
-#define	CTRL_EOF	((uint32)1 << 30)	/* end of frame */
-#define	CTRL_SOF	((uint32)1 << 31)	/* start of frame */
-
-/* control flags in the range [27:20] are core-specific and not defined here */
-#define	CTRL_CORE_MASK	0x0ff00000
-
 /* export structure */
-typedef volatile struct {
+struct hnddma_pub {
+	di_fcn_t	di_fn;		/* DMA function pointers */
+	uint		txavail;	/* # free tx descriptors */
+
 	/* rx error counters */
 	uint		rxgiants;	/* rx giant frames */
 	uint		rxnobuf;	/* rx out of dma descriptors */
 	/* tx error counters */
 	uint		txnobuf;	/* tx out of dma descriptors */
-} hnddma_t;
+};
 
-#ifndef di_t
-#define	di_t	void
-#endif
 
-/* externs */
-extern void * dma_attach(void *drv, void *dev, char *name, dmaregs_t *dmaregs,
+extern hnddma_t * dma_attach(osl_t *osh, char *name, sb_t *sbh, void *dmaregstx, void *dmaregsrx,
 	uint ntxd, uint nrxd, uint rxbufsize, uint nrxpost, uint rxoffset,
-	uint ddoffset, uint dataoffset, uint *msg_level);
-extern void dma_detach(di_t *di);
-extern void dma_txreset(di_t *di);
-extern void dma_rxreset(di_t *di);
-extern void dma_txinit(di_t *di);
-extern bool dma_txenabled(di_t *di);
-extern void dma_rxinit(di_t *di);
-extern void dma_rxenable(di_t *di);
-extern bool dma_rxenabled(di_t *di);
-extern void dma_txsuspend(di_t *di);
-extern void dma_txresume(di_t *di);
-extern bool dma_txsuspended(di_t *di);
-extern bool dma_txstopped(di_t *di);
-extern bool dma_rxstopped(di_t *di);
-extern int dma_txfast(di_t *di, void *p, uint32 coreflags);
-extern int dma_tx(di_t *di, void *p, uint32 coreflags);
-extern void dma_fifoloopbackenable(di_t *di);
-extern void *dma_rx(di_t *di);
-extern void dma_rxfill(di_t *di);
-extern void dma_txreclaim(di_t *di, bool forceall);
-extern void dma_rxreclaim(di_t *di);
-extern uintptr dma_getvar(di_t *di, char *name);
-extern void *dma_getnexttxp(di_t *di, bool forceall);
-extern void *dma_peeknexttxp(di_t *di);
-extern void *dma_getnextrxp(di_t *di, bool forceall);
-extern void dma_txblock(di_t *di);
-extern void dma_txunblock(di_t *di);
-extern uint dma_txactive(di_t *di);
-extern void dma_txrotate(di_t *di);
+                             uint *msg_level);
+#define dma_detach(di)			((di)->di_fn.detach(di))
+#define dma_txreset(di)			((di)->di_fn.txreset(di))
+#define dma_rxreset(di)			((di)->di_fn.rxreset(di))
+#define dma_rxidle(di)			((di)->di_fn.rxidle(di))
+#define dma_txinit(di)                  ((di)->di_fn.txinit(di))
+#define dma_txenabled(di)               ((di)->di_fn.txenabled(di))
+#define dma_rxinit(di)                  ((di)->di_fn.rxinit(di))
+#define dma_txsuspend(di)               ((di)->di_fn.txsuspend(di))
+#define dma_txresume(di)                ((di)->di_fn.txresume(di))
+#define dma_txsuspended(di)             ((di)->di_fn.txsuspended(di))
+#define dma_txsuspendedidle(di)         ((di)->di_fn.txsuspendedidle(di))
+#define dma_txfast(di, p, commit)	((di)->di_fn.txfast(di, p, commit))
+#define dma_fifoloopbackenable(di)      ((di)->di_fn.fifoloopbackenable(di))
+#define dma_txstopped(di)               ((di)->di_fn.txstopped(di))
+#define dma_rxstopped(di)               ((di)->di_fn.rxstopped(di))
+#define dma_rxenable(di)                ((di)->di_fn.rxenable(di))
+#define dma_rxenabled(di)               ((di)->di_fn.rxenabled(di))
+#define dma_rx(di)                      ((di)->di_fn.rx(di))
+#define dma_rxfill(di)                  ((di)->di_fn.rxfill(di))
+#define dma_txreclaim(di, forceall)	((di)->di_fn.txreclaim(di, forceall))
+#define dma_rxreclaim(di)               ((di)->di_fn.rxreclaim(di))
+#define dma_getvar(di, name)		((di)->di_fn.d_getvar(di, name))
+#define dma_getnexttxp(di, forceall)    ((di)->di_fn.getnexttxp(di, forceall))
+#define dma_getnextrxp(di, forceall)    ((di)->di_fn.getnextrxp(di, forceall))
+#define dma_peeknexttxp(di)             ((di)->di_fn.peeknexttxp(di))
+#define dma_txblock(di)                 ((di)->di_fn.txblock(di))
+#define dma_txunblock(di)               ((di)->di_fn.txunblock(di))
+#define dma_txactive(di)                ((di)->di_fn.txactive(di))
+#define dma_txrotate(di)                ((di)->di_fn.txrotate(di))
+#define dma_counterreset(di)            ((di)->di_fn.counterreset(di))
+
+/* return addresswidth allowed
+ * This needs to be done after SB attach but before dma attach.
+ * SB attach provides ability to probe backplane and dma core capabilities
+ * This info is needed by DMA_ALLOC_CONSISTENT in dma attach
+ */
+extern uint dma_addrwidth(sb_t *sbh, void *dmaregs);
 
+/* pio helpers */
+void dma_txpioloopback(osl_t *osh, dma32regs_t *);
 
 #endif	/* _hnddma_h_ */
--- src/include.1927/hndmips.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/hndmips.h	2007-11-19 06:40:31.000000000 +0300
@@ -13,4 +12,35 @@
  * $Id$
  */
 
-#include "sbmips.h"
+#ifndef _hndmips_h_
+#define _hndmips_h_
+
+extern void sb_mips_init(sb_t *sbh, uint shirq_map_base);
+extern bool sb_mips_setclock(sb_t *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock);
+extern void enable_pfc(uint32 mode);
+extern uint32 sb_memc_get_ncdl(sb_t *sbh);
+
+#if defined(BCMPERFSTATS)
+/* enable counting - exclusive version. Only one set of counters allowed at a time */
+extern void hndmips_perf_cyclecount_enable(void);
+extern void hndmips_perf_instrcount_enable(void);
+extern void hndmips_perf_icachecount_enable(void);
+extern void hndmips_perf_dcachecount_enable(void);
+/* start and stop counting */
+#define hndmips_perf_start01() \
+	MTC0(C0_PERFORMANCE, 4, MFC0(C0_PERFORMANCE, 4) | 0x80008000)
+#define hndmips_perf_stop01() \
+	MTC0(C0_PERFORMANCE, 4, MFC0(C0_PERFORMANCE, 4) & ~0x80008000)
+/* retrieve coutners - counters *decrement* */
+#define hndmips_perf_read0() -(long)(MFC0(C0_PERFORMANCE, 0))
+#define hndmips_perf_read1() -(long)(MFC0(C0_PERFORMANCE, 1))
+#define hndmips_perf_read2() -(long)(MFC0(C0_PERFORMANCE, 2))
+/* enable counting - modular version. Each counters can be enabled separately. */
+extern void hndmips_perf_icache_hit_enable(void);
+extern void hndmips_perf_icache_miss_enable(void);
+extern uint32 hndmips_perf_read_instrcount(void);
+extern uint32 hndmips_perf_read_cache_miss(void);
+extern uint32 hndmips_perf_read_cache_hit(void);
+#endif 
+
+#endif /* _hndmips_h_ */
--- src/include.1927/linux_osl.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/linux_osl.h	2007-11-19 06:40:31.000000000 +0300
@@ -21,7 +21,41 @@
 #include <linuxver.h>
 
 /* assert and panic */
+#ifdef BCMDBG_ASSERT
+#define ASSERT(exp) \
+	do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(char *exp, char *file, int line);
+#else /* BCMDBG_ASSERT */
+#ifdef __GNUC__
+#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#if GCC_VERSION > 30100
 #define	ASSERT(exp)		do {} while (0)
+#else
+/* ASSERT could causes segmentation fault on GCC3.1, use empty instead */
+#define	ASSERT(exp)
+#endif /* GCC_VERSION > 30100 */
+#endif /* __GNUC__ */
+#endif /* BCMDBG_ASSERT */
+
+/* microsecond delay */
+#define	OSL_DELAY(usec)		osl_delay(usec)
+extern void osl_delay(uint usec);
+
+#if defined(DSLCPE_DELAY)
+typedef struct {
+	int long_delay;
+	spinlock_t *lock;
+	void *wl;
+	unsigned long MIPS;
+} shared_osl_t;
+
+#define	OSL_LONG_DELAY(osh, usec)		osl_long_delay(osh, usec, 0)
+#define OSL_YIELD_EXEC(osh, usec)		osl_long_delay(osh, usec, 1)
+extern void osl_long_delay(osl_t *osh, uint usec, bool yield);
+extern int in_long_delay(osl_t *osh);
+extern void osl_oshsh_init(osl_t *osh, shared_osl_t *oshsh);
+#define IN_LONG_DELAY(osh)	in_long_delay(osh)
+#endif
 
 /* PCMCIA attribute space access macros */
 #if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
@@ -32,40 +66,60 @@
 	size_t size;		/* Size of window */
 	void *drv;		/* Driver data */
 };
-#endif
+#endif /* defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE) */
 #define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
 	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
 #define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
 	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
-extern void osl_pcmcia_read_attr(void *osh, uint offset, void *buf, int size);
-extern void osl_pcmcia_write_attr(void *osh, uint offset, void *buf, int size);
+extern void osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf, int size);
+extern void osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf, int size);
 
 /* PCI configuration space access macros */
 #define	OSL_PCI_READ_CONFIG(osh, offset, size) \
 	osl_pci_read_config((osh), (offset), (size))
 #define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
 	osl_pci_write_config((osh), (offset), (size), (val))
-extern uint32 osl_pci_read_config(void *osh, uint size, uint offset);
-extern void osl_pci_write_config(void *osh, uint offset, uint size, uint val);
+extern uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
+extern void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val);
+
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
+#define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
+extern uint osl_pci_bus(osl_t *osh);
+extern uint osl_pci_slot(osl_t *osh);
+
+/* Pkttag flag should be part of public information */
+typedef struct {
+	bool pkttag;
+	uint pktalloced; 	/* Number of allocated packet buffers */
+	bool mmbus;		/* Bus supports memory-mapped register accesses */
+	pktfree_cb_fn_t tx_fn;  /* Callback function for PKTFREE */
+	void *tx_ctx;		/* Context to the callback function */
+} osl_pubinfo_t;
 
 /* OSL initialization */
-extern void *osl_attach(void *pdev);
-extern void osl_detach(void *osh);
+extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
+extern void osl_detach(osl_t *osh);
+
+#define PKTFREESETCB(osh, _tx_fn, _tx_ctx) \
+	do { \
+	   ((osl_pubinfo_t*)osh)->tx_fn = _tx_fn; \
+	   ((osl_pubinfo_t*)osh)->tx_ctx = _tx_ctx; \
+	} while (0)
 
 /* host/bus architecture-specific byte swap */
 #define BUS_SWAP32(v)		(v)
 
-/* general purpose memory allocation */
-
-#if defined(BCMDBG_MEM)
+#ifdef BCMDBG_MEM
 
 #define	MALLOC(osh, size)	osl_debug_malloc((osh), (size), __LINE__, __FILE__)
 #define	MFREE(osh, addr, size)	osl_debug_mfree((osh), (addr), (size), __LINE__, __FILE__)
 #define MALLOCED(osh)		osl_malloced((osh))
-#define	MALLOC_DUMP(osh, buf, sz) osl_debug_memdump((osh), (buf), (sz))
-extern void *osl_debug_malloc(void *osh, uint size, int line, char* file);
-extern void osl_debug_mfree(void *osh, void *addr, uint size, int line, char* file);
-extern char *osl_debug_memdump(void *osh, char *buf, uint sz);
+#define	MALLOC_DUMP(osh, b) osl_debug_memdump((osh), (b))
+extern void *osl_debug_malloc(osl_t *osh, uint size, int line, char* file);
+extern void osl_debug_mfree(osl_t *osh, void *addr, uint size, int line, char* file);
+struct bcmstrbuf;
+extern int osl_debug_memdump(osl_t *osh, struct bcmstrbuf *b);
 
 #else
 
@@ -77,39 +131,50 @@
 
 #define	MALLOC_FAILED(osh)	osl_malloc_failed((osh))
 
-extern void *osl_malloc(void *osh, uint size);
-extern void osl_mfree(void *osh, void *addr, uint size);
-extern uint osl_malloced(void *osh);
-extern uint osl_malloc_failed(void *osh);
+extern void *osl_malloc(osl_t *osh, uint size);
+extern void osl_mfree(osl_t *osh, void *addr, uint size);
+extern uint osl_malloced(osl_t *osh);
+extern uint osl_malloc_failed(osl_t *osh);
 
 /* allocate/free shared (dma-able) consistent memory */
 #define	DMA_CONSISTENT_ALIGN	PAGE_SIZE
-#define	DMA_ALLOC_CONSISTENT(osh, size, pap) \
+#define	DMA_ALLOC_CONSISTENT(osh, size, pap, dmah) \
 	osl_dma_alloc_consistent((osh), (size), (pap))
-#define	DMA_FREE_CONSISTENT(osh, va, size, pa) \
+#define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
 	osl_dma_free_consistent((osh), (void*)(va), (size), (pa))
-extern void *osl_dma_alloc_consistent(void *osh, uint size, ulong *pap);
-extern void osl_dma_free_consistent(void *osh, void *va, uint size, ulong pa);
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap);
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa);
 
 /* map/unmap direction */
-#define	DMA_TX	1
-#define	DMA_RX	2
+#define	DMA_TX	1	/* TX direction for DMA */
+#define	DMA_RX	2	/* RX direction for DMA */
 
 /* map/unmap shared (dma-able) memory */
-#define	DMA_MAP(osh, va, size, direction, p) \
+#define	DMA_MAP(osh, va, size, direction, p, dmah) \
 	osl_dma_map((osh), (va), (size), (direction))
-#define	DMA_UNMAP(osh, pa, size, direction, p) \
+#define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
 	osl_dma_unmap((osh), (pa), (size), (direction))
-extern uint osl_dma_map(void *osh, void *va, uint size, int direction);
-extern void osl_dma_unmap(void *osh, uint pa, uint size, int direction);
+extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction);
+extern void osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction);
+
+/* API for DMA addressing capability */
+#define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
 
 /* register access macros */
 #if defined(BCMJTAG)
-struct bcmjtag_info;
-extern uint32 bcmjtag_read(struct bcmjtag_info *ejh, uint32 addr, uint size);
-extern void bcmjtag_write(struct bcmjtag_info *ejh, uint32 addr, uint32 val, uint size);
-#define	R_REG(r)	bcmjtag_read(NULL, (uint32)(r), sizeof (*(r)))
-#define	W_REG(r, v)	bcmjtag_write(NULL, (uint32)(r), (uint32)(v), sizeof (*(r)))
+#include <bcmjtag.h>
+#define OSL_WRITE_REG(osh, r, v) (bcmjtag_write(NULL, (uintptr)(r), (v), sizeof(*(r))))
+#define OSL_READ_REG(osh, r) (bcmjtag_read(NULL, (uintptr)(r), sizeof(*(r))))
+#endif
+
+#if defined(BCMJTAG)
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t*)(osh))->mmbus) \
+	mmap_op else bus_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t*)(osh))->mmbus) ? \
+	mmap_op : bus_op
+#else
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) mmap_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) mmap_op
 #endif
 
 /*
@@ -119,28 +184,61 @@
 #ifndef BINOSL
 
 /* string library, kernel mode */
+#ifndef printf
 #define	printf(fmt, args...)	printk(fmt, ## args)
+#endif /* printf */
 #include <linux/kernel.h>
 #include <linux/string.h>
 
 /* register access macros */
-#if !defined(BCMJTAG)
-#define R_REG(r) ( \
-	sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
+#ifndef IL_BIGENDIAN
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
 	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
-	readl((volatile uint32*)(r)) \
+	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
 )
-#define W_REG(r, v) do { \
+#define W_REG(osh, r, v) do { \
+	SELECT_BUS_WRITE(osh,  \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	writeb((uint8)(v), (volatile uint8*)(r)); break; \
 	case sizeof(uint16):	writew((uint16)(v), (volatile uint16*)(r)); break; \
 	case sizeof(uint32):	writel((uint32)(v), (volatile uint32*)(r)); break; \
+		}, \
+		(OSL_WRITE_REG(osh, r, v))); \
+	} while (0)
+#else	/* IL_BIGENDIAN */
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			switch (sizeof(*(r))) { \
+				case sizeof(uint8):	__osl_v = \
+					readb((volatile uint8*)((uintptr)(r)^3)); break; \
+				case sizeof(uint16):	__osl_v = \
+					readw((volatile uint16*)((uintptr)(r)^2)); break; \
+				case sizeof(uint32):	__osl_v = \
+					readl((volatile uint32*)(r)); break; \
 	} \
-} while (0)
-#endif
+			__osl_v; \
+		}), \
+		OSL_READ_REG(osh, r)) \
+)
+#define W_REG(osh, r, v) do { \
+	SELECT_BUS_WRITE(osh,  \
+		switch (sizeof(*(r))) { \
+			case sizeof(uint8):	writeb((uint8)(v), \
+					(volatile uint8*)((uintptr)(r)^3)); break; \
+			case sizeof(uint16):	writew((uint16)(v), \
+					(volatile uint16*)((uintptr)(r)^2)); break; \
+			case sizeof(uint32):	writel((uint32)(v), \
+					(volatile uint32*)(r)); break; \
+		}, \
+		(OSL_WRITE_REG(osh, r, v))); \
+	} while (0)
+#endif /* IL_BIGENDIAN */
 
-#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
-#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
 
 /* bcopy, bcmp, and bzero */
 #define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
@@ -153,64 +251,134 @@
 #include <asm/addrspace.h>
 #else
 #define OSL_UNCACHED(va)	(va)
-#endif
+#endif /* mips */
 
 /* get processor cycle count */
 #if defined(mips)
+#if defined DSLCPE_DELAY
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count())
+#define TICKDIFF(_x2_, _x1_)	\
+	((_x2_ >= _x1_) ? (_x2_ - _x1_) : ((unsigned long)(-1) - _x2_ + _x1_))
+#else
 #define	OSL_GETCYCLES(x)	((x) = read_c0_count() * 2)
+#endif
 #elif defined(__i386__)
 #define	OSL_GETCYCLES(x)	rdtscl((x))
 #else
 #define OSL_GETCYCLES(x)	((x) = 0)
-#endif
+#endif /* defined(mips) */
 
 /* dereference an address that may cause a bus exception */
 #ifdef mips
-#if defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17))
-#define BUSPROBE(val, addr)	panic("get_dbe() will not fixup a bus exception when compiled into a module")
+#if defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 17))
+#define BUSPROBE(val, addr)	panic("get_dbe() will not fixup a bus exception when compiled into"\
+					" a module")
 #else
 #define	BUSPROBE(val, addr)	get_dbe((val), (addr))
 #include <asm/paccess.h>
-#endif
+#endif /* defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 17)) */
 #else
-#define	BUSPROBE(val, addr)	({ (val) = R_REG((addr)); 0; })
-#endif
+#define	BUSPROBE(val, addr)	({ (val) = R_REG(NULL, (addr)); 0; })
+#endif /* mips */
 
 /* map/unmap physical to virtual I/O */
 #define	REG_MAP(pa, size)	ioremap_nocache((unsigned long)(pa), (unsigned long)(size))
 #define	REG_UNMAP(va)		iounmap((void *)(va))
 
-/* microsecond delay */
-#define	OSL_DELAY(usec)		udelay(usec)
-#include <linux/delay.h>
-
 /* shared (dma-able) memory access macros */
 #define	R_SM(r)			*(r)
 #define	W_SM(r, v)		(*(r) = (v))
 #define	BZERO_SM(r, len)	memset((r), '\0', (len))
 
 /* packet primitives */
-#define	PKTGET(drv, len, send)		osl_pktget((drv), (len), (send))
-#define	PKTFREE(drv, skb, send)		osl_pktfree((skb))
-#define	PKTDATA(drv, skb)		(((struct sk_buff*)(skb))->data)
-#define	PKTLEN(drv, skb)		(((struct sk_buff*)(skb))->len)
-#define PKTHEADROOM(drv, skb)		(PKTDATA(drv,skb)-(((struct sk_buff*)(skb))->head))
-#define PKTTAILROOM(drv, skb)		((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
-#define	PKTNEXT(drv, skb)		(((struct sk_buff*)(skb))->next)
-#define	PKTSETNEXT(skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
-#define	PKTSETLEN(drv, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
-#define	PKTPUSH(drv, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
-#define	PKTPULL(drv, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
-#define	PKTDUP(drv, skb)		skb_clone((struct sk_buff*)(skb), GFP_ATOMIC)
-#define	PKTCOOKIE(skb)			((void*)((struct sk_buff*)(skb))->csum)
-#define	PKTSETCOOKIE(skb, x)		(((struct sk_buff*)(skb))->csum = (uint)(x))
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
+#define	PKTDATA(osh, skb)		(((struct sk_buff*)(skb))->data)
+#define	PKTLEN(osh, skb)		(((struct sk_buff*)(skb))->len)
+#define PKTHEADROOM(osh, skb)		(PKTDATA(osh, skb)-(((struct sk_buff*)(skb))->head))
+#define PKTTAILROOM(osh, skb) ((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
+#define	PKTNEXT(osh, skb)		(((struct sk_buff*)(skb))->next)
+#define	PKTSETNEXT(osh, skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
+#define	PKTSETLEN(osh, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define	PKTTAG(skb)			((void*)(((struct sk_buff*)(skb))->cb))
+#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
+#ifdef BCMDBG_PKT     /* pkt logging for debugging */
+#define PKTLIST_DUMP(osh, buf) 		osl_pktlist_dump(osh, buf)
+#else /* BCMDBG_PKT */
+#define PKTLIST_DUMP(osh, buf)
+#endif /* BCMDBG_PKT */
+
+#ifdef BCMDBG_PKT     /* pkt logging for debugging */
+extern void osl_pktlist_add(osl_t *osh, void *p);
+extern void osl_pktlist_remove(osl_t *osh, void *p);
+extern char *osl_pktlist_dump(osl_t *osh, char *buf);
+#endif /* BCMDBG_PKT */
+
+/* Convert a native(OS) packet to driver packet.
+ * In the process, native packet is destroyed, there is no copying
+ * Also, a packettag is zeroed out
+ */
+static INLINE void *
+osl_pkt_frmnative(osl_pubinfo_t *osh, struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pkttag)
+		bzero((void*)skb->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	for (nskb = skb; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		osl_pktlist_add((osl_t *)osh, (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pktalloced++;
+	}
+
+	return (void *)skb;
+}
+#define PKTFRMNATIVE(osh, skb)	osl_pkt_frmnative(((osl_pubinfo_t *)osh), (struct sk_buff*)(skb))
+
+/* Convert a driver packet to native(OS) packet
+ * In the process, packettag is zeroed out before sending up
+ * IP code depends on skb->cb to be setup correctly with various options
+ * In our case, that means it should be 0
+ */
+static INLINE struct sk_buff *
+osl_pkt_tonative(osl_pubinfo_t *osh, void *pkt)
+{
+	struct sk_buff *nskb;
+
+	if (osh->pkttag)
+		bzero(((struct sk_buff*)pkt)->cb, OSL_PKTTAG_SZ);
+
+	/* Decrement the packet counter */
+	for (nskb = (struct sk_buff *)pkt; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+		osl_pktlist_remove((osl_t *)osh, (void *) nskb);
+#endif  /* BCMDBG_PKT */
+		osh->pktalloced--;
+	}
+
+	return (struct sk_buff *)pkt;
+}
+#define PKTTONATIVE(osh, pkt)		osl_pkt_tonative((osl_pubinfo_t *)(osh), (pkt))
+
 #define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
 #define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
 #define	PKTPRIO(skb)			(((struct sk_buff*)(skb))->priority)
 #define	PKTSETPRIO(skb, x)		(((struct sk_buff*)(skb))->priority = (x))
-extern void *osl_pktget(void *drv, uint len, bool send);
-extern void osl_pktfree(void *skb);
-
+#define PKTSUMNEEDED(skb)		(((struct sk_buff*)(skb))->ip_summed == CHECKSUM_HW)
+#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff*)(skb))->ip_summed = \
+						((x) ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE))
+/* PKTSETSUMNEEDED and PKTSUMGOOD are not possible because skb->ip_summed is overloaded */
+#define PKTSHARED(skb)                  (((struct sk_buff*)(skb))->cloned)
+
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
+extern void *osl_pktdup(osl_t *osh, void *skb);
 #else	/* BINOSL */                                    
 
 /* string library */
@@ -229,23 +397,23 @@
 #define	strcpy(d, s)			osl_strcpy((d), (s))
 #undef strncpy
 #define	strncpy(d, s, n)		osl_strncpy((d), (s), (n))
-#endif
+#endif /* LINUX_OSL */
 extern int osl_printf(const char *format, ...);
 extern int osl_sprintf(char *buf, const char *format, ...);
 extern int osl_strcmp(const char *s1, const char *s2);
 extern int osl_strncmp(const char *s1, const char *s2, uint n);
-extern int osl_strlen(char *s);
+extern int osl_strlen(const char *s);
 extern char* osl_strcpy(char *d, const char *s);
 extern char* osl_strncpy(char *d, const char *s, uint n);
 
 /* register access macros */
 #if !defined(BCMJTAG)
-#define R_REG(r) ( \
+#define R_REG(osh, r) (\
 	sizeof(*(r)) == sizeof(uint8) ? osl_readb((volatile uint8*)(r)) : \
 	sizeof(*(r)) == sizeof(uint16) ? osl_readw((volatile uint16*)(r)) : \
 	osl_readl((volatile uint32*)(r)) \
 )
-#define W_REG(r, v) do { \
+#define W_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	osl_writeb((uint8)(v), (volatile uint8*)(r)); break; \
 	case sizeof(uint16):	osl_writew((uint16)(v), (volatile uint16*)(r)); break; \
@@ -254,8 +422,8 @@
 } while (0)
 #endif
 
-#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
-#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
 extern uint8 osl_readb(volatile uint8 *r);
 extern uint16 osl_readw(volatile uint16 *r);
 extern uint32 osl_readl(volatile uint32 *r);
@@ -286,56 +454,73 @@
 extern void *osl_reg_map(uint32 pa, uint size);
 extern void osl_reg_unmap(void *va);
 
-/* microsecond delay */
-#define	OSL_DELAY(usec)		osl_delay((usec))
-extern void osl_delay(uint usec);
-
 /* shared (dma-able) memory access macros */
 #define	R_SM(r)			*(r)
 #define	W_SM(r, v)		(*(r) = (v))
 #define	BZERO_SM(r, len)	bzero((r), (len))
 
 /* packet primitives */
-#define	PKTGET(drv, len, send)		osl_pktget((drv), (len), (send))
-#define	PKTFREE(drv, skb, send)		osl_pktfree((skb))
-#define	PKTDATA(drv, skb)		osl_pktdata((drv), (skb))
-#define	PKTLEN(drv, skb)		osl_pktlen((drv), (skb))
-#define PKTHEADROOM(drv, skb)		osl_pktheadroom((drv), (skb))
-#define PKTTAILROOM(drv, skb)		osl_pkttailroom((drv), (skb))
-#define	PKTNEXT(drv, skb)		osl_pktnext((drv), (skb))
-#define	PKTSETNEXT(skb, x)		osl_pktsetnext((skb), (x))
-#define	PKTSETLEN(drv, skb, len)	osl_pktsetlen((drv), (skb), (len))
-#define	PKTPUSH(drv, skb, bytes)	osl_pktpush((drv), (skb), (bytes))
-#define	PKTPULL(drv, skb, bytes)	osl_pktpull((drv), (skb), (bytes))
-#define	PKTDUP(drv, skb)		osl_pktdup((drv), (skb))
-#define	PKTCOOKIE(skb)			osl_pktcookie((skb))
-#define	PKTSETCOOKIE(skb, x)		osl_pktsetcookie((skb), (x))
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
+#define	PKTDATA(osh, skb)		osl_pktdata((osh), (skb))
+#define	PKTLEN(osh, skb)		osl_pktlen((osh), (skb))
+#define PKTHEADROOM(osh, skb)		osl_pktheadroom((osh), (skb))
+#define PKTTAILROOM(osh, skb)		osl_pkttailroom((osh), (skb))
+#define	PKTNEXT(osh, skb)		osl_pktnext((osh), (skb))
+#define	PKTSETNEXT(osh, skb, x)		osl_pktsetnext((skb), (x))
+#define	PKTSETLEN(osh, skb, len)	osl_pktsetlen((osh), (skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	osl_pktpush((osh), (skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	osl_pktpull((osh), (skb), (bytes))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define PKTTAG(skb)			osl_pkttag((skb))
+#define PKTFRMNATIVE(osh, skb)		osl_pkt_frmnative((osh), (struct sk_buff*)(skb))
+#define PKTTONATIVE(osh, pkt)		osl_pkt_tonative((osh), (pkt))
 #define	PKTLINK(skb)			osl_pktlink((skb))
 #define	PKTSETLINK(skb, x)		osl_pktsetlink((skb), (x))
 #define	PKTPRIO(skb)			osl_pktprio((skb))
 #define	PKTSETPRIO(skb, x)		osl_pktsetprio((skb), (x))
-extern void *osl_pktget(void *drv, uint len, bool send);
-extern void osl_pktfree(void *skb);
-extern uchar *osl_pktdata(void *drv, void *skb);
-extern uint osl_pktlen(void *drv, void *skb);
-extern uint osl_pktheadroom(void *drv, void *skb);
-extern uint osl_pkttailroom(void *drv, void *skb);
-extern void *osl_pktnext(void *drv, void *skb);
+#define PKTSHARED(skb)                  osl_pktshared((skb))
+#define PKTALLOCED(osh)			osl_pktalloced((osh))
+#ifdef BCMDBG_PKT
+#define PKTLIST_DUMP(osh, buf) 		osl_pktlist_dump(osh, buf)
+#else /* BCMDBG_PKT */
+#define PKTLIST_DUMP(osh, buf)
+#endif /* BCMDBG_PKT */
+
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
+extern uchar *osl_pktdata(osl_t *osh, void *skb);
+extern uint osl_pktlen(osl_t *osh, void *skb);
+extern uint osl_pktheadroom(osl_t *osh, void *skb);
+extern uint osl_pkttailroom(osl_t *osh, void *skb);
+extern void *osl_pktnext(osl_t *osh, void *skb);
 extern void osl_pktsetnext(void *skb, void *x);
-extern void osl_pktsetlen(void *drv, void *skb, uint len);
-extern uchar *osl_pktpush(void *drv, void *skb, int bytes);
-extern uchar *osl_pktpull(void *drv, void *skb, int bytes);
-extern void *osl_pktdup(void *drv, void *skb);
-extern void *osl_pktcookie(void *skb);
-extern void osl_pktsetcookie(void *skb, void *x);
+extern void osl_pktsetlen(osl_t *osh, void *skb, uint len);
+extern uchar *osl_pktpush(osl_t *osh, void *skb, int bytes);
+extern uchar *osl_pktpull(osl_t *osh, void *skb, int bytes);
+extern void *osl_pktdup(osl_t *osh, void *skb);
+extern void *osl_pkttag(void *skb);
 extern void *osl_pktlink(void *skb);
 extern void osl_pktsetlink(void *skb, void *x);
 extern uint osl_pktprio(void *skb);
 extern void osl_pktsetprio(void *skb, uint x);
+extern void *osl_pkt_frmnative(osl_t *osh, struct sk_buff *skb);
+extern struct sk_buff *osl_pkt_tonative(osl_t *osh, void *pkt);
+extern bool osl_pktshared(void *skb);
+extern uint osl_pktalloced(osl_t *osh);
+
+#ifdef BCMDBG_PKT     /* pkt logging for debugging */
+extern char *osl_pktlist_dump(osl_t *osh, char *buf);
+extern void osl_pktlist_add(osl_t *osh, void *p);
+extern void osl_pktlist_remove(osl_t *osh, void *p);
+#endif /* BCMDBG_PKT */
 
 #endif	/* BINOSL */
 
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+extern int osl_error(int bcmerror);
+
 /* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
-#define	PKTBUFSZ	2048
+#define	PKTBUFSZ	2048   /* largest reasonable packet buffer, driver uses for ethernet MTU */
 
 #endif	/* _linux_osl_h_ */
--- src/include.1927/linuxver.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/linuxver.h	2007-11-19 06:40:31.000000000 +0300
@@ -16,24 +16,31 @@
 #ifndef _linuxver_h_
 #define _linuxver_h_
 
-#include <linux/config.h>
 #include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#include <linux/module.h>
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0))
 /* __NO_VERSION__ must be defined for all linkables except one in 2.2 */
 #ifdef __UNDEF_NO_VERSION__
 #undef __NO_VERSION__
 #else
 #define __NO_VERSION__
 #endif
-#endif
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0) */
 
-#if defined(MODULE) && defined(MODVERSIONS)
-#include <linux/modversions.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define module_param(_name_, _type_, _perm_)	MODULE_PARM(_name_, "i")
+#define module_param_string(_name_, _string_, _size_, _perm_) \
+		MODULE_PARM(_string_, "c" __MODULE_STRING(_size_))
 #endif
 
 /* linux/malloc.h is deprecated, use linux/slab.h instead. */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 9))
 #include <linux/malloc.h>
 #else
 #include <linux/slab.h>
@@ -48,7 +55,7 @@
 #include <linux/netdevice.h>
 #include <asm/io.h>
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
 #include <linux/workqueue.h>
 #else
 #include <linux/tqueue.h>
@@ -64,9 +71,16 @@
 #ifndef flush_scheduled_work
 #define flush_scheduled_work() flush_scheduled_tasks()
 #endif
-#endif
+#endif	/* LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41) */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#define	MY_INIT_WORK(_work, _func, _data)	INIT_WORK(_work, _func)
+#else
+#define	MY_INIT_WORK(_work, _func, _data)	INIT_WORK(_work, _func, _data)
+typedef void (*work_func_t)(void *work);
+#endif	/* < 2.6.20 */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
 /* Some distributions have their own 2.6.x compatibility layers */
 #ifndef IRQ_NONE
 typedef void irqreturn_t;
@@ -74,7 +88,9 @@
 #define IRQ_HANDLED
 #define IRQ_RETVAL(x)
 #endif
-#endif
+#else
+typedef irqreturn_t(*FN_ISR) (int irq, void *dev_id, struct pt_regs *ptregs);
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0) */
 
 #if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
 
@@ -85,9 +101,10 @@
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 69))
 /* In 2.5 (as of 2.5.69 at least) there is a cs_error exported which
- * does this, but it's not in 2.4 so we do our own for now. */
+ * does this, but it's not in 2.4 so we do our own for now.
+ */
 static inline void
 cs_error(client_handle_t handle, int func, int ret)
 {
@@ -96,6 +113,12 @@
 }
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 15))
+
+typedef	struct pcmcia_device dev_link_t;
+
+#endif
+
 #endif /* CONFIG_PCMCIA */
 
 #ifndef __exit
@@ -114,10 +137,10 @@
 #define __devexit_p(x)	x
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0))
 
 #define pci_get_drvdata(dev)		(dev)->sysdata
-#define pci_set_drvdata(dev, value)	(dev)->sysdata=(value)
+#define pci_set_drvdata(dev, value)	(dev)->sysdata = (value)
 
 /*
  * New-style (2.4.x) PCI/hot-pluggable PCI/CardBus registration
@@ -134,8 +157,11 @@
 	struct list_head node;
 	char *name;
 	const struct pci_device_id *id_table;	/* NULL if wants all devices */
-	int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);	/* New device inserted */
-	void (*remove)(struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
+	int (*probe)(struct pci_dev *dev,
+	             const struct pci_device_id *id); /* New device inserted */
+	void (*remove)(struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug
+						 * capable driver)
+						 */
 	void (*suspend)(struct pci_dev *dev);	/* Device suspended */
 	void (*resume)(struct pci_dev *dev);	/* Device woken up */
 };
@@ -150,7 +176,7 @@
 
 #endif /* PCI registration */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18))
 #ifdef MODULE
 #define module_init(x) int init_module(void) { return x(); }
 #define module_exit(x) void cleanup_module(void) { x(); }
@@ -158,28 +184,28 @@
 #define module_init(x)	__initcall(x);
 #define module_exit(x)	__exitcall(x);
 #endif
-#endif
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18) */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,48))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 48))
 #define list_for_each(pos, head) \
 	for (pos = (head)->next; pos != (head); pos = pos->next)
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,13))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 13))
 #define pci_resource_start(dev, bar)	((dev)->base_address[(bar)])
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,44))
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 44))
 #define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,23))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 23))
 #define pci_enable_device(dev) do { } while (0)
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,14))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 14))
 #define net_device device
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,42))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 42))
 
 /*
  * DMA mapping
@@ -237,10 +263,10 @@
 
 #endif /* DMA mapping */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 43))
 
 #define dev_kfree_skb_any(a)		dev_kfree_skb(a)
-#define netif_down(dev)			do { (dev)->start = 0; } while(0)
+#define netif_down(dev)			do { (dev)->start = 0; } while (0)
 
 /* pcmcia-cs provides its own netdevice compatibility layer */
 #ifndef _COMPAT_NETDEVICE_H
@@ -257,7 +283,8 @@
  */
 
 #define dev_kfree_skb_irq(a)		dev_kfree_skb(a)
-#define netif_wake_queue(dev)		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while(0)
+#define netif_wake_queue(dev) \
+		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while (0)
 #define netif_stop_queue(dev)		set_bit(0, &(dev)->tbusy)
 
 static inline void netif_start_queue(struct net_device *dev)
@@ -292,7 +319,7 @@
 	tasklet->routine = (void (*)(void *))func;
 	tasklet->data = (void *)data;
 }
-#define tasklet_kill(tasklet)			{do{} while(0);}
+#define tasklet_kill(tasklet)	{ do{} while (0); }
 
 /* 2.4.x introduced del_timer_sync() */
 #define del_timer_sync(timer) del_timer(timer)
@@ -303,7 +330,7 @@
 
 #endif /* SoftNet */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3))
 
 /*
  * Emit code to initialise a tq_struct's routine and data pointers
@@ -324,9 +351,9 @@
 		PREPARE_TQUEUE((_tq), (_routine), (_data));	\
 	} while (0)
 
-#endif
+#endif	/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3) */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6))
 
 /* Power management related routines */
 
@@ -336,7 +363,7 @@
 	int i;
 	if (buffer) {
 		for (i = 0; i < 16; i++)
-			pci_read_config_dword(dev, i * 4,&buffer[i]);
+			pci_read_config_dword(dev, i * 4, &buffer[i]);
 	}
 	return 0;
 }
@@ -348,7 +375,7 @@
 
 	if (buffer) {
 		for (i = 0; i < 16; i++)
-			pci_write_config_dword(dev,i * 4, buffer[i]);
+			pci_write_config_dword(dev, i * 4, buffer[i]);
 	}
 	/*
 	 * otherwise, write the context information we know from bootup.
@@ -369,7 +396,7 @@
 #endif /* PCI power management */
 
 /* Old cp0 access macros deprecated in 2.4.19 */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 19))
 #define read_c0_count() read_32bit_cp0_register(CP0_COUNT)
 #endif
 
@@ -391,9 +418,16 @@
 #define free_netdev(dev)		kfree(dev)
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
 /* struct packet_type redefined in 2.6.x */
 #define af_packet_priv			data
 #endif
 
+/* suspend args */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+#define DRV_SUSPEND_STATE_TYPE pm_message_t
+#else
+#define DRV_SUSPEND_STATE_TYPE uint32
+#endif
+
 #endif /* _linuxver_h_ */
--- src/include.1927/min_osl.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/min_osl.h	2007-11-19 06:40:31.000000000 +0300
@@ -18,33 +18,13 @@
 #include <typedefs.h>
 #include <sbconfig.h>
 #include <mipsinc.h>
+#include <bcmstdlib.h>
 
 /* Cache support */
 extern void caches_on(void);
 extern void blast_dcache(void);
 extern void blast_icache(void);
 
-/* uart output */
-extern void putc(int c);
-
-/* lib functions */
-extern int printf(const char *fmt, ...);
-extern int sprintf(char *buf, const char *fmt, ...);
-extern int strcmp(const char *s1, const char *s2);
-extern int strncmp(const char *s1, const char *s2, uint n);
-extern char *strcpy(char *dest, const char *src);
-extern char *strncpy(char *dest, const char *src, uint n);
-extern uint strlen(const char *s);
-extern char *strchr(const char *str,int c);
-extern char *strrchr(const char *str, int c);
-extern char *strcat(char *d, const char *s);
-extern void *memset(void *dest, int c, uint n);
-extern void *memcpy(void *dest, const void *src, uint n);
-extern int memcmp(const void *s1, const void *s2, uint n);
-#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
-#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
-#define	bzero(b, len)		memset((b), '\0', (len))
-
 /* assert & debugging */
 #define	ASSERT(exp)		do {} while (0)
 
@@ -60,6 +40,10 @@
 #define	OSL_PCI_WRITE_CONFIG(loc, offset, size, val) \
 	do {} while (0)
 
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	(0)
+#define OSL_PCI_SLOT(osh)	(0)
+
 /* register access macros */
 #define wreg32(r, v)		(*(volatile uint32*)(r) = (uint32)(v))
 #define rreg32(r)		(*(volatile uint32*)(r))
@@ -67,7 +51,7 @@
 #define rreg16(r)		(*(volatile uint16*)(r))
 #define wreg8(r, v)		(*(volatile uint8*)(r) = (uint8)(v))
 #define rreg8(r)		(*(volatile uint8*)(r))
-#define R_REG(r) ({ \
+#define R_REG(osh, r) ({ \
 	__typeof(*(r)) __osl_v; \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	__osl_v = rreg8((r)); break; \
@@ -76,22 +60,22 @@
 	} \
 	__osl_v; \
 })
-#define W_REG(r, v) do { \
+#define W_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
 	case sizeof(uint8):	wreg8((r), (v)); break; \
 	case sizeof(uint16):	wreg16((r), (v)); break; \
 	case sizeof(uint32):	wreg32((r), (v)); break; \
 	} \
 } while (0)
-#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
-#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
 
 /* general purpose memory allocation */
 #define	MALLOC(osh, size)	malloc(size)
 #define	MFREE(osh, addr, size)	free(addr)
 #define	MALLOCED(osh)		0
 #define	MALLOC_FAILED(osh)	0
-#define	MALLOC_DUMP(osh, buf, sz)
+#define	MALLOC_DUMP(osh, b)
 extern int free(void *ptr);
 extern void *malloc(uint size);
 
@@ -113,9 +97,40 @@
 #define	BUSPROBE(val, addr)	(uint32 *)(addr) = (val)
 
 /* Misc stubs */
-#define osl_attach(pdev)	(pdev)
+#define osl_attach(pdev)	((osl_t*)pdev)
 #define osl_detach(osh)
+
+#define PKTFREESETCB(osh, _tx_fn, _tx_ctx)
+
 extern void *osl_init(void);
-extern int getintvar(char *vars, char *name);
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+extern int osl_error(int);
+
+/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
+#define	PKTBUFSZ			(MAXPKTBUFSZ - LBUFSZ)
+
+/* packet primitives */
+#define PKTGET(osh, len, send)		((void *)NULL)
+#define PKTFREE(osh, p, send)
+#define	PKTDATA(osh, lb)		((void *)NULL)
+#define	PKTLEN(osh, lb)			0
+#define	PKTHEADROOM(osh, lb)		0
+#define	PKTTAILROOM(osh, lb)		0
+#define	PKTNEXT(osh, lb)		((void *)NULL)
+#define	PKTSETNEXT(osh, lb, x)
+#define	PKTSETLEN(osh, lb, len)
+#define	PKTPUSH(osh, lb, bytes)
+#define	PKTPULL(osh, lb, bytes)
+#define PKTDUP(osh, p)
+#define	PKTTAG(lb)			((void *)NULL)
+#define	PKTLINK(lb)			((void *)NULL)
+#define	PKTSETLINK(lb, x)
+#define	PKTPRIO(lb)			0
+#define	PKTSETPRIO(lb, x)
+#define PKTSHARED(lb)			1
+#define PKTALLOCED(osh)			0
+#define PKTLIST_DUMP(osh, buf)
+#define PKTFRMNATIVE(osh, lb)		((void *)NULL)
+#define PKTTONATIVE(osh, p)		((struct lbuf *)NULL)
 
 #endif	/* _min_osl_h_ */
--- src/include.1927/mipsinc.h	2004-11-25 09:11:38.000000000 +0300
+++ src/include/mipsinc.h	2007-11-19 06:40:31.000000000 +0300
@@ -59,9 +59,7 @@
 #define ra	$31	/* return address */
 
 
-/*  *********************************************************************
-    *  CP0 Registers 
-    ********************************************************************* */
+/* CP0 Registers */
 
 #define C0_INX		$0
 #define C0_RAND		$1
@@ -71,6 +69,7 @@
 #define C0_CTEXT	$4
 #define C0_PGMASK	$5
 #define C0_WIRED	$6
+#define C0_INFO		$7
 #define C0_BADVADDR	$8
 #define C0_COUNT 	$9
 #define C0_TLBHI	$10
@@ -87,6 +86,7 @@
 #define C0_XCTEXT	$20
 #define C0_DIAGNOSTIC	$22
 #define C0_BROADCOM	C0_DIAGNOSTIC
+#define	C0_PERFORMANCE	$25
 #define C0_ECC		$26
 #define C0_CACHEERR	$27
 #define C0_TAGLO	$28
@@ -100,19 +100,26 @@
 #define	LEAF(symbol)				\
 		.globl	symbol;			\
 		.align	2;			\
-		.type	symbol,@function;	\
-		.ent	symbol,0;		\
-symbol:		.frame	sp,0,ra
+		.type	symbol, @function;	\
+		.ent	symbol, 0;		\
+symbol:		.frame	sp, 0, ra
 
 /*
  * END - mark end of function
  */
 #define	END(function)				\
 		.end	function;		\
-		.size	function,.-function
+		.size	function, . - function
 
 #define	_ULCAST_
 
+#define MFC0_SEL(dst, src, sel) \
+		.word\t(0x40000000 | ((dst) << 16) | ((src) << 11) | (sel))
+
+
+#define MTC0_SEL(dst, src, sel) \
+		.word\t(0x40800000 | ((dst) << 16) | ((src) << 11) | (sel))
+
 #else
 
 /*
@@ -129,9 +136,7 @@
 #define	_ULCAST_ (unsigned long)
 
 
-/*  *********************************************************************
-    *  CP0 Registers 
-    ********************************************************************* */
+/* CP0 Registers */
 
 #define C0_INX		0		/* CP0: TLB Index */
 #define C0_RAND		1		/* CP0: TLB Random */
@@ -141,6 +146,7 @@
 #define C0_CTEXT	4		/* CP0: Context */
 #define C0_PGMASK	5		/* CP0: TLB PageMask */
 #define C0_WIRED	6		/* CP0: TLB Wired */
+#define C0_INFO		7		/* CP0: Info */
 #define C0_BADVADDR	8		/* CP0: Bad Virtual Address */
 #define C0_COUNT 	9		/* CP0: Count */
 #define C0_TLBHI	10		/* CP0: TLB EntryHi */
@@ -157,6 +163,7 @@
 #define C0_XCTEXT	20		/* CP0: XContext */
 #define C0_DIAGNOSTIC	22		/* CP0: Diagnostic */
 #define C0_BROADCOM	C0_DIAGNOSTIC	/* CP0: Broadcom Register */
+#define	C0_PERFORMANCE	25		/* CP0: Performance Counter/Control Registers */
 #define C0_ECC		26		/* CP0: ECC */
 #define C0_CACHEERR	27		/* CP0: CacheErr */
 #define C0_TAGLO	28		/* CP0: TagLo */
@@ -232,117 +239,22 @@
 					/* 0x1e is unused */
 #define Hit_Set_Virtual_SI	0x1e
 #define Hit_Set_Virtual_SD	0x1f
-#endif
-
-#ifndef	_LANGUAGE_ASSEMBLY
-
-/*
- * Macros to access the system control coprocessor
- */
-
-#define MFC0(source, sel)					\
-({								\
-	int __res;						\
-	__asm__ __volatile__(					\
-	".set\tnoreorder\n\t"					\
-	".set\tnoat\n\t"					\
-	".word\t"STR(0x40010000 | ((source)<<11) | (sel))"\n\t"	\
-	"move\t%0,$1\n\t"					\
-	".set\tat\n\t"						\
-	".set\treorder"						\
-	:"=r" (__res)						\
-	:							\
-	:"$1");							\
-	__res;							\
-})
-
-#define MTC0(source, sel, value)				\
-do {								\
-	__asm__ __volatile__(					\
-	".set\tnoreorder\n\t"					\
-	".set\tnoat\n\t"					\
-	"move\t$1,%z0\n\t"					\
-	".word\t"STR(0x40810000 | ((source)<<11) | (sel))"\n\t"	\
-	".set\tat\n\t"						\
-	".set\treorder"						\
-	:							\
-	:"jr" (value)						\
-	:"$1");							\
-} while (0)
-
-#define get_c0_count()						\
-({								\
-	int __res;						\
-	__asm__ __volatile__(					\
-	".set\tnoreorder\n\t"					\
-	".set\tnoat\n\t"					\
-	"mfc0\t%0,$9\n\t"					\
-	".set\tat\n\t"						\
-	".set\treorder"						\
-	:"=r" (__res));						\
-	__res;							\
-})
-
-static inline void icache_probe(uint32 config1, uint *size, uint *lsize)
-{
-	uint lsz, sets, ways;
-
-	/* Instruction Cache Size = Associativity * Line Size * Sets Per Way */
-	if ((lsz = ((config1 >> 19) & 7)))
-		lsz = 2 << lsz;
-	sets = 64 << ((config1 >> 22) & 7);
-	ways = 1 + ((config1 >> 16) & 7);
-	*size = lsz * sets * ways;
-	*lsize = lsz;
-}
-
-static inline void dcache_probe(uint32 config1, uint *size, uint *lsize)
-{
-	uint lsz, sets, ways;
-
-	/* Data Cache Size = Associativity * Line Size * Sets Per Way */
-	if ((lsz = ((config1 >> 10) & 7)))
-		lsz = 2 << lsz;
-	sets = 64 << ((config1 >> 13) & 7);
-	ways = 1 + ((config1 >> 7) & 7);
-	*size = lsz * sets * ways;
-	*lsize = lsz;
-}
-
-#define cache_unroll(base,op)	        	\
-	__asm__ __volatile__("	         	\
-		.set noreorder;		        \
-		.set mips3;		        \
-                cache %1, (%0);	                \
-		.set mips0;			\
-		.set reorder"			\
-		:				\
-		: "r" (base),			\
-		  "i" (op));
-
-#endif /* !_LANGUAGE_ASSEMBLY */
+#endif	/* !Index_Invalidate_I */
 
 
 /*
  * R4x00 interrupt enable / cause bits
  */
-#undef IE_SW0
-#undef IE_SW1
-#undef IE_IRQ0
-#undef IE_IRQ1
-#undef IE_IRQ2
-#undef IE_IRQ3
-#undef IE_IRQ4
-#undef IE_IRQ5
-#define IE_SW0		(1<< 8)
-#define IE_SW1		(1<< 9)
-#define IE_IRQ0		(1<<10)
-#define IE_IRQ1		(1<<11)
-#define IE_IRQ2		(1<<12)
-#define IE_IRQ3		(1<<13)
-#define IE_IRQ4		(1<<14)
-#define IE_IRQ5		(1<<15)
+#define IE_SW0			(_ULCAST_(1) <<  8)
+#define IE_SW1			(_ULCAST_(1) <<  9)
+#define IE_IRQ0			(_ULCAST_(1) << 10)
+#define IE_IRQ1			(_ULCAST_(1) << 11)
+#define IE_IRQ2			(_ULCAST_(1) << 12)
+#define IE_IRQ3			(_ULCAST_(1) << 13)
+#define IE_IRQ4			(_ULCAST_(1) << 14)
+#define IE_IRQ5			(_ULCAST_(1) << 15)
 
+#ifndef	ST0_UM
 /*
  * Bitfields in the mips32 cp0 status register
  */
@@ -370,6 +282,7 @@
 #define ST0_CU1			0x20000000
 #define ST0_CU2			0x40000000
 #define ST0_CU3			0x80000000
+#endif	/* !ST0_UM */
 
 
 /*
@@ -379,14 +292,14 @@
 #define C_EXC_SHIFT		2
 #define C_INT			0x0000ff00
 #define C_INT_SHIFT		8
-#define C_SW0			0x00000100
-#define C_SW1			0x00000200
-#define C_IRQ0			0x00000400
-#define C_IRQ1			0x00000800
-#define C_IRQ2			0x00001000
-#define C_IRQ3			0x00002000
-#define C_IRQ4			0x00004000
-#define C_IRQ5			0x00008000
+#define C_SW0			(_ULCAST_(1) <<  8)
+#define C_SW1			(_ULCAST_(1) <<  9)
+#define C_IRQ0			(_ULCAST_(1) << 10)
+#define C_IRQ1			(_ULCAST_(1) << 11)
+#define C_IRQ2			(_ULCAST_(1) << 12)
+#define C_IRQ3			(_ULCAST_(1) << 13)
+#define C_IRQ4			(_ULCAST_(1) << 14)
+#define C_IRQ5			(_ULCAST_(1) << 15)
 #define C_WP			0x00400000
 #define C_IV			0x00800000
 #define C_CE			0x30000000
@@ -428,9 +341,15 @@
 #define CONF_DB				(_ULCAST_(1) <<  4)
 #define CONF_IB				(_ULCAST_(1) <<  5)
 #define CONF_SE				(_ULCAST_(1) << 12)
+#ifndef CONF_BE				    /* duplicate in mipsregs.h */
+#define CONF_BE				(_ULCAST_(1) << 15)
+#endif
 #define CONF_SC				(_ULCAST_(1) << 17)
 #define CONF_AC				(_ULCAST_(1) << 23)
 #define CONF_HALT			(_ULCAST_(1) << 25)
+#ifndef CONF_M				    /* duplicate in mipsregs.h */
+#define CONF_M				(_ULCAST_(1) << 31)
+#endif
 
 
 /*
@@ -476,45 +395,149 @@
 #define PRID_IMP_BCM4710	0x4000
 #define PRID_IMP_BCM3302	0x9000
 #define PRID_IMP_BCM3303	0x9100
-#define	PRID_IMP_BCM3303	0x9100
 
 #define PRID_IMP_UNKNOWN	0xff00
 
 #define       BCM330X(id) \
-	(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) \
-	|| ((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
+		(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == \
+		 (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) || \
+		((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == \
+		 (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
 
 /* Bits in C0_BROADCOM */
 #define	BRCM_PFC_AVAIL		0x20000000	/* PFC is available */
 #define	BRCM_DC_ENABLE		0x40000000	/* Enable Data $ */
 #define	BRCM_IC_ENABLE		0x80000000	/* Enable Instruction $ */
 #define	BRCM_PFC_ENABLE		0x00400000	/* Obsolete? Enable PFC (at least on 4310) */
+#define BRCM_CLF_ENABLE		0x00100000	/* Enable cache line first feature */
 
 /* PreFetch Cache aka Read Ahead Cache */
 
 #define	PFC_CR0		0xff400000	/* control reg 0 */
 #define	PFC_CR1		0xff400004	/* control reg 1 */
 
+/* PFC operations */
+#define PFC_I			0x00000001	/* Enable PFC use for instructions */
+#define PFC_D			0x00000002	/* Enable PFC use for data */
+#define PFC_PFI			0x00000004	/* Enable seq. prefetch for instructions */
+#define PFC_PFD			0x00000008	/* Enable seq. prefetch for data */
+#define PFC_CINV		0x00000010	/* Enable selective (i/d) cacheop flushing */
+#define PFC_NCH			0x00000020	/* Disable flushing based on cacheops */
+#define PFC_DPF			0x00000040	/* Enable directional prefetching */
+#define PFC_FLUSH		0x00000100	/* Flush the PFC */
+#define PFC_BRR			0x40000000	/* Bus error indication */
+#define PFC_PWR			0x80000000	/* Disable power saving (clock gating) */
+
+/* Handy defaults */
+#define PFC_DISABLED		0
+#define PFC_AUTO			0xffffffff	/* auto select the default mode */
+#define PFC_INST		(PFC_I | PFC_PFI | PFC_CINV)
+#define PFC_INST_NOPF		(PFC_I | PFC_CINV)
+#define PFC_DATA		(PFC_D | PFC_PFD | PFC_CINV)
+#define PFC_DATA_NOPF		(PFC_D | PFC_CINV)
+#define PFC_I_AND_D		(PFC_INST | PFC_DATA)
+#define PFC_I_AND_D_NOPF	(PFC_INST_NOPF | PFC_DATA_NOPF)
+
+#ifndef	_LANGUAGE_ASSEMBLY
+
 /* 
- * These are the UART port assignments, expressed as offsets from the base
- * register.  These assignments should hold for any serial port based on
- * a 8250, 16450, or 16550(A).
- */
-
-#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
-#define UART_TX		0	/* Out: Transmit buffer (DLAB=0) */
-#define UART_DLL	0	/* Out: Divisor Latch Low (DLAB=1) */
-#define UART_DLM	1	/* Out: Divisor Latch High (DLAB=1) */
-#define UART_LCR	3	/* Out: Line Control Register */
-#define UART_MCR	4	/* Out: Modem Control Register */
-#define UART_LSR	5	/* In:  Line Status Register */
-#define UART_MSR	6	/* In:  Modem Status Register */
-#define UART_SCR	7	/* I/O: Scratch Register */
-#define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
-#define UART_LCR_WLEN8  0x03	/* Wordlength: 8 bits */
-#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
-#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
-#define UART_LSR_RXRDY	0x01	/* Receiver ready */
+ * Macros to access the system control coprocessor
+ */
 
+#define MFC0(source, sel)					\
+({								\
+	int __res;						\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	.word\t"STR(0x40010000 | ((source) << 11) | (sel))";	\
+	move\t%0, $1;						\
+	.set\tat;						\
+	.set\treorder"						\
+	:"=r" (__res)						\
+	:							\
+	:"$1");							\
+	__res;							\
+})
+
+#define MTC0(source, sel, value)				\
+do {								\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	move\t$1, %z0;						\
+	.word\t"STR(0x40810000 | ((source) << 11) | (sel))";	\
+	.set\tat;						\
+	.set\treorder"						\
+	:							\
+	:"jr" (value)						\
+	:"$1");							\
+} while (0)
+
+#define get_c0_count()						\
+({								\
+	int __res;						\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	mfc0\t%0, $9;						\
+	.set\tat;						\
+	.set\treorder"						\
+	:"=r" (__res));						\
+	__res;							\
+})
+
+static INLINE void icache_probe(uint32 config1, uint *size, uint *lsize)
+{
+	uint lsz, sets, ways;
+
+	/* Instruction Cache Size = Associativity * Line Size * Sets Per Way */
+	if ((lsz = ((config1 & CONF1_IL_MASK) >> CONF1_IL_SHIFT)))
+		lsz = CONF1_IL_BASE << lsz;
+	sets = CONF1_IS_BASE << ((config1 & CONF1_IS_MASK) >> CONF1_IS_SHIFT);
+	ways = CONF1_IA_BASE + ((config1 & CONF1_IA_MASK) >> CONF1_IA_SHIFT);
+	*size = lsz * sets * ways;
+	*lsize = lsz;
+}
+
+static INLINE void dcache_probe(uint32 config1, uint *size, uint *lsize)
+{
+	uint lsz, sets, ways;
+
+	/* Data Cache Size = Associativity * Line Size * Sets Per Way */
+	if ((lsz = ((config1 & CONF1_DL_MASK) >> CONF1_DL_SHIFT)))
+		lsz = CONF1_DL_BASE << lsz;
+	sets = CONF1_DS_BASE << ((config1 & CONF1_DS_MASK) >> CONF1_DS_SHIFT);
+	ways = CONF1_DA_BASE + ((config1 & CONF1_DA_MASK) >> CONF1_DA_SHIFT);
+	*size = lsz * sets * ways;
+	*lsize = lsz;
+}
+
+#define cache_op(base, op)			\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, (%0);			\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#define cache_unroll4(base, delta, op)		\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, 0(%0);		\
+		cache %1, delta(%0);		\
+		cache %1, (2 * delta)(%0);	\
+		cache %1, (3 * delta)(%0);	\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#endif /* !_LANGUAGE_ASSEMBLY */
 
 #endif	/* _MISPINC_H */
--- src/include.1927/osl.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/osl.h	2007-11-19 06:40:31.000000000 +0300
@@ -14,26 +14,38 @@
 #ifndef _osl_h_
 #define _osl_h_
 
-#if defined(linux)
+/* osl handle type forward declaration */
+typedef struct osl_info osl_t;
+typedef struct osl_dmainfo osldma_t;
+
+#define OSL_PKTTAG_SZ	32 /* Size of PktTag */
+
+/* Drivers use PKTFREESETCB to register a callback function when a packet is freed by OSL */
+typedef void (*pktfree_cb_fn_t)(void *ctx, void *pkt, unsigned int status);
+
+#if defined(PCBIOS)
+#include <pcbios_osl.h>
+#elif defined(__IOPOS__)
+#include <iopos_osl.h>
+#elif defined(linux)
 #include <linux_osl.h>
 #elif defined(NDIS)
 #include <ndis_osl.h>
 #elif defined(_CFE_)
 #include <cfe_osl.h>
-#elif defined(_HNDRTE_)
-#include <hndrte_osl.h>
 #elif defined(_MINOSL_)
 #include <min_osl.h>
-#elif PMON
-#include <pmon_osl.h>
 #elif defined(MACOSX)
 #include <macosx_osl.h>
+#elif defined(__NetBSD__)
+#include <bsd_osl.h>
+#elif defined(EFI)
+#include <efi_osl.h>
 #else
 #error "Unsupported OSL requested"
 #endif
 
 /* handy */
-#define	SET_REG(r, mask, val)	W_REG((r), ((R_REG(r) & ~(mask)) | (val)))
-#define	MAXPRIO		7	/* 0-7 */
+#define	SET_REG(osh, r, mask, val)	W_REG((osh), (r), ((R_REG((osh), r) & ~(mask)) | (val)))
 
 #endif	/* _osl_h_ */
--- src/include.1927/pcicfg.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/pcicfg.h	2007-11-19 06:40:31.000000000 +0300
@@ -12,8 +12,8 @@
  * $Id$
  */
 
-#ifndef	_h_pci_
-#define	_h_pci_
+#ifndef	_h_pcicfg_
+#define	_h_pcicfg_
 
 /* The following inside ifndef's so we don't collide with NTDDK.H */
 #ifndef PCI_MAX_BUS
@@ -39,7 +39,7 @@
 #define	PCICFG_BUS_SHIFT	16	/* Bus shift */
 #define	PCICFG_SLOT_SHIFT	11	/* Slot shift */
 #define	PCICFG_FUN_SHIFT	8	/* Function shift */
-#define	PCICFG_OFF_SHIFT	0	/* Bus shift */
+#define	PCICFG_OFF_SHIFT	0	/* Register shift */
 
 #define	PCICFG_BUS_MASK		0xff	/* Bus mask */
 #define	PCICFG_SLOT_MASK	0x1f	/* Slot mask */
@@ -57,6 +57,28 @@
 #define	PCI_CONFIG_FUN(a)	(((a) >> PCICFG_FUN_SHIFT) & PCICFG_FUN_MASK)
 #define	PCI_CONFIG_OFF(a)	(((a) >> PCICFG_OFF_SHIFT) & PCICFG_OFF_MASK)
 
+/* PCIE Config space accessing MACROS */
+
+#define	PCIECFG_BUS_SHIFT	24	/* Bus shift */
+#define	PCIECFG_SLOT_SHIFT	19	/* Slot/Device shift */
+#define	PCIECFG_FUN_SHIFT	16	/* Function shift */
+#define	PCIECFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCIECFG_BUS_MASK	0xff	/* Bus mask */
+#define	PCIECFG_SLOT_MASK	0x1f	/* Slot/Device mask */
+#define	PCIECFG_FUN_MASK	7	/* Function mask */
+#define	PCIECFG_OFF_MASK	0x3ff	/* Register mask */
+
+#define	PCIE_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCIECFG_BUS_MASK) << PCIECFG_BUS_SHIFT)		\
+		 | (((s) & PCIECFG_SLOT_MASK) << PCIECFG_SLOT_SHIFT)	\
+		 | (((f) & PCIECFG_FUN_MASK) << PCIECFG_FUN_SHIFT)	\
+		 | (((o) & PCIECFG_OFF_MASK) << PCIECFG_OFF_SHIFT))
+
+#define	PCIE_CONFIG_BUS(a)	(((a) >> PCIECFG_BUS_SHIFT) & PCIECFG_BUS_MASK)
+#define	PCIE_CONFIG_SLOT(a)	(((a) >> PCIECFG_SLOT_SHIFT) & PCIECFG_SLOT_MASK)
+#define	PCIE_CONFIG_FUN(a)	(((a) >> PCIECFG_FUN_SHIFT) & PCIECFG_FUN_MASK)
+#define	PCIE_CONFIG_OFF(a)	(((a) >> PCIECFG_OFF_SHIFT) & PCIECFG_OFF_MASK)
 
 /* The actual config space */
 
@@ -66,6 +88,19 @@
 
 #define	PCR_RSVDA_MAX		2
 
+/* Bits in PCI bars' flags */
+
+#define	PCIBAR_FLAGS		0xf
+#define	PCIBAR_IO		0x1
+#define	PCIBAR_MEM1M		0x2
+#define	PCIBAR_MEM64		0x4
+#define	PCIBAR_PREFETCH		0x8
+#define	PCIBAR_MEM32_MASK	0xFFFFFF80
+
+/* pci config status reg has a bit to indicate that capability ptr is present */
+
+#define PCI_CAPPTR_PRESENT	0x0010
+
 typedef struct _pci_config_regs {
     unsigned short	vendor;
     unsigned short	device;
@@ -121,11 +156,28 @@
 #define	PCI_CFG_SVID		0x2c
 #define	PCI_CFG_SSID		0x2e
 #define	PCI_CFG_ROMBAR		0x30
+#define PCI_CFG_CAPPTR		0x34
 #define	PCI_CFG_INT		0x3c
 #define	PCI_CFG_PIN		0x3d
 #define	PCI_CFG_MINGNT		0x3e
 #define	PCI_CFG_MAXLAT		0x3f
 
+#ifdef __NetBSD__
+#undef	PCI_CLASS_DISPLAY
+#undef	PCI_CLASS_MEMORY
+#undef	PCI_CLASS_BRIDGE
+#undef	PCI_CLASS_INPUT
+#undef	PCI_CLASS_DOCK
+#endif	/* __NetBSD__ */
+
+#ifdef EFI
+#undef PCI_CLASS_BRIDGE
+#undef PCI_CLASS_OLD
+#undef PCI_CLASS_DISPLAY
+#undef PCI_CLASS_SERIAL
+#undef PCI_CLASS_SATELLITE
+#endif /* EFI */
+
 /* Classes and subclasses */
 
 typedef enum {
@@ -146,7 +198,7 @@
     PCI_CLASS_SATELLITE,
     PCI_CLASS_CRYPT,
     PCI_CLASS_DSP,
-    PCI_CLASS_MAX
+	PCI_CLASS_XOR = 0xfe
 } pci_classes;
 
 typedef enum {
@@ -252,7 +304,7 @@
 } pci_serial_subclasses;
 
 typedef enum {
-    PCI_INTELLIGENT_I2O,
+	PCI_INTELLIGENT_I2O
 } pci_intelligent_subclasses;
 
 typedef enum {
@@ -274,6 +326,11 @@
     PCI_DSP_OTHER = 0x80
 } pci_dsp_subclasses;
 
+typedef enum {
+	PCI_XOR_QDMA,
+	PCI_XOR_OTHER = 0x80
+} pci_xor_subclasses;
+
 /* Header types */
 typedef enum {
 	PCI_HEADER_NORMAL,
@@ -329,7 +386,75 @@
     unsigned char	dev_dep[192];
 } ppb_config_regs;
 
-/* Eveything below is BRCM HND proprietary */
+
+/* PCI CAPABILITY DEFINES */
+#define PCI_CAP_POWERMGMTCAP_ID		0x01
+#define PCI_CAP_MSICAP_ID		0x05
+#define PCI_CAP_PCIECAP_ID		0x10
+
+/* Data structure to define the Message Signalled Interrupt facility 
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_msi {
+	unsigned char capID;
+	unsigned char nextptr;
+	unsigned short msgctrl;
+	unsigned int msgaddr;
+} pciconfig_cap_msi;
+
+/* Data structure to define the Power managment facility
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_pwrmgmt {
+	unsigned char capID;
+	unsigned char nextptr;
+	unsigned short pme_cap;
+	unsigned short pme_sts_ctrl;
+	unsigned char pme_bridge_ext;
+	unsigned char data;
+} pciconfig_cap_pwrmgmt;
+
+#define PME_CAP_PM_STATES (0x1f << 27)	/* Bits 31:27 states that can generate PME */
+#define PME_CSR_OFFSET	    0x4		/* 4-bytes offset */
+#define PME_CSR_PME_EN	  (1 << 8)	/* Bit 8 Enable generating of PME */
+#define PME_CSR_PME_STAT  (1 << 15)	/* Bit 15 PME got asserted */
+
+/* Data structure to define the PCIE capability */
+typedef struct _pciconfig_cap_pcie {
+	unsigned char capID;
+	unsigned char nextptr;
+	unsigned short pcie_cap;
+	unsigned int dev_cap;
+	unsigned short dev_ctrl;
+	unsigned short dev_status;
+	unsigned int link_cap;
+	unsigned short link_ctrl;
+	unsigned short link_status;
+} pciconfig_cap_pcie;
+
+/* PCIE Enhanced CAPABILITY DEFINES */
+#define PCIE_EXTCFG_OFFSET	0x100
+#define PCIE_ADVERRREP_CAPID	0x0001
+#define PCIE_VC_CAPID		0x0002
+#define PCIE_DEVSNUM_CAPID	0x0003
+#define PCIE_PWRBUDGET_CAPID	0x0004
+
+/* Header to define the PCIE specific capabilities in the extended config space */
+typedef struct _pcie_enhanced_caphdr {
+	unsigned short capID;
+	unsigned short cap_ver : 4;
+	unsigned short next_ptr : 12;
+} pcie_enhanced_caphdr;
+
+
+/* Everything below is BRCM HND proprietary */
+
+
+/* Brcm PCI configuration registers */
+#define cap_list	rsvd_a[0]
+#define bar0_window	dev_dep[0x80 - 0x40]
+#define bar1_window	dev_dep[0x84 - 0x40]
+#define sprom_control	dev_dep[0x88 - 0x40]
 
 #define	PCI_BAR0_WIN		0x80	/* backplane addres space accessed by BAR0 */
 #define	PCI_BAR1_WIN		0x84	/* backplane addres space accessed by BAR1 */
@@ -339,13 +464,24 @@
 #define	PCI_INT_MASK		0x94	/* mask of PCI and other cores interrupts */
 #define PCI_TO_SB_MB		0x98	/* signal backplane interrupts */
 #define PCI_BACKPLANE_ADDR	0xA0	/* address an arbitrary location on the system backplane */
-#define PCI_BACKPLANE_DATA	0xA4	/* data at the location specified by above address register */
+#define PCI_BACKPLANE_DATA	0xA4	/* data at the location specified by above address */
 #define	PCI_GPIO_IN		0xb0	/* pci config space gpio input (>=rev3) */
 #define	PCI_GPIO_OUT		0xb4	/* pci config space gpio output (>=rev3) */
 #define	PCI_GPIO_OUTEN		0xb8	/* pci config space gpio output enable (>=rev3) */
 
+#define	PCI_BAR0_SHADOW_OFFSET	(2 * 1024)	/* bar0 + 2K accesses sprom shadow (in pci core) */
 #define	PCI_BAR0_SPROM_OFFSET	(4 * 1024)	/* bar0 + 4K accesses external sprom */
 #define	PCI_BAR0_PCIREGS_OFFSET	(6 * 1024)	/* bar0 + 6K accesses pci core registers */
+#define	PCI_BAR0_PCISBR_OFFSET	(4 * 1024)	/* pci core SB registers are at the end of the
+						 * 8KB window, so their address is the "regular"
+						 * address plus 4K
+						 */
+#define PCI_BAR0_WINSZ		(16 * 1024)	/* bar0 window size Match with corerev 13 */
+
+/* On pci corerev >= 13 and all pcie, the bar0 is now 16KB and it maps: */
+#define	PCI_16KB0_PCIREGS_OFFSET (8 * 1024)	/* bar0 + 8K accesses pci/pcie core registers */
+#define	PCI_16KB0_CCREGS_OFFSET	(12 * 1024)	/* bar0 + 12K accesses chipc core registers */
+#define PCI_16KBB0_WINSZ	(16 * 1024)	/* bar0 window size */
 
 /* PCI_INT_STATUS */
 #define	PCI_SBIM_STATUS_SERR	0x4	/* backplane SBErr interrupt status */
@@ -356,9 +492,12 @@
 #define	PCI_SBIM_MASK_SERR	0x4	/* backplane SBErr interrupt mask */
 
 /* PCI_SPROM_CONTROL */
-#define	SPROM_BLANK		0x04  	/* indicating a blank sprom */
-#define SPROM_WRITEEN		0x10	/* sprom write enable */
+#define SPROM_SZ_MSK		0x02	/* SPROM Size Mask */
+#define SPROM_LOCKED		0x08	/* SPROM Locked */
+#define	SPROM_BLANK		0x04	/* indicating a blank SPROM */
+#define SPROM_WRITEEN		0x10	/* SPROM write enable */
 #define SPROM_BOOTROM_WE	0x20	/* external bootrom write enable */
+#define SPROM_OTPIN_USE		0x80	/* device OTP In use */
 
 #define	SPROM_SIZE		256	/* sprom size in 16-bit */
 #define SPROM_CRC_RANGE		64	/* crc cover range in 16-bit */
@@ -366,4 +505,4 @@
 /* PCI_CFG_CMD_STAT */
 #define PCI_CFG_CMD_STAT_TA	0x08000000	/* target abort status */
 
-#endif
+#endif	/* _h_pcicfg_ */
--- src/include.1927/proto/802.11.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/proto/802.11.h	2007-11-19 06:40:31.000000000 +0300
@@ -37,63 +36,68 @@
 #define DOT11_TU_TO_US			1024	/* 802.11 Time Unit is 1024 microseconds */
 
 /* Generic 802.11 frame constants */
-#define DOT11_A3_HDR_LEN		24
-#define DOT11_A4_HDR_LEN		30
-#define DOT11_MAC_HDR_LEN		DOT11_A3_HDR_LEN
-#define DOT11_FCS_LEN			4
-#define DOT11_ICV_LEN			4
-#define DOT11_ICV_AES_LEN		8
-#define DOT11_QOS_LEN			2
-
-#define DOT11_KEY_INDEX_SHIFT		6
-#define DOT11_IV_LEN			4
-#define DOT11_IV_TKIP_LEN		8
-#define DOT11_IV_AES_OCB_LEN		4
-#define DOT11_IV_AES_CCM_LEN		8
+#define DOT11_A3_HDR_LEN		24	/* d11 header length with A3 */
+#define DOT11_A4_HDR_LEN		30	/* d11 header length with A4 */
+#define DOT11_MAC_HDR_LEN		DOT11_A3_HDR_LEN	/* MAC header length */
+#define DOT11_FCS_LEN			4	/* d11 FCS length */
+#define DOT11_ICV_LEN			4	/* d11 ICV length */
+#define DOT11_ICV_AES_LEN		8	/* d11 ICV/AES length */
+#define DOT11_QOS_LEN			2	/* d11 QoS length */
+#define DOT11_HTC_LEN			4	/* d11 HT Control field length */
+
+#define DOT11_KEY_INDEX_SHIFT		6	/* d11 key index shift */
+#define DOT11_IV_LEN			4	/* d11 IV length */
+#define DOT11_IV_TKIP_LEN		8	/* d11 IV TKIP length */
+#define DOT11_IV_AES_OCB_LEN		4	/* d11 IV/AES/OCB length */
+#define DOT11_IV_AES_CCM_LEN		8	/* d11 IV/AES/CCM length */
+#define DOT11_IV_MAX_LEN		8	/* maximum iv len for any encryption */
 
 /* Includes MIC */
-#define DOT11_MAX_MPDU_BODY_LEN		2304
+#define DOT11_MAX_MPDU_BODY_LEN		2304	/* max MPDU body length */
 /* A4 header + QoS + CCMP + PDU + ICV + FCS = 2352 */
 #define DOT11_MAX_MPDU_LEN		(DOT11_A4_HDR_LEN + \
 					 DOT11_QOS_LEN + \
 					 DOT11_IV_AES_CCM_LEN + \
 					 DOT11_MAX_MPDU_BODY_LEN + \
 					 DOT11_ICV_LEN + \
-					 DOT11_FCS_LEN)
+					 DOT11_FCS_LEN)	/* d11 max MPDU length */
 
-#define DOT11_MAX_SSID_LEN		32
+#define DOT11_MAX_SSID_LEN		32	/* d11 max ssid length */
 
 /* dot11RTSThreshold */
-#define DOT11_DEFAULT_RTS_LEN		2347
-#define DOT11_MAX_RTS_LEN		2347
+#define DOT11_DEFAULT_RTS_LEN		2347	/* d11 default RTS length */
+#define DOT11_MAX_RTS_LEN		2347	/* d11 max RTS length */
 
 /* dot11FragmentationThreshold */
-#define DOT11_MIN_FRAG_LEN		256
-#define DOT11_MAX_FRAG_LEN		2346	/* Max frag is also limited by aMPDUMaxLength of the attached PHY */
-#define DOT11_DEFAULT_FRAG_LEN		2346
+#define DOT11_MIN_FRAG_LEN		256	/* d11 min fragmentation length */
+#define DOT11_MAX_FRAG_LEN		2346	/* Max frag is also limited by aMPDUMaxLength
+						* of the attached PHY
+						*/
+#define DOT11_DEFAULT_FRAG_LEN		2346	/* d11 default fragmentation length */
 
 /* dot11BeaconPeriod */
-#define DOT11_MIN_BEACON_PERIOD		1
-#define DOT11_MAX_BEACON_PERIOD		0xFFFF
+#define DOT11_MIN_BEACON_PERIOD		1	/* d11 min beacon period */
+#define DOT11_MAX_BEACON_PERIOD		0xFFFF	/* d11 max beacon period */
 
 /* dot11DTIMPeriod */
-#define DOT11_MIN_DTIM_PERIOD		1
-#define DOT11_MAX_DTIM_PERIOD		0xFF
+#define DOT11_MIN_DTIM_PERIOD		1	/* d11 min DTIM period */
+#define DOT11_MAX_DTIM_PERIOD		0xFF	/* d11 max DTIM period */
 
 /* 802.2 LLC/SNAP header used by 802.11 per 802.1H */
-#define DOT11_LLC_SNAP_HDR_LEN	8
-#define DOT11_OUI_LEN			3
+#define DOT11_LLC_SNAP_HDR_LEN		8	/* d11 LLC/SNAP header length */
+#define DOT11_OUI_LEN			3	/* d11 OUI length */
 struct dot11_llc_snap_header {
 	uint8	dsap;				/* always 0xAA */
 	uint8	ssap;				/* always 0xAA */
 	uint8	ctl;				/* always 0x03 */
 	uint8	oui[DOT11_OUI_LEN];		/* RFC1042: 0x00 0x00 0x00
-						   Bridge-Tunnel: 0x00 0x00 0xF8 */
+						 * Bridge-Tunnel: 0x00 0x00 0xF8
+						 */
 	uint16	type;				/* ethertype */
 } PACKED;
 
 /* RFC1042 header used by 802.11 per 802.1H */
-#define RFC1042_HDR_LEN			(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)
+#define RFC1042_HDR_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)	/* RCF1042 header length */
 
 /* Generic 802.11 MAC header */
 /*
@@ -119,21 +123,21 @@
 	struct ether_addr	ra;		/* receiver address */
 	struct ether_addr	ta;		/* transmitter address */
 } PACKED;
-#define	DOT11_RTS_LEN		16
+#define	DOT11_RTS_LEN		16		/* d11 RTS frame length */
 
 struct dot11_cts_frame {
 	uint16			fc;		/* frame control */
 	uint16			durid;		/* duration/ID */
 	struct ether_addr	ra;		/* receiver address */
 } PACKED;
-#define	DOT11_CTS_LEN		10
+#define	DOT11_CTS_LEN		10		/* d11 CTS frame length */
 
 struct dot11_ack_frame {
 	uint16			fc;		/* frame control */
 	uint16			durid;		/* duration/ID */
 	struct ether_addr	ra;		/* receiver address */
 } PACKED;
-#define	DOT11_ACK_LEN		10
+#define	DOT11_ACK_LEN		10		/* d11 ACK frame length */
 
 struct dot11_ps_poll_frame {
 	uint16			fc;		/* frame control */
@@ -141,7 +145,7 @@
 	struct ether_addr	bssid;		/* receiver address, STA in AP */
 	struct ether_addr	ta;		/* transmitter address */
 } PACKED;
-#define	DOT11_PS_POLL_LEN	16
+#define	DOT11_PS_POLL_LEN	16		/* d11 PS poll frame length */
 
 struct dot11_cf_end_frame {
 	uint16			fc;		/* frame control */
@@ -149,7 +153,47 @@
 	struct ether_addr	ra;		/* receiver address */
 	struct ether_addr	bssid;		/* transmitter address, STA in AP */
 } PACKED;
-#define	DOT11_CS_END_LEN	16
+#define	DOT11_CS_END_LEN	16		/* d11 CF-END frame length */
+
+/* BA/BAR Control parameters */
+#define DOT11_BA_CTL_POLICY_NORMAL	0x0000	/* normal ack */
+#define DOT11_BA_CTL_POLICY_NOACK	0x0001	/* no ack */
+#define DOT11_BA_CTL_POLICY_MASK	0x0001	/* ack policy mask */
+
+#define DOT11_BA_CTL_MTID		0x0002	/* multi tid BA */
+#define DOT11_BA_CTL_COMPRESSED		0x0004	/* compressed bitmap */
+
+#define DOT11_BA_CTL_NUMMSDU_MASK	0x0FC0	/* num msdu in bitmap mask */
+#define DOT11_BA_CTL_NUMMSDU_SHIFT	6	/* num msdu in bitmap shift */
+
+#define DOT11_BA_CTL_TID_MASK		0xF000	/* tid mask */
+#define DOT11_BA_CTL_TID_SHIFT		12	/* tid shift */
+
+/* control frame header (BA/BAR) */
+struct dot11_ctl_header {
+	uint16			fc;		/* frame control */
+	uint16			durid;		/* duration/ID */
+	struct ether_addr	ra;		/* receiver address */
+	struct ether_addr	ta;		/* transmitter address */
+} PACKED;
+#define DOT11_CTL_HDR_LEN	16		/* control frame hdr len */
+
+/* BAR frame payload */
+struct dot11_bar {
+	uint16			bar_control;	/* BAR Control */
+	uint16			seqnum;		/* Starting Sequence control */
+} PACKED;
+#define DOT11_BAR_LEN		4		/* BAR frame payload length */
+
+#define DOT11_BA_BITMAP_LEN	128		/* bitmap length */
+#define DOT11_BA_CMP_BITMAP_LEN	8		/* compressed bitmap length */
+/* BA frame payload */
+struct dot11_ba {
+	uint16			ba_control;	/* BA Control */
+	uint16			seqnum;		/* Starting Sequence control */
+	uint8			bitmap[DOT11_BA_BITMAP_LEN];	/* Block Ack Bitmap */
+} PACKED;
+#define DOT11_BA_LEN		4		/* BA frame payload len (wo bitmap) */
 
 /* Management frame header */
 struct dot11_management_header {
@@ -160,7 +204,7 @@
 	struct ether_addr	bssid;		/* BSS ID */
 	uint16			seq;		/* sequence control */
 } PACKED;
-#define	DOT11_MGMT_HDR_LEN	24
+#define	DOT11_MGMT_HDR_LEN	24		/* d11 management header length */
 
 /* Management frame payloads */
 
@@ -169,19 +213,29 @@
 	uint16			beacon_interval;
 	uint16			capability;
 } PACKED;
-#define	DOT11_BCN_PRB_LEN	12
+#define	DOT11_BCN_PRB_LEN	12		/* 802.11 beacon/probe frame fixed length */
 
 struct dot11_auth {
 	uint16			alg;		/* algorithm */
 	uint16			seq;		/* sequence control */
 	uint16			status;		/* status code */
 } PACKED;
-#define DOT11_AUTH_FIXED_LEN	6		/* length of auth frame without challenge info elt */
+#define DOT11_AUTH_FIXED_LEN	6		/* length of auth frame without challenge info
+						 * elt
+						 */
 
 struct dot11_assoc_req {
 	uint16			capability;	/* capability information */
 	uint16			listen;		/* listen interval */
 } PACKED;
+#define DOT11_ASSOC_REQ_FIXED_LEN	4	/* length of assoc frame without info elts */
+
+struct dot11_reassoc_req {
+	uint16			capability;	/* capability information */
+	uint16			listen;		/* listen interval */
+	struct ether_addr	ap;		/* Current AP address */
+} PACKED;
+#define DOT11_REASSOC_REQ_FIXED_LEN	10	/* length of assoc frame without info elts */
 
 struct dot11_assoc_resp {
 	uint16			capability;	/* capability information */
@@ -195,70 +249,163 @@
 	uint8	token;
 	uint8	data[1];
 } PACKED;
-#define DOT11_ACTION_MEASURE_LEN	3
+#define DOT11_ACTION_MEASURE_LEN	3	/* d11 action measurement header length */
+
+struct dot11_action_ht_ch_width {
+	uint8	category;
+	uint8	action;
+	uint8	ch_width;
+} PACKED;
+
+struct dot11_action_ht_mimops {
+	uint8	category;
+	uint8	action;
+	uint8	control;
+} PACKED;
+
+#define SM_PWRSAVE_ENABLE	1
+#define SM_PWRSAVE_MODE		2
 
-/**************
-  802.11h related definitions.
-**************/
-typedef struct {
+struct dot11_action_ht_info_xchg {
+	uint8	category;
+	uint8	action;
+	uint8	info;
+} PACKED;
+
+#define	DOT11_HT_INFO_XCHG_INFO_REQ		0x01
+#define	DOT11_HT_INFO_XCHG_40MHZ_INTOLERANT	0x02
+#define	DOT11_HT_INFO_XCHG_STA_CHAN_WIDTH	0x04
+
+
+/* ************* 802.11h related definitions. ************* */
+struct dot11_power_cnst {
 	uint8 id;
 	uint8 len;
 	uint8 power;
-} dot11_power_cnst_t;
+} PACKED;
+typedef struct dot11_power_cnst dot11_power_cnst_t;
 
-typedef struct {
+struct dot11_power_cap {
 	uint8 min;
 	uint8 max;
-} dot11_power_cap_t;
+} PACKED;
+typedef struct dot11_power_cap dot11_power_cap_t;
 
-typedef struct {
+struct dot11_tpc_rep {
 	uint8 id;
 	uint8 len;
 	uint8 tx_pwr;
 	uint8 margin;
-} dot11_tpc_rep_t;
+} PACKED;
+typedef struct dot11_tpc_rep dot11_tpc_rep_t;
 #define DOT11_MNG_IE_TPC_REPORT_LEN	2	/* length of IE data, not including 2 byte header */
 
-typedef struct {
+struct dot11_supp_channels {
 	uint8 id;
 	uint8 len;
 	uint8 first_channel;
 	uint8 num_channels;
-} dot11_supp_channels_t;
+} PACKED;
+typedef struct dot11_supp_channels dot11_supp_channels_t;
+
+/* Extension Channel Offset IE: 802.11n-D1.0 spec. added sideband
+ * offset for 40MHz operation.  The possible 3 values are:
+ * 1 = above control channel
+ * 3 = below control channel
+ * 0 = no extension channel
+ */
+struct dot11_extch {
+	uint8	id;		/* IE ID, 62, DOT11_MNG_EXT_CHANNEL_OFFSET */
+	uint8	len;		/* IE length */
+	uint8	extch;
+} PACKED;
+typedef struct dot11_extch dot11_extch_ie_t;
+
+struct dot11_brcm_extch {
+	uint8	id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	uint8	len;		/* IE length */
+	uint8	oui[3];		/* Proprietary OUI, BRCM_OUI */
+	uint8	type;           /* type inidicates what follows */
+	uint8	extch;
+} PACKED;
+typedef struct dot11_brcm_extch dot11_brcm_extch_ie_t;
+
+#define BRCM_EXTCH_IE_LEN	5
+#define BRCM_EXTCH_IE_TYPE	53	/* 802.11n ID not yet assigned */
+#define DOT11_EXTCH_IE_LEN	1
+#define DOT11_EXT_CH_MASK	0x03	/* extension channel mask */
+#define DOT11_EXT_CH_UPPER	0x01	/* ext. ch. on upper sb */
+#define DOT11_EXT_CH_LOWER	0x03	/* ext. ch. on lower sb */
+#define DOT11_EXT_CH_NONE	0x00	/* no extension ch.  */
+
+struct dot11_action_frmhdr {
+	uint8	category;
+	uint8	action;
+	uint8	data[1];
+} PACKED;
 
+/* CSA IE data structure */
 struct dot11_channel_switch {
-	uint8 id;
-	uint8 len;
-	uint8 mode;
-	uint8 channel;
-	uint8 count;
+	uint8 id;	/* id DOT11_MNG_CHANNEL_SWITCH_ID */
+	uint8 len;	/* length of IE */
+	uint8 mode;	/* mode 0 or 1 */
+	uint8 channel;	/* channel switch to */
+	uint8 count;	/* number of beacons before switching */
+} PACKED;
+typedef struct dot11_channel_switch dot11_chan_switch_ie_t;
+
+#define DOT11_SWITCH_IE_LEN	3	/* length of IE data, not including 2 byte header */
+/* CSA mode - 802.11h-2003 $7.3.2.20 */
+#define DOT11_CSA_MODE_ADVISORY		0	/* no DOT11_CSA_MODE_NO_TX restriction imposed */
+#define DOT11_CSA_MODE_NO_TX		1	/* no transmission upon receiving CSA frame. */
+
+struct dot11_action_switch_channel {
+	uint8	category;
+	uint8	action;
+	dot11_chan_switch_ie_t chan_switch_ie;	/* for switch IE */
+	dot11_brcm_extch_ie_t extch_ie;		/* extension channel offset */
+} PACKED;
+
+/* 11n Extended Channel Switch IE data structure */
+struct dot11_ext_csa {
+	uint8 id;	/* id DOT11_MNG_EXT_CHANNEL_SWITCH_ID */
+	uint8 len;	/* length of IE */
+	uint8 mode;	/* mode 0 or 1 */
+	uint8 reg;	/* regulatory class */
+	uint8 channel;	/* channel switch to */
+	uint8 count;	/* number of beacons before switching */
+} PACKED;
+typedef struct dot11_ext_csa dot11_ext_csa_ie_t;
+#define DOT11_EXT_CSA_IE_LEN	4	/* length of extended channel switch IE body */
+
+struct dot11_action_ext_csa {
+	uint8	category;
+	uint8	action;
+	dot11_ext_csa_ie_t chan_switch_ie;	/* for switch IE */
 }  PACKED;
-typedef struct dot11_channel_switch dot11_channel_switch_t;
 
 /* 802.11h Measurement Request/Report IEs */
 /* Measurement Type field */
-#define DOT11_MEASURE_TYPE_BASIC 	0
-#define DOT11_MEASURE_TYPE_CCA 		1
-#define DOT11_MEASURE_TYPE_RPI	 	2
-
-/* Measurement Mode field */
+#define DOT11_MEASURE_TYPE_BASIC 	0	/* d11 measurement basic type */
+#define DOT11_MEASURE_TYPE_CCA 		1	/* d11 measurement CCA type */
+#define DOT11_MEASURE_TYPE_RPI		2	/* d11 measurement PRI type */
 
 /* Measurement Request Modes */
-#define DOT11_MEASURE_MODE_ENABLE 	(1<<1)
-#define DOT11_MEASURE_MODE_REQUEST	(1<<2)
-#define DOT11_MEASURE_MODE_REPORT 	(1<<3)
+#define DOT11_MEASURE_MODE_ENABLE 	(1<<1)	/* d11 measurement enable */
+#define DOT11_MEASURE_MODE_REQUEST	(1<<2)	/* d11 measurement request */
+#define DOT11_MEASURE_MODE_REPORT 	(1<<3)	/* d11 measurement report */
 /* Measurement Report Modes */
-#define DOT11_MEASURE_MODE_LATE 	(1<<0)
-#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)
-#define DOT11_MEASURE_MODE_REFUSED	(1<<2)
+#define DOT11_MEASURE_MODE_LATE 	(1<<0)	/* d11 measurement late */
+#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)	/* d11 measurement incapable */
+#define DOT11_MEASURE_MODE_REFUSED	(1<<2)	/* d11 measurement refuse */
 /* Basic Measurement Map bits */
-#define DOT11_MEASURE_BASIC_MAP_BSS	((uint8)(1<<0))
-#define DOT11_MEASURE_BASIC_MAP_OFDM	((uint8)(1<<1))
-#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((uint8)(1<<2))
-#define DOT11_MEASURE_BASIC_MAP_RADAR	((uint8)(1<<3))
-#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((uint8)(1<<4))
+#define DOT11_MEASURE_BASIC_MAP_BSS	((uint8)(1<<0))	/* d11 measurement basic map BSS */
+#define DOT11_MEASURE_BASIC_MAP_OFDM	((uint8)(1<<1))	/* d11 measurement map OFDM */
+#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((uint8)(1<<2))	/* d11 measurement map unknown */
+#define DOT11_MEASURE_BASIC_MAP_RADAR	((uint8)(1<<3))	/* d11 measurement map radar */
+#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((uint8)(1<<4))	/* d11 measurement map unmeasuremnt */
 
-typedef struct {
+struct dot11_meas_req {
 	uint8 id;
 	uint8 len;
 	uint8 token;
@@ -267,10 +414,11 @@
 	uint8 channel;
 	uint8 start_time[8];
 	uint16 duration;
-} dot11_meas_req_t;
-#define DOT11_MNG_IE_MREQ_LEN 14
+} PACKED;
+typedef struct dot11_meas_req dot11_meas_req_t;
+#define DOT11_MNG_IE_MREQ_LEN 14	/* d11 measurement request IE length */
 /* length of Measure Request IE data not including variable len */
-#define DOT11_MNG_IE_MREQ_FIXED_LEN 3
+#define DOT11_MNG_IE_MREQ_FIXED_LEN 3	/* d11 measurement request IE fixed length */
 
 struct dot11_meas_rep {
 	uint8 id;
@@ -292,7 +440,7 @@
 typedef struct dot11_meas_rep dot11_meas_rep_t;
 
 /* length of Measure Report IE data not including variable len */
-#define DOT11_MNG_IE_MREP_FIXED_LEN	3
+#define DOT11_MNG_IE_MREP_FIXED_LEN	3	/* d11 measurement response IE fixed length */
 
 struct dot11_meas_rep_basic {
 	uint8 channel;
@@ -301,35 +449,37 @@
 	uint8 map;
 } PACKED;
 typedef struct dot11_meas_rep_basic dot11_meas_rep_basic_t;
-#define DOT11_MEASURE_BASIC_REP_LEN	12
+#define DOT11_MEASURE_BASIC_REP_LEN	12	/* d11 measurement basic report length */
 
 struct dot11_quiet {
 	uint8 id;
 	uint8 len;
 	uint8 count;	/* TBTTs until beacon interval in quiet starts */
 	uint8 period;	/* Beacon intervals between periodic quiet periods ? */
-	uint16 duration;/* Length of quiet period, in TU's */
+	uint16 duration;	/* Length of quiet period, in TU's */
 	uint16 offset;	/* TU's offset from TBTT in Count field */
 } PACKED;
 typedef struct dot11_quiet dot11_quiet_t;
 
-typedef struct {
+struct chan_map_tuple {
 	uint8 channel;
 	uint8 map;
-} chan_map_tuple_t;
+} PACKED;
+typedef struct chan_map_tuple chan_map_tuple_t;
 
-typedef struct {
+struct dot11_ibss_dfs {
 	uint8 id;
 	uint8 len;
 	uint8 eaddr[ETHER_ADDR_LEN];
 	uint8 interval;
 	chan_map_tuple_t map[1];
-} dot11_ibss_dfs_t;
+} PACKED;
+typedef struct dot11_ibss_dfs dot11_ibss_dfs_t;
 
 /* WME Elements */
-#define WME_OUI			"\x00\x50\xf2"
-#define WME_VER			1
-#define WME_TYPE		2
+#define WME_OUI			"\x00\x50\xf2"	/* WME OUI */
+#define WME_VER			1	/* WME version */
+#define WME_TYPE		2	/* WME type */
 #define WME_SUBTYPE_IE		0	/* Information Element */
 #define WME_SUBTYPE_PARAM_IE	1	/* Parameter Element */
 #define WME_SUBTYPE_TSPEC	2	/* Traffic Specification */
@@ -339,7 +489,13 @@
 #define AC_BK			1	/* Background */
 #define AC_VI			2	/* Video */
 #define AC_VO			3	/* Voice */
-#define AC_MAX			4
+#define AC_COUNT		4	/* number of ACs */
+
+typedef uint8 ac_bitmap_t;	/* AC bitmap of (1 << AC_xx) */
+
+#define AC_BITMAP_NONE		0x0	/* No ACs */
+#define AC_BITMAP_ALL		0xf	/* All ACs */
+#define AC_BITMAP_TST(ab, ac)	(((ab) & (1 << (ac))) != 0)
 
 /* WME Information Element (IE) */
 struct wme_ie {
@@ -347,114 +503,108 @@
 	uint8 type;
 	uint8 subtype;
 	uint8 version;
-	uint8 acinfo;
+	uint8 qosinfo;
 } PACKED;
 typedef struct wme_ie wme_ie_t;
-#define WME_IE_LEN 7
+#define WME_IE_LEN 7	/* WME IE length */
 
-struct wme_acparam {
+struct edcf_acparam {
 	uint8	ACI;
 	uint8	ECW;
 	uint16  TXOP;		/* stored in network order (ls octet first) */
 } PACKED;
-typedef struct wme_acparam wme_acparam_t;
+typedef struct edcf_acparam edcf_acparam_t;
 
 /* WME Parameter Element (PE) */
-struct wme_params {
+struct wme_param_ie {
 	uint8 oui[3];
 	uint8 type;
 	uint8 subtype;
 	uint8 version;
-	uint8 acinfo;
+	uint8 qosinfo;
 	uint8 rsvd;
-	wme_acparam_t acparam[4];
+	edcf_acparam_t acparam[AC_COUNT];
 } PACKED;
-typedef struct wme_params wme_params_t;
-#define WME_PARAMS_IE_LEN	24
+typedef struct wme_param_ie wme_param_ie_t;
+#define WME_PARAM_IE_LEN            24          /* WME Parameter IE length */
+
+/* QoS Info field for IE as sent from AP */
+#define WME_QI_AP_APSD_MASK         0x80        /* U-APSD Supported mask */
+#define WME_QI_AP_APSD_SHIFT        7           /* U-APSD Supported shift */
+#define WME_QI_AP_COUNT_MASK        0x0f        /* Parameter set count mask */
+#define WME_QI_AP_COUNT_SHIFT       0           /* Parameter set count shift */
+
+/* QoS Info field for IE as sent from STA */
+#define WME_QI_STA_MAXSPLEN_MASK    0x60        /* Max Service Period Length mask */
+#define WME_QI_STA_MAXSPLEN_SHIFT   5           /* Max Service Period Length shift */
+#define WME_QI_STA_APSD_ALL_MASK    0xf         /* APSD all AC bits mask */
+#define WME_QI_STA_APSD_ALL_SHIFT   0           /* APSD all AC bits shift */
+#define WME_QI_STA_APSD_BE_MASK     0x8         /* APSD AC_BE mask */
+#define WME_QI_STA_APSD_BE_SHIFT    3           /* APSD AC_BE shift */
+#define WME_QI_STA_APSD_BK_MASK     0x4         /* APSD AC_BK mask */
+#define WME_QI_STA_APSD_BK_SHIFT    2           /* APSD AC_BK shift */
+#define WME_QI_STA_APSD_VI_MASK     0x2         /* APSD AC_VI mask */
+#define WME_QI_STA_APSD_VI_SHIFT    1           /* APSD AC_VI shift */
+#define WME_QI_STA_APSD_VO_MASK     0x1         /* APSD AC_VO mask */
+#define WME_QI_STA_APSD_VO_SHIFT    0           /* APSD AC_VO shift */
 
-/* acinfo */
-#define WME_COUNT_MASK 	0x0f
 /* ACI */
-#define WME_AIFS_MASK 	0x0f
-#define WME_ACM_MASK 	0x10
-#define WME_ACI_MASK 	0x60
-#define WME_ACI_SHIFT 	5
+#define EDCF_AIFSN_MIN               1           /* AIFSN minimum value */
+#define EDCF_AIFSN_MAX               15          /* AIFSN maximum value */
+#define EDCF_AIFSN_MASK              0x0f        /* AIFSN mask */
+#define EDCF_ACM_MASK                0x10        /* ACM mask */
+#define EDCF_ACI_MASK                0x60        /* ACI mask */
+#define EDCF_ACI_SHIFT               5           /* ACI shift */
+
 /* ECW */
-#define WME_CWMIN_MASK	0x0f
-#define WME_CWMAX_MASK	0xf0
-#define WME_CWMAX_SHIFT	4
-
-#define WME_TXOP_UNITS	32
-
-/* AP: default params to be announced in the Beacon Frames/Probe Responses Table 12 WME Draft*/
-/* AP:  default params to be Used in the AP Side Table 14 WME Draft January 2004 802.11-03-504r5 */
-#define WME_AC_BK_ACI_STA       0x27
-#define WME_AC_BK_ECW_STA       0xA4
-#define WME_AC_BK_TXOP_STA      0x0000
-#define WME_AC_BE_ACI_STA       0x03
-#define WME_AC_BE_ECW_STA       0xA4
-#define WME_AC_BE_TXOP_STA      0x0000
-#define WME_AC_VI_ACI_STA       0x42
-#define WME_AC_VI_ECW_STA       0x43
-#define WME_AC_VI_TXOP_STA      0x005e
-#define WME_AC_VO_ACI_STA       0x62
-#define WME_AC_VO_ECW_STA       0x32
-#define WME_AC_VO_TXOP_STA      0x002f
-                                                                                                             
-#define WME_AC_BK_ACI_AP        0x27
-#define WME_AC_BK_ECW_AP        0xA4
-#define WME_AC_BK_TXOP_AP       0x0000
-#define WME_AC_BE_ACI_AP        0x03
-#define WME_AC_BE_ECW_AP        0x64
-#define WME_AC_BE_TXOP_AP       0x0000
-#define WME_AC_VI_ACI_AP        0x41
-#define WME_AC_VI_ECW_AP        0x43
-#define WME_AC_VI_TXOP_AP       0x005e
-#define WME_AC_VO_ACI_AP        0x61
-#define WME_AC_VO_ECW_AP        0x32
-#define WME_AC_VO_TXOP_AP       0x002f
-
-/* WME Traffic Specification (TSPEC) element */
-#define WME_SUBTYPE_TSPEC 2
-#define WME_TSPEC_HDR_LEN		2
-#define WME_TSPEC_BODY_OFF		2
-struct wme_tspec {
-	uint8 oui[DOT11_OUI_LEN];	/* WME_OUI */
-	uint8 type;			/* WME_TYPE */
-	uint8 subtype;			/* WME_SUBTYPE_TSPEC */
-	uint8 version;			/* WME_VERSION */
-	uint16 ts_info;			/* TS Info */
-	uint16 nom_msdu_size;		/* (Nominal or fixed) MSDU Size (bytes) */
-	uint16 max_msdu_size;		/* Maximum MSDU Size (bytes) */
-	uint32 min_service_interval;	/* Minimum Service Interval (us) */
-	uint32 max_service_interval;	/* Maximum Service Interval (us) */
-	uint32 inactivity_interval;	/* Inactivity Interval (us) */
-	uint32 service_start;		/* Service Start Time (us) */
-	uint32 min_rate;		/* Minimum Data Rate (bps) */
-	uint32 mean_rate;		/* Mean Data Rate (bps) */
-	uint32 max_burst_size;		/* Maximum Burst Size (bytes) */
-	uint32 min_phy_rate;		/* Minimum PHY Rate (bps) */
-	uint32 peak_rate;		/* Peak Data Rate (bps) */
-	uint32 delay_bound;		/* Delay Bound (us) */
-	uint16 surplus_bandwidth;	/* Surplus Bandwidth Allowance Factor */
-	uint16 medium_time;		/* Medium Time (32 us/s periods) */
-} PACKED;
-typedef struct wme_tspec wme_tspec_t;
-#define WME_TSPEC_LEN 56		/* not including 2-byte header */
-
-/* ts_info */
-/* 802.1D priority is duplicated - bits 13-11 AND bits 3-1 */
-#define TS_INFO_PRIO_SHIFT_HI		11
-#define TS_INFO_PRIO_MASK_HI		(0x7 << TS_INFO_PRIO_SHIFT_HI)
-#define TS_INFO_PRIO_SHIFT_LO		1
-#define TS_INFO_PRIO_MASK_LO		(0x7 << TS_INFO_PRIO_SHIFT_LO)
-#define TS_INFO_CONTENTION_SHIFT	7
-#define TS_INFO_CONTENTION_MASK		(0x1 << TS_INFO_CONTENTION_SHIFT)
-#define TS_INFO_DIRECTION_SHIFT		5
-#define TS_INFO_DIRECTION_MASK		(0x3 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_UPLINK			(0 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_DOWNLINK		(1 << TS_INFO_DIRECTION_SHIFT)
-#define TS_INFO_BIDIRECTIONAL		(3 << TS_INFO_DIRECTION_SHIFT)
+#define EDCF_ECW_MIN                 0           /* cwmin/cwmax exponent minimum value */
+#define EDCF_ECW_MAX                 15          /* cwmin/cwmax exponent maximum value */
+#define EDCF_ECW2CW(exp)             ((1 << (exp)) - 1)
+#define EDCF_ECWMIN_MASK             0x0f        /* cwmin exponent form mask */
+#define EDCF_ECWMAX_MASK             0xf0        /* cwmax exponent form mask */
+#define EDCF_ECWMAX_SHIFT            4           /* cwmax exponent form shift */
+
+/* TXOP */
+#define EDCF_TXOP_MIN                0           /* TXOP minimum value */
+#define EDCF_TXOP_MAX                65535       /* TXOP maximum value */
+#define EDCF_TXOP2USEC(txop)         ((txop) << 5)
+
+/* Default EDCF parameters that AP advertises for STA to use; WMM draft Table 12 */
+#define EDCF_AC_BE_ACI_STA           0x03	/* STA ACI value for best effort AC */
+#define EDCF_AC_BE_ECW_STA           0xA4	/* STA ECW value for best effort AC */
+#define EDCF_AC_BE_TXOP_STA          0x0000	/* STA TXOP value for best effort AC */
+#define EDCF_AC_BK_ACI_STA           0x27	/* STA ACI value for background AC */
+#define EDCF_AC_BK_ECW_STA           0xA4	/* STA ECW value for background AC */
+#define EDCF_AC_BK_TXOP_STA          0x0000	/* STA TXOP value for background AC */
+#define EDCF_AC_VI_ACI_STA           0x42	/* STA ACI value for video AC */
+#define EDCF_AC_VI_ECW_STA           0x43	/* STA ECW value for video AC */
+#define EDCF_AC_VI_TXOP_STA          0x005e	/* STA TXOP value for video AC */
+#define EDCF_AC_VO_ACI_STA           0x62	/* STA ACI value for audio AC */
+#define EDCF_AC_VO_ECW_STA           0x32	/* STA ECW value for audio AC */
+#define EDCF_AC_VO_TXOP_STA          0x002f	/* STA TXOP value for audio AC */
+
+/* Default EDCF parameters that AP uses; WMM draft Table 14 */
+#define EDCF_AC_BE_ACI_AP            0x03	/* AP ACI value for best effort AC */
+#define EDCF_AC_BE_ECW_AP            0x64	/* AP ECW value for best effort AC */
+#define EDCF_AC_BE_TXOP_AP           0x0000	/* AP TXOP value for best effort AC */
+#define EDCF_AC_BK_ACI_AP            0x27	/* AP ACI value for background AC */
+#define EDCF_AC_BK_ECW_AP            0xA4	/* AP ECW value for background AC */
+#define EDCF_AC_BK_TXOP_AP           0x0000	/* AP TXOP value for background AC */
+#define EDCF_AC_VI_ACI_AP            0x41	/* AP ACI value for video AC */
+#define EDCF_AC_VI_ECW_AP            0x43	/* AP ECW value for video AC */
+#define EDCF_AC_VI_TXOP_AP           0x005e	/* AP TXOP value for video AC */
+#define EDCF_AC_VO_ACI_AP            0x61	/* AP ACI value for audio AC */
+#define EDCF_AC_VO_ECW_AP            0x32	/* AP ECW value for audio AC */
+#define EDCF_AC_VO_TXOP_AP           0x002f	/* AP TXOP value for audio AC */
+
+struct dot11_qbss_load_ie {
+	uint8 id; 			/* 11, DOT11_MNG_QBSS_LOAD_ID */
+	uint8 length;
+	uint16 station_count; 		/* total number of STAs associated */
+	uint8 channel_utilization;	/* % of time, normalized to 255, QAP sensed medium busy */
+	uint16 aac; 			/* available admission capacity */
+} PACKED;
+typedef struct dot11_qbss_load_ie dot11_qbss_load_ie_t;
 
 /* nom_msdu_size */
 #define FIXED_MSDU_SIZE 0x8000		/* MSDU size is fixed */
@@ -462,8 +612,8 @@
 
 /* surplus_bandwidth */
 /* Represented as 3 bits of integer, binary point, 13 bits fraction */
-#define	INTEGER_SHIFT	13
-#define FRACTION_MASK	0x1FFF
+#define	INTEGER_SHIFT	13	/* integer shift */
+#define FRACTION_MASK	0x1FFF	/* fraction mask */
 
 /* Management Notification Frame */
 struct dot11_management_notification {
@@ -476,323 +626,515 @@
 #define DOT11_MGMT_NOTIFICATION_LEN 4	/* Fixed length */
 
 /* WME Action Codes */
-#define WME_SETUP_REQUEST	0
-#define WME_SETUP_RESPONSE	1
-#define WME_TEARDOWN		2
+#define WME_ADDTS_REQUEST	0	/* WME ADDTS request */
+#define WME_ADDTS_RESPONSE	1	/* WME ADDTS response */
+#define WME_DELTS_REQUEST	2	/* WME DELTS request */
 
 /* WME Setup Response Status Codes */
-#define WME_ADMISSION_ACCEPTED	0
-#define WME_INVALID_PARAMETERS	1
-#define WME_ADMISSION_REFUSED	3
+#define WME_ADMISSION_ACCEPTED	0	/* WME admission accepted */
+#define WME_INVALID_PARAMETERS	1	/* WME invalide parameters */
+#define WME_ADMISSION_REFUSED	3	/* WME admission refused */
 
 /* Macro to take a pointer to a beacon or probe response
- * header and return the char* pointer to the SSID info element
+ * body and return the char* pointer to the SSID info element
  */
-#define BCN_PRB_SSID(hdr) ((char*)(hdr) + DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_LEN)
+#define BCN_PRB_SSID(body) ((char*)(body) + DOT11_BCN_PRB_LEN)
 
 /* Authentication frame payload constants */
-#define DOT11_OPEN_SYSTEM	0
-#define DOT11_SHARED_KEY	1
-#define DOT11_CHALLENGE_LEN	128
+#define DOT11_OPEN_SYSTEM	0	/* d11 open authentication */
+#define DOT11_SHARED_KEY	1	/* d11 shared authentication */
+#define DOT11_CHALLENGE_LEN	128	/* d11 challenge text length */
 
 /* Frame control macros */
-#define FC_PVER_MASK		0x3
-#define FC_PVER_SHIFT		0
-#define FC_TYPE_MASK		0xC
-#define FC_TYPE_SHIFT		2
-#define FC_SUBTYPE_MASK		0xF0
-#define FC_SUBTYPE_SHIFT	4
-#define FC_TODS			0x100
-#define FC_TODS_SHIFT		8
-#define FC_FROMDS		0x200
-#define FC_FROMDS_SHIFT		9
-#define FC_MOREFRAG		0x400
-#define FC_MOREFRAG_SHIFT	10
-#define FC_RETRY		0x800
-#define FC_RETRY_SHIFT		11
-#define FC_PM			0x1000
-#define FC_PM_SHIFT		12
-#define FC_MOREDATA		0x2000
-#define FC_MOREDATA_SHIFT	13
-#define FC_WEP			0x4000
-#define FC_WEP_SHIFT		14
-#define FC_ORDER		0x8000
-#define FC_ORDER_SHIFT		15
+#define FC_PVER_MASK		0x3	/* PVER mask */
+#define FC_PVER_SHIFT		0	/* PVER shift */
+#define FC_TYPE_MASK		0xC	/* type mask */
+#define FC_TYPE_SHIFT		2	/* type shift */
+#define FC_SUBTYPE_MASK		0xF0	/* subtype mask */
+#define FC_SUBTYPE_SHIFT	4	/* subtype shift */
+#define FC_TODS			0x100	/* to DS */
+#define FC_TODS_SHIFT		8	/* to DS shift */
+#define FC_FROMDS		0x200	/* from DS */
+#define FC_FROMDS_SHIFT		9	/* from DS shift */
+#define FC_MOREFRAG		0x400	/* more frag. */
+#define FC_MOREFRAG_SHIFT	10	/* more frag. shift */
+#define FC_RETRY		0x800	/* retry */
+#define FC_RETRY_SHIFT		11	/* retry shift */
+#define FC_PM			0x1000	/* PM */
+#define FC_PM_SHIFT		12	/* PM shift */
+#define FC_MOREDATA		0x2000	/* more data */
+#define FC_MOREDATA_SHIFT	13	/* more data shift */
+#define FC_WEP			0x4000	/* WEP */
+#define FC_WEP_SHIFT		14	/* WEP shift */
+#define FC_ORDER		0x8000	/* order */
+#define FC_ORDER_SHIFT		15	/* order shift */
 
 /* sequence control macros */
-#define SEQNUM_SHIFT		4
-#define FRAGNUM_MASK		0xF
+#define SEQNUM_SHIFT		4	/* seq. number shift */
+#define SEQNUM_MAX		0x1000	/* max seqnum + 1 */
+#define FRAGNUM_MASK		0xF	/* frag. number mask */
 
 /* Frame Control type/subtype defs */
 
 /* FC Types */
-#define FC_TYPE_MNG		0
-#define FC_TYPE_CTL		1
-#define FC_TYPE_DATA		2
+#define FC_TYPE_MNG		0	/* management type */
+#define FC_TYPE_CTL		1	/* control type */
+#define FC_TYPE_DATA		2	/* data type */
 
 /* Management Subtypes */
-#define FC_SUBTYPE_ASSOC_REQ		0
-#define FC_SUBTYPE_ASSOC_RESP		1
-#define FC_SUBTYPE_REASSOC_REQ		2
-#define FC_SUBTYPE_REASSOC_RESP		3
-#define FC_SUBTYPE_PROBE_REQ		4
-#define FC_SUBTYPE_PROBE_RESP		5
-#define FC_SUBTYPE_BEACON		8
-#define FC_SUBTYPE_ATIM			9
-#define FC_SUBTYPE_DISASSOC		10
-#define FC_SUBTYPE_AUTH			11
-#define FC_SUBTYPE_DEAUTH		12
-#define FC_SUBTYPE_ACTION		13
+#define FC_SUBTYPE_ASSOC_REQ		0	/* assoc. request */
+#define FC_SUBTYPE_ASSOC_RESP		1	/* assoc. response */
+#define FC_SUBTYPE_REASSOC_REQ		2	/* reassoc. request */
+#define FC_SUBTYPE_REASSOC_RESP		3	/* reassoc. response */
+#define FC_SUBTYPE_PROBE_REQ		4	/* probe request */
+#define FC_SUBTYPE_PROBE_RESP		5	/* probe response */
+#define FC_SUBTYPE_BEACON		8	/* beacon */
+#define FC_SUBTYPE_ATIM			9	/* ATIM */
+#define FC_SUBTYPE_DISASSOC		10	/* disassoc. */
+#define FC_SUBTYPE_AUTH			11	/* authentication */
+#define FC_SUBTYPE_DEAUTH		12	/* de-authentication */
+#define FC_SUBTYPE_ACTION		13	/* action */
+#define FC_SUBTYPE_ACTION_NOACK		14	/* action no-ack */
 
 /* Control Subtypes */
-#define FC_SUBTYPE_PS_POLL		10
-#define FC_SUBTYPE_RTS			11
-#define FC_SUBTYPE_CTS			12
-#define FC_SUBTYPE_ACK			13
-#define FC_SUBTYPE_CF_END		14
-#define FC_SUBTYPE_CF_END_ACK		15
+#define FC_SUBTYPE_CTL_WRAPPER		7	/* Control Wrapper */
+#define FC_SUBTYPE_BLOCKACK_REQ		8	/* Block Ack Req */
+#define FC_SUBTYPE_BLOCKACK		9	/* Block Ack */
+#define FC_SUBTYPE_PS_POLL		10	/* PS poll */
+#define FC_SUBTYPE_RTS			11	/* RTS */
+#define FC_SUBTYPE_CTS			12	/* CTS */
+#define FC_SUBTYPE_ACK			13	/* ACK */
+#define FC_SUBTYPE_CF_END		14	/* CF-END */
+#define FC_SUBTYPE_CF_END_ACK		15	/* CF-END ACK */
 
 /* Data Subtypes */
-#define FC_SUBTYPE_DATA			0
-#define FC_SUBTYPE_DATA_CF_ACK		1
-#define FC_SUBTYPE_DATA_CF_POLL		2
-#define FC_SUBTYPE_DATA_CF_ACK_POLL	3
-#define FC_SUBTYPE_NULL			4
-#define FC_SUBTYPE_CF_ACK		5
-#define FC_SUBTYPE_CF_POLL		6
-#define FC_SUBTYPE_CF_ACK_POLL		7
-#define FC_SUBTYPE_QOS_DATA		8
-#define FC_SUBTYPE_QOS_NULL		12
-
-/* type-subtype combos */
-#define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)
-
-#define FC_KIND(t, s) (((t) << FC_TYPE_SHIFT) | ((s) << FC_SUBTYPE_SHIFT))
-
-#define FC_ASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)
-#define FC_ASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)
-#define FC_REASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)
-#define FC_REASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)
-#define FC_PROBE_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)
-#define FC_PROBE_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)
-#define FC_BEACON	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)
-#define FC_DISASSOC	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)
-#define FC_AUTH		FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)
-#define FC_DEAUTH	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)
-#define FC_ACTION	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)
-
-#define FC_PS_POLL	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)
-#define FC_RTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)
-#define FC_CTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)
-#define FC_ACK		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)
-#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)
-#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)
-
-#define FC_DATA		FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)
-#define FC_NULL_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)
-#define FC_DATA_CF_ACK	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)
-#define FC_QOS_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)
-#define FC_QOS_NULL	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)
+#define FC_SUBTYPE_DATA			0	/* Data */
+#define FC_SUBTYPE_DATA_CF_ACK		1	/* Data + CF-ACK */
+#define FC_SUBTYPE_DATA_CF_POLL		2	/* Data + CF-Poll */
+#define FC_SUBTYPE_DATA_CF_ACK_POLL	3	/* Data + CF-Ack + CF-Poll */
+#define FC_SUBTYPE_NULL			4	/* Null */
+#define FC_SUBTYPE_CF_ACK		5	/* CF-Ack */
+#define FC_SUBTYPE_CF_POLL		6	/* CF-Poll */
+#define FC_SUBTYPE_CF_ACK_POLL		7	/* CF-Ack + CF-Poll */
+#define FC_SUBTYPE_QOS_DATA		8	/* QoS Data */
+#define FC_SUBTYPE_QOS_DATA_CF_ACK	9	/* QoS Data + CF-Ack */
+#define FC_SUBTYPE_QOS_DATA_CF_POLL	10	/* QoS Data + CF-Poll */
+#define FC_SUBTYPE_QOS_DATA_CF_ACK_POLL	11	/* QoS Data + CF-Ack + CF-Poll */
+#define FC_SUBTYPE_QOS_NULL		12	/* QoS Null */
+#define FC_SUBTYPE_QOS_CF_POLL		14	/* QoS CF-Poll */
+#define FC_SUBTYPE_QOS_CF_ACK_POLL	15	/* QoS CF-Ack + CF-Poll */
+
+/* Data Subtype Groups */
+#define FC_SUBTYPE_ANY_QOS(s)		(((s) & 8) != 0)
+#define FC_SUBTYPE_ANY_NULL(s)		(((s) & 4) != 0)
+#define FC_SUBTYPE_ANY_CF_POLL(s)	(((s) & 2) != 0)
+#define FC_SUBTYPE_ANY_CF_ACK(s)	(((s) & 1) != 0)
+
+/* Type/Subtype Combos */
+#define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)	/* FC kind mask */
+
+#define FC_KIND(t, s)	(((t) << FC_TYPE_SHIFT) | ((s) << FC_SUBTYPE_SHIFT))	/* FC kind */
+
+#define FC_SUBTYPE(fc)	(((fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT)	/* Subtype from FC */
+#define FC_TYPE(fc)	(((fc) & FC_TYPE_MASK) >> FC_TYPE_SHIFT)	/* Type from FC */
+
+#define FC_ASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)	/* assoc. request */
+#define FC_ASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)	/* assoc. response */
+#define FC_REASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)	/* reassoc. request */
+#define FC_REASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)	/* reassoc. response */
+#define FC_PROBE_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)	/* probe request */
+#define FC_PROBE_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)	/* probe response */
+#define FC_BEACON	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)		/* beacon */
+#define FC_DISASSOC	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)	/* disassoc */
+#define FC_AUTH		FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)		/* authentication */
+#define FC_DEAUTH	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)		/* deauthentication */
+#define FC_ACTION	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)		/* action */
+#define FC_ACTION_NOACK	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION_NOACK)	/* action no-ack */
+
+#define FC_CTL_WRAPPER	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTL_WRAPPER)	/* Control Wrapper */
+#define FC_BLOCKACK_REQ	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK_REQ)	/* Block Ack Req */
+#define FC_BLOCKACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK)	/* Block Ack */
+#define FC_PS_POLL	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)	/* PS poll */
+#define FC_RTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)		/* RTS */
+#define FC_CTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)		/* CTS */
+#define FC_ACK		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)		/* ACK */
+#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)		/* CF-END */
+#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)	/* CF-END ACK */
+
+#define FC_DATA		FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)		/* data */
+#define FC_NULL_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)		/* null data */
+#define FC_DATA_CF_ACK	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)	/* data CF ACK */
+#define FC_QOS_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)	/* QoS data */
+#define FC_QOS_NULL	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)	/* QoS null */
 
 /* QoS Control Field */
 
-/* 802.1D Tag */
-#define QOS_PRIO_SHIFT		0
-#define QOS_PRIO_MASK		0x0007
-#define QOS_PRIO(qos)		(((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)
-
-/* Ack Policy (0 means Acknowledge) */
-#define QOS_ACK_SHIFT		5
-#define QOS_ACK_MASK		0x0060
-#define QOS_ACK(qos)		(((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)
+/* 802.1D Priority */
+#define QOS_PRIO_SHIFT		0	/* QoS priority shift */
+#define QOS_PRIO_MASK		0x0007	/* QoS priority mask */
+#define QOS_PRIO(qos)		(((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)	/* QoS priority */
+
+/* Traffic Identifier */
+#define QOS_TID_SHIFT		0	/* QoS TID shift */
+#define QOS_TID_MASK		0x000f	/* QoS TID mask */
+#define QOS_TID(qos)		(((qos) & QOS_TID_MASK) >> QOS_TID_SHIFT)	/* QoS TID */
+
+/* End of Service Period (U-APSD) */
+#define QOS_EOSP_SHIFT		4	/* QoS End of Service Period shift */
+#define QOS_EOSP_MASK		0x0010	/* QoS End of Service Period mask */
+#define QOS_EOSP(qos)		(((qos) & QOS_EOSP_MASK) >> QOS_EOSP_SHIFT)	/* Qos EOSP */
+
+/* Ack Policy */
+#define QOS_ACK_NORMAL_ACK	0	/* Normal Ack */
+#define QOS_ACK_NO_ACK		1	/* No Ack (eg mcast) */
+#define QOS_ACK_NO_EXP_ACK	2	/* No Explicit Ack */
+#define QOS_ACK_BLOCK_ACK	3	/* Block Ack */
+#define QOS_ACK_SHIFT		5	/* QoS ACK shift */
+#define QOS_ACK_MASK		0x0060	/* QoS ACK mask */
+#define QOS_ACK(qos)		(((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)	/* QoS ACK */
+
+/* A-MSDU flag */
+#define QOS_AMSDU_SHIFT		7	/* AMSDU shift */
+#define QOS_AMSDU_MASK		0x0080	/* AMSDU mask */
 
 /* Management Frames */
 
 /* Management Frame Constants */
 
 /* Fixed fields */
-#define DOT11_MNG_AUTH_ALGO_LEN		2
-#define DOT11_MNG_AUTH_SEQ_LEN		2
-#define DOT11_MNG_BEACON_INT_LEN	2
-#define DOT11_MNG_CAP_LEN		2
-#define DOT11_MNG_AP_ADDR_LEN		6
-#define DOT11_MNG_LISTEN_INT_LEN	2
-#define DOT11_MNG_REASON_LEN		2
-#define DOT11_MNG_AID_LEN		2
-#define DOT11_MNG_STATUS_LEN		2
-#define DOT11_MNG_TIMESTAMP_LEN		8
+#define DOT11_MNG_AUTH_ALGO_LEN		2	/* d11 management auth. algo. length */
+#define DOT11_MNG_AUTH_SEQ_LEN		2	/* d11 management auth. seq. length */
+#define DOT11_MNG_BEACON_INT_LEN	2	/* d11 management beacon interval length */
+#define DOT11_MNG_CAP_LEN		2	/* d11 management cap. length */
+#define DOT11_MNG_AP_ADDR_LEN		6	/* d11 management AP address length */
+#define DOT11_MNG_LISTEN_INT_LEN	2	/* d11 management listen interval length */
+#define DOT11_MNG_REASON_LEN		2	/* d11 management reason length */
+#define DOT11_MNG_AID_LEN		2	/* d11 management AID length */
+#define DOT11_MNG_STATUS_LEN		2	/* d11 management status length */
+#define DOT11_MNG_TIMESTAMP_LEN		8	/* d11 management timestamp length */
 
 /* DUR/ID field in assoc resp is 0xc000 | AID */
-#define DOT11_AID_MASK			0x3fff
+#define DOT11_AID_MASK			0x3fff	/* d11 AID mask */
 
 /* Reason Codes */
-#define DOT11_RC_RESERVED			0
+#define DOT11_RC_RESERVED		0	/* d11 RC reserved */
 #define DOT11_RC_UNSPECIFIED			1	/* Unspecified reason */
 #define DOT11_RC_AUTH_INVAL			2	/* Previous authentication no longer valid */
-#define DOT11_RC_DEAUTH_LEAVING			3	/* Deauthenticated because sending station is
-							   leaving (or has left) IBSS or ESS */
+#define DOT11_RC_DEAUTH_LEAVING		3	/* Deauthenticated because sending station
+						 * is leaving (or has left) IBSS or ESS
+						 */
 #define DOT11_RC_INACTIVITY			4	/* Disassociated due to inactivity */
 #define DOT11_RC_BUSY				5	/* Disassociated because AP is unable to handle
-							   all currently associated stations */
+						 * all currently associated stations
+						 */
 #define DOT11_RC_INVAL_CLASS_2			6	/* Class 2 frame received from
-							   nonauthenticated station */
+						 * nonauthenticated station
+						 */
 #define DOT11_RC_INVAL_CLASS_3			7	/* Class 3 frame received from
-							   nonassociated station */
+						 *  nonassociated station
+						 */
 #define DOT11_RC_DISASSOC_LEAVING		8	/* Disassociated because sending station is
-							   leaving (or has left) BSS */
-#define DOT11_RC_NOT_AUTH			9	/* Station requesting (re)association is
-							   not authenticated with responding station */
+						 * leaving (or has left) BSS
+						 */
+#define DOT11_RC_NOT_AUTH		9	/* Station requesting (re)association is not
+						 * authenticated with responding station
+						 */
+#define DOT11_RC_BAD_PC			10	/* Unacceptable power capability element */
+#define DOT11_RC_BAD_CHANNELS		11	/* Unacceptable supported channels element */
+/* 12 is unused */
+
+/* 32-39 are QSTA specific reasons added in 11e */
+#define DOT11_RC_UNSPECIFIED_QOS	32	/* unspecified QoS-related reason */
+#define DOT11_RC_INSUFFCIENT_BW		33	/* QAP lacks sufficient bandwidth */
+#define DOT11_RC_EXCESSIVE_FRAMES	34	/* excessive number of frames need ack */
+#define DOT11_RC_TX_OUTSIDE_TXOP	35	/* transmitting outside the limits of txop */
+#define DOT11_RC_LEAVING_QBSS		36	/* QSTA is leaving the QBSS (or restting) */
+#define DOT11_RC_BAD_MECHANISM		37	/* does not want to use the mechanism */
+#define DOT11_RC_SETUP_NEEDED		38	/* mechanism needs a setup */
+#define DOT11_RC_TIMEOUT		39	/* timeout */
+
 #define DOT11_RC_MAX				23	/* Reason codes > 23 are reserved */
 
 /* Status Codes */
-#define DOT11_STATUS_SUCCESS			0	/* Successful */
-#define DOT11_STATUS_FAILURE			1	/* Unspecified failure */
-#define DOT11_STATUS_CAP_MISMATCH		10	/* Cannot support all requested capabilities
-							   in the Capability Information field */
-#define DOT11_STATUS_REASSOC_FAIL		11	/* Reassociation denied due to inability to
-							   confirm that association exists */
-#define DOT11_STATUS_ASSOC_FAIL			12	/* Association denied due to reason outside
-							   the scope of this standard */
-#define DOT11_STATUS_AUTH_MISMATCH		13	/* Responding station does not support the
-							   specified authentication algorithm */
-#define DOT11_STATUS_AUTH_SEQ			14	/* Received an Authentication frame with
-							   authentication transaction sequence number
-							   out of expected sequence */
-#define DOT11_STATUS_AUTH_CHALLENGE_FAIL	15	/* Authentication rejected because of challenge failure */
-#define DOT11_STATUS_AUTH_TIMEOUT		16	/* Authentication rejected due to timeout waiting
-							   for next frame in sequence */
-#define DOT11_STATUS_ASSOC_BUSY_FAIL		17	/* Association denied because AP is unable to
-							   handle additional associated stations */
-#define DOT11_STATUS_ASSOC_RATE_MISMATCH	18	/* Association denied due to requesting station
-							   not supporting all of the data rates in the
-							   BSSBasicRateSet parameter */
-#define DOT11_STATUS_ASSOC_SHORT_REQUIRED	19	/* Association denied due to requesting station
-							   not supporting the Short Preamble option */
-#define DOT11_STATUS_ASSOC_PBCC_REQUIRED	20	/* Association denied due to requesting station
-							   not supporting the PBCC Modulation option */
-#define DOT11_STATUS_ASSOC_AGILITY_REQUIRED	21	/* Association denied due to requesting station
-							   not supporting the Channel Agility option */
-#define DOT11_STATUS_ASSOC_SPECTRUM_REQUIRED	22	/* Association denied because Spectrum Management 
-							   capability is required. */
-#define DOT11_STATUS_ASSOC_BAD_POWER_CAP	23	/* Association denied because the info in the 
-							   Power Cap element is unacceptable. */
-#define DOT11_STATUS_ASSOC_BAD_SUP_CHANNELS	24	/* Association denied because the info in the 
-							   Supported Channel element is unacceptable */
-#define DOT11_STATUS_ASSOC_SHORTSLOT_REQUIRED	25	/* Association denied due to requesting station
-							   not supporting the Short Slot Time option */
-#define DOT11_STATUS_ASSOC_ERPBCC_REQUIRED	26	/* Association denied due to requesting station
-							   not supporting the ER-PBCC Modulation option */
-#define DOT11_STATUS_ASSOC_DSSOFDM_REQUIRED	27	/* Association denied due to requesting station
-							   not supporting the DSS-OFDM option */
+#define DOT11_SC_SUCCESS		0	/* Successful */
+#define DOT11_SC_FAILURE		1	/* Unspecified failure */
+#define DOT11_SC_CAP_MISMATCH		10	/* Cannot support all requested
+						 * capabilities in the Capability
+						 * Information field
+						 */
+#define DOT11_SC_REASSOC_FAIL		11	/* Reassociation denied due to inability
+						 * to confirm that association exists
+						 */
+#define DOT11_SC_ASSOC_FAIL		12	/* Association denied due to reason
+						 * outside the scope of this standard
+						 */
+#define DOT11_SC_AUTH_MISMATCH		13	/* Responding station does not support
+						 * the specified authentication
+						 * algorithm
+						 */
+#define DOT11_SC_AUTH_SEQ		14	/* Received an Authentication frame
+						 * with authentication transaction
+						 * sequence number out of expected
+						 * sequence
+						 */
+#define DOT11_SC_AUTH_CHALLENGE_FAIL	15	/* Authentication rejected because of
+						 * challenge failure
+						 */
+#define DOT11_SC_AUTH_TIMEOUT		16	/* Authentication rejected due to timeout
+						 * waiting for next frame in sequence
+						 */
+#define DOT11_SC_ASSOC_BUSY_FAIL	17	/* Association denied because AP is
+						 * unable to handle additional
+						 * associated stations
+						 */
+#define DOT11_SC_ASSOC_RATE_MISMATCH	18	/* Association denied due to requesting
+						 * station not supporting all of the
+						 * data rates in the BSSBasicRateSet
+						 * parameter
+						 */
+#define DOT11_SC_ASSOC_SHORT_REQUIRED	19	/* Association denied due to requesting
+						 * station not supporting the Short
+						 * Preamble option
+						 */
+#define DOT11_SC_ASSOC_PBCC_REQUIRED	20	/* Association denied due to requesting
+						 * station not supporting the PBCC
+						 * Modulation option
+						 */
+#define DOT11_SC_ASSOC_AGILITY_REQUIRED	21	/* Association denied due to requesting
+						 * station not supporting the Channel
+						 * Agility option
+						 */
+#define DOT11_SC_ASSOC_SPECTRUM_REQUIRED	22	/* Association denied because Spectrum
+							 * Management capability is required.
+							 */
+#define DOT11_SC_ASSOC_BAD_POWER_CAP	23	/* Association denied because the info
+						 * in the Power Cap element is
+						 * unacceptable.
+						 */
+#define DOT11_SC_ASSOC_BAD_SUP_CHANNELS	24	/* Association denied because the info
+						 * in the Supported Channel element is
+						 * unacceptable
+						 */
+#define DOT11_SC_ASSOC_SHORTSLOT_REQUIRED	25	/* Association denied due to requesting
+							 * station not supporting the Short Slot
+							 * Time option
+							 */
+#define DOT11_SC_ASSOC_ERPBCC_REQUIRED	26	/* Association denied due to requesting
+						 * station not supporting the ER-PBCC
+						 * Modulation option
+						 */
+#define DOT11_SC_ASSOC_DSSOFDM_REQUIRED	27	/* Association denied due to requesting
+						 * station not supporting the DSS-OFDM
+						 * option
+						 */
+
+#define	DOT11_SC_DECLINED		37	/* request declined */
+#define	DOT11_SC_INVALID_PARAMS		38	/* One or more params have invalid values */
 
 /* Info Elts, length of INFORMATION portion of Info Elts */
-#define DOT11_MNG_DS_PARAM_LEN			1
-#define DOT11_MNG_IBSS_PARAM_LEN		2
+#define DOT11_MNG_DS_PARAM_LEN			1	/* d11 management DS parameter length */
+#define DOT11_MNG_IBSS_PARAM_LEN		2	/* d11 management IBSS parameter length */
 
 /* TIM Info element has 3 bytes fixed info in INFORMATION field,
- * followed by 1 to 251 bytes of Partial Virtual Bitmap */
-#define DOT11_MNG_TIM_FIXED_LEN			3
-#define DOT11_MNG_TIM_DTIM_COUNT		0
-#define DOT11_MNG_TIM_DTIM_PERIOD		1
-#define DOT11_MNG_TIM_BITMAP_CTL		2
-#define DOT11_MNG_TIM_PVB			3
+ * followed by 1 to 251 bytes of Partial Virtual Bitmap
+ */
+#define DOT11_MNG_TIM_FIXED_LEN			3	/* d11 management TIM fixed length */
+#define DOT11_MNG_TIM_DTIM_COUNT		0	/* d11 management DTIM count */
+#define DOT11_MNG_TIM_DTIM_PERIOD		1	/* d11 management DTIM period */
+#define DOT11_MNG_TIM_BITMAP_CTL		2	/* d11 management TIM BITMAP control  */
+#define DOT11_MNG_TIM_PVB			3	/* d11 management TIM PVB */
 
 /* TLV defines */
-#define TLV_TAG_OFF		0
-#define TLV_LEN_OFF		1
-#define TLV_HDR_LEN		2
-#define TLV_BODY_OFF		2
+#define TLV_TAG_OFF		0	/* tag offset */
+#define TLV_LEN_OFF		1	/* length offset */
+#define TLV_HDR_LEN		2	/* header length */
+#define TLV_BODY_OFF		2	/* body offset */
 
 /* Management Frame Information Element IDs */
-#define DOT11_MNG_SSID_ID			0
-#define DOT11_MNG_RATES_ID			1
-#define DOT11_MNG_FH_PARMS_ID			2
-#define DOT11_MNG_DS_PARMS_ID			3
-#define DOT11_MNG_CF_PARMS_ID			4
-#define DOT11_MNG_TIM_ID			5
-#define DOT11_MNG_IBSS_PARMS_ID			6
-#define DOT11_MNG_COUNTRY_ID			7
-#define DOT11_MNG_HOPPING_PARMS_ID		8
-#define DOT11_MNG_HOPPING_TABLE_ID		9
-#define DOT11_MNG_REQUEST_ID			10
-#define DOT11_MNG_CHALLENGE_ID			16
+#define DOT11_MNG_SSID_ID			0	/* d11 management SSID id */
+#define DOT11_MNG_RATES_ID			1	/* d11 management rates id */
+#define DOT11_MNG_FH_PARMS_ID			2	/* d11 management FH parameter id */
+#define DOT11_MNG_DS_PARMS_ID			3	/* d11 management DS parameter id */
+#define DOT11_MNG_CF_PARMS_ID			4	/* d11 management CF parameter id */
+#define DOT11_MNG_TIM_ID			5	/* d11 management TIM id */
+#define DOT11_MNG_IBSS_PARMS_ID			6	/* d11 management IBSS parameter id */
+#define DOT11_MNG_COUNTRY_ID			7	/* d11 management country id */
+#define DOT11_MNG_HOPPING_PARMS_ID		8	/* d11 management hopping parameter id */
+#define DOT11_MNG_HOPPING_TABLE_ID		9	/* d11 management hopping table id */
+#define DOT11_MNG_REQUEST_ID			10	/* d11 management request id */
+#define DOT11_MNG_QBSS_LOAD_ID 			11	/* d11 management QBSS Load id */
+#define DOT11_MNG_CHALLENGE_ID			16	/* d11 management chanllenge id */
 #define DOT11_MNG_PWR_CONSTRAINT_ID		32    /* 11H PowerConstraint	*/
 #define DOT11_MNG_PWR_CAP_ID			33    /* 11H PowerCapability	*/
 #define DOT11_MNG_TPC_REQUEST_ID 		34    /* 11H TPC Request	*/
 #define DOT11_MNG_TPC_REPORT_ID			35    /* 11H TPC Report		*/
 #define DOT11_MNG_SUPP_CHANNELS_ID		36    /* 11H Supported Channels	*/
-#define DOT11_MNG_CHANNEL_SWITCH_ID		37    /* 11H ChannelSwitch Announcement*/
+#define DOT11_MNG_CHANNEL_SWITCH_ID		37	/* 11H ChannelSwitch Announcement */
 #define DOT11_MNG_MEASURE_REQUEST_ID		38    /* 11H MeasurementRequest	*/
 #define DOT11_MNG_MEASURE_REPORT_ID		39    /* 11H MeasurementReport	*/
 #define DOT11_MNG_QUIET_ID			40    /* 11H Quiet		*/
 #define DOT11_MNG_IBSS_DFS_ID			41    /* 11H IBSS_DFS 		*/
-#define DOT11_MNG_ERP_ID			42
-#define DOT11_MNG_NONERP_ID			47
-#define DOT11_MNG_RSN_ID			48
-#define DOT11_MNG_EXT_RATES_ID			50
-#define DOT11_MNG_WPA_ID			221
-#define DOT11_MNG_PROPR_ID			221
+#define DOT11_MNG_ERP_ID			42	/* d11 management ERP id */
+#define DOT11_MNG_TS_DELAY_ID			43	/* d11 management TS Delay id */
+#define	DOT11_MNG_HT_CAP			45	/* d11 mgmt HT cap id */
+#define DOT11_MNG_NONERP_ID			47	/* d11 management NON-ERP id */
+#define DOT11_MNG_RSN_ID			48	/* d11 management RSN id */
+#define DOT11_MNG_EXT_RATES_ID			50	/* d11 management ext. rates id */
+#define DOT11_MNG_EXT_CSA_ID			60	/* d11 Extended CSA */
+#define	DOT11_MNG_HT_ADD			61	/* d11 mgmt additional HT info */
+#define	DOT11_MNG_EXT_CHANNEL_OFFSET		62	/* d11 mgmt ext channel offset */
+#define	DOT11_MNG_EXT_CAP			127	/* d11 mgmt ext capability */
+#define DOT11_MNG_WPA_ID			221	/* d11 management WPA id */
+#define DOT11_MNG_PROPR_ID			221	/* d11 management proprietary id */
+
+/* Rate element Basic flag and rate mask */
+#define DOT11_RATE_BASIC			0x80	/* flag for a Basic Rate */
+#define DOT11_RATE_MASK				0x7F	/* mask for numeric part of rate */
 
 /* ERP info element bit values */
 #define DOT11_MNG_ERP_LEN			1	/* ERP is currently 1 byte long */
-#define DOT11_MNG_NONERP_PRESENT		0x01	/* NonERP (802.11b) STAs are present in the BSS */
-#define DOT11_MNG_USE_PROTECTION		0x02	/* Use protection mechanisms for ERP-OFDM frames */
-#define DOT11_MNG_BARKER_PREAMBLE		0x04	/* Short Preambles: 0 == allowed, 1 == not allowed */
+#define DOT11_MNG_NONERP_PRESENT		0x01	/* NonERP (802.11b) STAs are present
+							 *in the BSS
+							 */
+#define DOT11_MNG_USE_PROTECTION		0x02	/* Use protection mechanisms for
+							 *ERP-OFDM frames
+							 */
+#define DOT11_MNG_BARKER_PREAMBLE		0x04	/* Short Preambles: 0 == allowed,
+							 * 1 == not allowed
+							 */
+/* TS Delay element offset & size */
+#define DOT11_MGN_TS_DELAY_LEN		4	/* length of TS DELAY IE */
+#define TS_DELAY_FIELD_SIZE			4	/* TS DELAY field size */
 
 /* Capability Information Field */
-#define DOT11_CAP_ESS				0x0001
-#define DOT11_CAP_IBSS				0x0002
-#define DOT11_CAP_POLLABLE			0x0004
-#define DOT11_CAP_POLL_RQ			0x0008
-#define DOT11_CAP_PRIVACY			0x0010
-#define DOT11_CAP_SHORT				0x0020
-#define DOT11_CAP_PBCC				0x0040
-#define DOT11_CAP_AGILITY			0x0080
-#define DOT11_CAP_SPECTRUM			0x0100
-#define DOT11_CAP_SHORTSLOT			0x0400
-#define DOT11_CAP_CCK_OFDM			0x2000
+#define DOT11_CAP_ESS				0x0001	/* d11 cap. ESS */
+#define DOT11_CAP_IBSS				0x0002	/* d11 cap. IBSS */
+#define DOT11_CAP_POLLABLE			0x0004	/* d11 cap. pollable */
+#define DOT11_CAP_POLL_RQ			0x0008	/* d11 cap. poll request */
+#define DOT11_CAP_PRIVACY			0x0010	/* d11 cap. privacy */
+#define DOT11_CAP_SHORT				0x0020	/* d11 cap. short */
+#define DOT11_CAP_PBCC				0x0040	/* d11 cap. PBCC */
+#define DOT11_CAP_AGILITY			0x0080	/* d11 cap. agility */
+#define DOT11_CAP_SPECTRUM			0x0100	/* d11 cap. spectrum */
+#define DOT11_CAP_SHORTSLOT			0x0400	/* d11 cap. shortslot */
+#define DOT11_CAP_CCK_OFDM			0x2000	/* d11 cap. CCK/OFDM */
+
+/* Extended Capability Information Field */
+#define DOT11_EXT_CAP_HT_IE_SUPPORT	0x01	/* support for info xchg action frame */
 
 /* Action Frame Constants */
-#define DOT11_ACTION_CAT_ERR_MASK	0x80
-#define DOT11_ACTION_CAT_SPECT_MNG	0x00
+#define DOT11_ACTION_HDR_LEN		2	/* action frame header length */
+#define DOT11_ACTION_CAT_ERR_MASK	0x80	/* d11 action category error mask */
+#define DOT11_ACTION_CAT_MASK		0x7F	/* d11 action category mask */
+#define DOT11_ACTION_CAT_SPECT_MNG	0x00	/* d11 action category spectrum management */
+#define DOT11_ACTION_CAT_BLOCKACK	0x03	/* d11 action category block ack */
+#define DOT11_ACTION_CAT_HT		0x07	/* d11 action category for HT */
 #define DOT11_ACTION_NOTIFICATION	0x11	/* 17 */
 
-#define DOT11_ACTION_ID_M_REQ		0
-#define DOT11_ACTION_ID_M_REP		1
-#define DOT11_ACTION_ID_TPC_REQ		2
-#define DOT11_ACTION_ID_TPC_REP		3
-#define DOT11_ACTION_ID_CHANNEL_SWITCH	4
+#define DOT11_ACTION_ID_M_REQ		0	/* d11 action measurement request */
+#define DOT11_ACTION_ID_M_REP		1	/* d11 action measurement response */
+#define DOT11_ACTION_ID_TPC_REQ		2	/* d11 action TPC request */
+#define DOT11_ACTION_ID_TPC_REP		3	/* d11 action TPC response */
+#define DOT11_ACTION_ID_CHANNEL_SWITCH	4	/* d11 action channel switch */
+#define DOT11_ACTION_ID_EXT_CSA		5	/* d11 extened CSA for 11n */
+
+/* HT action ids */
+#define DOT11_ACTION_ID_HT_CH_WIDTH	0	/* notify channel width action id */
+#define DOT11_ACTION_ID_HT_MIMO_PS	1	/* mimo ps action id */
+#define DOT11_ACTION_ID_HT_INFO_XCHG	8	/* HT Information Exchange action id */
+
+/* Block Ack action types */
+#define DOT11_BA_ACTION_ADDBA_REQ	0	/* ADDBA Req action frame type */
+#define DOT11_BA_ACTION_ADDBA_RESP	1	/* ADDBA Resp action frame type */
+#define DOT11_BA_ACTION_DELBA		2	/* DELBA action frame type */
+
+/* ADDBA action parameters */
+#define DOT11_ADDBA_PARAM_AMSDU_SUP	0x0001	/* AMSDU supported under BA */
+#define DOT11_ADDBA_PARAM_POLICY_MASK	0x0002	/* policy mask(ack vs delayed) */
+#define DOT11_ADDBA_PARAM_POLICY_SHIFT	1	/* policy shift */
+#define DOT11_ADDBA_PARAM_TID_MASK	0x003c	/* tid mask */
+#define DOT11_ADDBA_PARAM_TID_SHIFT	2	/* tid shift */
+#define DOT11_ADDBA_PARAM_BSIZE_MASK	0xffc0	/* buffer size mask */
+#define DOT11_ADDBA_PARAM_BSIZE_SHIFT	6	/* buffer size shift */
+
+#define DOT11_ADDBA_POLICY_DELAYED	0	/* delayed BA policy */
+#define DOT11_ADDBA_POLICY_IMMEDIATE	1	/* immediate BA policy */
+
+struct dot11_addba_req {
+	uint8 category;				/* category of action frame (3) */
+	uint8 action;				/* action: addba req */
+	uint8 token;				/* identifier */
+	uint16 addba_param_set;			/* parameter set */
+	uint16 timeout;				/* timeout in seconds */
+	uint16 start_seqnum;			/* starting sequence number */
+}PACKED;
+typedef struct dot11_addba_req dot11_addba_req_t;
+#define DOT11_ADDBA_REQ_LEN		9	/* length of addba req frame */
+
+struct dot11_addba_resp {
+	uint8 category;				/* category of action frame (3) */
+	uint8 action;				/* action: addba resp */
+	uint8 token;				/* identifier */
+	uint16 status;				/* status of add request */
+	uint16 addba_param_set;			/* negotiated parameter set */
+	uint16 timeout;				/* negotiated timeout in seconds */
+}PACKED;
+typedef struct dot11_addba_resp dot11_addba_resp_t;
+#define DOT11_ADDBA_RESP_LEN		9	/* length of addba resp frame */
+
+/* DELBA action parameters */
+#define DOT11_DELBA_PARAM_INIT_MASK	0x0800	/* initiator mask */
+#define DOT11_DELBA_PARAM_INIT_SHIFT	11	/* initiator shift */
+#define DOT11_DELBA_PARAM_TID_MASK	0xf000	/* tid mask */
+#define DOT11_DELBA_PARAM_TID_SHIFT	12	/* tid shift */
+
+struct dot11_delba {
+	uint8 category;				/* category of action frame (3) */
+	uint8 action;				/* action: addba req */
+	uint16 delba_param_set;			/* paarmeter set */
+	uint16 reason;				/* reason for dellba */
+}PACKED;
+typedef struct dot11_delba dot11_delba_t;
+#define DOT11_DELBA_LEN			6	/* length of delba frame */
 
 /* MLME Enumerations */
-#define DOT11_BSSTYPE_INFRASTRUCTURE		0
-#define DOT11_BSSTYPE_INDEPENDENT		1
-#define DOT11_BSSTYPE_ANY			2
-#define DOT11_SCANTYPE_ACTIVE			0
-#define DOT11_SCANTYPE_PASSIVE			1
+#define DOT11_BSSTYPE_INFRASTRUCTURE		0	/* d11 infrastructure */
+#define DOT11_BSSTYPE_INDEPENDENT		1	/* d11 independent */
+#define DOT11_BSSTYPE_ANY			2	/* d11 any BSS type */
+#define DOT11_SCANTYPE_ACTIVE			0	/* d11 scan active */
+#define DOT11_SCANTYPE_PASSIVE			1	/* d11 scan passive */
+
+/* 802.11 BRCM "Compromise" Pre N constants */
+#define PREN_PREAMBLE		24	/* green field preamble time */
+#define PREN_MM_EXT		8	/* extra mixed mode preamble time */
+#define PREN_PREAMBLE_EXT	4	/* extra preamble (multiply by unique_streams-1) */
+
+/* 802.11 N PHY constants */
+#define NPHY_RIFS_TIME		2	/* NPHY RIFS time */
 
 /* 802.11 A PHY constants */
-#define APHY_SLOT_TIME		9
-#define APHY_SIFS_TIME		16
-#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))
-#define APHY_PREAMBLE_TIME	16
-#define APHY_SIGNAL_TIME	4
-#define APHY_SYMBOL_TIME	4
-#define APHY_SERVICE_NBITS	16
-#define APHY_TAIL_NBITS		6
-#define	APHY_CWMIN		15
+#define APHY_SLOT_TIME		9	/* APHY slot time */
+#define APHY_SIFS_TIME		16	/* APHY SIFS time */
+#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))	/* APHY DIFS time */
+#define APHY_PREAMBLE_TIME	16	/* APHY preamble time */
+#define APHY_SIGNAL_TIME	4	/* APHY signal time */
+#define APHY_SYMBOL_TIME	4	/* APHY symbol time */
+#define APHY_SERVICE_NBITS	16	/* APHY service nbits */
+#define APHY_TAIL_NBITS		6	/* APHY tail nbits */
+#define	APHY_CWMIN		15	/* APHY cwmin */
 
 /* 802.11 B PHY constants */
-#define BPHY_SLOT_TIME		20
-#define BPHY_SIFS_TIME		10
-#define BPHY_DIFS_TIME		50
-#define BPHY_PLCP_TIME		192
-#define BPHY_PLCP_SHORT_TIME	96
-#define	BPHY_CWMIN		31
+#define BPHY_SLOT_TIME		20	/* BPHY slot time */
+#define BPHY_SIFS_TIME		10	/* BPHY SIFS time */
+#define BPHY_DIFS_TIME		50	/* BPHY DIFS time */
+#define BPHY_PLCP_TIME		192	/* BPHY PLCP time */
+#define BPHY_PLCP_SHORT_TIME	96	/* BPHY PLCP short time */
+#define	BPHY_CWMIN		31	/* BPHY cwmin */
 
 /* 802.11 G constants */
-#define DOT11_OFDM_SIGNAL_EXTENSION	6
+#define DOT11_OFDM_SIGNAL_EXTENSION	6	/* d11 OFDM signal extension */
 
-#define PHY_CWMAX		1023
+#define PHY_CWMAX		1023	/* PHY cwmax */
 
 #define	DOT11_MAXNUMFRAGS	16	/* max # fragments per MSDU */
 
@@ -815,30 +1157,179 @@
 } d11cnt_t;
 
 /* BRCM OUI */
-#define BRCM_OUI		"\x00\x10\x18"
+#define BRCM_OUI		"\x00\x10\x18"	/* Broadcom OUI */
+
+/* OUI for BRCM proprietary IE */
+#define BRCM_PROP_OUI		"\x00\x90\x4C"	/* Broadcom proprietary OUI */
 
 /* BRCM info element */
 struct brcm_ie {
-	uchar	id;		/* 221, DOT11_MNG_PROPR_ID */
-	uchar	len;   
-	uchar 	oui[3];
-	uchar	ver;
-	uchar	assoc;		/*  # of assoc STAs */
-	uchar	flags;		/* misc flags */
+	uint8	id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	uint8	len;		/* IE length */
+	uint8	oui[3];		/* Proprietary OUI, BRCM_OUI */
+	uint8	ver;		/* type/ver of this IE */
+	uint8	assoc;		/* # of assoc STAs */
+	uint8	flags;		/* misc flags */
+	uint8	flags1;		/* misc flags */
+	uint16	amsdu_mtu_pref;	/* preferred A-MSDU MTU */
 } PACKED;
-#define BRCM_IE_LEN		8
 typedef	struct brcm_ie brcm_ie_t;
-#define BRCM_IE_VER		2
-#define BRCM_IE_LEGACY_AES_VER	1
+#define BRCM_IE_LEN		11	/* BRCM IE length */
+#define BRCM_IE_VER		2	/* BRCM IE version */
+#define BRCM_IE_LEGACY_AES_VER	1	/* BRCM IE legacy AES version */
 
 /* brcm_ie flags */
 #define	BRF_ABCAP		0x1	/* afterburner capable */
 #define	BRF_ABRQRD		0x2	/* afterburner requested */
 #define	BRF_LZWDS		0x4	/* lazy wds enabled */
+#define	BRF_BLOCKACK		0x8	/* BlockACK capable */
+#define BRF_ABCOUNTER_MASK	0xf0	/* afterburner wds "state" counter */
+#define BRF_ABCOUNTER_SHIFT	4	/* offset of afterburner wds "state" counter */
+
+/* brcm_ie flags1 */
+#define	BRF1_AMSDU		0x1	/* A-MSDU capable */
+#define	BRF1_DPT		0x2	/* DPT capable */
 
+#define AB_WDS_TIMEOUT_MAX	15	/* afterburner wds Max count indicating not
+					 * locally capable
+					 */
+#define AB_WDS_TIMEOUT_MIN	1	/* afterburner wds, use zero count as indicating
+					 * "downrev"
+					 */
 
-/* OUI for BRCM proprietary IE */
-#define BRCM_PROP_OUI		"\x00\x90\x4C"
+/* EWC definitions */
+#define MCSSET_LEN	16	/* 16-bits per 8-bit set to give 128-bits bitmap of MCS Index */
+#define MAX_MCS_NUM	(128)	/* max mcs number = 128 */
+
+struct ewc_cap_ie {
+	uint16	cap;
+	uint8	params;
+	uint8	supp_mcs[MCSSET_LEN];
+	uint16	ext_htcap;
+	uint32	txbf_cap;
+	uint8	as_cap;
+} PACKED;
+typedef struct ewc_cap_ie ewc_cap_ie_t;
+
+/* CAP IE: EWC 1.0 spec. simply stole a 802.11 IE, we use our prop. IE until this is resolved */
+/* the capability IE is primarily used to convey this nodes abilities */
+struct ewc_prop_cap_ie {
+	uint8	id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	uint8	len;		/* IE length */
+	uint8	oui[3];		/* Proprietary OUI, BRCM_PROP_OUI */
+	uint8	type;           /* type inidicates what follows */
+	ewc_cap_ie_t cap_ie;
+} PACKED;
+typedef struct ewc_prop_cap_ie ewc_prop_cap_ie_t;
+#define EWC_PROP_IE_OVERHEAD	4	/* overhead bytes for prop oui ie */
+#define EWC_CAP_IE_LEN	26	
+#define EWC_CAP_IE_TYPE	51      
+
+#define EWC_CAP_LDPC_CODING	0x0001	/* Support for rx of LDPC coded pkts */
+#define EWC_CAP_40MHZ		0x0002  /* FALSE:20Mhz, TRUE:20/40MHZ supported */
+#define EWC_CAP_MIMO_PS_MASK	0x000C  /* Mimo PS mask */
+#define EWC_CAP_MIMO_PS_SHIFT	0x0002	/* Mimo PS shift */
+#define EWC_CAP_MIMO_PS_OFF	0x0003	/* Mimo PS, no restriction */
+#define EWC_CAP_MIMO_PS_RTS	0x0001	/* Mimo PS, send RTS/CTS around MIMO frames */
+#define EWC_CAP_MIMO_PS_ON	0x0000	/* Mimo PS, MIMO disallowed */
+#define EWC_CAP_GF		0x0010	/* Greenfield preamble support */
+#define EWC_CAP_SHORT_GI_20	0x0020	/* 20MHZ short guard interval support */
+#define EWC_CAP_SHORT_GI_40	0x0040	/* 40Mhz short guard interval support */
+#define EWC_CAP_TX_STBC		0x0080	/* Tx STBC support */
+#define EWC_CAP_RX_STBC_MASK	0x0300	/* Rx STBC mask */
+#define EWC_CAP_RX_STBC_SHIFT	8	/* Rx STBC shift */
+#define EWC_CAP_DELAYED_BA	0x0400	/* delayed BA support */
+#define EWC_CAP_MAX_AMSDU	0x0800	/* Max AMSDU size in bytes , 0=3839, 1=7935 */
+#define EWC_CAP_DSSS_CCK	0x1000	/* DSSS/CCK supported by the BSS */
+#define EWC_CAP_PSMP		0x2000	/* Power Save Multi Poll support */
+#define EWC_CAP_40MHZ_INTOLERANT 0x4000	/* 40MHz Intolerant */
+#define EWC_CAP_LSIG_TXOP	0x8000	/* L-SIG TXOP protection support */
+
+#define EWC_CAP_RX_STBC_NO		0x0	/* no rx STBC support */
+#define EWC_CAP_RX_STBC_ONE_STREAM	0x1	/* rx STBC support of 1 spatial stream */
+#define EWC_CAP_RX_STBC_TWO_STREAM	0x2	/* rx STBC support of 1-2 spatial streams */
+#define EWC_CAP_RX_STBC_THREE_STREAM	0x3	/* rx STBC support of 1-3 spatial streams */
+
+#define EWC_MAX_AMSDU		7935	/* max amsdu size (bytes) per the EWC spec */
+#define EWC_MIN_AMSDU		3835	/* min amsdu size (bytes) per the EWC spec */
+
+#define EWC_PARAMS_RX_FACTOR_MASK	0x03	/* ampdu rcv factor mask */
+#define EWC_PARAMS_DENSITY_MASK		0x1C	/* ampdu density mask */
+#define EWC_PARAMS_DENSITY_SHIFT	2	/* ampdu density shift */
+
+/* EWC/AMPDU specific define */
+#define AMPDU_MAX_MPDU_DENSITY	7	/* max mpdu density; in 1/8 usec units */
+#define AMPDU_MAX_RX_FACTOR	3	/* max rcv ampdu len (64kb) */
+#define AMPDU_RX_FACTOR_BASE	8*1024	/* ampdu factor base for rx len */
+#define AMPDU_DELIMITER_LEN	4	/* length of ampdu delimiter */
+
+struct ewc_add_ie {
+	uint8	ctl_ch;			/* control channel number */
+	uint8	byte1;			/* ext ch,rec. ch. width, RIFS support */
+	uint16	opmode;			/* operation mode */
+	uint16	misc_bits;		/* misc bits */
+	uint8	basic_mcs[MCSSET_LEN];  /* required MCS set */
+} PACKED;
+typedef struct ewc_add_ie ewc_add_ie_t;
+
+/* ADD IE: EWC 1.0 spec. simply stole a 802.11 IE, we use our prop. IE until this is resolved */
+/* the additional IE is primarily used to convey the current BSS configuration */
+struct ewc_prop_add_ie {
+	uint8	id;		/* IE ID, 221, DOT11_MNG_PROPR_ID */
+	uint8	len;		/* IE length */
+	uint8	oui[3];		/* Proprietary OUI, BRCM_PROP_OUI */
+	uint8	type;		/* indicates what follows */
+	ewc_add_ie_t add_ie;
+} PACKED;
+typedef struct ewc_prop_add_ie ewc_prop_add_ie_t;
+
+#define EWC_ADD_IE_LEN	22	
+#define EWC_ADD_IE_TYPE	52	
+
+/* byte1 defn's */
+#define EWC_BW_ANY		0x04	/* set, STA can use 20 or 40MHz */
+#define EWC_RIFS_PERMITTED     	0x08	/* RIFS allowed */
+
+/* opmode defn's */
+#define EWC_OPMODE_MASK	        0x0003	/* protection mode mask */
+#define EWC_OPMODE_SHIFT	0	/* protection mode shift */
+#define EWC_OPMODE_PURE		0x0000	/* protection mode PURE */
+#define EWC_OPMODE_OPTIONAL	0x0001	/* protection mode optional */
+#define EWC_OPMODE_HT20IN40	0x0002	/* protection mode 20MHz HT in 40MHz BSS */
+#define EWC_OPMODE_MIXED	0x0003	/* protection mode Mixed Mode */
+#define EWC_OPMODE_NONGF	0x0004	/* protection mode non-GF */
+#define DOT11N_TXBURST		0x0008	/* Tx burst limit */
+#define DOT11N_OBSS_NONHT	0x0010	/* OBSS Non-HT STA present */
+
+/* misc_bites defn's */
+#define EWC_BASIC_STBC_MCS	0x007f	/* basic STBC MCS */
+#define EWC_DUAL_STBC_PROT	0x0080	/* Dual STBC Protection */
+#define EWC_SECOND_BCN		0x0100	/* Secondary beacon support */
+#define EWC_LSIG_TXOP		0x0200	/* L-SIG TXOP Protection full support */
+#define EWC_PCO_ACTIVE		0x0400	/* PCO active */
+#define EWC_PCO_PHASE		0x0800	/* PCO phase */
+
+/* Tx Burst Limits */
+#define DOT11N_2G_TXBURST_LIMIT	6160	/* 2G band Tx burst limit per 802.11n Draft 1.10 (usec) */
+#define DOT11N_5G_TXBURST_LIMIT	3080	/* 5G band Tx burst limit per 802.11n Draft 1.10 (usec) */
+
+/* Macros for opmode */
+#define GET_EWC_OPMODE(add_ie)		((ltoh16_ua(&add_ie->opmode) & EWC_OPMODE_MASK) \
+					>> EWC_OPMODE_SHIFT)
+#define EWC_MIXEDMODE_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & EWC_OPMODE_MASK) \
+					== EWC_OPMODE_MIXED)	/* mixed mode present */
+#define EWC_HT20_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & EWC_OPMODE_MASK) \
+					== EWC_OPMODE_HT20IN40)	/* 20MHz HT present */
+#define EWC_OPTIONAL_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & EWC_OPMODE_MASK) \
+					== EWC_OPMODE_OPTIONAL)	/* Optional protection present */
+#define EWC_USE_PROTECTION(add_ie)	(EWC_HT20_PRESENT((add_ie)) || \
+					EWC_MIXEDMODE_PRESENT((add_ie))) /* use protection */
+#define EWC_NONGF_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & EWC_OPMODE_NONGF) \
+					== EWC_OPMODE_NONGF)	/* non-GF present */
+#define DOT11N_TXBURST_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_TXBURST) \
+					== DOT11N_TXBURST)	/* Tx Burst present */
+#define DOT11N_OBSS_NONHT_PRESENT(add_ie)	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) \
+					== DOT11N_OBSS_NONHT)	/* OBSS Non-HT present */
 
 /* Vendor IE structure */
 struct vndr_ie {
@@ -846,22 +1337,22 @@
 	uchar len;
 	uchar oui [3];
 	uchar data [1]; 	/* Variable size data */
-}PACKED;
+} PACKED;
 typedef struct vndr_ie vndr_ie_t;
 
 #define VNDR_IE_HDR_LEN		2	/* id + len field */
 #define VNDR_IE_MIN_LEN		3	/* size of the oui field */
-#define VNDR_IE_MAX_LEN		256
+#define VNDR_IE_MAX_LEN		256	/* verdor IE max length */
 
 /* WPA definitions */
-#define WPA_VERSION		1
-#define WPA_OUI			"\x00\x50\xF2"
+#define WPA_VERSION		1	/* WPA version */
+#define WPA_OUI			"\x00\x50\xF2"	/* WPA OUI */
 
-#define WPA2_VERSION		1
-#define WPA2_VERSION_LEN	2
-#define WPA2_OUI		"\x00\x0F\xAC"
+#define WPA2_VERSION		1	/* WPA2 version */
+#define WPA2_VERSION_LEN	2	/* WAP2 version length */
+#define WPA2_OUI		"\x00\x0F\xAC"	/* WPA2 OUI */
 
-#define WPA_OUI_LEN	3
+#define WPA_OUI_LEN	3	/* WPA OUI length */
 
 /* RSN authenticated key managment suite */
 #define RSN_AKM_NONE		0	/* None (IBSS) */
@@ -885,8 +1375,8 @@
 #define TKIP_KEY_SIZE		32	/* size of any TKIP key */
 #define TKIP_MIC_AUTH_TX	16	/* offset to Authenticator MIC TX key */
 #define TKIP_MIC_AUTH_RX	24	/* offset to Authenticator MIC RX key */
-#define TKIP_MIC_SUP_RX		16	/* offset to Supplicant MIC RX key */
-#define TKIP_MIC_SUP_TX		24	/* offset to Supplicant MIC TX key */
+#define TKIP_MIC_SUP_RX		TKIP_MIC_AUTH_TX	/* offset to Supplicant MIC RX key */
+#define TKIP_MIC_SUP_TX		TKIP_MIC_AUTH_RX	/* offset to Supplicant MIC TX key */
 #define AES_KEY_SIZE		16	/* size of AES key */
 
 #undef PACKED
--- src/include.1927/proto/ethernet.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/proto/ethernet.h	2007-11-19 06:40:31.000000000 +0300
@@ -1,6 +1,7 @@
-/*******************************************************************************
- * $Id$
- * Copyright 2004, Broadcom Corporation      
+/*
+ * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
+ *
+ * Copyright 2007, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
@@ -43,7 +45,7 @@
 /*
  * The length of the combined header.
  */
-#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
 
 /*
  * The minimum packet length.
@@ -66,21 +68,24 @@
 #define	ETHER_MAX_DATA		1500
 
 /* ether types */
+#define ETHER_TYPE_MIN		0x0600		/* Anything less than MIN is a length */
 #define	ETHER_TYPE_IP		0x0800		/* IP */
 #define ETHER_TYPE_ARP		0x0806		/* ARP */
 #define ETHER_TYPE_8021Q	0x8100		/* 802.1Q */
 #define	ETHER_TYPE_BRCM		0x886c		/* Broadcom Corp. */
 #define	ETHER_TYPE_802_1X	0x888e		/* 802.1x */
-#define	ETHER_TYPE_802_1X_PREAUTH	0x88c7	/* 802.1x preauthentication*/
+#ifdef BCMWPA2
+#define	ETHER_TYPE_802_1X_PREAUTH 0x88c7	/* 802.1x preauthentication */
+#endif
 
 /* Broadcom subtype follows ethertype;  First 2 bytes are reserved; Next 2 are subtype; */
 #define	ETHER_BRCM_SUBTYPE_LEN	4		/* Broadcom 4 byte subtype */
 #define	ETHER_BRCM_CRAM		0x1		/* Broadcom subtype cram protocol */
 
 /* ether header */
-#define ETHER_DEST_OFFSET	0		/* dest address offset */
-#define ETHER_SRC_OFFSET	6		/* src address offset */
-#define ETHER_TYPE_OFFSET	12		/* ether type offset */
+#define ETHER_DEST_OFFSET	(0 * ETHER_ADDR_LEN)	/* dest address offset */
+#define ETHER_SRC_OFFSET	(1 * ETHER_ADDR_LEN)	/* src address offset */
+#define ETHER_TYPE_OFFSET	(2 * ETHER_ADDR_LEN)	/* ether type offset */
 
 /*
  * A macro to validate a length with
@@ -105,17 +110,29 @@
 struct	ether_addr {
 	uint8 octet[ETHER_ADDR_LEN];
 } PACKED;
-#endif
+#endif	/* !__INCif_etherh Quick and ugly hack for VxWorks */
+
+/*
+ * Takes a pointer, set, test, clear, toggle locally admininistered
+ * address bit in the 48-bit Ethernet address.
+ */
+#define ETHER_SET_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	(((uint8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & 0xd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] ^ 2))
+
+/* Takes a pointer, marks unicast address bit in the MAC address */
+#define ETHER_SET_UNICAST(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & ~1))
 
 /*
  * Takes a pointer, returns true if a 48-bit multicast address
  * (including broadcast, since it is all ones)
  */
-#define ETHER_ISMULTI(ea) (((uint8 *)(ea))[0] & 1)
+#define ETHER_ISMULTI(ea) (((const uint8 *)(ea))[0] & 1)
+
 
 /* compare two ethernet addresses - assumes the pointers can be referenced as shorts */
-#define	ether_cmp(a, b)	( \
-	!(((short*)a)[0] == ((short*)b)[0]) | \
+#define	ether_cmp(a, b)	(!(((short*)a)[0] == ((short*)b)[0]) | \
 	!(((short*)a)[1] == ((short*)b)[1]) | \
 	!(((short*)a)[2] == ((short*)b)[2]))
 
@@ -136,6 +153,7 @@
 			    ((uint8 *)(ea))[5]) == 0xff)
 
 static const struct ether_addr ether_bcast = {{255, 255, 255, 255, 255, 255}};
+static const struct ether_addr ether_null = {{0, 0, 0, 0, 0, 0}};
 
 /*
  * Takes a pointer, returns true if a 48-bit null address (all zeros)
@@ -147,12 +165,6 @@
 			    ((uint8 *)(ea))[4] |		\
 			    ((uint8 *)(ea))[5]) == 0)
 
-/* Differentiated Services Codepoint - upper 6 bits of tos in iphdr */
-#define	DSCP_MASK		0xFC		/* upper 6 bits */
-#define	DSCP_SHIFT		2
-#define	DSCP_WME_PRI_MASK	0xE0		/* upper 3 bits */
-#define	DSCP_WME_PRI_SHIFT	5
-
 #undef PACKED
 #if !defined(__GNUC__)
 #pragma pack()
--- src/include.1927/proto/vlan.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/proto/vlan.h	2007-11-19 06:40:31.000000000 +0300
@@ -30,7 +30,9 @@
 #define VLAN_PRI_MASK		7	/* 3 bits of priority */
 
 #define	VLAN_TAG_LEN		4
-#define	VLAN_TAG_OFFSET		(2 * ETHER_ADDR_LEN)
+#define	VLAN_TAG_OFFSET		(2 * ETHER_ADDR_LEN)	/* offset in Ethernet II packet only */
+
+#define VLAN_TPID		0x8100	/* VLAN ethertype/Tag Protocol ID */
 
 struct ethervlan_header {
 	uint8	ether_dhost[ETHER_ADDR_LEN];
--- src/include.1927/proto/wpa.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/proto/wpa.h	2007-11-19 06:40:31.000000000 +0300
@@ -28,16 +28,14 @@
 
 /* Reason Codes */
 
-/* 10 and 11 are from TGh. */
-#define DOT11_RC_BAD_PC				10	/* Unacceptable power capability element */
-#define DOT11_RC_BAD_CHANNELS			11	/* Unacceptable supported channels element */
-/* 12 is unused */
-/* 13 through 23 taken from P802.11i/D3.0, November 2002 */
+/* 13 through 23 taken from IEEE Std 802.11i-2004 */
 #define DOT11_RC_INVALID_WPA_IE			13	/* Invalid info. element */
 #define DOT11_RC_MIC_FAILURE			14	/* Michael failure */
 #define DOT11_RC_4WH_TIMEOUT			15	/* 4-way handshake timeout */
 #define DOT11_RC_GTK_UPDATE_TIMEOUT		16	/* Group key update timeout */
-#define DOT11_RC_WPA_IE_MISMATCH		17	/* WPA IE in 4-way handshake differs from (re-)assoc. request/probe response */
+#define DOT11_RC_WPA_IE_MISMATCH	17	/* WPA IE in 4-way handshake differs from
+						 * (re-)assoc. request/probe response
+						 */
 #define DOT11_RC_INVALID_MC_CIPHER		18	/* Invalid multicast cipher */
 #define DOT11_RC_INVALID_UC_CIPHER		19	/* Invalid unicast cipher */
 #define DOT11_RC_INVALID_AKMP			20	/* Invalid authenticated key management protocol */
@@ -63,6 +61,7 @@
 #define WPA_IE_FIXED_LEN	8
 #define WPA_IE_TAG_FIXED_LEN	6
 
+#ifdef BCMWPA2
 typedef struct {
 	uint8 tag;	/* TAG */
 	uint8 length;	/* TAG length */
@@ -74,6 +73,7 @@
 #define WPA_RSN_IE_FIXED_LEN	4
 #define WPA_RSN_IE_TAG_FIXED_LEN	2
 typedef uint8 wpa_pmkid_t[WPA2_PMKID_LEN];
+#endif
 
 /* WPA suite/multicast suite */
 typedef struct
@@ -93,6 +93,7 @@
 	wpa_suite_t list[1];
 } PACKED wpa_suite_ucast_t, wpa_suite_auth_key_mgmt_t;
 #define WPA_IE_SUITE_COUNT_LEN	2
+#ifdef BCMWPA2
 typedef struct
 {
 	struct {
@@ -101,6 +102,7 @@
 	} PACKED count;
 	wpa_pmkid_t list[1];
 } PACKED wpa_pmkid_list_t;
+#endif
 
 /* WPA cipher suites */
 #define WPA_CIPHER_NONE		0	/* None */
@@ -121,16 +123,32 @@
 #define WPA_TKIP_CM_DETECT	60	/* multiple MIC failure window (seconds) */
 #define WPA_TKIP_CM_BLOCK	60	/* countermeasures active window (seconds) */
 
+/* RSN IE defines */
+#define RSN_CAP_LEN		2	/* Length of RSN capabilities field (2 octets) */
+
+/* RSN Capabilities defined in 802.11i */
+#define RSN_CAP_PREAUTH			0x0001
+#define RSN_CAP_NOPAIRWISE		0x0002
+#define RSN_CAP_PTK_REPLAY_CNTR_MASK	0x000C
+#define RSN_CAP_PTK_REPLAY_CNTR_SHIFT	2
+#define RSN_CAP_GTK_REPLAY_CNTR_MASK	0x0030
+#define RSN_CAP_GTK_REPLAY_CNTR_SHIFT	4
+#define RSN_CAP_1_REPLAY_CNTR		0
+#define RSN_CAP_2_REPLAY_CNTRS		1
+#define RSN_CAP_4_REPLAY_CNTRS		2
+#define RSN_CAP_16_REPLAY_CNTRS		3
+
 /* WPA capabilities defined in 802.11i */
-#define WPA_CAP_4_REPLAY_CNTRS		2
-#define WPA_CAP_16_REPLAY_CNTRS		3
-#define WPA_CAP_REPLAY_CNTR_SHIFT	2
-#define WPA_CAP_REPLAY_CNTR_MASK	0x000c
+#define WPA_CAP_4_REPLAY_CNTRS		RSN_CAP_4_REPLAY_CNTRS
+#define WPA_CAP_16_REPLAY_CNTRS		RSN_CAP_16_REPLAY_CNTRS
+#define WPA_CAP_REPLAY_CNTR_SHIFT	RSN_CAP_PTK_REPLAY_CNTR_SHIFT
+#define WPA_CAP_REPLAY_CNTR_MASK	RSN_CAP_PTK_REPLAY_CNTR_MASK
 
 /* WPA Specific defines */
-#define WPA_CAP_LEN	2
+#define WPA_CAP_LEN	RSN_CAP_LEN	/* Length of RSN capabilities in RSN IE (2 octets) */
+
+#define	WPA_CAP_WPA2_PREAUTH		RSN_CAP_PREAUTH
 
-#define	WPA_CAP_WPA2_PREAUTH		1
 
 #undef PACKED
 #if !defined(__GNUC__)
--- src/include.1927/sbchipc.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbchipc.h	2007-11-19 06:40:31.000000000 +0300
@@ -44,7 +43,8 @@
 	/* Interrupt control */
 	uint32	intstatus;		/* 0x20 */
 	uint32	intmask;
-	uint32	PAD[2];
+	uint32	chipcontrol;		/* 0x28, rev >= 11 */
+	uint32	chipstatus;		/* 0x2c, rev >= 11 */
 
 	/* Jtag Master */
 	uint32	jtagcmd;		/* 0x30, rev >= 10 */
@@ -61,27 +61,37 @@
 	/* Silicon backplane configuration broadcast control */
 	uint32	broadcastaddress;	/* 0x50 */
 	uint32	broadcastdata;
-	uint32	PAD[2];
 
 	/* gpio - cleared only by power-on-reset */
+	uint32	gpiopullup;		/* 0x58, corerev >= 20 */
+	uint32	gpiopulldown;		/* 0x5c, corerev >= 20 */
 	uint32	gpioin;			/* 0x60 */
 	uint32	gpioout;
 	uint32	gpioouten;
 	uint32	gpiocontrol;
 	uint32	gpiointpolarity;
 	uint32	gpiointmask;
-	uint32	PAD[2];
+
+	/* GPIO events corerev >= 11 */
+	uint32	gpioevent;
+	uint32	gpioeventintmask;
 
 	/* Watchdog timer */
 	uint32	watchdog;		/* 0x80 */
-	uint32	PAD[3];
+
+	/* GPIO events corerev >= 11 */
+	uint32	gpioeventintpolarity;
+
+	/* GPIO based LED powersave registers corerev >= 16 */
+	uint32  gpiotimerval;		/* 0x88 */
+	uint32  gpiotimeroutmask;
 
 	/* clock control */
 	uint32	clockcontrol_n;		/* 0x90 */
 	uint32	clockcontrol_sb;	/* aka m0 */
 	uint32	clockcontrol_pci;	/* aka m1 */
 	uint32	clockcontrol_m2;	/* mii/uart/mipsref */
-	uint32	clockcontrol_mips;	/* aka m3 */
+	uint32	clockcontrol_m3;	/* cpu */
 	uint32	clkdiv;			/* corerev >= 3 */
 	uint32	PAD[2];
 
@@ -109,7 +119,33 @@
 	uint32	prog_waitcount;
 	uint32	flash_config;
 	uint32	flash_waitcount;
-	uint32	PAD[116];
+	uint32	PAD[4];
+
+	/* Enhanced Coexistance Interface (ECI) registers (corerev >= 21) */
+	uint32	eci_output;		/* 0x140 */
+	uint32	eci_control;
+	uint32	eci_inputlo;
+	uint32	eci_inputmi;
+	uint32	eci_inputhi;
+	uint32	eci_inputintpolaritylo;
+	uint32	eci_inputintpolaritymi;
+	uint32	eci_inputintpolarityhi;
+	uint32	eci_intmasklo;
+	uint32	eci_intmaskmi;
+	uint32	eci_intmaskhi;
+	uint32	eci_eventlo;
+	uint32	eci_eventmi;
+	uint32	eci_eventhi;
+	uint32	eci_eventmasklo;
+	uint32	eci_eventmaskmi;
+	uint32	eci_eventmaskhi;
+	uint32	PAD[23];
+
+
+	/* Clock control and hardware workarounds (corerev >= 20) */
+	uint32	clk_ctl_st;		/* 0x1e0 */
+	uint32	hw_war;
+	uint32	PAD[70];
 
 	/* uarts */
 	uint8	uart0data;		/* 0x300 */
@@ -130,18 +166,68 @@
 	uint8	uart1lsr;
 	uint8	uart1msr;
 	uint8	uart1scratch;
+	uint32	PAD[126];
+
+	/* PMU registers (corerev >= 20) */
+	uint32	pmucontrol;		/* 0x600 */
+	uint32	pmucapabilities;
+	uint32	pmustatus;
+	uint32	res_state;
+	uint32	res_pending;
+	uint32	pmutimer;
+	uint32	min_res_mask;
+	uint32	max_res_mask;
+	uint32	res_table_sel;
+	uint32	res_dep_mask;
+	uint32	res_updn_timer;
+	uint32	res_timer;
+	uint32	clkstretch;
+	uint32	pmuwatchdog;
+	uint32	PAD[2];
+	uint32	res_req_timer_sel;
+	uint32	res_req_timer;
+	uint32	res_req_mask;
+	uint32	PAD;
+	uint32	chipcontrol_addr;
+	uint32	chipcontrol_data;
+	uint32	regcontrol_addr;
+	uint32	regcontrol_data;
+	uint32	pllcontrol_addr;
+	uint32	pllcontrol_data;
+	uint32	PAD[102];
+	uint16	otp[512];
 } chipcregs_t;
 
 #endif /* _LANGUAGE_ASSEMBLY */
 
 #define	CC_CHIPID		0
 #define	CC_CAPABILITIES		4
+#define CC_OTPST		0x10
+#define CC_CHIPST		0x2c
 #define	CC_JTAGCMD		0x30
 #define	CC_JTAGIR		0x34
 #define	CC_JTAGDR		0x38
 #define	CC_JTAGCTRL		0x3c
+#define	CC_WATCHDOG		0x80
+#define	CC_CLKC_N		0x90
+#define	CC_CLKC_M0		0x94
+#define	CC_CLKC_M1		0x98
+#define	CC_CLKC_M2		0x9c
+#define	CC_CLKC_M3		0xa0
 #define	CC_CLKDIV		0xa4
-#define	CC_OTP			0x800
+#define	CC_SYS_CLK_CTL		0xc0
+#define	CC_CLK_CTL_ST		SB_CLK_CTL_ST
+#define	PMU_CTL			0x600
+#define	PMU_CAP			0x604
+#define	PMU_ST			0x608
+#define PMU_TIMER		0x614
+#define	PMU_MIN_RES_MASK	0x618
+#define	PMU_MAX_RES_MASK	0x61c
+#define PMU_REG_CONTROL_ADDR	0x658
+#define PMU_REG_CONTROL_DATA	0x65C
+#define PMU_PLL_CONTROL_ADDR 	0x660
+#define PMU_PLL_CONTROL_DATA 	0x664
+#define	CC_OTP			0x800		/* OTP address space */
 
 /* chipid */
 #define	CID_ID_MASK		0x0000ffff		/* Chip Id mask */
@@ -153,19 +239,26 @@
 #define CID_CC_SHIFT		24
 
 /* capabilities */
-#define	CAP_UARTS_MASK		0x00000003		/* Number of uarts */
-#define CAP_MIPSEB		0x00000004		/* MIPS is in big-endian mode */
-#define CAP_UCLKSEL		0x00000018		/* UARTs clock select */
-#define CAP_UINTCLK		0x00000008		/* UARTs are driven by internal divided clock */
-#define CAP_UARTGPIO		0x00000020		/* UARTs own Gpio's 15:12 */
-#define CAP_EXTBUS		0x00000040		/* External bus present */
-#define	CAP_FLASH_MASK		0x00000700		/* Type of flash */
-#define	CAP_PLL_MASK		0x00038000		/* Type of PLL */
-#define CAP_PWR_CTL		0x00040000		/* Power control */
-#define CAP_OTPSIZE		0x00380000		/* OTP Size (0 = none) */
-#define CAP_OTPSIZE_SHIFT	19			/* OTP Size shift */
-#define CAP_JTAGP		0x00400000		/* JTAG Master Present */
-#define CAP_ROM			0x00800000		/* Internal boot rom active */
+#define	CC_CAP_UARTS_MASK	0x00000003	/* Number of uarts */
+#define CC_CAP_MIPSEB		0x00000004	/* MIPS is in big-endian mode */
+#define CC_CAP_UCLKSEL		0x00000018	/* UARTs clock select */
+#define CC_CAP_UINTCLK		0x00000008	/* UARTs are driven by internal divided clock */
+#define CC_CAP_UARTGPIO		0x00000020	/* UARTs own Gpio's 15:12 */
+#define CC_CAP_EXTBUS_MASK	0x000000c0	/* External bus mask */
+#define CC_CAP_EXTBUS_NONE	0x00000000	/* No ExtBus present */
+#define CC_CAP_EXTBUS_FULL	0x00000040	/* ExtBus: PCMCIA, IDE & Prog */
+#define CC_CAP_EXTBUS_PROG	0x00000080	/* ExtBus: ProgIf only */
+#define	CC_CAP_FLASH_MASK	0x00000700	/* Type of flash */
+#define	CC_CAP_PLL_MASK		0x00038000	/* Type of PLL */
+#define CC_CAP_PWR_CTL		0x00040000	/* Power control */
+#define CC_CAP_OTPSIZE		0x00380000	/* OTP Size (0 = none) */
+#define CC_CAP_OTPSIZE_SHIFT	19		/* OTP Size shift */
+#define CC_CAP_OTPSIZE_BASE	5		/* OTP Size base */
+#define CC_CAP_JTAGP		0x00400000	/* JTAG Master Present */
+#define CC_CAP_ROM		0x00800000	/* Internal boot rom active */
+#define CC_CAP_BKPLN64		0x08000000	/* 64-bit backplane */
+#define	CC_CAP_PMU		0x10000000	/* PMU Present, rev >= 20 */
+#define	CC_CAP_ECI		0x20000000	/* ECI Present, rev >= 21 */
 
 /* PLL type */
 #define PLL_NONE		0x00000000
@@ -175,10 +268,74 @@
 #define PLL_TYPE4		0x00008000		/* 48Mhz, 4 dividers */
 #define PLL_TYPE5		0x00018000		/* 25Mhz, 4 dividers */
 #define PLL_TYPE6		0x00028000		/* 100/200 or 120/240 only */
+#define PLL_TYPE7		0x00038000	/* 25Mhz, 4 dividers */
+
+/* ALP clock on pre-PMU chips */
+#define	ALP_CLOCK		20000000
+
+/* HT clock */
+#define	HT_CLOCK		80000000
+
+/* watchdog clock */
+#define WATCHDOG_CLOCK_5354 	32000		/* Hz */
 
 /* corecontrol */
 #define CC_UARTCLKO		0x00000001		/* Drive UART with internal clock */
 #define	CC_SE			0x00000002		/* sync clk out enable (corerev >= 3) */
+#define CC_UARTCLKEN		0x00000008	/* enable UART Clock (corerev > = 21 */
+
+/* chipcontrol */
+#define CHIPCTRL_4321A0_DEFAULT	0x3a4		
+#define CHIPCTRL_4321A1_DEFAULT	0x0a4		
+
+/* Fields in the otpstatus register in rev >= 21 */
+#define OTPS_OL_MASK		0x000000ff
+#define OTPS_OL_MFG		0x00000001	/* manuf row is locked */
+#define OTPS_OL_OR1		0x00000002	/* otp redundancy row 1 is locked */
+#define OTPS_OL_OR2		0x00000004	/* otp redundancy row 2 is locked */
+#define OTPS_OL_GU		0x00000008	/* general use region is locked */
+#define OTPS_GUP_MASK		0x00000f00
+#define OTPS_GUP_SHIFT		8
+#define OTPS_GUP_HW		0x00000100	/* h/w subregion is programmed */
+#define OTPS_GUP_SW		0x00000200	/* s/w subregion is programmed */
+#define OTPS_GUP_CI		0x00000400	/* chipid/pkgopt subregion is programmed */
+#define OTPS_GUP_FUSE		0x00000800	/* fuse subregion is programmed */
+#define OTPS_READY		0x00001000
+#define OTPS_RV(x)		(1 << (16 + (x)))
+
+/* Fields in the otpcontrol register in rev >= 21 */
+#define OTPC_PROGSEL		0x00000001
+#define OTPC_PCOUNT_MASK	0x0000000e
+#define OTPC_PCOUNT_SHIFT	1
+#define OTPC_VSEL_MASK		0x000000f0
+#define OTPC_VSEL_SHIFT		4
+#define OTPC_TMM_MASK		0x00000700
+#define OTPC_TMM_SHIFT		8
+#define OTPC_ODM		0x00000800
+#define OTPC_PROGEN		0x80000000
+
+/* Fields in otpprog in rev >= 21 */
+#define OTPP_COL_MASK		0x000000ff
+#define OTPP_COL_SHIFT		0
+#define OTPP_ROW_MASK		0x0000ff00
+#define OTPP_ROW_SHIFT		8
+#define OTPP_OC_MASK		0x0f000000
+#define OTPP_OC_SHIFT		24
+#define OTPP_READERR		0x10000000
+#define OTPP_VALUE_MASK		0x20000000
+#define OTPP_VALUE_SHIFT	29
+#define OTPP_START_BUSY		0x80000000
+
+/* Opcodes for OTPP_OC field */
+#define OTPPOC_READ		0
+#define OTPPOC_BIT_PROG		1
+#define OTPPOC_VERIFY		3
+#define OTPPOC_INIT		4
+#define OTPPOC_SET		5
+#define OTPPOC_RESET		6
+#define OTPPOC_OCST		7
+#define OTPPOC_ROW_LOCK		8
+#define OTPPOC_PRESCN_TEST	9
 
 /* jtagcmd */
 #define JCMD_START		0x80000000
@@ -219,7 +376,12 @@
 
 /* intstatus/intmask */
 #define	CI_GPIO			0x00000001		/* gpio intr */
-#define	CI_EI			0x00000002		/* ro: ext intr pin (corerev >= 3) */
+#define	CI_EI			0x00000002	/* extif intr (corerev >= 3) */
+#define	CI_TEMP			0x00000004	/* temp. ctrl intr (corerev >= 15) */
+#define	CI_SIRQ			0x00000008	/* serial IRQ intr (corerev >= 15) */
+#define	CI_ECI			0x00000010	/* eci intr (corerev >= 21) */
+#define	CI_PMU			0x00000020	/* pmu intr (corerev >= 21) */
+#define	CI_UART			0x00000040	/* uart intr (corerev >= 21) */
 #define	CI_WDRESET		0x80000000		/* watchdog reset occurred */
 
 /* slow_clk_ctl */
@@ -228,22 +390,44 @@
 #define	SCC_SS_XTAL		0x00000001		/* source of slow clock is crystal */
 #define	SCC_SS_PCI		0x00000002		/* source of slow clock is PCI */
 #define SCC_LF			0x00000200		/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
-#define SCC_LP			0x00000400		/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
-#define SCC_FS			0x00000800		/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
-#define SCC_IP			0x00001000		/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
-#define SCC_XC			0x00002000		/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define SCC_LP			0x00000400	/* LPOPowerDown, 1: LPO is disabled,
+						 * 0: LPO is enabled
+						 */
+#define SCC_FS			0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock,
+						 * 0: power logic control
+						 */
+#define SCC_IP			0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors
+						 * PLL clock disable requests from core
+						 */
+#define SCC_XC			0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't
+						 * disable crystal when appropriate
+						 */
 #define SCC_XP			0x00004000		/* XtalPU (RO), 1/0: crystal running/disabled */
-#define SCC_CD_MASK		0xffff0000		/* ClockDivider mask, SlowClk = 1/(4+divisor) * crystal/PCI clock */
-#define SCC_CD_SHF		16			/* CLockDivider shift */
+#define SCC_CD_MASK		0xffff0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define SCC_CD_SHIFT		16
 
-/* sys_clk_ctl */
+/* system_clk_ctl */
 #define	SYCC_IE			0x00000001		/* ILPen: Enable Idle Low Power */
 #define	SYCC_AE			0x00000002		/* ALPen: Enable Active Low Power */
 #define	SYCC_FP			0x00000004		/* ForcePLLOn */
 #define	SYCC_AR			0x00000008		/* Force ALP (or HT if ALPen is not set */
 #define	SYCC_HR			0x00000010		/* Force HT */
-#define SYCC_CD_MASK		0xffff0000		/* ClockDivider mask, SlowClk = 1/(4+divisor) * crystal/PCI clock */
-#define SYCC_CD_SHF		16			/* CLockDivider shift */
+#define SYCC_CD_MASK		0xffff0000	/* ClkDiv  (ILP = 1/(4 * (divisor + 1)) */
+#define SYCC_CD_SHIFT		16
+
+/* Fields in pmucontrol */
+#define	PCTL_ILP_DIV_MASK	0xffff0000
+#define	PCTL_ILP_DIV_SHIFT	16
+#define PCTL_NOILP_ON_WAIT	0x00000200
+#define	PCTL_HT_REQ_EN		0x00000100
+#define	PCTL_ALP_REQ_EN		0x00000080
+#define	PCTL_XTALFREQ_MASK	0x0000007c
+#define	PCTL_XTALFREQ_SHIFT	2
+#define	PCTL_ILP_DIV_EN		0x00000002
+#define	PCTL_LPO_SEL		0x00000001
+
+/* gpiotimerval */
+#define GPIO_ONTIME_SHIFT	16
 
 /* clockcontrol_n */
 #define	CN_N1_MASK		0x3f			/* n1 control */
@@ -261,12 +515,6 @@
 #define	CC_MC_MASK		0x1f000000		/* mux control */
 #define	CC_MC_SHIFT		24
 
-/* N3M Clock control values for 125Mhz */
-#define	CC_125_N		0x0802			/* Default values for bcm4310 */
-#define	CC_125_M		0x04020009
-#define	CC_125_M25		0x11090009
-#define	CC_125_M33		0x11090005
-
 /* N3M Clock control magic field values */
 #define	CC_F6_2			0x02			/* A factor of 2 in */
 #define	CC_F6_3			0x03			/* 6-bit fields like */
@@ -298,7 +546,12 @@
 #define	SB2MIPS_T6(sb)		(2 * (sb))
 
 /* Common clock base */
-#define	CC_CLOCK_BASE		24000000		/* Half the clock freq */
+#define	CC_CLOCK_BASE1		24000000	/* Half the clock freq */
+#define CC_CLOCK_BASE2		12500000	/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define	CLKC_5350_N		0x0311
+#define	CLKC_5350_M		0x04020009
 
 /* Flash types in the chipcommon capabilities register */
 #define FLASH_NONE		0x000		/* No flash */
@@ -306,23 +559,48 @@
 #define SFLASH_AT		0x200		/* Atmel serial flash */
 #define	PFLASH			0x700		/* Parallel flash */
 
-/* Bits in the config registers */
+/* Bits in the ExtBus config registers */
 #define	CC_CFG_EN		0x0001		/* Enable */
 #define	CC_CFG_EM_MASK		0x000e		/* Extif Mode */
-#define	CC_CFG_EM_ASYNC		0x0002		/*   Async/Parallel flash */
-#define	CC_CFG_EM_SYNC		0x0004		/*   Synchronous */
-#define	CC_CFG_EM_PCMCIA	0x0008		/*   PCMCIA */
-#define	CC_CFG_EM_IDE		0x000a		/*   IDE */
+#define	CC_CFG_EM_ASYNC		0x0000		/*   Async/Parallel flash */
+#define	CC_CFG_EM_SYNC		0x0002		/*   Synchronous */
+#define	CC_CFG_EM_PCMCIA	0x0004		/*   PCMCIA */
+#define	CC_CFG_EM_IDE		0x0006		/*   IDE */
 #define	CC_CFG_DS		0x0010		/* Data size, 0=8bit, 1=16bit */
-#define	CC_CFG_CD_MASK		0x0060		/* Sync: Clock divisor */
-#define	CC_CFG_CE		0x0080		/* Sync: Clock enable */
-#define	CC_CFG_SB		0x0100		/* Sync: Size/Bytestrobe */
+#define	CC_CFG_CD_MASK		0x00e0		/* Sync: Clock divisor, rev >= 20 */
+#define	CC_CFG_CE		0x0100		/* Sync: Clock enable, rev >= 20 */
+#define	CC_CFG_SB		0x0200		/* Sync: Size/Bytestrobe, rev >= 20 */
+#define	CC_CFG_IS		0x0400		/* Extif Sync Clk Select, rev >= 20 */
+
+/* ExtBus address space */
+#define	CC_EB_BASE		0x1a000000	/* Chipc ExtBus base address */
+#define	CC_EB_PCMCIA_MEM	0x1a000000	/* PCMCIA 0 memory base address */
+#define	CC_EB_PCMCIA_IO		0x1a200000	/* PCMCIA 0 I/O base address */
+#define	CC_EB_PCMCIA_CFG	0x1a400000	/* PCMCIA 0 config base address */
+#define	CC_EB_IDE		0x1a800000	/* IDE memory base */
+#define	CC_EB_PCMCIA1_MEM	0x1a800000	/* PCMCIA 1 memory base address */
+#define	CC_EB_PCMCIA1_IO	0x1aa00000	/* PCMCIA 1 I/O base address */
+#define	CC_EB_PCMCIA1_CFG	0x1ac00000	/* PCMCIA 1 config base address */
+#define	CC_EB_PROGIF		0x1b000000	/* ProgIF Async/Sync base address */
+
 
 /* Start/busy bit in flashcontrol */
+#define SFLASH_OPCODE		0x000000ff
+#define SFLASH_ACTION		0x00000700
+#define	SFLASH_CS_ACTIVE	0x00001000	/* Chip Select Active, rev >= 20 */
 #define SFLASH_START		0x80000000
 #define SFLASH_BUSY		SFLASH_START
 
-/* flashcontrol opcodes for ST flashes */
+/* flashcontrol action codes */
+#define	SFLASH_ACT_OPONLY	0x0000		/* Issue opcode only */
+#define	SFLASH_ACT_OP1D		0x0100		/* opcode + 1 data byte */
+#define	SFLASH_ACT_OP3A		0x0200		/* opcode + 3 address bytes */
+#define	SFLASH_ACT_OP3A1D	0x0300		/* opcode + 3 addres & 1 data bytes */
+#define	SFLASH_ACT_OP3A4D	0x0400		/* opcode + 3 addres & 4 data bytes */
+#define	SFLASH_ACT_OP3A4X4D	0x0500		/* opcode + 3 addres, 4 don't care & 4 data bytes */
+#define	SFLASH_ACT_OP3A1X4D	0x0700		/* opcode + 3 addres, 1 don't care & 4 data bytes */
+
+/* flashcontrol action+opcodes for ST flashes */
 #define SFLASH_ST_WREN		0x0006		/* Write Enable */
 #define SFLASH_ST_WRDIS		0x0004		/* Write Disable */
 #define SFLASH_ST_RDSR		0x0105		/* Read Status Register */
@@ -333,6 +611,7 @@
 #define SFLASH_ST_BE		0x00c7		/* Bulk Erase */
 #define SFLASH_ST_DP		0x00b9		/* Deep Power-down */
 #define SFLASH_ST_RES		0x03ab		/* Read Electronic Signature */
+#define SFLASH_ST_CSA		0x1000		/* Keep chip select asserted */
 
 /* Status register bits for ST flashes */
 #define SFLASH_ST_WIP		0x01		/* Write In Progress */
@@ -341,7 +620,7 @@
 #define SFLASH_ST_BP_SHIFT	2
 #define SFLASH_ST_SRWD		0x80		/* Status Register Write Disable */
 
-/* flashcontrol opcodes for Atmel flashes */
+/* flashcontrol action+opcodes for Atmel flashes */
 #define SFLASH_AT_READ				0x07e8
 #define SFLASH_AT_PAGE_READ			0x07d2
 #define SFLASH_AT_BUF1_READ
@@ -370,22 +649,264 @@
 #define SFLASH_AT_ID_MASK			0x38
 #define SFLASH_AT_ID_SHIFT			3
 
-/* OTP conventions */
-#define	OTP_HWBASE	0
-#define	OTP_SWLIM	256
-#define	OTP_CIDBASE	256
-#define	OTP_CIDLIM	260
-
-#define	OTP_BOUNDARY	252
-#define	OTP_HWSIGN	253
-#define	OTP_SWSIGN	254
-#define	OTP_CIDSIGN	255
-
-#define	OTP_CID		256
-#define	OTP_PKG		257
-#define	OTP_FID		258
+/* 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
 
-#define	OTP_SIGNATURE	0x578a
-#define	OTP_MAGIC	0x4e56
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+#define UART_TX		0	/* Out: Transmit buffer (DLAB=0) */
+#define UART_DLL	0	/* Out: Divisor Latch Low (DLAB=1) */
+#define UART_IER	1	/* In/Out: Interrupt Enable Register (DLAB=0) */
+#define UART_DLM	1	/* Out: Divisor Latch High (DLAB=1) */
+#define UART_IIR	2	/* In: Interrupt Identity Register  */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
+#define UART_LCR_WLEN8	0x03	/* Wordlength: 8 bits */
+#define UART_MCR_OUT2	0x08	/* MCR GPIO out 2 */
+#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
+#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
+#define UART_LSR_RXRDY	0x01	/* Receiver ready */
+#define UART_FCR_FIFO_ENABLE 1	/* FIFO control register bit controlling FIFO enable/disable */
+
+/* Interrupt Identity Register (IIR) bits */
+#define UART_IIR_FIFO_MASK	0xc0	/* IIR FIFO disable/enabled mask */
+#define UART_IIR_INT_MASK	0xf	/* IIR interrupt ID source */
+#define UART_IIR_MDM_CHG	0x0	/* Modem status changed */
+#define UART_IIR_NOINT		0x1	/* No interrupt pending */
+#define UART_IIR_THRE		0x2	/* THR empty */
+#define UART_IIR_RCVD_DATA	0x4	/* Received data available */
+#define UART_IIR_RCVR_STATUS 	0x6	/* Receiver status */
+#define UART_IIR_CHAR_TIME 	0xc	/* Character time */
+
+/* Interrupt Enable Register (IER) bits */
+#define UART_IER_EDSSI	8	/* enable modem status interrupt */
+#define UART_IER_ELSI	4	/* enable receiver line status interrupt */
+#define UART_IER_ETBEI  2	/* enable transmitter holding register empty interrupt */
+#define UART_IER_ERBFI	1	/* enable data available interrupt */
+
+/* pmustatus */
+#define	PST_INTPEND	0x0040
+#define	PST_SBCLKST	0x0030
+#define	PST_ALPAVAIL	0x0008
+#define	PST_HTAVAIL	0x0004
+#define	PST_RESINIT	0x0003
+
+/* pmucapabilities */
+#define PCAP_REV_MASK	0x000000ff
+
+/* PMU Resource Request Timer registers */
+/* This is based on PmuRev0 */
+#define	PRRT_TIME_MASK	0x03ff
+#define	PRRT_INTEN	0x0400
+#define	PRRT_REQ_ACTIVE	0x0800
+#define	PRRT_ALP_REQ	0x1000
+#define	PRRT_HT_REQ	0x2000
+
+/* PMU resource bit position */
+#define PMURES_BIT(bit)	(1 << (bit))
+
+/* PMU corerev and chip specific PLL controls.
+ * PMU<rev>_PLL<num>_XXXX where <rev> is PMU corerev and <num> is an arbitary number
+ * to differentiate different PLLs controlled by the same PMU rev.
+ */
+#if defined(CONFIG_BCM4328) || defined(CONFIG_BCM5354)
+/* pllcontrol registers */
+/* PDIV, div_phy, div_arm, div_adc, dith_sel, ioff, kpd_scale, lsb_sel, mash_sel, lf_c & lf_r */
+#define	PMU0_PLL0_PLLCTL0		0
+#define	PMU0_PLL0_PC0_PDIV_MASK		1
+#define	PMU0_PLL0_PC0_PDIV_FREQ		25000
+#define PMU0_PLL0_PC0_DIV_ARM_MASK	0x00000038
+#define PMU0_PLL0_PC0_DIV_ARM_SHIFT	3
+#define PMU0_PLL0_PC0_DIV_ARM_BASE	8
+
+/* PC0_DIV_ARM for PLLOUT_ARM */
+#define PMU0_PLL0_PC0_DIV_ARM_110MHZ	0
+#define PMU0_PLL0_PC0_DIV_ARM_97_7MHZ	1
+#define PMU0_PLL0_PC0_DIV_ARM_88MHZ	2
+#define PMU0_PLL0_PC0_DIV_ARM_80MHZ	3 /* Default */
+#define PMU0_PLL0_PC0_DIV_ARM_73_3MHZ	4
+#define PMU0_PLL0_PC0_DIV_ARM_67_7MHZ	5
+#define PMU0_PLL0_PC0_DIV_ARM_62_9MHZ	6
+#define PMU0_PLL0_PC0_DIV_ARM_58_6MHZ	7
+
+/* Wildcard base, stop_mod, en_lf_tp, en_cal & lf_r2 */
+#define	PMU0_PLL0_PLLCTL1		1
+#define	PMU0_PLL0_PC1_WILD_INT_MASK	0xf0000000
+#define	PMU0_PLL0_PC1_WILD_INT_SHIFT	28
+#define	PMU0_PLL0_PC1_WILD_FRAC_MASK	0x0fffff00
+#define	PMU0_PLL0_PC1_WILD_FRAC_SHIFT	8
+#define	PMU0_PLL0_PC1_STOP_MOD		0x00000040
+
+/* Wildcard base, vco_calvar, vco_swc, vco_var_selref, vso_ical & vco_sel_avdd */
+#define	PMU0_PLL0_PLLCTL2		2
+#define	PMU0_PLL0_PC2_WILD_INT_MASK	0xf
+#define	PMU0_PLL0_PC2_WILD_INT_SHIFT	4
+#endif	/* BCM4328 || BCM5354 */
+
+/* Chip specific PMU resources. */
+#if defined(CONFIG_BCM4328)
+#define RES4328_EXT_SWITCHER_PWM	0	/* 0x00001 */
+#define RES4328_BB_SWITCHER_PWM		1	/* 0x00002 */
+#define RES4328_BB_SWITCHER_BURST	2	/* 0x00004 */
+#define RES4328_BB_EXT_SWITCHER_BURST	3	/* 0x00008 */
+#define RES4328_ILP_REQUEST		4	/* 0x00010 */
+#define RES4328_RADIO_SWITCHER_PWM	5	/* 0x00020 */
+#define RES4328_RADIO_SWITCHER_BURST	6	/* 0x00040 */
+#define RES4328_ROM_SWITCH		7	/* 0x00080 */
+#define RES4328_PA_REF_LDO		8	/* 0x00100 */
+#define RES4328_RADIO_LDO		9	/* 0x00200 */
+#define RES4328_AFE_LDO			10	/* 0x00400 */
+#define RES4328_PLL_LDO			11	/* 0x00800 */
+#define RES4328_BG_FILTBYP		12	/* 0x01000 */
+#define RES4328_TX_FILTBYP		13	/* 0x02000 */
+#define RES4328_RX_FILTBYP		14	/* 0x04000 */
+#define RES4328_XTAL_PU			15	/* 0x08000 */
+#define RES4328_XTAL_EN			16	/* 0x10000 */
+#define RES4328_BB_PLL_FILTBYP		17	/* 0x20000 */
+#define RES4328_RF_PLL_FILTBYP		18	/* 0x40000 */
+#define RES4328_BB_PLL_PU		19	/* 0x80000 */
+#endif	/* BCM4328 */
+
+#if defined(CONFIG_BCM5354)
+#define RES5354_EXT_SWITCHER_PWM	0	/* 0x00001 */
+#define RES5354_BB_SWITCHER_PWM		1	/* 0x00002 */
+#define RES5354_BB_SWITCHER_BURST	2	/* 0x00004 */
+#define RES5354_BB_EXT_SWITCHER_BURST	3	/* 0x00008 */
+#define RES5354_ILP_REQUEST		4	/* 0x00010 */
+#define RES5354_RADIO_SWITCHER_PWM	5	/* 0x00020 */
+#define RES5354_RADIO_SWITCHER_BURST	6	/* 0x00040 */
+#define RES5354_ROM_SWITCH		7	/* 0x00080 */
+#define RES5354_PA_REF_LDO		8	/* 0x00100 */
+#define RES5354_RADIO_LDO		9	/* 0x00200 */
+#define RES5354_AFE_LDO			10	/* 0x00400 */
+#define RES5354_PLL_LDO			11	/* 0x00800 */
+#define RES5354_BG_FILTBYP		12	/* 0x01000 */
+#define RES5354_TX_FILTBYP		13	/* 0x02000 */
+#define RES5354_RX_FILTBYP		14	/* 0x04000 */
+#define RES5354_XTAL_PU			15	/* 0x08000 */
+#define RES5354_XTAL_EN			16	/* 0x10000 */
+#define RES5354_BB_PLL_FILTBYP		17	/* 0x20000 */
+#define RES5354_RF_PLL_FILTBYP		18	/* 0x40000 */
+#define RES5354_BB_PLL_PU		19	/* 0x80000 */
+#endif	/* BCM5354 */
+
+#if defined(CONFIG_BCM4325) || defined(CONFIG_BCM4312)
+/* pllcontrol registers */
+/* ndiv_pwrdn, pwrdn_ch<x>, refcomp_pwrdn, dly_ch<x>, p1div, p2div, _bypsss_sdmod */
+#define PMU1_PLL0_PLLCTL0		0
+#define PMU1_PLL0_PC0_P1DIV_MASK	0x00f00000
+#define PMU1_PLL0_PC0_P1DIV_SHIFT	20
+#define PMU1_PLL0_PC0_P2DIV_MASK	0x0f000000
+#define PMU1_PLL0_PC0_P2DIV_SHIFT	24
+
+/* m<x>div */
+#define PMU1_PLL0_PLLCTL1		1
+#define PMU1_PLL0_PC1_M1DIV_MASK	0x000000ff
+#define PMU1_PLL0_PC1_M1DIV_SHIFT	0
+#define PMU1_PLL0_PC1_M2DIV_MASK	0x0000ff00
+#define PMU1_PLL0_PC1_M2DIV_SHIFT	8
+#define PMU1_PLL0_PC1_M3DIV_MASK	0x00ff0000
+#define PMU1_PLL0_PC1_M3DIV_SHIFT	16
+#define PMU1_PLL0_PC1_M4DIV_MASK	0xff000000
+#define PMU1_PLL0_PC1_M4DIV_SHIFT	24
+
+/* m<x>div, ndiv_dither_mfb, ndiv_mode, ndiv_int */
+#define PMU1_PLL0_PLLCTL2		2
+#define PMU1_PLL0_PC2_M5DIV_MASK	0x000000ff
+#define PMU1_PLL0_PC2_M5DIV_SHIFT	0
+#define PMU1_PLL0_PC2_M6DIV_MASK	0x0000ff00
+#define PMU1_PLL0_PC2_M6DIV_SHIFT	8
+#define PMU1_PLL0_PC2_NDIV_MODE_MASK	0x000e0000
+#define PMU1_PLL0_PC2_NDIV_MODE_SHIFT	17
+#define PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
+#define PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
+
+/* ndiv_frac */
+#define PMU1_PLL0_PLLCTL3		3
+#define PMU1_PLL0_PC3_NDIV_FRAC_MASK	0x00ffffff
+#define PMU1_PLL0_PC3_NDIV_FRAC_SHIFT	0
+
+/* pll_ctrl */
+#define PMU1_PLL0_PLLCTL4		4
+
+/* pll_ctrl, vco_rng, clkdrive_ch<x> */
+#define PMU1_PLL0_PLLCTL5		5
+#define PMU1_PLL0_PC5_CLK_DRV_MASK 0xffffff00
+#define PMU1_PLL0_PC5_CLK_DRV_SHIFT 8
+
+
+#endif	
+
+#if defined(CONFIG_BCM4325)
+#define RES4325_BUCK_BOOST_BURST	0	/* 0x00000001 */
+#define RES4325_CBUCK_BURST		1	/* 0x00000002 */
+#define RES4325_CBUCK_PWM		2	/* 0x00000004 */
+#define RES4325_CLDO_CBUCK_BURST	3	/* 0x00000008 */
+#define RES4325_CLDO_CBUCK_PWM		4	/* 0x00000010 */
+#define RES4325_BUCK_BOOST_PWM		5	/* 0x00000020 */
+#define RES4325_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4325_ABUCK_BURST		7	/* 0x00000080 */
+#define RES4325_ABUCK_PWM		8	/* 0x00000100 */
+#define RES4325_LNLDO1_PU		9	/* 0x00000200 */
+#define RES4325_LNLDO2_PU		10	/* 0x00000400 */
+#define RES4325_LNLDO3_PU		11	/* 0x00000800 */
+#define RES4325_LNLDO4_PU		12	/* 0x00001000 */
+#define RES4325_XTAL_PU			13	/* 0x00002000 */
+#define RES4325_ALP_AVAIL		14	/* 0x00004000 */
+#define RES4325_RX_PWRSW_PU		15	/* 0x00008000 */
+#define RES4325_TX_PWRSW_PU		16	/* 0x00010000 */
+#define RES4325_RFPLL_PWRSW_PU		17	/* 0x00020000 */
+#define RES4325_LOGEN_PWRSW_PU		18	/* 0x00040000 */
+#define RES4325_AFE_PWRSW_PU		19	/* 0x00080000 */
+#define RES4325_BBPLL_PWRSW_PU		20	/* 0x00100000 */
+#define RES4325_HT_AVAIL		21	/* 0x00200000 */
+
+/* Chip specific ChipStatus register bits */
+#define CST4325_SPROM_OTP_SEL_MASK	0x00000003
+#define CST4325_DEFCIS_SEL		0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4325_SPROM_SEL		1	/* OTP is powered up, SPROM is present */
+#define CST4325_OTP_SEL			2	/* OTP is powered up, no SPROM */
+#define CST4325_OTP_PWRDN		3	/* OTP is powered down, SPROM is present */
+#define CST4325_SDIO_USB_MODE_MASK	0x00000004
+#define CST4325_SDIO_USB_MODE_SHIFT	2
+#define CST4325_RCAL_VALID_MASK		0x00000008
+#define CST4325_RCAL_VALID_SHIFT	3
+#define CST4325_RCAL_VALUE_MASK		0x000001f0
+#define CST4325_RCAL_VALUE_SHIFT	4
+#define CST4325_PMUTOP_2B_MASK 		0x00000200	/* 1 for 2b, 0 for to 2a */
+#define CST4325_PMUTOP_2B_SHIFT   	9
+#endif	/* BCM4325 */
+
+#if defined(CONFIG_BCM4312)
+#define RES4312_SWITCHER_BURST		0	/* 0x00000001 */
+#define RES4312_SWITCHER_PWM    	1	/* 0x00000002 */
+#define RES4312_PA_REF_LDO		2	/* 0x00000004 */
+#define RES4312_CORE_LDO_BURST		3	/* 0x00000008 */
+#define RES4312_CORE_LDO_PWM		4	/* 0x00000010 */
+#define RES4312_RADIO_LDO		5	/* 0x00000020 */
+#define RES4312_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4312_BG_FILTBYP		7	/* 0x00000080 */
+#define RES4312_TX_FILTBYP		8	/* 0x00000100 */
+#define RES4312_RX_FILTBYP		9	/* 0x00000200 */
+#define RES4312_XTAL_PU			10	/* 0x00000400 */
+#define RES4312_ALP_AVAIL		11	/* 0x00000800 */
+#define RES4312_BB_PLL_FILTBYP		12	/* 0x00001000 */
+#define RES4312_RF_PLL_FILTBYP		13	/* 0x00002000 */
+#define RES4312_HT_AVAIL		14	/* 0x00004000 */
+#endif	/* BCM4312 */
+
+
+/*
+* Maximum delay for the PMU state transition.
+* This is an upper bound intended for spinwaits etc.
+*/
+#define PMU_MAX_TRANSITION_DLY 15000
 
 #endif	/* _SBCHIPC_H */
--- src/include.1927/sbconfig.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbconfig.h	2007-11-19 06:40:31.000000000 +0300
@@ -1,14 +1,15 @@
 /*
  * Broadcom SiliconBackplane hardware register definitions.
  *
- * Copyright 2004, Broadcom Corporation      
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
  * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
- * $Id$
+ *
+ * $Id: sbconfig.h,v 1.1.1.11 2006/02/27 03:43:16 honor Exp $
  */
 
 #ifndef	_SBCONFIG_H
@@ -27,6 +28,7 @@
  */
 #define SB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
 #define SB_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SB_PCI_MEM_SZ		(64 * 1024 * 1024)
 #define SB_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
 #define	SB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
 #define SB_ENUM_BASE    	0x18000000	/* Enumeration space base */
@@ -34,15 +36,23 @@
 
 #define	SB_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
 #define	SB_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
-
-#define	SB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
-#define	SB_FLASH1		0x1fc00000	/* Flash Region 1 */
-#define	SB_FLASH1_SZ		0x00400000	/* Size of Flash Region 1 */
+#define	SB_ARMCM3_ROM		0x1e000000	/* ARM Cortex-M3 ROM */
+#define	SB_FLASH1		0x1fc00000	/* MIPS Flash Region 1 */
+#define	SB_FLASH1_SZ		0x00400000	/* MIPS Size of Flash Region 1 */
+#define	SB_ARM7S_ROM		0x20000000	/* ARM7TDMI-S ROM */
+#define	SB_ARMCM3_SRAM2		0x60000000	/* ARM Cortex-M3 SRAM Region 2 */
+#define	SB_ARM7S_SRAM2		0x80000000	/* ARM7TDMI-S SRAM Region 2 */
+#define	SB_ARM_FLASH1		0xffff0000	/* ARM Flash Region 1 */
+#define	SB_ARM_FLASH1_SZ	0x00010000	/* ARM Size of Flash Region 1 */
 
 #define SB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
 #define SB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
-#define	SB_EUART		(SB_EXTIF_BASE + 0x00800000)
-#define	SB_LED			(SB_EXTIF_BASE + 0x00900000)
+#define SB_PCIE_DMA_L32		0x00000000	/* PCIE Client Mode sb2pcitranslation2
+						 * (2 ZettaBytes), low 32 bits
+						 */
+#define SB_PCIE_DMA_H32		0x80000000	/* PCIE Client Mode sb2pcitranslation2
+						 * (2 ZettaBytes), high 32 bits
+						 */
 
 /* enumeration space related defs */
 #define SB_CORE_SIZE    	0x1000		/* each core gets 4Kbytes for registers */
@@ -80,6 +91,16 @@
 #define SBIDLOW			0xf8
 #define SBIDHIGH		0xfc
 
+/* All the previous registers are above SBCONFIGOFF, but with Sonics 2.3, we have
+ * a few registers *below* that line. I think it would be very confusing to try
+ * and change the value of SBCONFIGOFF, so I'm definig them as absolute offsets here,
+ */
+
+#define SBIMERRLOGA		0xea8
+#define SBIMERRLOG		0xeb0
+#define SBTMPORTCONNID0		0xed8
+#define SBTMPORTLOCK0		0xef8
+
 #ifndef _LANGUAGE_ASSEMBLY
 
 typedef volatile struct _sbconfig {
@@ -158,7 +179,8 @@
 
 /* sbtmstatelow */
 #define	SBTML_RESET		0x1		/* reset */
-#define	SBTML_REJ		0x2		/* reject */
+#define	SBTML_REJ_MASK		0x6		/* reject */
+#define	SBTML_REJ_SHIFT		1
 #define	SBTML_CLK		0x10000		/* clock enable */
 #define	SBTML_FGC		0x20000		/* force gated clocks on */
 #define	SBTML_FL_MASK		0x3ffc0000	/* core-specific flags */
@@ -170,7 +192,8 @@
 #define	SBTMH_INT		0x2		/* interrupt */
 #define	SBTMH_BUSY		0x4		/* busy */
 #define	SBTMH_TO		0x00000020	/* timeout (sonics >= 2.3) */
-#define	SBTMH_FL_MASK		0x1fff0000	/* core-specific flags */
+#define	SBTMH_FL_MASK		0x0fff0000	/* core-specific flags */
+#define SBTMH_DMA64		0x10000000      /* supports DMA with 64-bit addresses */
 #define	SBTMH_GCR		0x20000000	/* gated clock request */
 #define	SBTMH_BISTF		0x40000000	/* bist failed */
 #define	SBTMH_BISTD		0x80000000	/* bist done */
@@ -262,10 +286,16 @@
 #define	SBIDL_IP_SHIFT		24
 #define	SBIDL_RV_MASK		0xf0000000	/* sonics backplane revision code */
 #define	SBIDL_RV_SHIFT		28
+#define	SBIDL_RV_2_2		0x00000000	/* version 2.2 or earlier */
+#define	SBIDL_RV_2_3		0x10000000	/* version 2.3 */
 
 /* sbidhigh */
-#define	SBIDH_RC_MASK		0xf		/* revision code*/
-#define	SBIDH_CC_MASK		0xfff0		/* core code */
+#define	SBIDH_RC_MASK		0x000f		/* revision code */
+#define	SBIDH_RCE_MASK		0x7000		/* revision code extension field */
+#define	SBIDH_RCE_SHIFT		8
+#define	SBCOREREV(sbidh) \
+	((((sbidh) & SBIDH_RCE_MASK) >> SBIDH_RCE_SHIFT) | ((sbidh) & SBIDH_RC_MASK))
+#define	SBIDH_CC_MASK		0x8ff0		/* core code */
 #define	SBIDH_CC_SHIFT		4
 #define	SBIDH_VC_MASK		0xffff0000	/* vendor code */
 #define	SBIDH_VC_SHIFT		16
@@ -276,6 +306,7 @@
 #define	SB_VEND_BCM		0x4243		/* Broadcom's SB vendor code */
 
 /* core codes */
+#define	SB_NODEV		0x700		/* Invalid coreid */
 #define	SB_CC			0x800		/* chipcommon core */
 #define	SB_ILINE20		0x801		/* iline20 core */
 #define	SB_SDRAM		0x803		/* sdram core */
@@ -302,6 +333,36 @@
 #define	SB_ATA100		0x81d		/* parallel ATA core */
 #define	SB_SATAXOR		0x81e		/* serial ATA & XOR DMA core */
 #define	SB_GIGETH		0x81f		/* gigabit ethernet core */
+#define	SB_PCIE			0x820		/* pci express core */
+#define	SB_MIMO			0x821		/* MIMO phy core */
+#define	SB_SRAMC		0x822		/* SRAM controller core */
+#define	SB_MINIMAC		0x823		/* MINI MAC/phy core */
+#define	SB_ARM11		0x824		/* ARM 1176 core */
+#define	SB_ARM7S		0x825		/* ARM7tdmi-s core */
+#define SB_SDIOD		0x829		/* SDIO device core */
+#define SB_ARMCM3		0x82a		/* ARM Cortex M3 core */
+#define SB_OCP			0x830		/* OCP2OCP bridge core */
+#define SB_SC			0x831		/* shared common core */
+#define SB_AHB			0x832		/* OCP2AHB bridge core */
+
+#define	SB_CC_IDX		0		/* chipc, when present, is always core 0 */
+
+/* Not an enumeration space register, but common to all cores to
+ * communicate w/PMU regarding Silicon Backplane clocking.
+ */
+#define SB_CLK_CTL_ST		0x1e0		/* clock control and status */
+
+/* clk_ctl_st register */
+#define	CCS_FORCEALP		0x00000001	/* force ALP request */
+#define	CCS_FORCEHT		0x00000002	/* force HT request */
+#define	CCS_FORCEILP		0x00000004	/* force ILP request */
+#define	CCS_ALPAREQ		0x00000008	/* ALP Avail Request */
+#define	CCS_HTAREQ		0x00000010	/* HT Avail Request */
+#define	CCS_FORCEHWREQOFF	0x00000020	/* Force HW Clock Request Off */
+#define	CCS_ALPAVAIL		0x00010000	/* ALP is available */
+#define	CCS_HTAVAIL		0x00020000	/* HT is available */
+#define	CCS0_HTAVAIL		0x00010000	/* HT avail in chipc and pcmcia on 4328a0 */
+#define	CCS0_ALPAVAIL		0x00020000	/* ALP avail in chipc and pcmcia on 4328a0 */
 
 /* Not really related to Silicon Backplane, but a couple of software
  * conventions for the use the flash space:
@@ -315,10 +375,11 @@
 #define	BISZ_MAGIC		0x4249535a	/* Marked with this value: 'BISZ' */
 #define	BISZ_MAGIC_IDX		0		/* Word 0: magic */
 #define	BISZ_TXTST_IDX		1		/*	1: text start */
-#define	BISZ_TXTEND_IDX		2		/*	2: text start */
-#define	BISZ_DATAST_IDX		3		/*	3: text start */
-#define	BISZ_DATAEND_IDX	4		/*	4: text start */
-#define	BISZ_BSSST_IDX		5		/*	5: text start */
-#define	BISZ_BSSEND_IDX		6		/*	6: text start */
+#define	BISZ_TXTEND_IDX		2		/*	2: text end */
+#define	BISZ_DATAST_IDX		3		/*	3: data start */
+#define	BISZ_DATAEND_IDX	4		/*	4: data end */
+#define	BISZ_BSSST_IDX		5		/*	5: bss start */
+#define	BISZ_BSSEND_IDX		6		/*	6: bss end */
+#define BISZ_SIZE		7		/* descriptor size in 32-bit intergers */
 
 #endif	/* _SBCONFIG_H */
--- src/include.1927/sbmemc.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbmemc.h	2007-11-19 06:40:31.000000000 +0300
@@ -39,8 +39,7 @@
 #define	MEMC_BARRIER		0x50
 #define	MEMC_CORE		0x54
 
-
-#else
+#else	/* !_LANGUAGE_ASSEMBLY */
 
 /* Sonics side: MEMC core registers */
 typedef volatile struct sbmemcregs {
@@ -68,7 +67,7 @@
 	uint32	core;
 } sbmemcregs_t;
 
-#endif
+#endif	/* _LANGUAGE_ASSEMBLY */
 
 /* MEMC Core Init values (OCP ID 0x80f) */
 
@@ -101,6 +100,7 @@
 #define MEMC_DRAMTIM2_INIT	0x000754d8
 #define MEMC_DRAMTIM25_INIT	0x000754d9
 #define MEMC_RDNCDLCOR_INIT	0x00000000
+#define MEMC_RDNCDLCOR_SIMINIT	0xf6f6f6f6	/* For hdl sim */
 #define MEMC_WRNCDLCOR_INIT	0x49351200
 #define MEMC_1_WRNCDLCOR_INIT	0x14500200
 #define MEMC_DQSGATENCDL_INIT	0x00030000
--- src/include.1927/sbpci.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbpci.h	2007-11-19 06:40:31.000000000 +0300
@@ -9,10 +8,14 @@
  * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * $Id$
  */
 
-#ifndef	_SBPCI_H
-#define	_SBPCI_H
+#ifndef	_sbpci_h_
+#define	_sbpci_h_
+
+#ifndef _LANGUAGE_ASSEMBLY
 
 /* cpp contortions to concatenate w/arg prescan */
 #ifndef PAD
@@ -42,11 +45,14 @@
 	uint32 sbtopci0;	/* Sonics to PCI translation 0 */
 	uint32 sbtopci1;	/* Sonics to PCI translation 1 */
 	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
-	uint32 PAD[445];
+	uint32 PAD[189];
+	uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
 	uint16 sprom[36];	/* SPROM shadow Area */
 	uint32 PAD[46];
 } sbpciregs_t;
 
+#endif	/* _LANGUAGE_ASSEMBLY */
+
 /* PCI control */
 #define PCI_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
 #define PCI_RST		0x02	/* Value driven out to pin */
@@ -56,12 +62,17 @@
 /* PCI arbiter control */
 #define PCI_INT_ARB	0x01	/* When set, use an internal arbiter */
 #define PCI_EXT_ARB	0x02	/* When set, use an external arbiter */
-#define PCI_PARKID_MASK	0x06	/* Selects which agent is parked on an idle bus */
-#define PCI_PARKID_SHIFT   1
-#define PCI_PARKID_LAST	   0	/* Last requestor */
-#define PCI_PARKID_4710	   1	/* 4710 */
-#define PCI_PARKID_EXTREQ0 2	/* External requestor 0 */
-#define PCI_PARKID_EXTREQ1 3	/* External requestor 1 */
+/* ParkID - for PCI corerev >= 8 */
+#define PCI_PARKID_MASK		0x1c	/* Selects which agent is parked on an idle bus */
+#define PCI_PARKID_SHIFT	2
+#define PCI_PARKID_EXT0		0	/* External master 0 */
+#define PCI_PARKID_EXT1		1	/* External master 1 */
+#define PCI_PARKID_EXT2		2	/* External master 2 */
+#define PCI_PARKID_EXT3		3	/* External master 3 (rev >= 11) */
+#define PCI_PARKID_INT		3	/* Internal master (rev < 11) */
+#define PCI11_PARKID_INT	4	/* Internal master (rev >= 11) */
+#define PCI_PARKID_LAST		4	/* Last active master (rev < 11) */
+#define PCI11_PARKID_LAST	5	/* Last active master (rev >= 11) */
 
 /* Interrupt status/mask */
 #define PCI_INTA	0x01	/* PCI INTA# is asserted */
@@ -98,20 +109,9 @@
 #define	SBTOPCI_RC_READLINE	0x10	/* memory read line */
 #define	SBTOPCI_RC_READMULTI	0x20	/* memory read multiple */
 
-/* PCI side: Reserved PCI configuration registers (see pcicfg.h) */
-#define cap_list	rsvd_a[0]
-#define bar0_window	dev_dep[0x80 - 0x40]
-#define bar1_window	dev_dep[0x84 - 0x40]
-#define sprom_control	dev_dep[0x88 - 0x40]
-
-#ifndef _LANGUAGE_ASSEMBLY
-
-extern int sbpci_read_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len);
-extern int sbpci_write_config(void *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len);
-extern void sbpci_ban(uint16 core);
-extern int sbpci_init(void *sbh);
-extern void sbpci_check(void *sbh);
-
-#endif /* !_LANGUAGE_ASSEMBLY */
+/* PCI core index in SROM shadow area */
+#define SRSH_PI_OFFSET	0	/* first word */
+#define SRSH_PI_MASK	0xf000	/* bit 15:12 */
+#define SRSH_PI_SHIFT	12	/* bit 15:12 */
 
-#endif	/* _SBPCI_H */
+#endif	/* _sbpci_h_ */
--- src/include.1927/sbpcmcia.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbpcmcia.h	2007-11-19 06:40:31.000000000 +0300
@@ -74,6 +75,8 @@
 #define SROM_DATAH		(0x073a / 2)
 #define SROM_ADDRL		(0x073c / 2)
 #define SROM_ADDRH		(0x073e / 2)
+#define	SROM_INFO2		(0x0772 / 2)	/* Corerev >= 2 && <= 5 */
+#define	SROM_INFO		(0x07be / 2)	/* Corerev >= 6 */
 
 /*  Values for srom_cs: */
 #define SROM_IDLE		0
@@ -83,16 +86,30 @@
 #define SROM_WDS		7
 #define SROM_DONE		8
 
+/* Fields in srom_info: */
+#define	SRI_SZ_MASK		0x03
+#define	SRI_BLANK		0x04
+#define	SRI_OTP			0x80
+
 /* CIS stuff */
 
 /* The CIS stops where the FCRs start */
 #define	CIS_SIZE		PCMCIA_FCR
 
+/* CIS tuple length field max */
+#define CIS_TUPLE_LEN_MAX	0xff
+
 /* Standard tuples we know about */
 
+#define	CISTPL_VERS_1		0x15		/* CIS ver, manf, dev & ver strings */
 #define	CISTPL_MANFID		0x20		/* Manufacturer and device id */
+#define CISTPL_FUNCID		0x21		/* Function identification */
 #define	CISTPL_FUNCE		0x22		/* Function extensions */
 #define	CISTPL_CFTABLE		0x1b		/* Config table entry */
+#define	CISTPL_END		0xff		/* End of the CIS tuple chain */
+
+/* Function identifier provides context for the function extentions tuple */
+
 
 /* Function extensions for LANs */
 
@@ -116,18 +133,47 @@
 
 /* Subtypes of BRCM_HNBU: */
 
-#define	HNBU_CHIPID		0x01		/* Six bytes with PCI vendor &
-						 * device id and chiprev
+#define HNBU_SROMREV		0x00		/* A byte with sromrev, 1 if not present */
+#define HNBU_CHIPID		0x01		/* Two 16bit values: PCI vendor & device id */
+#define HNBU_BOARDREV		0x02		/* One byte board revision */
+#define HNBU_PAPARMS		0x03		/* PA parameters: 8 (sromrev == 1)
+						 * or 9 (sromrev > 1) bytes
 						 */
-#define	HNBU_BOARDREV		0x02		/* Two bytes board revision */
-#define	HNBU_PAPARMS		0x03		/* Eleven bytes PA parameters */
-#define	HNBU_OEM		0x04		/* Eight bytes OEM data */
-#define	HNBU_CC			0x05		/* Default country code */
+#define HNBU_OEM		0x04		/* Eight bytes OEM data (sromrev == 1) */
+#define HNBU_CC			0x05		/* Default country code (sromrev == 1) */
 #define	HNBU_AA			0x06		/* Antennas available */
 #define	HNBU_AG			0x07		/* Antenna gain */
-#define HNBU_BOARDFLAGS		0x08		/* board flags */
-#define HNBU_LED		0x09		/* LED set */
-
+#define HNBU_BOARDFLAGS		0x08		/* board flags (2 or 4 bytes) */
+#define HNBU_LEDS		0x09		/* LED set */
+#define HNBU_CCODE		0x0a		/* Country code (2 bytes ascii + 1 byte cctl)
+						 * in rev 2
+						 */
+#define HNBU_CCKPO		0x0b		/* 2 byte cck power offsets in rev 3 */
+#define HNBU_OFDMPO		0x0c		/* 4 byte 11g ofdm power offsets in rev 3 */
+#define HNBU_GPIOTIMER		0x0d		/* 2 bytes with on/off values in rev 3 */
+#define HNBU_PAPARMS5G		0x0e		/* 5G PA params */
+#define HNBU_ANT5G		0x0f		/* 4328 5G antennas available/gain */
+#define HNBU_RDLID		0x10		/* 2 byte USB remote downloader (RDL) product Id */
+#define HNBU_RSSISMBXA2G	0x11		/* 4328 2G RSSI mid pt sel & board switch arch,
+						 * 2 bytes, rev 3.
+						 */
+#define HNBU_RSSISMBXA5G	0x12		/* 4328 5G RSSI mid pt sel & board switch arch,
+						 * 2 bytes, rev 3.
+						 */
+#define HNBU_XTALFREQ		0x13		/* 4 byte Crystal frequency in kilohertz */
+#define HNBU_TRI2G		0x14		/* 4328 2G TR isolation, 1 byte */
+#define HNBU_TRI5G		0x15		/* 4328 5G TR isolation, 3 bytes */
+#define HNBU_RXPO2G		0x16		/* 4328 2G RX power offset, 1 byte */
+#define HNBU_RXPO5G		0x17		/* 4328 5G RX power offset, 1 byte */
+#define HNBU_BOARDNUM	0x18		/* board serial number, independent of mac addr */
+#define HNBU_MACADDR	0x19		/* mac addr override for the standard CIS LAN_NID */
+#define HNBU_RDLSN		0x1a		/* 2 bytes; serial # advertised in USB descriptor */
+#define HNBU_BOARDTYPE		0x1b		/* 2 bytes; boardtype */
+#define HNBU_RDLRNDIS		0x20		/* 1 byte; 1 = RDL advertises RNDIS config */
+#define HNBU_RDLRWU		0x30		/* 1 byte; 1 = RDL advertises Remote Wake-up */
+#define HNBU_SROM3SWRGN		0x80	/* 78 bytes; srom rev 3 s/w region without crc8
+					 * plus extra info appended.
+					 */
 
 /* sbtmstatelow */
 #define SBTML_INT_ACK		0x40000		/* ack the sb interrupt */
--- src/include.1927/sbsdram.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbsdram.h	2007-11-19 06:40:31.000000000 +0300
@@ -1,14 +1,15 @@
 /*
  * BCM47XX Sonics SiliconBackplane SDRAM controller core hardware definitions.
  *
- * Copyright 2004, Broadcom Corporation      
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
  * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
- * $Id$
+ *
+ * $Id: sbsdram.h,v 1.1.1.9 2006/03/02 13:03:52 honor Exp $
  */
 
 #ifndef	_SBSDRAM_H
@@ -25,7 +26,7 @@
 	uint32	pad2;
 } sbsdramregs_t;
 
-#endif
+#endif /* !_LANGUAGE_ASSEMBLY */
 
 /* SDRAM initialization control (initcontrol) register bits */
 #define SDRAM_CBR	0x0001	/* Writing 1 generates refresh cycle and toggles bit */
--- src/include.1927/sbsocram.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbsocram.h	2007-11-19 06:40:31.000000000 +0300
@@ -1,7 +1,7 @@
 /*
  * BCM47XX Sonics SiliconBackplane embedded ram core
  *
- * Copyright 2004, Broadcom Corporation      
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
@@ -9,9 +9,9 @@
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
  *
- * $Id$
+ * $Id: sbsocram.h,v 1.1.1.3 2006/02/27 03:43:16 honor Exp $
  */
 
 #ifndef	_SBSOCRAM_H
 #define	_SBSOCRAM_H
 
@@ -15,23 +15,72 @@
 #ifndef	_SBSOCRAM_H
 #define	_SBSOCRAM_H
 
-#define	SOCRAM_MEMSIZE		0x00
-#define	SOCRAM_BISTSTAT		0x0c
-
-
 #ifndef _LANGUAGE_ASSEMBLY
 
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
 /* Memcsocram core registers */
 typedef volatile struct sbsocramregs {
-	uint32	memsize;
+	uint32	coreinfo;
+	uint32	bwalloc;
+	uint32	PAD;
 	uint32	biststat;
+	uint32	bankidx;
+	uint32	standbyctrl;
+	uint32	PAD[116];
+	uint32	pwrctl;		/* corerev >= 2 */
 } sbsocramregs_t;
 
-#endif
+#endif	/* _LANGUAGE_ASSEMBLY */
+
+/* Register offsets */
+#define	SR_COREINFO		0x00
+#define	SR_BWALLOC		0x04
+#define	SR_BISTSTAT		0x0c
+#define	SR_BANKINDEX		0x10
+#define	SR_BANKSTBYCTL		0x14
+#define SR_PWRCTL		0x1e8
+
+/* Coreinfo register */
+#define	SRCI_PT_MASK		0x00030000
+#define	SRCI_PT_SHIFT		16
+/* corerev >= 3 */
+#define SRCI_LSS_MASK		0x00f00000
+#define SRCI_LSS_SHIFT		20
+#define SRCI_LRS_MASK		0x0f000000
+#define SRCI_LRS_SHIFT		24
 
-/* Them memory size is 2 to the power of the following
- * base added to the contents of the memsize register.
+/* In corerev 0, the memory size is 2 to the power of the
+ * base plus 16 plus to the contents of the memsize field plus 1.
+ */
+#define	SRCI_MS0_MASK		0xf
+#define SR_MS0_BASE		16
+
+/*
+ * In corerev 1 the bank size is 2 ^ the bank size field plus 14,
+ * the memory size is number of banks times bank size.
+ * The same applies to rom size.
  */
-#define SOCRAM_MEMSIZE_BASESHIFT 16
+#define	SRCI_ROMNB_MASK		0xf000
+#define	SRCI_ROMNB_SHIFT	12
+#define	SRCI_ROMBSZ_MASK	0xf00
+#define	SRCI_ROMBSZ_SHIFT	8
+#define	SRCI_SRNB_MASK		0xf0
+#define	SRCI_SRNB_SHIFT		4
+#define	SRCI_SRBSZ_MASK		0xf
+#define	SRCI_SRBSZ_SHIFT	0
+
+#define SR_BSZ_BASE		14
+
+/* Standby control register */
+#define	SRSC_SBYOVR_MASK		0x80000000
+#define	SRSC_SBYOVR_SHIFT		31
+#define	SRSC_SBYOVRVAL_MASK		0x60000000
+#define	SRSC_SBYOVRVAL_SHIFT		29
 
 #endif	/* _SBSOCRAM_H */
--- src/include.1927/sbutils.h	2004-10-14 23:11:17.000000000 +0400
+++ src/include/sbutils.h	2007-11-19 06:40:31.000000000 +0300
@@ -2,7 +2,7 @@
  * Misc utility routines for accessing chip-specific features
  * of Broadcom HNBU SiliconBackplane-based chips.
  *
- * Copyright 2004, Broadcom Corporation
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.
  * 
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -17,6 +17,36 @@
 #define	_sbutils_h_
 
 /*
+ * Data structure to export all chip specific common variables
+ * public (read-only) portion of sbutils handle returned by
+ * sb_attach()/sb_kattach()
+*/
+
+struct sb_pub {
+
+	uint	bustype;		/* SB_BUS, PCI_BUS  */
+	uint	buscoretype;		/* SB_PCI, SB_PCMCIA, SB_PCIE */
+	uint	buscorerev;		/* buscore rev */
+	uint	buscoreidx;		/* buscore index */
+	int	ccrev;			/* chip common core rev */
+	uint32	cccaps;			/* chip common capabilities */
+	int	pmurev;			/* pmu core rev */
+	uint32	pmucaps;		/* pmu capabilities */
+	uint	boardtype;		/* board type */
+	uint	boardvendor;		/* board vendor */
+	uint	boardflags;		/* board flags */
+	uint	chip;			/* chip number */
+	uint	chiprev;		/* chip revision */
+	uint	chippkg;		/* chip package option */
+	uint32	chipst;			/* chip status */
+	uint    sonicsrev;		/* sonics backplane rev */
+	bool	pr42780;		/* whether PCIE 42780 WAR applies to this chip */
+	bool	pr32414;		/* whether 432414 WAR applis to the chip */
+};
+
+typedef const struct sb_pub sb_t;
+
+/*
  * Many of the routines below take an 'sbh' handle as their first arg.
  * Allocate this by calling sb_attach().  Free it by calling sb_detach().
  * At any one time, the sbh is logically focused on one particular sb core
@@ -24,64 +54,150 @@
  * Use sb_setcore() or sb_setcoreidx() to change the association to another core.
  */
 
+#define	SB_OSH		NULL	/* Use for sb_kattach when no osh is available */
+
 /* exported externs */
-extern void * BCMINIT(sb_attach)(uint pcidev, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
-extern void * BCMINIT(sb_kattach)(void);
-extern void sb_detach(void *sbh);
-extern uint BCMINIT(sb_chip)(void *sbh);
-extern uint BCMINIT(sb_chiprev)(void *sbh);
-extern uint BCMINIT(sb_chipcrev)(void *sbh);
-extern uint BCMINIT(sb_chippkg)(void *sbh);
-extern uint BCMINIT(sb_pcirev)(void *sbh);
-extern uint BCMINIT(sb_pcmciarev)(void *sbh);
-extern uint BCMINIT(sb_boardvendor)(void *sbh);
-extern uint BCMINIT(sb_boardtype)(void *sbh);
-extern uint sb_bus(void *sbh);
-extern uint sb_corelist(void *sbh, uint coreid[]);
-extern uint sb_coreid(void *sbh);
-extern uint sb_coreidx(void *sbh);
-extern uint sb_coreunit(void *sbh);
-extern uint sb_corevendor(void *sbh);
-extern uint sb_corerev(void *sbh);
-extern void *sb_osh(void *sbh);
-extern void *sb_coreregs(void *sbh);
-extern uint32 sb_coreflags(void *sbh, uint32 mask, uint32 val);
-extern uint32 sb_coreflagshi(void *sbh, uint32 mask, uint32 val);
-extern bool sb_iscoreup(void *sbh);
-extern void *sb_setcoreidx(void *sbh, uint coreidx);
-extern void *sb_setcore(void *sbh, uint coreid, uint coreunit);
-extern void sb_commit(void *sbh);
+extern sb_t *sb_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+                       void *sdh, char **vars, uint *varsz);
+extern sb_t *sb_kattach(osl_t *osh);
+extern void sb_detach(sb_t *sbh);
+extern uint sb_chip(sb_t *sbh);
+extern uint sb_chiprev(sb_t *sbh);
+extern uint sb_chipcrev(sb_t *sbh);
+extern uint sb_chippkg(sb_t *sbh);
+extern uint sb_pcirev(sb_t *sbh);
+extern bool sb_war16165(sb_t *sbh);
+extern uint sb_pcmciarev(sb_t *sbh);
+extern uint sb_boardvendor(sb_t *sbh);
+extern uint sb_boardtype(sb_t *sbh);
+extern uint sb_bus(sb_t *sbh);
+extern uint sb_buscoretype(sb_t *sbh);
+extern uint sb_buscorerev(sb_t *sbh);
+extern uint sb_corelist(sb_t *sbh, uint coreid[]);
+extern uint sb_coreid(sb_t *sbh);
+extern uint sb_flag(sb_t *sbh);
+extern uint sb_coreidx(sb_t *sbh);
+extern uint sb_coreunit(sb_t *sbh);
+extern uint sb_corevendor(sb_t *sbh);
+extern uint sb_corerev(sb_t *sbh);
+extern void *sb_osh(sb_t *sbh);
+extern void sb_setosh(sb_t *sbh, osl_t *osh);
+extern uint sb_corereg(sb_t *sbh, uint coreidx, uint regoff, uint mask, uint val);
+extern void *sb_coreregs(sb_t *sbh);
+extern uint32 sb_coreflags(sb_t *sbh, uint32 mask, uint32 val);
+extern void sb_coreflags_wo(sb_t *sbh, uint32 mask, uint32 val);
+extern uint32 sb_coreflagshi(sb_t *sbh, uint32 mask, uint32 val);
+extern bool sb_iscoreup(sb_t *sbh);
+extern uint sb_findcoreidx(sb_t *sbh, uint coreid, uint coreunit);
+extern void *sb_setcoreidx(sb_t *sbh, uint coreidx);
+extern void *sb_setcore(sb_t *sbh, uint coreid, uint coreunit);
+extern int sb_corebist(sb_t *sbh);
+extern void sb_commit(sb_t *sbh);
 extern uint32 sb_base(uint32 admatch);
 extern uint32 sb_size(uint32 admatch);
-extern void sb_core_reset(void *sbh, uint32 bits);
-extern void sb_core_tofixup(void *sbh);
-extern void sb_core_disable(void *sbh, uint32 bits);
+extern void sb_core_reset(sb_t *sbh, uint32 bits, uint32 resetbits);
+extern void sb_core_tofixup(sb_t *sbh);
+extern void sb_core_disable(sb_t *sbh, uint32 bits);
 extern uint32 sb_clock_rate(uint32 pll_type, uint32 n, uint32 m);
-extern uint32 sb_clock(void *sbh);
-extern void sb_pci_setup(void *sbh, uint32 *dmaoffset, uint coremask);
-extern void sb_pcmcia_init(void *sbh);
-extern void sb_watchdog(void *sbh, uint ticks);
-extern void *sb_gpiosetcore(void *sbh);
-extern uint32 sb_gpiocontrol(void *sbh, uint32 mask, uint32 val);
-extern uint32 sb_gpioouten(void *sbh, uint32 mask, uint32 val);
-extern uint32 sb_gpioout(void *sbh, uint32 mask, uint32 val);
-extern uint32 sb_gpioin(void *sbh);
-extern uint32 sb_gpiointpolarity(void *sbh, uint32 mask, uint32 val);
-extern uint32 sb_gpiointmask(void *sbh, uint32 mask, uint32 val);
-extern void sb_pwrctl_init(void *sbh);
-extern uint16 sb_pwrctl_fast_pwrup_delay(void *sbh);
-extern bool sb_pwrctl_clk(void *sbh, uint mode);
-extern int sb_pwrctl_xtal(void *sbh, uint what, bool on);
-extern int sb_pwrctl_slowclk(void *sbh, bool set, uint *div);
-extern void sb_register_intr_callback(void *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intrsenabled_fn, void *intr_arg);
+extern uint32 sb_clock(sb_t *sbh);
+extern uint32 sb_alp_clock(sb_t *sbh);
+extern void sb_pci_setup(sb_t *sbh, uint coremask);
+extern void sb_pcmcia_init(sb_t *sbh);
+extern void sb_watchdog(sb_t *sbh, uint ticks);
+extern void *sb_gpiosetcore(sb_t *sbh);
+extern uint32 sb_gpiocontrol(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioouten(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioout(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioin(sb_t *sbh);
+extern uint32 sb_gpiointpolarity(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpiointmask(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioled(sb_t *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpioreserve(sb_t *sbh, uint32 gpio_num, uint8 priority);
+extern uint32 sb_gpiorelease(sb_t *sbh, uint32 gpio_num, uint8 priority);
+extern uint32 sb_gpiopull(sb_t *sbh, bool updown, uint32 mask, uint32 val);
+extern uint32 sb_gpioevent(sb_t *sbh, uint regtype, uint32 mask, uint32 val);
+extern uint32 sb_gpio_int_enable(sb_t *sbh, bool enable);
+
+/* GPIO event handlers */
+typedef void (*gpio_handler_t)(uint32 stat, void *arg);
+
+extern void *sb_gpio_handler_register(sb_t *sbh, uint32 event,
+	bool level, gpio_handler_t cb, void *arg);
+extern void sb_gpio_handler_unregister(sb_t *sbh, void* gpioh);
+extern void sb_gpio_handler_process(sb_t *sbh);
+
+extern void sb_clkctl_init(sb_t *sbh);
+extern uint16 sb_clkctl_fast_pwrup_delay(sb_t *sbh);
+extern bool sb_clkctl_clk(sb_t *sbh, uint mode);
+extern int sb_clkctl_xtal(sb_t *sbh, uint what, bool on);
+extern void sb_register_intr_callback(sb_t *sbh, void *intrsoff_fn, void *intrsrestore_fn,
+                                      void *intrsenabled_fn, void *intr_arg);
+extern void sb_deregister_intr_callback(sb_t *sbh);
+extern uint32 sb_set_initiator_to(sb_t *sbh, uint32 to, uint idx);
+extern uint16 sb_d11_devid(sb_t *sbh);
+extern int sb_corepciid(sb_t *sbh, uint func, uint16 *pcivendor, uint16 *pcidevice,
+                        uint8 *pciclass, uint8 *pcisubclass, uint8 *pciprogif,
+                        uint8 *pciheader);
+extern uint sb_pcie_readreg(void *sbh, void* arg1, uint offset);
+extern uint sb_pcie_writereg(sb_t *sbh, void *arg1,  uint offset, uint val);
+extern uint32 sb_gpiotimerval(sb_t *sbh, uint32 mask, uint32 val);
+extern bool sb_backplane64(sb_t *sbh);
+extern void sb_btcgpiowar(sb_t *sbh);
+
+
+#if defined(BCMDBG_ASSERT)
+extern bool sb_taclear(sb_t *sbh);
+#endif 
 
-/* pwrctl xtal what flags */
+
+extern bool sb_deviceremoved(sb_t *sbh);
+extern uint32 sb_socram_size(sb_t *sbh);
+
+/*
+* Build device path. Path size must be >= SB_DEVPATH_BUFSZ.
+* The returned path is NULL terminated and has trailing '/'.
+* Return 0 on success, nonzero otherwise.
+*/
+extern int sb_devpath(sb_t *sbh, char *path, int size);
+/* Read variable with prepending the devpath to the name */
+extern char *sb_getdevpathvar(sb_t *sbh, const char *name);
+extern int sb_getdevpathintvar(sb_t *sbh, const char *name);
+
+extern uint8 sb_pcieclkreq(sb_t *sbh, uint32 mask, uint32 val);
+extern void sb_war42780_clkreq(sb_t *sbh, bool clkreq);
+extern void sb_pci_sleep(sb_t *sbh);
+extern void sb_pci_down(sb_t *sbh);
+extern void sb_pci_up(sb_t *sbh);
+
+/* Wake-on-wireless-LAN (WOWL) */
+extern bool sb_pci_pmecap(sb_t *sbh);
+extern bool sb_pci_pmeclr(sb_t *sbh);
+extern void sb_pci_pmeen(sb_t *sbh);
+
+/* clkctl xtal what flags */
 #define	XTAL		0x1			/* primary crystal oscillator (2050) */
 #define	PLL		0x2			/* main chip pll */
 
-/* pwrctl clk mode */
+/* clkctl clk mode */
 #define	CLK_FAST	0			/* force fast (pll) clock */
-#define	CLK_SLOW	1			/* force slow clock */
-#define	CLK_DYNAMIC	2			/* enable dynamic power control */
+#define	CLK_DYNAMIC		2		/* enable dynamic clock control */
+
+
+/* GPIO usage priorities */
+#define GPIO_DRV_PRIORITY	0		/* Driver */
+#define GPIO_APP_PRIORITY	1		/* Application */
+#define GPIO_HI_PRIORITY	2		/* Highest priority. Ignore GPIO reservation */
+
+/* GPIO pull up/down */
+#define GPIO_PULLUP		0
+#define GPIO_PULLDN		1
+
+/* GPIO event regtype */
+#define GPIO_REGEVT			0	/* GPIO register event */
+#define GPIO_REGEVT_INTMSK		1	/* GPIO register event int mask */
+#define GPIO_REGEVT_INTPOL		2	/* GPIO register event int polarity */
+
+/* device path */
+#define SB_DEVPATH_BUFSZ	16		/* min buffer size in bytes */
 
 #endif	/* _sbutils_h_ */
--- src.1972/include/sflash.h	2004-10-14 23:11:17.000000000 +0400
+++ src.1985/include/sflash.h	2007-09-20 12:53:48.000000000 +0400
@@ -1,7 +1,7 @@
 /*
  * Broadcom SiliconBackplane chipcommon serial flash interface
  *
- * Copyright 2004, Broadcom Corporation      
+ * Copyright 2006, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
@@ -9,7 +9,7 @@
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
  *
- * $Id$
+ * $Id: sflash.h,v 1.1.1.8 2006/02/27 03:43:16 honor Exp $
  */
 
 #ifndef _sflash_h_
--- src/include.1927/trxhdr.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/trxhdr.h	2007-11-19 06:42:00.000000000 +0300
@@ -1,7 +1,7 @@
 /*
  * TRX image file header format.
  *
- * Copyright 2004, Broadcom Corporation
+ * Copyright 2005, Broadcom Corporation
  * All Rights Reserved.
  * 
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
@@ -15,11 +15,11 @@
 #include <typedefs.h>
 
 #define TRX_MAGIC	0x30524448	/* "HDR0" */
-#define TRX_VERSION	1
-#define TRX_MAX_LEN	0x3A0000
+#define TRX_VERSION	1		/* Version 1 */
+#define TRX_MAX_LEN	0x7A0000	/* Max length */
 #define TRX_NO_HEADER	1		/* Do not write TRX header */	
 #define TRX_GZ_FILES	0x2     /* Contains up to TRX_MAX_OFFSET individual gzip files */
-#define TRX_MAX_OFFSET	3
+#define TRX_MAX_OFFSET	3		/* Max number of individual files */
 
 struct trx_header {
 	uint32 magic;		/* "HDR0" */
--- src/include.1927/typedefs.h	2004-10-14 23:11:18.000000000 +0400
+++ src/include/typedefs.h	2007-11-19 06:40:31.000000000 +0300
@@ -28,9 +28,10 @@
 
 #ifdef SITE_TYPEDEFS
 
-/*******************************************************************************
+/*
  * Site Specific Typedefs
- *******************************************************************************/
+ *
+ */
 
 #include "site_typedefs.h"
 
@@ -36,9 +37,10 @@
 
 #else
 
-/*******************************************************************************
+/*
  * Inferred Typedefs
- *******************************************************************************/
+ *
+ */
 
 /* Infer the compile environment based on preprocessor symbols and pramas.
  * Override type definitions as needed, and include configuration dependent
@@ -67,12 +69,32 @@
 #endif	/* ! __cplusplus */
 
 /* use the Windows ULONG_PTR type when compiling for 64 bit */
-#if defined(_WIN64)
+#if defined(_WIN64) && !defined(EFI)
 #include <basetsd.h>
 #define TYPEDEF_UINTPTR
 typedef ULONG_PTR	uintptr;
+#elif defined(__x86_64__)
+#define TYPEDEF_UINTPTR
+typedef unsigned long long int uintptr;
+#endif
+
+
+#if defined(_MINOSL_)
+#define _NEED_SIZE_T_
+#endif
+
+#if defined(EFI) && !defined(_WIN64)
+#define _NEED_SIZE_T_
+#endif
+
+#if defined(_NEED_SIZE_T_)
+typedef long unsigned int size_t;
 #endif
 
+#ifdef __DJGPP__
+typedef long unsigned int size_t;
+#endif /* __DJGPP__ */
+
 #ifdef _MSC_VER	    /* Microsoft C */
 #define TYPEDEF_INT64
 #define TYPEDEF_UINT64
@@ -80,18 +102,29 @@
 typedef unsigned __int64 uint64;
 #endif
 
-#if defined(MACOSX) && defined(KERNEL)
+#if defined(MACOSX)
 #define TYPEDEF_BOOL
 #endif
 
+#if defined(__NetBSD__)
+#define TYPEDEF_ULONG
+#endif
 
-#if defined(linux)
+
+#ifdef	linux
 #define TYPEDEF_UINT
 #define TYPEDEF_USHORT
 #define TYPEDEF_ULONG
-#endif
+#ifdef __KERNEL__
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19))
+#define TYPEDEF_BOOL
+#endif	/* >= 2.6.19 */
+#endif	/* __KERNEL__ */
+#endif	/* linux */
 
-#if !defined(linux) && !defined(_WIN32) && !defined(PMON) && !defined(_CFE_) && !defined(_HNDRTE_) && !defined(_MINOSL_)
+#if !defined(linux) && !defined(_WIN32) && !defined(_CFE_) && \
+	!defined(_HNDRTE_) && !defined(_MINOSL_) && !defined(__DJGPP__) && !defined(__IOPOS__)
 #define TYPEDEF_UINT
 #define TYPEDEF_USHORT
 #endif
@@ -115,8 +149,8 @@
 
 #endif /* __ICL */
 
-
-#if !defined(_WIN32) && !defined(PMON) && !defined(_CFE_) && !defined(_HNDRTE_) && !defined(_MINOSL_)
+#if !defined(_WIN32) && !defined(_CFE_) && !defined(_MINOSL_) && \
+	!defined(__DJGPP__) && !defined(__IOPOS__)
 
 /* pick up ushort & uint from standard types.h */
 #if defined(linux) && defined(__KERNEL__)
@@ -129,11 +163,38 @@
 
 #endif
 
-#endif /* !_WIN32 && !PMON && !_CFE_ && !_HNDRTE_  && !_MINOSL_ */
+#endif 
 
-#if defined(MACOSX) && defined(KERNEL)
-#include <IOKit/IOTypes.h>
+#if defined(MACOSX)
+
+#ifdef __BIG_ENDIAN__
+#define IL_BIGENDIAN
+#else
+#ifdef IL_BIGENDIAN
+#error "IL_BIGENDIAN was defined for a little-endian compile"
 #endif
+#endif /* __BIG_ENDIAN__ */
+
+#if !defined(__cplusplus)
+
+#if defined(__i386__)
+typedef unsigned char bool;
+#else
+typedef unsigned int bool;
+#endif
+#define TYPE_BOOL 1
+enum {
+    false	= 0,
+    true	= 1
+};
+
+#if defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#endif /* KERNEL */
+
+#endif /* __cplusplus */
+
+#endif /* MACOSX */
 
 
 /* use the default typedefs in the next section of this file */
@@ -142,9 +203,10 @@
 #endif /* SITE_TYPEDEFS */
 
 
-/*******************************************************************************
+/*
  * Default Typedefs
- *******************************************************************************/
+ *
+ */
 
 #ifdef USE_TYPEDEF_DEFAULTS
 #undef USE_TYPEDEF_DEFAULTS
@@ -150,10 +212,10 @@
 #undef USE_TYPEDEF_DEFAULTS
 
 #ifndef TYPEDEF_BOOL
-typedef	/*@abstract@*/ unsigned char	bool;
+typedef	/* @abstract@ */ unsigned char	bool;
 #endif
 
-/*----------------------- define uchar, ushort, uint, ulong ------------------*/
+/* define uchar, ushort, uint, ulong */
 
 #ifndef TYPEDEF_UCHAR
 typedef unsigned char	uchar;
@@ -171,7 +233,7 @@
 typedef unsigned long	ulong;
 #endif
 
-/*----------------------- define [u]int8/16/32/64, uintptr --------------------*/
+/* define [u]int8/16/32/64, uintptr */
 
 #ifndef TYPEDEF_UINT8
 typedef unsigned char	uint8;
@@ -209,7 +271,7 @@
 typedef signed long long int64;
 #endif
 
-/*----------------------- define float32/64, float_t -----------------------*/
+/* define float32/64, float_t */
 
 #ifndef TYPEDEF_FLOAT32
 typedef float		float32;
@@ -235,14 +297,14 @@
 
 #endif /* TYPEDEF_FLOAT_T */
 
-/*----------------------- define macro values -----------------------------*/
+/* define macro values */
 
 #ifndef FALSE
 #define FALSE	0
 #endif
 
 #ifndef TRUE
-#define TRUE	1
+#define TRUE	1  /* TRUE */
 #endif
 
 #ifndef NULL
@@ -254,31 +316,15 @@
 #endif
 
 #ifndef ON
-#define	ON	1
+#define	ON	1  /* ON = 1 */
 #endif
 
-#define	AUTO	(-1)
-
-/* Reclaiming text and data :
-   The following macros specify special linker sections that can be reclaimed
-   after a system is considered 'up'.
- */ 
-#if defined(__GNUC__) && defined(BCMRECLAIM)
-extern bool	bcmreclaimed;
-#define BCMINITDATA(_data)	__attribute__ ((__section__ (".dataini." #_data))) _data##_ini		
-#define BCMINITFN(_fn)		__attribute__ ((__section__ (".textini." #_fn))) _fn##_ini
-#define BCMINIT(_id)		_id##_ini
-#else 
-#define BCMINITDATA(_data)	_data		
-#define BCMINITFN(_fn)		_fn
-#define BCMINIT(_id)		_id
-#define bcmreclaimed		0
-#endif
+#define	AUTO	(-1) /* Auto = -1 */
 
-/*----------------------- define PTRSZ, INLINE ----------------------------*/
+/* define PTRSZ, INLINE */
 
 #ifndef PTRSZ
-#define	PTRSZ	sizeof (char*)
+#define	PTRSZ	sizeof(char*)
 #endif
 
 #ifndef INLINE
@@ -287,7 +333,7 @@
 
 #define INLINE __inline
 
-#elif __GNUC__
+#elif defined(__GNUC__)
 
 #define INLINE __inline__
 
@@ -319,4 +365,10 @@
 
 #endif /* USE_TYPEDEF_DEFAULTS */
 
+/* 
+ * Including the bcmdefs.h here, to make sure everyone including typedefs.h
+ * gets this automatically
+*/
+#include <bcmdefs.h>
+
 #endif /* _TYPEDEFS_H_ */
--- src/include.1927/wlioctl.h	2004-10-14 23:11:36.000000000 +0400
+++ src/include/wlioctl.h	2007-11-19 06:40:31.000000000 +0300
@@ -20,35 +20,63 @@
 
 #include <typedefs.h>
 #include <proto/ethernet.h>
+#include <proto/bcmeth.h>
+#include <proto/bcmevent.h>
 #include <proto/802.11.h>
+#include <bcmwifi.h>
+
+#ifdef __NetBSD__
+/* NetBSD 2.0 does not have SIOCDEVPRIVATE. This is NetBSD 2.0 specific */
+#define SIOCDEVPRIVATE	_IOWR('i', 139, struct ifreq)
+#endif
 
 /* require default structure packing */
 #if !defined(__GNUC__)
-#pragma pack(push,8)
+#pragma pack(push, 8)
 #endif
 
-#define WL_NUMRATES		255	/* max # of rates in a rateset */
+/* Legacy structure to help keep backward compatible wl tool and tray app */
 
-typedef struct wl_rateset {
-	uint32	count;			/* # rates in this set */
-	uint8	rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
-} wl_rateset_t;
+#define	LEGACY_WL_BSS_INFO_VERSION	107	/* older version of wl_bss_info struct */
 
-#define WL_CHANSPEC_CHAN_MASK	0x0fff
-#define WL_CHANSPEC_BAND_MASK	0xf000
-#define WL_CHANSPEC_BAND_SHIFT	12
-#define WL_CHANSPEC_BAND_A	0x1000
-#define WL_CHANSPEC_BAND_B	0x2000
+typedef struct wl_bss_info_107 {
+	uint32		version;		/* version field */
+	uint32		length;			/* byte length of data in this record,
+						 * starting at version and including IEs
+						 */
+	struct ether_addr BSSID;
+	uint16		beacon_period;		/* units are Kusec */
+	uint16		capability;		/* Capability information */
+	uint8		SSID_len;
+	uint8		SSID[32];
+	struct {
+		uint	count;			/* # rates in this set */
+		uint8	rates[16];		/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;				/* supported rates */
+	uint8		channel;		/* Channel no. */
+	uint16		atim_window;		/* units are Kusec */
+	uint8		dtim_period;		/* DTIM period */
+	int16		RSSI;			/* receive signal strength (in dBm) */
+	int8		phy_noise;		/* noise (in dBm) */
+	uint32		ie_length;		/* byte length of Information Elements */
+	/* variable length Information Elements */
+} wl_bss_info_107_t;
 
 /*
  * Per-bss information structure.
  */
 
-#define	WL_BSS_INFO_VERSION		107	/* current version of wl_bss_info struct */
+#define	WL_BSS_INFO_VERSION	108		/* current version of wl_bss_info struct */
 
+/* BSS info structure
+ * Applications MUST CHECK ie_offset field and length field to access IEs and
+ * next bss_info structure in a vector (in wl_scan_results_t)
+ */
 typedef struct wl_bss_info {
 	uint32		version;	/* version field */
-	uint32		length;		/* byte length of data in this record, starting at version and including IEs */
+	uint32		length;			/* byte length of data in this record,
+						 * starting at version and including IEs
+						 */
 	struct ether_addr BSSID;
 	uint16		beacon_period;	/* units are Kusec */
 	uint16		capability;	/* Capability information */
@@ -58,12 +86,21 @@
 		uint	count;		/* # rates in this set */
 		uint8	rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;			/* supported rates */
-	uint8		channel;	/* Channel no. */
+	chanspec_t	chanspec;		/* chanspec for bss */
 	uint16		atim_window;	/* units are Kusec */
 	uint8		dtim_period;	/* DTIM period */
 	int16		RSSI;		/* receive signal strength (in dBm) */
 	int8		phy_noise;	/* noise (in dBm) */
+
+	bool		n_cap;			/* BSS is 802.11N Capable */
+	uint32		nbss_cap;		/* 802.11N BSS Capabilities (based on EWC_CAP_*) */
+	uint8		ctl_ch;			/* 802.11N BSS control channel number */
+	uint32		reserved[2];		/* Reserved for expansion of BSS properties */
+	uint8		basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+
+	uint16		ie_offset;		/* offset at which IEs start, from beginning */
 	uint32		ie_length;	/* byte length of Information Elements */
+	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_t;
 
@@ -72,21 +109,73 @@
 	uchar		SSID[32];
 } wlc_ssid_t;
 
+typedef struct chan_scandata {
+	uint8		txpower;
+	uint8		pad;
+	chanspec_t	channel;	/* Channel num, bw, ctrl_sb and band */
+	uint32		channel_mintime;
+	uint32		channel_maxtime;
+} chan_scandata_t;
+
+typedef enum wl_scan_type {
+	EXTDSCAN_BACKGROUND_SCAN,
+	EXTDSCAN_FOREGROUND_SCAN,
+	EXTDSCAN_FORCEDBACKGROUND_SCAN
+}wl_scan_type_t;
+
+#define WLC_EXTDSCAN_MAX_SSID		5
+#define WL_EXTDSCAN_PARAMS_FIXED_SIZE 	200
+
+typedef struct wl_extdscan_params {
+	int8 		nprobes;		/* 0, passive, otherwise active */
+	wl_scan_type_t	scan_type;		/* enum */
+	int8    	split_scan;		/* split scan */
+	int8		band;			/* band */
+	wlc_ssid_t 	ssid[WLC_EXTDSCAN_MAX_SSID]; /* ssid list */
+	int32 		channel_num;
+	chan_scandata_t channel_list[1];	/* list of chandata structs */
+} wl_extdscan_params_t;
+
 typedef struct wl_scan_params {
-	wlc_ssid_t ssid;	/* default is {0, ""} */
-	struct ether_addr bssid;/* default is bcast */
-	int8 bss_type;		/* default is any, DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT */
+	wlc_ssid_t ssid;		/* default: {0, ""} */
+	struct ether_addr bssid;	/* default: bcast */
+	int8 bss_type;			/* default: any,
+					 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
+					 */
 	int8 scan_type;		/* -1 use default, DOT11_SCANTYPE_ACTIVE/PASSIVE */
 	int32 nprobes;		/* -1 use default, number of probes per channel */
-	int32 active_time;	/* -1 use default, dwell time per channel for active scanning */
-	int32 passive_time;	/* -1 use default, dwell time per channel for passive scanning */
-	int32 home_time;	/* -1 use default, dwell time for the home channel between channel scans */
-	int32 channel_num;	/* 0 use default (all available channels), count of channels in channel_list */
+	int32 active_time;		/* -1 use default, dwell time per channel for
+					 * active scanning
+					 */
+	int32 passive_time;		/* -1 use default, dwell time per channel
+					 * for passive scanning
+					 */
+	int32 home_time;		/* -1 use default, dwell time for the home channel
+					 * between channel scans
+					 */
+	int32 channel_num;		/* 0 use default (all available channels), count of
+					 * channels in channel_list
+					 */
 	uint16 channel_list[1];	/* list of chanspecs */
 } wl_scan_params_t;
 /* size of wl_scan_params not including variable length array */
 #define WL_SCAN_PARAMS_FIXED_SIZE 64
 
+#define WL_SCAN_ACTION_START      1
+#define WL_SCAN_ACTION_CONTINUE   2
+
+#define ISCAN_REQ_VERSION 1
+
+/* incremental scan struct */
+typedef struct wl_iscan_params {
+	uint32 version;
+	uint16 action;
+	uint16 scan_duration;
+	wl_scan_params_t params;
+} wl_iscan_params_t;
+/* 3 fields + size of wl_scan_params, not including variable length array */
+#define WL_ISCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
+
 typedef struct wl_scan_results {
 	uint32 buflen;
 	uint32 version;
@@ -96,6 +185,27 @@
 /* size of wl_scan_results not including variable length array */
 #define WL_SCAN_RESULTS_FIXED_SIZE 12
 
+/* wl_iscan_results status values */
+#define WL_SCAN_RESULTS_SUCCESS	0
+#define WL_SCAN_RESULTS_PARTIAL	1
+#define WL_SCAN_RESULTS_PENDING	2
+#define WL_SCAN_RESULTS_ABORTED	3
+
+/* incremental scan results struct */
+typedef struct wl_iscan_results {
+	uint32 status;
+	wl_scan_results_t results;
+} wl_iscan_results_t;
+/* size of wl_iscan_results not including variable length array */
+#define WL_ISCAN_RESULTS_FIXED_SIZE \
+	(WL_SCAN_RESULTS_FIXED_SIZE + OFFSETOF(wl_iscan_results_t, results))
+
+#define WL_NUMRATES		255	/* max # of rates in a rateset */
+typedef struct wl_rateset {
+	uint32	count;			/* # rates in this set */
+	uint8	rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+} wl_rateset_t;
+
 /* uint32 list */
 typedef struct wl_uint32_list {
 	/* in - # of elements, out - # of entries */
@@ -106,6 +216,38 @@
 
 #define WLC_CNTRY_BUF_SZ	4		/* Country string is 3 bytes + NULL */
 
+/* defines used by the nrate iovar */
+#define NRATE_MCS_INUSE	0x00000080	/* MSC in use,indicates b0-6 holds an mcs */
+#define NRATE_RATE_MASK 0x0000007f	/* rate/mcs value */
+#define NRATE_STF_MASK	0x0000ff00	/* stf mode mask: siso, cdd, stbc, sdm */
+#define NRATE_STF_SHIFT	8		/* stf mode shift */
+#define NRATE_OVERRIDE	0x80000000	/* bit indicate override both rate & mode */
+
+#define NRATE_STF_SISO	0		/* stf mode SISO */
+#define NRATE_STF_CDD	1		/* stf mode CDD */
+#define NRATE_STF_STBC	2		/* stf mode STBC */
+#define NRATE_STF_SDM	3		/* stf mode SDM */
+
+#define ANTENNA_NUM_1	1		/* total number of antennas to be used */
+#define ANTENNA_NUM_2	2
+#define ANTENNA_NUM_3	3
+#define ANTENNA_NUM_4	4
+
+#define WL_ANTCFG_AUTO		0x80	/* bit indicate antenna sel AUTO */
+#define ANTSEL_CONFIG_MASK	0x33	/* antenna configuration mask */
+#define MAX_NUM_ANT_CFG		4	/* max number of antenna configuration */
+#define UNICAST_TXANT_CFG	0	/* unicast tx antenna configuration */
+#define UNICAST_RXANT_CFG	1	/* unicast rx antenna configuration */
+#define DEFAULT_TXANT_CFG	2	/* default tx antenna configuration */
+#define DEFAULT_RXANT_CFG	3	/* default rx antenna configuration */
+
+typedef struct {
+	uint8 ant_config[MAX_NUM_ANT_CFG];	/* antenna configuration */
+	uint8 num_antcfg;	/* number of available antenna configurations */
+} wlc_antselcfg_t;
+
+#define HIGHEST_SINGLE_STREAM_MCS	7 /* MCS values greater than this enable multiple streams */
+
 typedef struct wl_channels_in_country {
 	uint32 buflen;
 	uint32 band;
@@ -122,6 +264,7 @@
 	char country_abbrev[1];
 } wl_country_list_t;
 
+#define WL_NUM_RPI_BINS		8
 #define WL_RM_TYPE_BASIC	1
 #define WL_RM_TYPE_CCA		2
 #define WL_RM_TYPE_RPI		3
@@ -135,7 +278,7 @@
 typedef struct wl_rm_req_elt {
 	int8	type;
 	int8	flags;
-	uint16	chanspec;
+	chanspec_t	chanspec;
 	uint32	token;		/* token for this measurement */
 	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
 	uint32	tsf_l;		/* TSF low 32-bits */
@@ -144,15 +287,17 @@
 
 typedef struct wl_rm_req {
 	uint32	token;		/* overall measurement set token */
-	uint32	count;		/* number of measurement reqests */
+	uint32	count;		/* number of measurement requests */
+	void * cb;		/* completion callback function: may be NULL */
+	void *	cb_arg;	/* arg to completion callback function */
 	wl_rm_req_elt_t	req[1];	/* variable length block of requests */
 } wl_rm_req_t;
-#define WL_RM_REQ_FIXED_LEN	8
+#define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
 
 typedef struct wl_rm_rep_elt {
 	int8	type;
 	int8	flags;
-	uint16	chanspec;
+	chanspec_t	chanspec;
 	uint32	token;		/* token for this measurement */
 	uint32	tsf_h;		/* TSF high 32-bits of Measurement start time */
 	uint32	tsf_l;		/* TSF low 32-bits */
@@ -184,9 +329,10 @@
 	WLC_SUP_AUTHENTICATING,
 	WLC_SUP_AUTHENTICATED,
 	WLC_SUP_KEYXCHANGE,
-	WLC_SUP_KEYED
+	WLC_SUP_KEYED,
+	WLC_SUP_TIMEOUT
 } sup_auth_status_t;
-#endif	/* BCMCCX | BCMSUP_PSK */
+#endif	
 
 /* Enumerate crypto algorithms */
 #define	CRYPTO_ALGO_OFF			0
@@ -205,6 +351,7 @@
 #define WL_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
 #define WL_KF_RES_4	(1 << 4)	/* Reserved for backward compat */
 #define WL_KF_RES_5	(1 << 5)	/* Reserved for backward compat */
+#define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
 
 typedef struct wl_wsec_key {
 	uint32		index;		/* key index */
@@ -233,7 +379,7 @@
 /* Flag for key material needing passhash'ing */
 #define WSEC_PASSPHRASE		(1<<0)
 
-/* recepticle for WLC_SET_WSEC_PMK parameter */
+/* receptacle for WLC_SET_WSEC_PMK parameter */
 typedef struct {
 	ushort	key_len;		/* octets in key material */
 	ushort	flags;			/* key handling qualification */
@@ -241,19 +387,51 @@
 } wsec_pmk_t;
 
 /* wireless security bitvec */
-#define WEP_ENABLED		1
-#define TKIP_ENABLED		2
-#define AES_ENABLED		4
-#define WSEC_SWFLAG		8
+#define WEP_ENABLED		0x0001
+#define TKIP_ENABLED		0x0002
+#define AES_ENABLED		0x0004
+#define WSEC_SWFLAG		0x0008
+#define SES_OW_ENABLED		0x0040	/* to go into transition mode without setting wep */
+#define FIPS_ENABLED	0x0080
 
 /* WPA authentication mode bitvec */
 #define WPA_AUTH_DISABLED	0x0000	/* Legacy (i.e., non-WPA) */
 #define WPA_AUTH_NONE		0x0001	/* none (IBSS) */
 #define WPA_AUTH_UNSPECIFIED	0x0002	/* over 802.1x */
 #define WPA_AUTH_PSK		0x0004	/* Pre-shared key */
-/*#define WPA_AUTH_8021X 0x0020*/	/* 802.1x, reserved */
+/* #define WPA_AUTH_8021X 0x0020 */	/* 802.1x, reserved */
+#ifdef BCMWPA2
 #define WPA2_AUTH_UNSPECIFIED	0x0040	/* over 802.1x */
 #define WPA2_AUTH_PSK		0x0080	/* Pre-shared key */
+#define BRCM_AUTH_PSK          0x0100  /* BRCM specific PSK */
+#endif	/* BCMWPA2 */
+
+#ifdef BCMWPA2
+/* pmkid */
+#define	MAXPMKID		16	
+
+typedef struct _pmkid
+{
+	struct ether_addr	BSSID;
+	uint8			PMKID[WPA2_PMKID_LEN];
+} pmkid_t;
+
+typedef struct _pmkid_list
+{
+	uint32	npmkid;
+	pmkid_t	pmkid[1];
+} pmkid_list_t;
+
+typedef struct _pmkid_cand {
+	struct ether_addr	BSSID;
+	uint8			preauth;
+} pmkid_cand_t;
+
+typedef struct _pmkid_cand_list {
+	uint32	npmkid_cand;
+	pmkid_cand_t	pmkid_cand[1];
+} pmkid_cand_list_t;
+#endif	/* BCMWPA2 */
 
 typedef struct wl_led_info {
 	uint32		index;		/* led index */
@@ -261,74 +438,16 @@
 	bool		activehi;
 } wl_led_info_t;
 
-/*
- * definitions for driver messages passed from WL to NAS.
- */
-/* Use this to recognize wpa and 802.1x driver messages. */
-static const uint8 wl_wpa_snap_template[] =
-	{ 0xaa, 0xaa, 0x03, 0x00, 0x90, 0x4c };
-
-#define WL_WPA_MSG_IFNAME_MAX	16
-
-/* WPA driver message */
-typedef struct wl_wpa_header {
-	struct ether_header eth;
-	struct dot11_llc_snap_header snap;
-	uint8 version;
-	uint8 type;
-	/* version 2 additions */
-	char ifname[WL_WPA_MSG_IFNAME_MAX];
-	/* version specific data */
-	/* uint8 data[1]; */
-} wl_wpa_header_t;
-
-#define WL_WPA_HEADER_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN + 2 + WL_WPA_MSG_IFNAME_MAX)
-
-/* WPA driver message ethertype - private between wlc and nas */
-#define WL_WPA_ETHER_TYPE	0x9999
-
-/* WPA driver message current version */
-#define WL_WPA_MSG_VERSION	2
-
-/* Type field values for the 802.2 driver messages for WPA. */
-#define WLC_ASSOC_MSG		1
-#define WLC_DISASSOC_MSG	2
-#define WLC_PTK_MIC_MSG		3
-#define WLC_GTK_MIC_MSG		4
-
-/* 802.1x driver message */
-typedef struct wl_eapol_header {
-	struct ether_header eth;
-	struct dot11_llc_snap_header snap;
-	uint8 version;
-	uint8 reserved;
-	char ifname[WL_WPA_MSG_IFNAME_MAX];
-	/* version specific data */
-	/* uint8 802_1x_msg[1]; */
-} wl_eapol_header_t;
-
-#define WL_EAPOL_HEADER_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN + 2 + WL_WPA_MSG_IFNAME_MAX)
-
-/* 802.1x driver message ethertype - private between wlc and nas */
-#define WL_EAPOL_ETHER_TYPE	0x999A
-
-/* 802.1x driver message current version */
-#define WL_EAPOL_MSG_VERSION	1
-
-#define WL_SECPVT_DATA_LEN	(ETHER_HDR_LEN + 4 + WL_WPA_MSG_IFNAME_MAX)
-
-/* message header for the private data exchange between nas and wl*/
-typedef struct wl_secpvt_data {
-	struct ether_header eth; /* use the Type field in the eth header with the private type*/
-	uint8 version;
-	uint8 sub_type;
-	uint16 data_len;
-	char ifname[WL_WPA_MSG_IFNAME_MAX];
-	/* version specific data */
-	/* uint8 802_1x_msg[1]; */
-}wl_secpvt_data_t;
-
-
+typedef struct wlc_assoc_info {
+	uint32		req_len;
+	uint32		resp_len;
+	uint32		flags;
+	struct dot11_assoc_req req;
+	struct ether_addr reassoc_bssid; /* used in reassoc's */
+	struct dot11_assoc_resp resp;
+} wl_assoc_info_t;
+/* flags */
+#define WLC_ASSOC_REQ_IS_REASSOC 0x01 /* assoc req was actually a reassoc */
 /* srom read/write struct passed through ioctl */
 typedef struct {
 	uint	byteoff;		/* byte offset */
@@ -341,115 +460,98 @@
 	uint32	byteoff;	/* byte offset of the field in d11regs_t */
 	uint32	val;		/* read/write value of the field */
 	uint32	size;		/* sizeof the field */
+	uint	band;		/* band (optional) */
 } rw_reg_t;
 
-/* Structure used by GET/SET_ATTEN ioctls */
+/* Structure used by GET/SET_ATTEN ioctls - it controls power in b/g-band */
+/* PCL - Power Control Loop */
+/* current gain setting is replaced by user input */
+#define WL_ATTEN_APP_INPUT_PCL_OFF	0	/* turn off PCL, apply supplied input */
+#define WL_ATTEN_PCL_ON			1	/* turn on PCL */
+/* current gain setting is maintained */
+#define WL_ATTEN_PCL_OFF		2	/* turn off PCL. */
 typedef struct {
-	uint16	auto_ctrl;	/* 1: Automatic control, 0: overriden */
+	uint16	auto_ctrl;	/* WL_ATTEN_XX */
 	uint16	bb;		/* Baseband attenuation */
 	uint16	radio;		/* Radio attenuation */
 	uint16	txctl1;		/* Radio TX_CTL1 value */
 } atten_t;
 
+/* Per-AC retry parameters */
+struct wme_tx_params_s {
+	uint8  short_retry;
+	uint8  short_fallback;
+	uint8  long_retry;
+	uint8  long_fallback;
+	uint16 max_rate;  /* In units of 512 Kbps */
+};
+typedef struct wme_tx_params_s wme_tx_params_t;
+#define WL_WME_TX_PARAMS_IO_BYTES (sizeof(wme_tx_params_t) * AC_COUNT)
+
+/* defines used by poweridx iovar - it controls power in a-band */
+/* current gain setting is maintained */
+#define WL_PWRIDX_PCL_OFF	-2	/* turn off PCL.  */
+#define WL_PWRIDX_PCL_ON	-1	/* turn on PCL */
+#define WL_PWRIDX_LOWER_LIMIT	-2	/* lower limit */
+#define WL_PWRIDX_UPPER_LIMIT	63	/* upper limit */
+/* value >= 0 causes
+ *	- input to be set to that value
+ *	- PCL to be off
+ */
+
 /* Used to get specific STA parameters */
 typedef struct {
 	uint32	val;
 	struct ether_addr ea;
 } scb_val_t;
 
-/* Event data type */
-typedef struct {
-	uint msg;			/* Message (see below) */
-	struct ether_addr *addr;	/* Station address (if applicable) */
-	uint status;			/* Status code (see below) */
-	uint reason;			/* Reason code (if applicable) */
-	uint auth_type;			/* WLC_E_AUTH */
-	bool link;			/* WLC_E_LINK */
-	bool group;			/* WLC_E_MIC_ERROR */
-	bool flush_txq;			/* WLC_E_MIC_ERROR */
-} wlc_event_t;
+#define BCM_MAC_STATUS_INDICATION	(0x40010200L)
 
+/* Please update the following when modifying this structure:
+ *   StaInfo Twiki page flags section - description of the sta_info_t struct
+ *    src/wl/exe/wlu.c - print of sta_info_t
+ * Pay attention to version if structure changes.
+ */
 typedef struct {
 	uint16		ver;		/* version of this struct */
 	uint16		len;		/* length in bytes of this structure */
-	uint16		cap;		/* sta's advertized capabilities */
+	uint16			cap;		/* sta's advertised capabilities */
 	uint32		flags;		/* flags defined below */
 	uint32		idle;		/* time since data pkt rx'd from sta */
 	struct ether_addr	ea;	/* Station address */
 	wl_rateset_t	rateset;	/* rateset in use */
 	uint32		in;		/* seconds elapsed since associated */
-	uint32		listen_interval_inms; /* Min Listen interval in ms for this STA*/
+	uint32			listen_interval_inms; /* Min Listen interval in ms for this STA */
+	uint32			tx_pkts;	/* # of packets transmitted */
+	uint32			tx_failures;	/* # of packets failed */
+	uint32			rx_ucast_pkts;	/* # of unicast packets received */
+	uint32			rx_mcast_pkts;	/* # of multicast packets received */
+	uint32			tx_rate;	/* Rate of last successful tx frame */
+	uint32			rx_rate;	/* Rate of last successful rx frame */
 } sta_info_t;
 
+#define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
+
 #define WL_STA_VER	2
 
-/* flags fields */
-#define WL_STA_BRCM	0x01
-#define WL_STA_WME	0x02
-#define WL_STA_ABCAP	0x04
-#define WL_STA_AUTHE	0x08
-#define WL_STA_ASSOC	0x10
-#define WL_STA_AUTHO	0x20
-#define WL_STA_WDS	0x40
-#define WL_WDS_LINKUP	0x80
-
-/* Event messages */
-#define WLC_E_SET_SSID		1
-#define WLC_E_JOIN		2
-#define WLC_E_START		3
-#define WLC_E_AUTH		4
-#define WLC_E_AUTH_IND		5
-#define WLC_E_DEAUTH		6
-#define WLC_E_DEAUTH_IND	7
-#define WLC_E_ASSOC		8
-#define WLC_E_ASSOC_IND		9
-#define WLC_E_REASSOC		10
-#define WLC_E_REASSOC_IND	11
-#define WLC_E_DISASSOC		12
-#define WLC_E_DISASSOC_IND	13
-#define WLC_E_QUIET_START	14	/* 802.11h Quiet period started */
-#define WLC_E_QUIET_END		15	/* 802.11h Quiet period ended */
-#define WLC_E_GOT_BEACONS	16
-#define WLC_E_LINK		17	/* Link indication */
-#define WLC_E_MIC_ERROR		18	/* TKIP MIC error occurred */
-#define WLC_E_NDIS_LINK		19	/* NDIS style link indication */
-#define WLC_E_ROAM		20
-#define WLC_E_TXFAIL		21	/* dot11FailedCount (txfail) */
-#define WLC_E_LAST		22
-
-/* Event status codes */
-#define WLC_E_STATUS_SUCCESS		0
-#define WLC_E_STATUS_FAIL		1
-#define WLC_E_STATUS_TIMEOUT		2
-#define WLC_E_STATUS_NO_NETWORKS	3
-#define WLC_E_STATUS_ABORT		4
-
-typedef struct wlc_event_cb {
-	uint msg;				/* Event message or 0 for all */
-	void (*fn)(void *, wlc_event_t *);	/* Callback function */
-	void *context;				/* Passed to callback function */
-	struct wlc_event_cb *next;		/* Next in the chain */
-} wlc_event_cb_t;
+/* Flags for sta_info_t indicating properties of STA */
+#define WL_STA_BRCM		0x1		/* Running a Broadcom driver */
+#define WL_STA_WME		0x2		/* WMM association */
+#define WL_STA_ABCAP		0x4		/* Afterburner-capable */
+#define WL_STA_AUTHE		0x8		/* Authenticated */
+#define WL_STA_ASSOC		0x10		/* Associated */
+#define WL_STA_AUTHO		0x20		/* Authorized */
+#define WL_STA_WDS		0x40		/* Wireless Distribution System */
+#define WL_STA_WDS_LINKUP	0x80		/* WDS traffic/probes flowing properly */
+#define WL_STA_PS		0x100		/* STA is in power save mode from AP's viewpoint */
+#define WL_STA_APSD_BE		0x200		/* APSD delv/trigger for AC_BE is default enabled */
+#define WL_STA_APSD_BK		0x400		/* APSD delv/trigger for AC_BK is default enabled */
+#define WL_STA_APSD_VI		0x800		/* APSD delv/trigger for AC_VI is default enabled */
+#define WL_STA_APSD_VO		0x1000		/* APSD delv/trigger for AC_VO is default enabled */
+#define WL_STA_N_CAP		0x2000		/* STA 802.11n capable */
+#define WL_STA_SCBSTATS		0x4000		/* Per STA debug stats */
 
-/*
- * Country locale determines which channels are available to us.
- */
-typedef enum _wlc_locale {
-	WLC_WW = 0,	/* Worldwide */
-	WLC_THA,	/* Thailand */
-	WLC_ISR,	/* Israel */
-	WLC_JDN,	/* Jordan */
-	WLC_PRC,	/* China */
-	WLC_JPN,	/* Japan */
-	WLC_FCC,	/* USA */
-	WLC_EUR,	/* Europe */
-	WLC_USL,	/* US Low Band only */
-	WLC_JPH,	/* Japan High Band only */
-	WLC_ALL,	/* All the channels in this band */
-	WLC_11D,	/* Represents locale recieved by 11d beacons */
-	WLC_LAST_LOCALE,
-	WLC_UNDEFINED_LOCALE = 0xf
-} wlc_locale_t;
+#define WL_WDS_LINKUP		WL_STA_WDS_LINKUP	/* deprecated */
 
 /* channel encoding */
 typedef struct channel_info {
@@ -470,6 +572,7 @@
 	uint rx_bad_pkt;
 	uint tx_good_pkt;
 	uint tx_bad_pkt;
+	uint rx_ocast_good_pkt; /* unicast packets destined for others */
 } get_pktcnt_t;
 
 /* Linux network driver ioctl encoding */
@@ -501,6 +604,27 @@
 	uint		chipnum;	/* chip number */
 } wlc_rev_info_t;
 
+#define WL_BRAND_MAX 10
+typedef struct wl_instance_info {
+	uint instance;
+	char brand[WL_BRAND_MAX];
+} wl_instance_info_t;
+
+/* structure to change size of tx fifo */
+typedef struct wl_txfifo_sz {
+	uint8	fifo;
+	uint8	size;
+} wl_txfifo_sz_t;
+
+/* Transfer info about an IOVar from the driver */
+/* Max supported IOV name size in bytes, + 1 for null termination */
+#define WLC_IOV_NAME_LEN 30
+typedef struct wlc_iov_trx_s {
+	uint8 module;
+	uint8 type;
+	char name[WLC_IOV_NAME_LEN];
+} wlc_iov_trx_t;
+
 /* check this magic number */
 #define WLC_IOCTL_MAGIC		0x14e46c77
 
@@ -521,12 +645,12 @@
 #define WLC_GET_PROMISC				9
 #define WLC_SET_PROMISC				10
 #define WLC_GET_RATE				12
-#define WLC_SET_RATE				13
+/* #define WLC_SET_RATE				13 */ /* no longer supported */
 #define WLC_GET_INSTANCE			14
-#define WLC_GET_FRAG				15
-#define WLC_SET_FRAG				16
-#define WLC_GET_RTS				17
-#define WLC_SET_RTS				18
+/* #define WLC_GET_FRAG				15 */ /* no longer supported */
+/* #define WLC_SET_FRAG				16 */ /* no longer supported */
+/* #define WLC_GET_RTS				17 */ /* no longer supported */
+/* #define WLC_SET_RTS				18 */ /* no longer supported */
 #define WLC_GET_INFRA				19
 #define WLC_SET_INFRA				20
 #define WLC_GET_AUTH				21
@@ -547,10 +671,12 @@
 #define WLC_GET_RADIO				37
 #define WLC_SET_RADIO				38
 #define WLC_GET_PHYTYPE				39
-#define WLC_GET_WEP				42
-#define WLC_SET_WEP				43
+/* #define WLC_GET_WEP				42 */ /* no longer supported */
+/* #define WLC_SET_WEP				43 */ /* no longer supported */
 #define WLC_GET_KEY				44
 #define WLC_SET_KEY				45
+#define WLC_GET_REGULATORY			46
+#define WLC_SET_REGULATORY			47
 #define WLC_SCAN				50
 #define WLC_SCAN_RESULTS			51
 #define WLC_DISASSOC				52
@@ -561,16 +687,16 @@
 #define WLC_SET_TXANT				62
 #define WLC_GET_ANTDIV				63
 #define WLC_SET_ANTDIV				64
-#define WLC_GET_TXPWR				65
-#define WLC_SET_TXPWR				66
+/* #define WLC_GET_TXPWR			65 */ /* no longer supported */
+/* #define WLC_SET_TXPWR			66 */ /* no longer supported */
 #define WLC_GET_CLOSED				67
 #define WLC_SET_CLOSED				68
 #define WLC_GET_MACLIST				69
 #define WLC_SET_MACLIST				70
 #define WLC_GET_RATESET				71
 #define WLC_SET_RATESET				72
-#define WLC_GET_LOCALE				73
-#define WLC_SET_LOCALE				74
+/* #define WLC_GET_LOCALE			73 */ /* no longer supported */
+#define WLC_LONGTRAIN				74
 #define WLC_GET_BCNPRD				75
 #define WLC_SET_BCNPRD				76
 #define WLC_GET_DTIMPRD				77
@@ -613,8 +739,8 @@
 #define WLC_GET_GMODE_PROTECTION_OVERRIDE	150
 #define WLC_SET_GMODE_PROTECTION_OVERRIDE	151
 #define WLC_UPGRADE				152
-#define WLC_GET_MRATE				153
-#define WLC_SET_MRATE				154
+/* #define WLC_GET_MRATE			153 */ /* no longer supported */
+/* #define WLC_SET_MRATE			154 */ /* no longer supported */
 #define WLC_GET_ASSOCLIST			159
 #define WLC_GET_CLK				160
 #define WLC_SET_CLK				161
@@ -622,12 +748,12 @@
 #define WLC_OUT					163
 #define WLC_GET_WPA_AUTH			164
 #define WLC_SET_WPA_AUTH			165
-#define WLC_GET_GMODE_PROTECTION_CONTROL	178
-#define WLC_SET_GMODE_PROTECTION_CONTROL	179
+#define WLC_GET_PROTECTION_CONTROL		178
+#define WLC_SET_PROTECTION_CONTROL		179
 #define WLC_GET_PHYLIST				180
 #define WLC_GET_KEY_SEQ				183
-#define WLC_GET_GMODE_PROTECTION_CTS		198
-#define WLC_SET_GMODE_PROTECTION_CTS		199
+/* #define WLC_GET_GMODE_PROTECTION_CTS		198 */ /* no longer supported */
+/* #define WLC_SET_GMODE_PROTECTION_CTS		199 */ /* no longer supported */
 #define WLC_GET_PIOMODE				203
 #define WLC_SET_PIOMODE				204
 #define WLC_SET_LED				209
@@ -641,20 +767,36 @@
 #define WLC_SET_WET				231
 #define WLC_GET_KEY_PRIMARY			235
 #define WLC_SET_KEY_PRIMARY			236
-#define WLC_WDS_GET_REMOTE_HWADDR		246	/* currently handled in wl_linux.c/wl_vx.c */
+#define WLC_GET_RADAR				242
+#define WLC_SET_RADAR				243
+#define WLC_SET_SPECT_MANAGMENT			244
+#define WLC_GET_SPECT_MANAGMENT			245
+#define WLC_WDS_GET_REMOTE_HWADDR		246	/* handled in wl_linux.c/wl_vx.c */
 #define WLC_SET_CS_SCAN_TIMER			248
 #define WLC_GET_CS_SCAN_TIMER			249
+#define WLC_SEND_PWR_CONSTRAINT			254
 #define WLC_CURRENT_PWR				256
 #define WLC_GET_CHANNELS_IN_COUNTRY		260
 #define WLC_GET_COUNTRY_LIST			261
 #define WLC_GET_VAR				262	/* get value of named variable */
 #define WLC_SET_VAR				263	/* set named variable to value */
-#define WLC_NVRAM_GET				264
+#define WLC_NVRAM_GET				264	/* deprecated */
 #define WLC_NVRAM_SET				265
 #define WLC_SET_WSEC_PMK			268
 #define WLC_GET_AUTH_MODE			269
 #define WLC_SET_AUTH_MODE			270
-#define WLC_LAST				273	/* do not change - use get_var/set_var */
+#define WLC_NDCONFIG_ITEM			273	/* currently handled in wl_oid.c */
+#define WLC_NVOTPW				274
+#define WLC_OTPW				275
+#define WLC_IOV_BLOCK_GET			276
+#define WLC_IOV_MODULES_GET			277
+#define WLC_SOFT_RESET				278
+#define WLC_GET_ALLOW_MODE			279
+#define WLC_SET_ALLOW_MODE			280
+#define WLC_GET_DESIRED_BSSID			281
+#define WLC_SET_DESIRED_BSSID			282
+#define	WLC_DISASSOC_MYAP			283
+#define WLC_LAST				284	/* do not change - use get_var/set_var */
 
 /*
  * Minor kludge alert:
@@ -684,6 +826,7 @@
 
 /* NDIS overrides */
 #define OID_WL_GETINSTANCE	(WL_OID_BASE + WLC_GET_INSTANCE)
+#define OID_WL_NDCONFIG_ITEM (WL_OID_BASE + WLC_NDCONFIG_ITEM)
 
 #define WL_DECRYPT_STATUS_SUCCESS	1
 #define WL_DECRYPT_STATUS_FAILURE	2
@@ -693,24 +836,59 @@
 #define WLC_UPGRADE_SUCCESS			0
 #define WLC_UPGRADE_PENDING			1
 
+#ifdef CONFIG_USBRNDIS_RETAIL
+/* struct passed in for WLC_NDCONFIG_ITEM */
+typedef struct {
+	char *name;
+	void *param;
+} ndconfig_item_t;
+#endif
+
 /* Bit masks for radio disabled status - returned by WL_GET_RADIO */
 #define WL_RADIO_SW_DISABLE		(1<<0)
 #define WL_RADIO_HW_DISABLE		(1<<1)
-#define WL_RADIO_UNASSOC_DISABLE	(1<<2)
+#define WL_RADIO_MPC_DISABLE		(1<<2)
+#define WL_RADIO_COUNTRY_DISABLE	(1<<3)	/* some countries don't support any channel */
 
 /* Override bit for WLC_SET_TXPWR.  if set, ignore other level limits */
 #define WL_TXPWR_OVERRIDE	(1<<31)
 
+/* "diag" iovar argument and error code */
+#define WL_DIAG_INTERRUPT			1	/* d11 loopback interrupt test */
+#define WL_DIAG_MEMORY				3	/* d11 memory test */
+#define WL_DIAG_LED				4	/* LED test */
+#define WL_DIAG_REG				5	/* d11/phy register test */
+#define WL_DIAG_SROM				6	/* srom read/crc test */
+#define WL_DIAG_DMA				7	/* DMA test */
+
+#define WL_DIAGERR_SUCCESS			0
+#define WL_DIAGERR_FAIL_TO_RUN			1	/* unable to run requested diag */
+#define WL_DIAGERR_NOT_SUPPORTED		2	/* diag requested is not supported */
+#define WL_DIAGERR_INTERRUPT_FAIL		3	/* loopback interrupt test failed */
+#define WL_DIAGERR_LOOPBACK_FAIL		4	/* loopback data test failed */
+#define WL_DIAGERR_SROM_FAIL			5	/* srom read failed */
+#define WL_DIAGERR_SROM_BADCRC			6	/* srom crc failed */
+#define WL_DIAGERR_REG_FAIL			7	/* d11/phy register test failed */
+#define WL_DIAGERR_MEMORY_FAIL			8	/* d11 memory test failed */
+#define WL_DIAGERR_NOMEM			9	/* diag test failed due to no memory */
+#define WL_DIAGERR_DMA_FAIL			10	/* DMA test failed */
 
-/* Bus types */
-#define WL_SB_BUS	0	/* Silicon Backplane */
-#define WL_PCI_BUS	1	/* PCI target */
-#define WL_PCMCIA_BUS	2	/* PCMCIA target */
+#define WL_DIAGERR_MEMORY_TIMEOUT		11	/* d11 memory test didn't finish in time */
+#define WL_DIAGERR_MEMORY_BADPATTERN		12	/* d11 memory test result in bad pattern */
 
 /* band types */
 #define	WLC_BAND_AUTO		0	/* auto-select */
-#define	WLC_BAND_A		1	/* "a" band (5 Ghz) */
-#define	WLC_BAND_B		2	/* "b" band (2.4 Ghz) */
+#define	WLC_BAND_5G		1	/* 5 Ghz */
+#define	WLC_BAND_2G		2	/* 2.4 Ghz */
+#define	WLC_BAND_ALL		3	/* all bands */
+
+/* phy types (returned by WLC_GET_PHYTPE) */
+#define	WLC_PHY_TYPE_A		0
+#define	WLC_PHY_TYPE_B		1
+#define	WLC_PHY_TYPE_G		2
+#define	WLC_PHY_TYPE_N		4
+#define	WLC_PHY_TYPE_LP		5
+#define	WLC_PHY_TYPE_NULL	0xf
 
 /* MAC list modes */
 #define WLC_MACMODE_DISABLED	0	/* MAC list disabled */
@@ -733,15 +911,50 @@
 #define WLC_PLCP_SHORT	0
 #define WLC_PLCP_LONG	1
 
-/* values for g_protection_override */
-#define WLC_G_PROTECTION_AUTO	-1
-#define WLC_G_PROTECTION_OFF	0
-#define WLC_G_PROTECTION_ON	1
-
-/* values for g_protection_control */
-#define WLC_G_PROTECTION_CTL_OFF	0
-#define WLC_G_PROTECTION_CTL_LOCAL	1
-#define WLC_G_PROTECTION_CTL_OVERLAP	2
+/* values for g_protection_override and n_protection_override */
+#define WLC_PROTECTION_AUTO		-1
+#define WLC_PROTECTION_OFF		0
+#define WLC_PROTECTION_ON		1
+#define WLC_PROTECTION_MMHDR_ONLY	2
+#define WLC_PROTECTION_CTS_ONLY		3
+
+/* values for g_protection_control and n_protection_control */
+#define WLC_PROTECTION_CTL_OFF		0
+#define WLC_PROTECTION_CTL_LOCAL	1
+#define WLC_PROTECTION_CTL_OVERLAP	2
+
+/* deprecated const names for g_protection_override */
+#define WLC_G_PROTECTION_AUTO		WLC_PROTECTION_AUTO
+#define WLC_G_PROTECTION_OFF		WLC_PROTECTION_OFF
+#define WLC_G_PROTECTION_ON		WLC_PROTECTION_ON
+
+/* deprecated const names for g_protection_control */
+#define WLC_G_PROTECTION_CTL_OFF	WLC_PROTECTION_CTL_OFF
+#define WLC_G_PROTECTION_CTL_LOCAL	WLC_PROTECTION_CTL_LOCAL
+#define WLC_G_PROTECTION_CTL_OVERLAP	WLC_PROTECTION_CTL_OVERLAP
+
+/* deprecated const names for get/set g_protection_control */
+#define WLC_GET_GMODE_PROTECTION_CONTROL	WLC_GET_PROTECTION_CONTROL
+#define WLC_SET_GMODE_PROTECTION_CONTROL	WLC_SET_PROTECTION_CONTROL
+
+/* values for n_protection */
+#define WLC_N_PROTECTION_OFF		0
+#define WLC_N_PROTECTION_OPTIONAL	1
+#define WLC_N_PROTECTION_20IN40		2
+#define WLC_N_PROTECTION_MIXEDMODE	3
+
+/* values for n_preamble_type */
+#define WLC_N_PREAMBLE_MIXEDMODE	0
+#define WLC_N_PREAMBLE_GF		1
+
+/* values for band specific 40MHz capabilities */
+#define WLC_N_BW_20ALL			0
+#define WLC_N_BW_40ALL			1
+#define WLC_N_BW_20IN2G_40IN5G		2
+
+/* values to force tx/rx chain */
+#define WLC_N_TXRX_CHAIN0		0
+#define WLC_N_TXRX_CHAIN1		1
 
 /* Values for PM */
 #define PM_OFF	0
@@ -750,21 +963,134 @@
 
 
 
+#define WL_ACI_ARGS_LEGACY_LENGTH	16	/* bytes of pre NPHY aci args */
+
+/* Begin: wl_radar_args_t */
+typedef struct {
+	int npulses; 	/* required number of pulses at n * t_int */
+	int ncontig; 	/* required number of pulses at t_int */
+	int min_pw; 	/* minimum pulse width (20 MHz clocks) */
+	int max_pw; 	/* maximum pulse width (20 MHz clocks) */
+	uint16 thresh0;	/* Radar detection, thresh 0 */
+	uint16 thresh1;	/* Radar detection, thresh 1 */
+	uint16 blank;	/* Radar detection, blank control */
+	uint16 fmdemodcfg;	/* Radar detection, fmdemod config */
+	int npulses_lp;  /* Radar detection, minimum long pulses */
+	int min_pw_lp; /* Minimum pulsewidth for long pulses */
+	int max_pw_lp; /* Maximum pulsewidth for long pulses */
+	int min_fm_lp; /* Minimum fm for long pulses */
+	int max_deltat_lp;  /* Maximum deltat for long pulses */
+	int min_deltat; /* Minimum spacing between pulses */
+	int max_deltat; /* Maximum spacing between pulses */
+	uint16 autocorr;        /* Radar detection, autocorr on or off */
+	uint16 st_level_time;   /* Radar detection, start_timing level */
+	uint32 version; /* version */
+} wl_radar_args_t;
+/* End: wl_radar_args_t */
+#define WL_RADAR_ARGS_VERSION 1
+
+typedef struct {
+	uint32 version; /* version */
+	uint16 thresh0_20_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 20MHz */
+	uint16 thresh1_20_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 20MHz */
+	uint16 thresh0_40_lo;	/* Radar detection, thresh 0 (range 5250-5350MHz) for BW 40MHz */
+	uint16 thresh1_40_lo;	/* Radar detection, thresh 1 (range 5250-5350MHz) for BW 40MHz */
+	uint16 thresh0_20_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 20MHz */
+	uint16 thresh1_20_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 20MHz */
+	uint16 thresh0_40_hi;	/* Radar detection, thresh 0 (range 5470-5725MHz) for BW 40MHz */
+	uint16 thresh1_40_hi;	/* Radar detection, thresh 1 (range 5470-5725MHz) for BW 40MHz */
+} wl_radar_thr_t;
+#define WL_RADAR_THR_VERSION 1
+#define WL_THRESHOLD_LO_BAND	70	/* range from 5250MHz - 5350MHz */
+
+/* radar iovar SET defines */
+#define WL_RADAR_DETECTOR_OFF		0	/* radar detector off */
+#define WL_RADAR_DETECTOR_ON		1	/* radar detector on */
+#define WL_RADAR_SIMULATED		2	/* force radar detector to declare
+						 * detection once
+						 */
+
+#define WL_RSSI_ANT_VERSION	1	/* current version of wl_rssi_ant_t */
+#define WL_RSSI_ANT_MAX		4	/* max possible rx antennas */
+
+/* RSSI per antenna */
+typedef struct {
+	uint32	version;		/* version field */
+	uint32	count;			/* number of valid antenna rssi */
+	int8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
+} wl_rssi_ant_t;
 
 
-/* 802.11h enforcement levels */
-#define SPECT_MNGMT_OFF		0		/* 11h disabled */
-#define SPECT_MNGMT_LOOSE	1		/* qllow scan lists to contain non-11h AP */
-#define SPECT_MNGMT_STRICT	2		/* prune out non-11h APs from scan list */
+/* dfs_status iovar-related defines */
 
+/* cac - channel availability check,
+ * ism - in-service monitoring
+ * csa - channel switching announcement
+ */
+
+/* cac state values */
+#define WL_DFS_CACSTATE_IDLE		0	/* state for operating in non-radar channel */
+#define	WL_DFS_CACSTATE_PREISM_CAC	1	/* CAC in progress */
+#define WL_DFS_CACSTATE_ISM		2	/* ISM in progress */
+#define WL_DFS_CACSTATE_CSA		3	/* csa */
+#define WL_DFS_CACSTATE_POSTISM_CAC	4	/* ISM CAC */
+#define WL_DFS_CACSTATE_PREISM_OOC	5	/* PREISM OOC */
+#define WL_DFS_CACSTATE_POSTISM_OOC	6	/* POSTISM OOC */
+#define WL_DFS_CACSTATES		7	/* this many states exist */
+
+/* data structure used in 'dfs_status' wl interface, which is used to query dfs status */
+typedef struct {
+	uint state;		/* noted by WL_DFS_CACSTATE_XX. */
+	uint duration;		/* time spent in ms in state. */
+	/* as dfs enters ISM state, it removes the operational channel from quiet channel
+	 * list and notes the channel in channel_cleared. set to 0 if no channel is cleared
+	 */
+	chanspec_t chanspec_cleared;
+	/* chanspec cleared used to be a uint, add another to uint16 to maintain size */
+	uint16 pad;
+} wl_dfs_status_t;
+
+
+
+typedef struct tx_inst_power {
+	uint8 txpwr_est_Pout[2];			/* Latest estimate for 2.4 and 5 Ghz */
+	uint8 txpwr_est_Pout_gofdm;			/* Pwr estimate for 2.4 OFDM */
+} tx_inst_power_t;
+
+
+/* regulatory enforcement levels */
+#define SPECT_MNGMT_OFF			0		/* both 11h and 11d disabled */
+#define SPECT_MNGMT_LOOSE_11H		1		/* allow non-11h APs in scan lists */
+#define SPECT_MNGMT_STRICT_11H		2		/* prune out non-11h APs from scan list */
+#define SPECT_MNGMT_STRICT_11D		3		/* switch to 802.11D mode */
+/* SPECT_MNGMT_LOOSE_11H_D - same as SPECT_MNGMT_LOOSE with the exception that Country IE
+ * adoption is done irregardless of capability-spectrum_management
+ */
+#define SPECT_MNGMT_LOOSE_11H_D		4		/* operation defined above */
 
 #define WL_CHAN_VALID_HW	(1 << 0)	/* valid with current HW */
 #define WL_CHAN_VALID_SW	(1 << 1)	/* valid with current country setting */
-#define WL_CHAN_BAND_A		(1 << 2)	/* A-band channel */
+#define WL_CHAN_BAND_5G		(1 << 2)	/* 5GHz-band channel */
 #define WL_CHAN_RADAR		(1 << 3)	/* radar sensitive  channel */
-#define WL_CHAN_INACTIVE	(1 << 4)	/* temporarily out of service due to radar */
-#define WL_CHAN_RADAR_PASSIVE	(1 << 5)	/* radar channel is in passive mode */
-
+#define WL_CHAN_INACTIVE	(1 << 4)	/* temporarily inactive due to radar */
+#define WL_CHAN_PASSIVE		(1 << 5)	/* channel is in passive mode */
+#define WL_CHAN_RESTRICTED	(1 << 6)	/* restricted use channel */
+
+/* BTC mode used by "btc_mode" iovar */
+#define	WL_BTC_DISABLE		0	/* disable BT coexistence */
+#define WL_BTC_ENABLE		1	/* enable BT coexistence */
+#define WL_BTC_PREMPT		2	/* enable BT coexistence and BT preemption */
+
+#define WL_PHYCAL_VAL		0x00100000
+#define WL_MPC_VAL		0x00400000
+#define WL_APSTA_VAL		0x00800000
+#define WL_DFS_VAL		0x01000000
+#define WL_BA_VAL		0x02000000
+#define WL_MBSS_VAL		0x04000000
+#define WL_CAC_VAL		0x08000000
+#define WL_AMSDU_VAL		0x10000000
+#define WL_AMPDU_VAL		0x20000000
+#define WL_FFPLD_VAL		0x40000000
 
 /* max # of leds supported by GPIO (gpio pin# == led index#) */
 #define	WL_LED_NUMGPIO		16	/* gpio 0-15 */
@@ -782,44 +1090,639 @@
 #define	WL_LED_WI3		9		
 #define	WL_LED_ASSOC		10		/* associated state indicator */
 #define	WL_LED_INACTIVE		11		/* null behavior (clears default behavior) */
-#define	WL_LED_NUMBEHAVIOR	12
+#define	WL_LED_ASSOCACT		12		/* on when associated; blink fast for activity */
+#define	WL_LED_NUMBEHAVIOR	13
 
 /* led behavior numeric value format */
 #define	WL_LED_BEH_MASK		0x7f		/* behavior mask */
 #define	WL_LED_AL_MASK		0x80		/* activelow (polarity) bit */
 
+#define WL_NUMCHANSPECS		100
 
 /* WDS link local endpoint WPA role */
 #define WL_WDS_WPA_ROLE_AUTH	0	/* authenticator */
 #define WL_WDS_WPA_ROLE_SUP	1	/* supplicant */
 #define WL_WDS_WPA_ROLE_AUTO	255	/* auto, based on mac addr value */
 
+/* number of bytes needed to define a 128-bit mask for MAC event reporting */
+#define WL_EVENTING_MASK_LEN	16
+
 /* Structures and constants used for "vndr_ie" IOVar interface */
-#define VNDR_IE_CMD_LEN		4	/* length of the set command string: "add", "del" (+ NULL) */
+#define VNDR_IE_CMD_LEN		4	/* length of the set command string:
+					 * "add", "del" (+ NULL)
+					 */
 
 /* 802.11 Mgmt Packet flags */
 #define VNDR_IE_BEACON_FLAG	0x1
 #define VNDR_IE_PRBRSP_FLAG	0x2
 #define VNDR_IE_ASSOCRSP_FLAG	0x4
 #define VNDR_IE_AUTHRSP_FLAG	0x8
+#define VNDR_IE_PRBREQ_FLAG	0x10
+#define VNDR_IE_ASSOCREQ_FLAG	0x20
 
-typedef struct vndr_ie_info {
+#define VNDR_IE_INFO_HDR_LEN	(sizeof(uint32))
+
+typedef struct {
 	uint32 pktflag;			/* bitmask indicating which packet(s) contain this IE */
 	vndr_ie_t vndr_ie_data;		/* vendor IE data */
 } vndr_ie_info_t;
 
-typedef struct vndr_ie_buf {
+typedef struct {
 	int iecount;			/* number of entries in the vndr_ie_list[] array */
 	vndr_ie_info_t vndr_ie_list[1];	/* variable size list of vndr_ie_info_t structs */
 } vndr_ie_buf_t;
 
-typedef struct vndr_ie_setbuf {
+typedef struct {
 	char cmd[VNDR_IE_CMD_LEN];	/* vndr_ie IOVar set command : "add", "del" + NULL */
 	vndr_ie_buf_t vndr_ie_buffer;	/* buffer containing Vendor IE list information */
 } vndr_ie_setbuf_t;
 
+/* join preference iovar value */
+/*
+ * Join preference iovar value is an array of tuples. Each tuple has a one-byte type,
+ * a one-byte length, and a variable length value.  RSSI type tuple must be present
+ * in the array.
+ *
+ * Types are defined in "join preference types" section.
+ *
+ * Length is the value size in octets. It is reserved for WL_JOIN_PREF_WPA type tuple
+ * and must be set to zero.
+ *
+ * Values are defined below.
+ *
+ * 1. RSSI - 2 octets
+ * offset 0: reserved
+ * offset 1: reserved
+ *
+ * 2. WPA - 2 + 12 * n octets (n is # tuples defined below)
+ * offset 0: reserved
+ * offset 1: # of tuples
+ * offset 2: tuple 1
+ * offset 14: tuple 2
+ * ...
+ * offset 2 + 12 * (n - 1) octets: tuple n
+ *
+ * struct wpa_cfg_tuple {
+ *   uint8 akm[DOT11_OUI_LEN+1];     akm suite
+ *   uint8 ucipher[DOT11_OUI_LEN+1]; unicast cipher suite
+ *   uint8 mcipher[DOT11_OUI_LEN+1]; multicast cipher suite
+ * };
+ *
+ * multicast cipher suite can be specified as a specific cipher suite or WL_WPA_ACP_MCS_ANY.
+ *
+ * 3. BAND - 2 octets
+ * offset 0: reserved
+ * offset 1: see "band preference" and "band types"
+ */
+/* join preference types */
+#define WL_JOIN_PREF_RSSI	1	/* by RSSI */
+#define WL_JOIN_PREF_WPA	2	/* by akm and ciphers */
+#define WL_JOIN_PREF_BAND	3	/* by 802.11 band */
+
+/* band preference */
+
+/* any multicast cipher suite */
+#define WL_WPA_ACP_MCS_ANY	"\x00\x00\x00\x00"
+
+struct tsinfo_arg {
+	uint8 octets[3];
+};
+
 #if !defined(__GNUC__)
 #pragma pack(pop)
 #endif
 
+#define	NFIFO			6	/* # tx/rx fifopairs */
+
+#define	WL_CNT_T_VERSION	3	/* current version of wl_cnt_t struct */
+
+typedef struct {
+	uint16	version;	/* see definition of WL_CNT_T_VERSION */
+	uint16	length;		/* length of entire structure */
+
+	/* transmit stat counters */
+	uint32	txframe;	/* tx data frames */
+	uint32	txbyte;		/* tx data bytes */
+	uint32	txretrans;	/* tx mac retransmits */
+	uint32	txerror;	/* tx data errors (derived: sum of others) */
+	uint32	txctl;		/* tx management frames */
+	uint32	txprshort;	/* tx short preamble frames */
+	uint32	txserr;		/* tx status errors */
+	uint32	txnobuf;	/* tx out of buffers errors */
+	uint32	txnoassoc;	/* tx discard because we're not associated */
+	uint32	txrunt;		/* tx runt frames */
+	uint32	txchit;		/* tx header cache hit (fastpath) */
+	uint32	txcmiss;	/* tx header cache miss (slowpath) */
+
+	/* transmit chip error counters */
+	uint32	txuflo;		/* tx fifo underflows */
+	uint32	txphyerr;	/* tx phy errors (indicated in tx status) */
+	uint32	txphycrs;	
+
+	/* receive stat counters */
+	uint32	rxframe;	/* rx data frames */
+	uint32	rxbyte;		/* rx data bytes */
+	uint32	rxerror;	/* rx data errors (derived: sum of others) */
+	uint32	rxctl;		/* rx management frames */
+	uint32	rxnobuf;	/* rx out of buffers errors */
+	uint32	rxnondata;	/* rx non data frames in the data channel errors */
+	uint32	rxbadds;	/* rx bad DS errors */
+	uint32	rxbadcm;	/* rx bad control or management frames */
+	uint32	rxfragerr;	/* rx fragmentation errors */
+	uint32	rxrunt;		/* rx runt frames */
+	uint32	rxgiant;	/* rx giant frames */
+	uint32	rxnoscb;	/* rx no scb error */
+	uint32	rxbadproto;	/* rx invalid frames */
+	uint32	rxbadsrcmac;	/* rx frames with Invalid Src Mac */
+	uint32	rxbadda;	/* rx frames tossed for invalid da */
+	uint32	rxfilter;	/* rx frames filtered out */
+
+	/* receive chip error counters */
+	uint32	rxoflo;		/* rx fifo overflow errors */
+	uint32	rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
+
+	uint32	d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
+	uint32	d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
+	uint32	d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
+
+	/* misc counters */
+	uint32	dmade;		/* tx/rx dma descriptor errors */
+	uint32	dmada;		/* tx/rx dma data errors */
+	uint32	dmape;		/* tx/rx dma descriptor protocol errors */
+	uint32	reset;		/* reset count */
+	uint32	tbtt;		/* cnts the TBTT int's */
+	uint32	txdmawar;	
+	uint32	pkt_callback_reg_fail;	/* callbacks register failure */
+
+	/* MAC counters: 32-bit version of d11.h's macstat_t */
+	uint32	txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
+				 * Control Management (includes retransmissions)
+				 */
+	uint32	txrtsfrm;	/* number of RTS sent out by the MAC */
+	uint32	txctsfrm;	/* number of CTS sent out by the MAC */
+	uint32	txackfrm;	/* number of ACK frames sent out */
+	uint32	txdnlfrm;	/* Not used */
+	uint32	txbcnfrm;	/* beacons transmitted */
+	uint32	txfunfl[8];	/* per-fifo tx underflows */
+	uint32	txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
+				 * or BCN)
+				 */
+	uint32	txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
+				 * driver enqueued frames
+				 */
+	uint32	rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
+	uint32	rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
+	uint32	rxinvmachdr;	/* Either the protocol version != 0 or frame type not
+				 * data/control/management
+				 */
+	uint32	rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
+	uint32	rxbadplcp;	/* parity check of the PLCP header failed */
+	uint32	rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
+	uint32	rxstrt;		/* Number of received frames with a good PLCP
+				 * (i.e. passing parity check)
+				 */
+	uint32	rxdfrmucastmbss; /* Number of received DATA frames with good FCS and matching RA */
+	uint32	rxmfrmucastmbss; /* number of received mgmt frames with good FCS and matching RA */
+	uint32	rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
+	uint32	rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
+	uint32	rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
+	uint32	rxackucast;	/* number of ucast ACKS received (good FCS) */
+	uint32	rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
+	uint32	rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
+	uint32	rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
+	uint32	rxrtsocast;	/* number of received RTS not addressed to the MAC */
+	uint32	rxctsocast;	/* number of received CTS not addressed to the MAC */
+	uint32	rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
+	uint32	rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
+	uint32	rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
+				 * (unlikely to see these)
+				 */
+	uint32	rxbeaconmbss;	/* beacons received from member of BSS */
+	uint32	rxdfrmucastobss; /* number of unicast frames addressed to the MAC from
+				  * other BSS (WDS FRAME)
+				  */
+	uint32	rxbeaconobss;	/* beacons received from other BSS */
+	uint32	rxrsptmout;	/* Number of response timeouts for transmitted frames
+				 * expecting a response
+				 */
+	uint32	bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
+	uint32	rxf0ovfl;	/* Number of receive fifo 0 overflows */
+	uint32	rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
+	uint32	rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
+	uint32	txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
+	uint32	pmqovfl;	/* Number of PMQ overflows */
+	uint32	rxcgprqfrm;	/* Number of received Probe requests that made it into
+				 * the PRQ fifo
+				 */
+	uint32	rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
+	uint32	txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
+				 * not get ACK
+				 */
+	uint32	txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
+	uint32	prs_timeout;	/* Number of probe requests that were dropped from the PRQ
+				 * fifo because a probe response could not be sent out within
+				 * the time limit defined in M_PRS_MAXTIME
+				 */
+	uint32	rxnack;		/* Number of NACKS received (Afterburner) */
+	uint32	frmscons;	/* Number of frames completed without transmission because of an
+				 * Afterburner re-queue
+				 */
+	uint32	txnack;		/* Number of NACKs transmitted (Afterburner) */
+	uint32	txglitch_nack;	/* obsolete */
+	uint32	txburst;	/* obsolete */
+
+	/* 802.11 MIB counters, pp. 614 of 802.11 reaff doc. */
+	uint32	txfrag;		/* dot11TransmittedFragmentCount */
+	uint32	txmulti;	/* dot11MulticastTransmittedFrameCount */
+	uint32	txfail;		/* dot11FailedCount */
+	uint32	txretry;	/* dot11RetryCount */
+	uint32	txretrie;	/* dot11MultipleRetryCount */
+	uint32	rxdup;		/* dot11FrameduplicateCount */
+	uint32	txrts;		/* dot11RTSSuccessCount */
+	uint32	txnocts;	/* dot11RTSFailureCount */
+	uint32	txnoack;	/* dot11ACKFailureCount */
+	uint32	rxfrag;		/* dot11ReceivedFragmentCount */
+	uint32	rxmulti;	/* dot11MulticastReceivedFrameCount */
+	uint32	rxcrc;		/* dot11FCSErrorCount */
+	uint32	txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
+	uint32	rxundec;	/* dot11WEPUndecryptableCount */
+
+	/* WPA2 counters (see rxundec for DecryptFailureCount) */
+	uint32	tkipmicfaill;	/* TKIPLocalMICFailures */
+	uint32	tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
+	uint32	tkipreplay;	/* TKIPReplays */
+	uint32	ccmpfmterr;	/* CCMPFormatErrors */
+	uint32	ccmpreplay;	/* CCMPReplays */
+	uint32	ccmpundec;	/* CCMPDecryptErrors */
+	uint32	fourwayfail;	/* FourWayHandshakeFailures */
+	uint32	wepundec;	/* dot11WEPUndecryptableCount */
+	uint32	wepicverr;	/* dot11WEPICVErrorCount */
+	uint32	decsuccess;	/* DecryptSuccessCount */
+	uint32	tkipicverr;	/* TKIPICVErrorCount */
+	uint32	wepexcluded;	/* dot11WEPExcludedCount */
+
+	uint32	txchanrej;	/* Tx frames suppressed due to channel rejection */
+	uint32	psmwds;		/* Count PSM watchdogs */
+	uint32	phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
+
+	/* MBSS counters, AP only */
+	uint32	prq_entries_handled;	/* PRQ entries read in */
+	uint32	prq_undirected_entries;	/*    which were bcast bss & ssid */
+	uint32	prq_bad_entries;	/*    which could not be translated to info */
+	uint32	atim_suppress_count;	/* TX suppressions on ATIM fifo */
+	uint32	bcn_template_not_ready;	/* Template marked in use on send bcn ... */
+	uint32	bcn_template_not_ready_done; /* ...but "DMA done" interrupt rcvd */
+	uint32	late_tbtt_dpc;	/* TBTT DPC did not happen in time */
+} wl_cnt_t;
+
+#define WL_WME_CNT_VERSION	1	/* current version of wl_wme_cnt_t */
+
+typedef struct {
+	uint32 packets;
+	uint32 bytes;
+} wl_traffic_stats_t;
+
+typedef struct {
+	uint16	version;	/* see definition of WL_WME_CNT_VERSION */
+	uint16	length;		/* length of entire structure */
+
+	wl_traffic_stats_t tx[AC_COUNT];	/* Packets transmitted */
+	wl_traffic_stats_t tx_failed[AC_COUNT];	/* Packets dropped or failed to transmit */
+	wl_traffic_stats_t rx[AC_COUNT];	/* Packets received */
+	wl_traffic_stats_t rx_failed[AC_COUNT];	/* Packets failed to receive */
+
+	wl_traffic_stats_t forward[AC_COUNT];	/* Packets forwarded by AP */
+
+	wl_traffic_stats_t tx_expired[AC_COUNT];	/* packets dropped due to lifetime expiry */
+
+} wl_wme_cnt_t;
+
+#ifdef WLBA
+
+#define	WLC_BA_CNT_VERSION	1	/* current version of wlc_ba_cnt_t */
+
+/* block ack related stats */
+typedef struct wlc_ba_cnt {
+	uint16	version;	/* WLC_BA_CNT_VERSION */
+	uint16	length;		/* length of entire structure */
+
+	/* transmit stat counters */
+	uint32 txpdu;		/* pdus sent */
+	uint32 txsdu;		/* sdus sent */
+	uint32 txfc;		/* tx side flow controlled packets */
+	uint32 txfci;		/* tx side flow control initiated */
+	uint32 txretrans;	/* retransmitted pdus */
+	uint32 txbatimer;	/* ba resend due to timer */
+	uint32 txdrop;		/* dropped packets */
+	uint32 txaddbareq;	/* addba req sent */
+	uint32 txaddbaresp;	/* addba resp sent */
+	uint32 txdelba;		/* delba sent */
+	uint32 txba;		/* ba sent */
+	uint32 txbar;		/* bar sent */
+	uint32 txpad[4];	/* future */
+
+	/* receive side counters */
+	uint32 rxpdu;		/* pdus recd */
+	uint32 rxqed;		/* pdus buffered before sending up */
+	uint32 rxdup;		/* duplicate pdus */
+	uint32 rxnobuf;		/* pdus discarded due to no buf */
+	uint32 rxaddbareq;	/* addba req recd */
+	uint32 rxaddbaresp;	/* addba resp recd */
+	uint32 rxdelba;		/* delba recd */
+	uint32 rxba;		/* ba recd */
+	uint32 rxbar;		/* bar recd */
+	uint32 rxinvba;		/* invalid ba recd */
+	uint32 rxbaholes;	/* ba recd with holes */
+	uint32 rxunexp;		/* unexpected packets */
+	uint32 rxpad[4];	/* future */
+} wlc_ba_cnt_t;
+#endif /* WLBA */
+
+/* structure for per-tid ampdu control */
+struct ampdu_tid_control {
+	uint8 tid;			/* tid */
+	uint8 enable;			/* enable/disable */
+};
+
+/* structure for identifying ea/tid for sending addba/delba */
+struct ampdu_ea_tid {
+	struct ether_addr ea;		/* Station address */
+	uint8 tid;			/* tid */
+};
+
+/* Different discovery modes for dpt */
+#define	DPT_DISCOVERY_MANUAL	0x01	/* manual discovery mode */
+#define	DPT_DISCOVERY_AUTO	0x02	/* auto discovery mode */
+#define	DPT_DISCOVERY_SCAN	0x04	/* scan-based discovery mode */
+
+/* different path selection values */
+#define DPT_PATHSEL_AUTO	0	/* auto mode for path selection */
+#define DPT_PATHSEL_DIRECT	1	/* always use direct DPT path */
+#define DPT_PATHSEL_APPATH	2	/* always use AP path */
+
+/* different ops for deny list */
+#define DPT_DENY_LIST_ADD 	1	/* add to dpt deny list */
+#define DPT_DENY_LIST_REMOVE 	2	/* remove from dpt deny list */
+
+/* different ops for manual end point */
+#define DPT_MANUAL_EP_CREATE	1	/* create manual dpt endpoint */
+#define DPT_MANUAL_EP_MODIFY	2	/* modify manual dpt endpoint */
+#define DPT_MANUAL_EP_DELETE	3	/* delete manual dpt endpoint */
+
+/* structure for dpt iovars */
+typedef struct dpt_iovar {
+	struct ether_addr ea;		/* Station address */
+	uint8 mode;			/* mode: depends on iovar */
+	uint32 pad;			/* future */
+} dpt_iovar_t;
+
+/* structure for addts arguments */
+/* For ioctls that take a list of TSPEC */
+struct tslist {
+	int count;			/* number of tspecs */
+	struct tsinfo_arg tsinfo[1];	/* variable length array of tsinfo */
+};
+
+/* structure for addts/delts arguments */
+typedef struct tspec_arg {
+	uint16 version;			/* see definition of TSPEC_ARG_VERSION */
+	uint16 length;			/* length of entire structure */
+	uint flag;			/* bit field */
+	/* TSPEC Arguments */
+	struct tsinfo_arg tsinfo;	/* TS Info bit field */
+	uint16 nom_msdu_size;		/* (Nominal or fixed) MSDU Size (bytes) */
+	uint16 max_msdu_size;		/* Maximum MSDU Size (bytes) */
+	uint min_srv_interval;		/* Minimum Service Interval (us) */
+	uint max_srv_interval;		/* Maximum Service Interval (us) */
+	uint inactivity_interval;	/* Inactivity Interval (us) */
+	uint suspension_interval;	/* Suspension Interval (us) */
+	uint srv_start_time;		/* Service Start Time (us) */
+	uint min_data_rate;		/* Minimum Data Rate (bps) */
+	uint mean_data_rate;		/* Mean Data Rate (bps) */
+	uint peak_data_rate;		/* Peak Data Rate (bps) */
+	uint max_burst_size;		/* Maximum Burst Size (bytes) */
+	uint delay_bound;		/* Delay Bound (us) */
+	uint min_phy_rate;		/* Minimum PHY Rate (bps) */
+	uint16 surplus_bw;		/* Surplus Bandwidth Allowance Factor */
+	uint16 medium_time;		/* Medium Time (32 us/s periods) */
+} tspec_arg_t;
+
+/* current version of wl_tspec_arg_t struct */
+#define	TSPEC_ARG_VERSION	1	/* current version of wl_tspec_arg_t struct */
+#define TSPEC_ARG_LENGTH	55	/* argment length from tsinfo to medium_time */
+
+/* define for flag */
+#define TSPEC_PENDING		0	/* TSPEC pending */
+#define TSPEC_ACCEPTED		1	/* TSPEC accepted */
+#define TSPEC_REJECTED		2	/* TSPEC rejected */
+#define TSPEC_UNKNOWN		3	/* TSPEC unknown */
+#define TSPEC_STATUS_MASK	7	/* TSPEC status mask */
+
+
+/* Software feature flag defines used by wlfeatureflag */
+#define WL_SWFL_ABBFL		0x0001 /* Allow Afterburner on systems w/o hardware BFL */
+#define WL_SWFL_ABENCORE	0x0002 /* Allow AB on non-4318E chips */
+#define WL_SWFL_NOHWRADIO	0x0004 /* Disable HW Radio monitor (e.g., Apple) */
+
+#define WL_LIFETIME_MAX 0xFFFF /* Max value in ms */
+
+/* Packet lifetime configuration per ac */
+typedef struct wl_lifetime {
+	uint32 ac;	        /* access class */
+	uint32 lifetime;    /* Packet lifetime value in ms */
+} wl_lifetime_t;
+
+
+/* Channel Switch Announcement param */
+typedef struct wl_chan_switch {
+	uint8 mode;		/* value 0 or 1 */
+	uint8 count;		/* count # of beacons before switching */
+	chanspec_t chspec;	/* chanspec */
+	uint8 reg;		/* regulatory class */
+} wl_chan_switch_t;
+
+/* Roaming trigger definitions for WLC_SET_ROAM_TRIGGER.
+ *
+ * (-100 < value < 0)   value is used directly as a roaming trigger in dBm
+ * (0 <= value) value specifies a logical roaming trigger level from
+ *                      the list below
+ *
+ * WLC_GET_ROAM_TRIGGER always returns roaming trigger value in dBm, never
+ * the logical roam trigger value.
+ */
+#define WLC_ROAM_TRIGGER_DEFAULT	0 /* default roaming trigger */
+#define WLC_ROAM_TRIGGER_BANDWIDTH	1 /* optimize for bandwidth roaming trigger */
+#define WLC_ROAM_TRIGGER_DISTANCE	2 /* optimize for distance roaming trigger */
+#define WLC_ROAM_TRIGGER_MAX_VALUE	2 /* max. valid value */
+
+/* Preferred Network Offload (PNO, formerly PFN) defines */
+enum {
+	PFN_LIST_ORDER,
+	PFN_RSSI
+};
+
+enum {
+	DISABLE,
+	ENABLE
+};
+
+#define SORT_CRITERIA_BIT		0
+#define AUTO_NET_SWITCH_BIT		1
+#define ENABLE_BKGRD_SCAN_BIT		2
+
+#define SORT_CRITERIA_MASK		0x01
+#define AUTO_NET_SWITCH_MASK		0x02
+#define ENABLE_BKGRD_SCAN_MASK		0x04
+
+#define PFN_VERSION			1
+
+/* PFN data structure */
+typedef struct wl_pfn_param {
+	int32 version;					/* version field */
+	int32 scan_freq;				/* Scan frequency */
+	int32 lost_network_timeout;			/* Timeout in sec. to declare
+							 * discovered network as lost
+							 */
+	int16 flags;					/* Bit field to control feature
+							 * of PFN such as sort criteria auto
+							 * enable switch and back ground scan
+							 */
+#if defined(WLPFN_AUTO_CONNECT) || !defined(BCMDRIVER)
+	int16 rssi_margin;				/* Margin to avoid jitter for choosing a
+							 * PFN based on RSSI sort criteria
+							 */
+#else
+	int16 pad;
+#endif
+} wl_pfn_param_t;
+
+typedef struct wl_pfn {
+	wlc_ssid_t		ssid;			/* ssid name and its length */
+	int32			bss_type;		/* IBSS or infrastructure */
+#if defined(WLPFN_AUTO_CONNECT) || !defined(BCMDRIVER)
+	int32			infra;			/* BSS Vs IBSS */
+	int32			auth;			/* Open Vs Closed */
+	int32			wpa_auth;		/* WPA type */
+	int32			wsec;			/* wsec value */
+	union {
+		wl_wsec_key_t	sec_key;		/* Security Settings for WEP */
+		wsec_pmk_t	wpa_sec_key;		/* Security setting for WPA */
+	} pfn_security;
+#endif
+} wl_pfn_t;
+
+/* TCP Checksum Offload defines */
+#define TOE_TX_CSUM_OL		0x00000001
+#define TOE_RX_CSUM_OL		0x00000002
+
+/* TCP Checksum Offload error injection for testing (BCMINTERNAL) */
+#define TOE_ERRTEST_TX_CSUM	0x00000001
+#define TOE_ERRTEST_RX_CSUM	0x00000002
+#define TOE_ERRTEST_RX_CSUM2	0x00000004
+
+struct toe_ol_stats_t {
+	/* Num of tx packets that don't need to be checksummed */
+	uint32 tx_summed;
+
+	/* Num of tx packets where checksum is filled by offload engine */
+	uint32 tx_iph_fill;
+	uint32 tx_tcp_fill;
+	uint32 tx_udp_fill;
+	uint32 tx_icmp_fill;
+
+	/*  Num of rx packets where toe finds out if checksum is good or bad */
+	uint32 rx_iph_good;
+	uint32 rx_iph_bad;
+	uint32 rx_tcp_good;
+	uint32 rx_tcp_bad;
+	uint32 rx_udp_good;
+	uint32 rx_udp_bad;
+	uint32 rx_icmp_good;
+	uint32 rx_icmp_bad;
+
+	/* Num of tx packets in which csum error is injected */
+	uint32 tx_tcp_errinj;
+	uint32 tx_udp_errinj;
+	uint32 tx_icmp_errinj;
+
+	/* Num of rx packets in which csum error is injected */
+	uint32 rx_tcp_errinj;
+	uint32 rx_udp_errinj;
+	uint32 rx_icmp_errinj;
+};
+
+/* ARP Offload feature flags for arp_ol iovar */
+#define ARP_OL_AGENT		0x00000001
+#define ARP_OL_SNOOP		0x00000002
+#define ARP_OL_HOST_AUTO_REPLY	0x00000004
+#define ARP_OL_PEER_AUTO_REPLY	0x00000008
+
+/* ARP Offload error injection (BCMINTERNAL) */
+#define ARP_ERRTEST_REPLY_PEER	0x1
+#define ARP_ERRTEST_REPLY_HOST	0x2
+
+#define ARP_MULTIHOMING_MAX	8	/* Maximum local host IP addresses */
+
+/* Arp offload statistic counts */
+struct arp_ol_stats_t {
+	uint32  host_ip_entries;	/* Host IP table addresses (more than one if multihomed) */
+	uint32  host_ip_overflow;	/* Host IP table additions skipped due to overflow */
+
+	uint32  arp_table_entries;	/* ARP table entries */
+	uint32  arp_table_overflow;	/* ARP table additions skipped due to overflow */
+
+	uint32  host_request;		/* ARP requests from host */
+	uint32  host_reply;		/* ARP replies from host */
+	uint32  host_service;		/* ARP requests from host serviced by ARP Agent */
+
+	uint32  peer_request;		/* ARP requests received from network */
+	uint32  peer_request_drop;	/* ARP requests from network that were dropped */
+	uint32  peer_reply;		/* ARP replies received from network */
+	uint32  peer_reply_drop;	/* ARP replies from network that were dropped */
+	uint32  peer_service;		/* ARP request from host serviced by ARP Agent */
+};
+
+/* Packet engine interface */
+#define WL_PKTENG_PER_TX_START	0x01
+#define WL_PKTENG_PER_TX_STOP	0x02
+#define WL_PKTENG_PER_RX_START	0x04
+#define WL_PKTENG_PER_RX_STOP	0x08
+#define WL_PKTENG_CONT_TX_START	0x10
+#define WL_PKTENG_CONT_TX_STOP	0x20
+
+typedef struct wl_pkteng {
+	uint32 flags;
+	uint32 delay;		/* Inter packet delay */
+	uint32 nframes;		/* number of frames */
+	uint32 length;		/* packet length */
+	bool seqno;			/* enable/disable sequence no. */
+	struct ether_addr dest;	/* destination address */
+} wl_pkteng_t;
+
+#define WL_WOWL_MAGIC	(1 << 0)	/* Wakeup on Magic packet */
+#define WL_WOWL_NET	(1 << 1)	/* Wakeup on Netpattern */
+#define WL_WOWL_DIS	(1 << 2)	/* Wakeup on loss-of-link due to Disassoc/Deauth */
+#define WL_WOWL_RETR	(1 << 3)	/* Wakeup on retrograde TSF */
+#define WL_WOWL_BCN	(1 << 4)	/* Wakeup on loss of beacon */
+
+typedef struct {
+	uint masksize;		/* Size of the mask in #of bytes */
+	uint offset;		/* Offset to start looking for the packet in # of bytes */
+	uint patternoffset;	/* Offset of start of pattern in the structure */
+	uint patternsize;	/* Size of the pattern itself in #of bytes */
+	/* Mask follows the structure above */
+	/* Pattern follows the mask is at 'patternoffset' from the start */
+} wl_wowl_pattern_t;
+
+typedef struct {
+	uint			count;
+	wl_wowl_pattern_t	pattern[1];
+} wl_wowl_pattern_list_t;
+
+#if defined(DSLCPE_DELAY)
+#define WL_DELAYMODE_DEFER	0	/* defer by scheduler's choice, make this driver default */
+#define WL_DELAYMODE_FORCE	1	/* force, this is driver default */
+#define WL_DELAYMODE_AUTO	2	/* defer if no sta associated, force if sta associated */
+#endif
+
 #endif /* _wlioctl_h_ */
