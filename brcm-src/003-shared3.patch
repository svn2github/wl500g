Broadcom SDK from GPL 500gpV2 3.0.4.2

diff -urBwp src/shared/boot.S shared/boot.S
--- src/shared/boot.S	2007-11-19 06:40:26.000000000 +0300
+++ src.3034/shared/boot.S	2008-07-21 13:20:53.000000000 +0400
@@ -24,14 +24,14 @@
 	.set	noreorder
 
 
-	li	a0,KSEG1ADDR(SB_ENUM_BASE)
+	li	a2,KSEG1ADDR(SB_ENUM_BASE)
 
        	# XXX: the following code snipet sets clk frequency to 200M
         # correct pll clk freq to real speed in the 5350 case.
 	# unless its vsim which we detect as pkg option 1 (should be 0xe)
         # It is Ugly...but
 	li	a3,BCM5350_CHIP_ID		# 5350 ChipID
-	lw	t1,CC_CHIPID(a0)		# ChipID register
+	lw	t1,CC_CHIPID(a2)		# ChipID register
 	li	t2,CID_ID_MASK			# chip id is bit 0-15
 	and	t2,t1,t2
 	bne	t2,a3,2f			# if not 5350 then skip
@@ -40,47 +40,57 @@
 	li	t2,CID_PKG_MASK			# if it is a vsim 5350, also skip
 	and	t2,t1,t2
 	li	a3,(HDLSIM5350_PKG_ID << CID_PKG_SHIFT)
-	beq	t2,a3,2f			# if pkg opt 1 then skip
+	beq	t2,a3,ramcheck			# if pkg opt 1 then skip
 	nop
 
 	li	a3,CLKC_5350_N
-	lw	t1,CC_CLKC_N(a0)
-	beq	a3,t1,2f			# move ahead if clk freq set correctly
+	lw	t3,CC_CLKC_N(a2)
+	beq	a3,t3,ramcheck			# move ahead if clk freq set correctly
 	nop
-	sw	a3,CC_CLKC_N(a0)		# set control N1 to select 6
-	li	t1,1
-	sw	t1,CC_WATCHDOG(a0)		# set WatchDog Reset
+	sw	a3,CC_CLKC_N(a2)		# set control N1 to select 6
+	li	t3,1
+	sw	t3,CC_WATCHDOG(a2)		# set WatchDog Reset
 1:	b	1b
 	nop
 
-2:
-#ifdef	BCM5354
-	lw	t1,CC_CHIPID(a0)		# ChipID register
-	li	t2,CID_ID_MASK			# chip id is bit 0-15
-	li	a3,BCM5354_CHIP_ID		# 5354 ChipID
-	and	t2,t1,t2
+2:	li	a3,BCM5354_CHIP_ID		# 5354 ChipID
 	bne	t2,a3,ramcheck			# if not 5354 then skip
 	nop
 
+	li	t2,CID_REV_MASK			# Get chip rev
+	and	t2,t1,t2
+	li	t3,(3 << CID_REV_SHIFT)		# Is it an a3?
+	blt	t2,t3,a0a1a2
+	nop 
+
+	/* Fix up for a3 (and up?) */
+	li	a0,0x01330000			# Value for regcontrol 2
+	li	t2,2
+	sw	t2,PMU_REG_CONTROL_ADDR(a2)
+	sw	a0,PMU_REG_CONTROL_DATA(a2)
+	
+a0a1a2:
+	li	a0,0x00002000			# Value for regcontrol 0
+	li	a1,0x06800000			# Value for regcontrol 1
+	li	a3,0x02000000			# Value for regcontrol 3
+	
+fixregctl:
 	li	t2,0x1				# Need define
-	sw	t2,PMU_REG_CONTROL_ADDR(a0)
-	li 	t3,0x6800000			# Should only affect the switch bits
-	sw	t3,PMU_REG_CONTROL_DATA(a0)
+	sw	t2,PMU_REG_CONTROL_ADDR(a2)
+	sw	a1,PMU_REG_CONTROL_DATA(a2)
 	
 	/* 
 	 * Trim the output voltage of the 1.2V BB switcher and 2.5V
 	 * regulator to the correct value.
 	 */
 	li	t2,0x0
-	sw	t2,PMU_REG_CONTROL_ADDR(a0)
-	li 	t3,0x2000			# Reduce the output voltage of
-	sw	t3,PMU_REG_CONTROL_DATA(a0)	# BB switcher to get 1.2V
+	sw	t2,PMU_REG_CONTROL_ADDR(a2)
+	sw	a0,PMU_REG_CONTROL_DATA(a2)	# BB switcher to get 1.2V
 	li	t2,0x3
-	sw	t2,PMU_REG_CONTROL_ADDR(a0)
-	li 	t3,0x02000000			# Increase the output voltage
-	sw	t3,PMU_REG_CONTROL_DATA(a0)	# of VDDP LDO to get 2.5V
+	sw	t2,PMU_REG_CONTROL_ADDR(a2)
+	sw	a3,PMU_REG_CONTROL_DATA(a2)	# of VDDP LDO to get 2.5V
 
-	lw	t2,PMU_CTL(a0)			# Check if PLL has been programmed
+	lw	t2,PMU_CTL(a2)			# Check if PLL has been programmed
 	andi	t2,t2,PCTL_XTALFREQ_MASK
 	bnez	t2,3f				# Yup, leave it alone
 	nop
@@ -84,13 +94,23 @@
 	andi	t2,t2,PCTL_XTALFREQ_MASK
 	bnez	t2,3f				# Yup, leave it alone
 	nop
+
 	li	t2,0x7ffff			# Should only turn off the PLL bit
-	sw	t2,PMU_MIN_RES_MASK(a0)		# Disable base band PLL
-	sw	t2,PMU_MAX_RES_MASK(a0)
+	sw	t2,PMU_MIN_RES_MASK(a2)		# Disable base band PLL
+	sw	t2,PMU_MAX_RES_MASK(a2)
+
+	li	t2,0x1
+	sw	t2,PMU_PLL_CONTROL_ADDR(a2)
+	li	t2,0x66666602			# Set the PLL Mode properly
+	sw	t2,PMU_PLL_CONTROL_DATA(a2)
+	li	t2,0xfffff			# Enable base band PLL 
+	sw	t2,PMU_MIN_RES_MASK(a2)
+	sw	t2,PMU_MAX_RES_MASK(a2)
 	nop
 
 	/* Init code for FF4 space without TLB, enabling RAC */
 3:	li 	t0,0x1fa0000c			# Set up CBR to 0x1fax_xxxx
+	.set	mips32
 	mtc0 	t0,$22,6
 	li 	t1,0x1fa00000
 	lw 	t2,0x14(t1)
@@ -98,7 +118,7 @@
 	sw 	t3,0x14(t1) 
 	li 	t0,0xff40000c			# change CBR to ff4x_xxxx
 	mtc0 	t0,$22,6
-#endif	/* BCM5354 */
+	.set	mips0
 
 ramcheck:
 	/* Check if we booted from SDRAM */
@@ -283,6 +283,36 @@
 	jr	t2
 	nop
 
+	/* Black hole for traps with BEV on */
+	.org	0x380
+bevtrap: nop
+	nop
+	.set	mips32
+	wait
+	.set	mips0
+	nop
+	nop
+	b	bevtrap
+	nop
+
+	/* Record the size of the binary */
+	.org	BISZ_OFFSET
+	.word	BISZ_MAGIC
+	.word	text_start
+	.word	text_end
+	.word	data_start
+	.word	data_end
+	.word	bss_start
+	.word	bss_end
+	.word	_end
+
+	/* Embedded NVRAM */
+	.balign	0x400	
+	.globl	embedded_nvram
+embedded_nvram:
+	.fill	0x100,4,~(0x48534c46)
+	
+
 initdram:
 	/* Initialize SDRAM */
 	li	t0,KSEG0ADDR(SB_FLASH1)
@@ -315,37 +345,6 @@
 	add	a1,4
 	blt	a1,a2,1b
 	nop
-	b	setsp
-	nop
-
-	/* Black hole for traps with BEV on */
-	.org	0x380
-bevtrap: nop
-	nop
-	.set	mips32
-	wait
-	.set	mips0
-	nop
-	nop
-	b	bevtrap
-	nop
-
-	/* Record the size of the binary */
-	.org	BISZ_OFFSET
-	.word	BISZ_MAGIC
-	.word	text_start
-	.word	text_end
-	.word	data_start
-	.word	data_end
-	.word	bss_start
-	.word	bss_end
-	.word	_end
-
-	/* Embedded NVRAM */
-	.balign	0x400	
-	.globl	embedded_nvram
-embedded_nvram:
-	.fill	0x100,4,~(0x48534c46)
 
 setsp:
 	/* Record the memory size */
diff -urBwp src/shared/sbutils.c shared/sbutils.c
--- src/shared/sbutils.c	2007-01-25 20:52:12.000000000 +0300
+++ src.3034/shared/sbutils.c	2008-07-21 13:20:53.000000000 +0400
@@ -173,10 +173,19 @@ static bool sb_onetimeinit = FALSE;
 #define	ILP_DIV_5MHZ		0		/* ILP = 5 MHz */
 #define	ILP_DIV_1MHZ		4		/* ILP = 1 MHz */
 
-/* force HT war check */
+/* force HT war check on non-mips platforms
+   This WAR seem to introduce a significant slowdon on 
+   4704 mips router where the problem itself never shows. 
+*/
+
+#ifndef __mips__
 #define FORCEHT_WAR32414(si)	\
 	(((PCIE(si)) && (si->sb.chip == BCM4311_CHIP_ID) && ((si->sb.chiprev <= 1))) || \
 	((PCI(si) || PCIE(si)) && (si->sb.chip == BCM4321_CHIP_ID) && (si->sb.chiprev <= 3)))
+#else
+#define FORCEHT_WAR32414(si)   0
+#endif /* __mips__ */
+
 
 #define PCIE_ASPMWARS(si)	\
 	((PCIE(si)) && ((si->sb.buscorerev >= 3) && (si->sb.buscorerev <= 5)))
diff -urBwp src/include/sflash.h src.3034/include/sflash.h
--- src/include/sflash.h	2007-09-20 12:53:48.000000000 +0400
+++ src.3034/include/sflash.h	2008-07-21 13:14:16.000000000 +0400
@@ -26,11 +26,14 @@ struct sflash {
 };
 
 /* Utility functions */
-extern int sflash_poll(chipcregs_t *cc, uint offset);
-extern int sflash_read(chipcregs_t *cc, uint offset, uint len, uchar *buf);
-extern int sflash_write(chipcregs_t *cc, uint offset, uint len, const uchar *buf);
-extern int sflash_erase(chipcregs_t *cc, uint offset);
-extern int sflash_commit(chipcregs_t *cc, uint offset, uint len, const uchar *buf);
-extern struct sflash * sflash_init(chipcregs_t *cc);
+extern int sflash_poll(sb_t *sbh, chipcregs_t *cc, uint offset);
+extern int sflash_read(sb_t *sbh, chipcregs_t *cc,
+                       uint offset, uint len, uchar *buf);
+extern int sflash_write(sb_t *sbh, chipcregs_t *cc,
+                        uint offset, uint len, const uchar *buf);
+extern int sflash_erase(sb_t *sbh, chipcregs_t *cc, uint offset);
+extern int sflash_commit(sb_t *sbh, chipcregs_t *cc,
+                         uint offset, uint len, const uchar *buf);
+extern struct sflash *sflash_init(sb_t *sbh, chipcregs_t *cc);
 
 #endif /* _sflash_h_ */
diff -urBwp src/shared/sflash.c shared/sflash.c
--- src/shared/sflash.c	2007-11-19 07:12:47.000000000 +0300
+++ src.3034/shared/sflash.c	2008-07-21 13:20:53.000000000 +0400
@@ -1,7 +1,7 @@
 /*
  * Broadcom SiliconBackplane chipcommon serial flash interface
  *
- * Copyright 2004, Broadcom Corporation      
+ * Copyright 2007, Broadcom Corporation
  * All Rights Reserved.      
  *       
  * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
@@ -9,45 +9,52 @@
  * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
  * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
  *
- * $Id$
+ * $Id: sflash.c,v 1.1.1.1 2008/07/21 09:20:53 james26_jang Exp $
  */
 
 #include <typedefs.h>
 #include <osl.h>
+#include <bcmutils.h>
+#include <sbutils.h>
 #include <sbconfig.h>
 #include <sbchipc.h>
-#include <mipsinc.h>
-#include <bcmutils.h>
 #include <bcmdevs.h>
 #include <sflash.h>
 
+#define	SFL_MSG(args)
+
 /* Private global state */
 static struct sflash sflash;
 
 /* Issue a serial flash command */
 static INLINE void
-sflash_cmd(chipcregs_t *cc, uint opcode)
+sflash_cmd(osl_t *osh, chipcregs_t *cc, uint opcode)
 {
-	W_REG(NULL, &cc->flashcontrol, SFLASH_START | opcode);
-	while (R_REG(NULL, &cc->flashcontrol) & SFLASH_BUSY);
+	W_REG(osh, &cc->flashcontrol, SFLASH_START | opcode);
+	while (R_REG(osh, &cc->flashcontrol) & SFLASH_BUSY);
 }
 
 /* Initialize serial flash access */
 struct sflash *
-sflash_init(chipcregs_t *cc)
+sflash_init(sb_t *sbh, chipcregs_t *cc)
 {
 	uint32 id, id2;
+	osl_t *osh;
+
+	ASSERT(sbh);
+
+	osh = sb_osh(sbh);
 
 	bzero(&sflash, sizeof(sflash));
 
-	sflash.type = R_REG(NULL, &cc->capabilities) & CC_CAP_FLASH_MASK;
+	sflash.type = sbh->cccaps & CC_CAP_FLASH_MASK;
 
 	switch (sflash.type) {
 	case SFLASH_ST:
 		/* Probe for ST chips */
-		sflash_cmd(cc, SFLASH_ST_DP);
-		sflash_cmd(cc, SFLASH_ST_RES);
-		id = R_REG(NULL, &cc->flashdata);
+		sflash_cmd(osh, cc, SFLASH_ST_DP);
+		sflash_cmd(osh, cc, SFLASH_ST_RES);
+		id = R_REG(osh, &cc->flashdata);
 		switch (id) {
 		case 0x11:
 			/* ST M25P20 2 Mbit Serial Flash */
@@ -80,9 +87,9 @@ sflash_init(chipcregs_t *cc)
 			sflash.numblocks = 128;
 			break;
 		case 0xbf:
-			W_REG(NULL, &cc->flashaddress, 1);
-			sflash_cmd(cc, SFLASH_ST_RES);
-			id2 = R_REG(NULL, &cc->flashdata);
+			W_REG(osh, &cc->flashaddress, 1);
+			sflash_cmd(osh, cc, SFLASH_ST_RES);
+			id2 = R_REG(osh, &cc->flashdata);
 			if (id2 == 0x44) {
 				/* SST M25VF80 4 Mbit Serial Flash */
 				sflash.blocksize = 64 * 1024;
@@ -94,8 +101,8 @@ sflash_init(chipcregs_t *cc)
 
 	case SFLASH_AT:
 		/* Probe for Atmel chips */
-		sflash_cmd(cc, SFLASH_AT_STATUS);
-		id = R_REG(NULL, &cc->flashdata) & 0x3c;
+		sflash_cmd(osh, cc, SFLASH_AT_STATUS);
+		id = R_REG(osh, &cc->flashdata) & 0x3c;
 		switch (id) {
 		case 0xc:
 			/* Atmel AT45DB011 1Mbit Serial Flash */
@@ -142,10 +149,13 @@ sflash_init(chipcregs_t *cc)
 
 /* Read len bytes starting at offset into buf. Returns number of bytes read. */
 int
-sflash_read(chipcregs_t *cc, uint offset, uint len, uchar *buf)
+sflash_read(sb_t *sbh, chipcregs_t *cc, uint offset, uint len, uchar *buf)
 {
-	int cnt;
-	uint32 *from, *to;
+	uint8 *from, *to;
+	int cnt, i;
+	osl_t *osh;
+
+	ASSERT(sbh);
 
 	if (!len)
 		return 0;
@@ -155,21 +165,29 @@ sflash_read(chipcregs_t *cc, uint offset
 
 	if ((len >= 4) && (offset & 3))
 		cnt = 4 - (offset & 3);
-	else if ((len >= 4) && ((uint32)buf & 3))
-		cnt = 4 - ((uint32)buf & 3);
+	else if ((len >= 4) && ((uintptr)buf & 3))
+		cnt = 4 - ((uintptr)buf & 3);
 	else
 		cnt = len;
 
-	from = (uint32 *)KSEG1ADDR(SB_FLASH2 + offset);
-	to = (uint32 *)buf;
+	osh = sb_osh(sbh);
+
+	from = (uint8 *)(uintptr)OSL_UNCACHED(SB_FLASH2 + offset);
+	to = (uint8 *)buf;
 
 	if (cnt < 4) {
-		bcopy(from, to, cnt);
+		for (i = 0; i < cnt; i ++) {
+			*to = R_REG(osh, from);
+			from ++;
+			to ++;
+		}
 		return cnt;
 	}
 
 	while (cnt >= 4) {
-		*to++ = *from++;
+		*(uint32 *)to = R_REG(osh, (uint32 *)from);
+		from += 4;
+		to += 4;
 		cnt -= 4;
 	}
 
@@ -178,20 +196,26 @@ sflash_read(chipcregs_t *cc, uint offset
 
 /* Poll for command completion. Returns zero when complete. */
 int
-sflash_poll(chipcregs_t *cc, uint offset)
+sflash_poll(sb_t *sbh, chipcregs_t *cc, uint offset)
 {
+	osl_t *osh;
+
+	ASSERT(sbh);
+
+	osh = sb_osh(sbh);
+
 	if (offset >= sflash.size)
 		return -22;
 
 	switch (sflash.type) {
 	case SFLASH_ST:
 		/* Check for ST Write In Progress bit */
-		sflash_cmd(cc, SFLASH_ST_RDSR);
-		return R_REG(NULL, &cc->flashdata) & SFLASH_ST_WIP;
+		sflash_cmd(osh, cc, SFLASH_ST_RDSR);
+		return R_REG(osh, &cc->flashdata) & SFLASH_ST_WIP;
 	case SFLASH_AT:
 		/* Check for Atmel Ready bit */
-		sflash_cmd(cc, SFLASH_AT_STATUS);
-		return !(R_REG(NULL, &cc->flashdata) & SFLASH_AT_READY);
+		sflash_cmd(osh, cc, SFLASH_AT_STATUS);
+		return !(R_REG(osh, &cc->flashdata) & SFLASH_AT_READY);
 	}
 
 	return 0;
@@ -200,94 +224,156 @@ sflash_poll(chipcregs_t *cc, uint offset
 /* Write len bytes starting at offset into buf. Returns number of bytes
  * written. Caller should poll for completion.
  */
+#define	ST_RETRIES	3
+
 int
-sflash_write(chipcregs_t *cc, uint offset, uint len, const uchar *buf)
+sflash_write(sb_t *sbh, chipcregs_t *cc, uint offset, uint length, const uchar *buffer)
 {
 	struct sflash *sfl;
-	int ret = 0;
+	uint off = offset, len = length;
+	const uchar *buf = buffer;
+	int ret = 0, try = 0;
 	bool is4712b0;
 	uint32 page, byte, mask;
+	osl_t *osh;
+
+	ASSERT(sbh);
+
+	osh = sb_osh(sbh);
 
 	if (!len)
 		return 0;
 
-	if ((offset + len) > sflash.size)
+	sfl = &sflash;
+	if ((off + len) > sfl->size)
 		return -22;
 
-	sfl = &sflash;
 	switch (sfl->type) {
 	case SFLASH_ST:
-		mask = R_REG(NULL, &cc->chipid);
-		is4712b0 = (((mask & CID_ID_MASK) == BCM4712_CHIP_ID) &&
-		            ((mask & CID_REV_MASK) == (3 << CID_REV_SHIFT)));
+		is4712b0 = (sbh->chip == BCM4712_CHIP_ID) && (sbh->chiprev == 3);
 		/* Enable writes */
-		sflash_cmd(cc, SFLASH_ST_WREN);
+retry:		sflash_cmd(osh, cc, SFLASH_ST_WREN);
+		off = offset;
+		len = length;
+		buf = buffer;
+		try++;
 		if (is4712b0) {
 			mask = 1 << 14;
-			W_REG(NULL, &cc->flashaddress, offset);
-			W_REG(NULL, &cc->flashdata, *buf++);
+			W_REG(osh, &cc->flashaddress, off);
+			W_REG(osh, &cc->flashdata, *buf++);
 			/* Set chip select */
-			OR_REG(NULL, &cc->gpioout, mask);
+			OR_REG(osh, &cc->gpioout, mask);
 			/* Issue a page program with the first byte */
-			sflash_cmd(cc, SFLASH_ST_PP);
+			sflash_cmd(osh, cc, SFLASH_ST_PP);
 			ret = 1;
-			offset++;
+			off++;
 			len--;
 			while (len > 0) {
-				if ((offset & 255) == 0) {
+				if ((off & 255) == 0) {
 					/* Page boundary, drop cs and return */
-					AND_REG(NULL, &cc->gpioout, ~mask);
-					if (!sflash_poll(cc, offset)) {
+					AND_REG(osh, &cc->gpioout, ~mask);
+					OSL_DELAY(1);
+					if (!sflash_poll(sbh, cc, off)) {
 						/* Flash rejected command */
+						if (try <= ST_RETRIES)
+							goto retry;
+						else
 						return -11;
 					}
 					return ret;
 				} else {
 					/* Write single byte */
-					sflash_cmd(cc, *buf++);
+					sflash_cmd(osh, cc, *buf++);
 				}
 				ret++;
-				offset++;
+				off++;
 				len--;
 			}
-			/* All done, drop cs if needed */
-			if ((offset & 255) != 1) {
-				/* Drop cs */
-				AND_REG(NULL, &cc->gpioout, ~mask);
-				if (!sflash_poll(cc, offset)) {
+			/* All done, drop cs */
+			AND_REG(osh, &cc->gpioout, ~mask);
+			OSL_DELAY(1);
+			if (!sflash_poll(sbh, cc, off)) {
 					/* Flash rejected command */
+				if (try <= ST_RETRIES)
+					goto retry;
+				else
 					return -12;
 				}
+		} else if (sbh->ccrev >= 20) {
+			W_REG(NULL, &cc->flashaddress, off);
+			W_REG(NULL, &cc->flashdata, *buf++);
+			/* Issue a page program with CSA bit set */
+			sflash_cmd(osh, cc, SFLASH_ST_CSA | SFLASH_ST_PP);
+			ret = 1;
+			off++;
+			len--;
+			while (len > 0) {
+				if ((off & 255) == 0) {
+					/* Page boundary, poll droping cs and return */
+					W_REG(NULL, &cc->flashcontrol, 0);
+					OSL_DELAY(1);
+					if (sflash_poll(sbh, cc, off) == 0) {
+						/* Flash rejected command */
+						SFL_MSG(("sflash: pp rejected, try: %d,"
+						         " off: %d/%d, len: %d/%d, ret:"
+						         "%d\n", try, off, offset, len,
+						         length, ret));
+						if (try <= ST_RETRIES)
+							goto retry;
+						else
+							return -11;
+					}
+					return ret;
+				} else {
+					/* Write single byte */
+					sflash_cmd(osh, cc, SFLASH_ST_CSA | *buf++);
+				}
+				ret++;
+				off++;
+				len--;
+			}
+			/* All done, drop cs & poll */
+			W_REG(NULL, &cc->flashcontrol, 0);
+			OSL_DELAY(1);
+			if (sflash_poll(sbh, cc, off) == 0) {
+				/* Flash rejected command */
+				SFL_MSG(("sflash: pp rejected, try: %d, off: %d/%d,"
+				         " len: %d/%d, ret: %d\n",
+				         try, off, offset, len, length, ret));
+				if (try <= ST_RETRIES)
+					goto retry;
+				else
+					return -12;
 			}
 		} else {
 			ret = 1;
-			W_REG(NULL, &cc->flashaddress, offset);
-			W_REG(NULL, &cc->flashdata, *buf);
+			W_REG(osh, &cc->flashaddress, off);
+			W_REG(osh, &cc->flashdata, *buf);
 		/* Page program */
-		sflash_cmd(cc, SFLASH_ST_PP);
+			sflash_cmd(osh, cc, SFLASH_ST_PP);
 		}
 		break;
 	case SFLASH_AT:
 		mask = sfl->blocksize - 1;
-		page = (offset & ~mask) << 1;
-		byte = offset & mask;
+		page = (off & ~mask) << 1;
+		byte = off & mask;
 		/* Read main memory page into buffer 1 */
 		if (byte || (len < sfl->blocksize)) {
-			W_REG(NULL, &cc->flashaddress, page);
-			sflash_cmd(cc, SFLASH_AT_BUF1_LOAD);
+			W_REG(osh, &cc->flashaddress, page);
+			sflash_cmd(osh, cc, SFLASH_AT_BUF1_LOAD);
 			/* 250 us for AT45DB321B */
-			SPINWAIT(sflash_poll(cc, offset), 1000);
-			ASSERT(!sflash_poll(cc, offset));
+			SPINWAIT(sflash_poll(sbh, cc, off), 1000);
+			ASSERT(!sflash_poll(sbh, cc, off));
 		}
 		/* Write into buffer 1 */
 		for (ret = 0; (ret < (int)len) && (byte < sfl->blocksize); ret++) {
-			W_REG(NULL, &cc->flashaddress, byte++);
-			W_REG(NULL, &cc->flashdata, *buf++);
-			sflash_cmd(cc, SFLASH_AT_BUF1_WRITE);
+			W_REG(osh, &cc->flashaddress, byte++);
+			W_REG(osh, &cc->flashdata, *buf++);
+			sflash_cmd(osh, cc, SFLASH_AT_BUF1_WRITE);
 		}
 		/* Write buffer 1 into main memory page */
-		W_REG(NULL, &cc->flashaddress, page);
-		sflash_cmd(cc, SFLASH_AT_BUF1_PROGRAM);
+		W_REG(osh, &cc->flashaddress, page);
+		sflash_cmd(osh, cc, SFLASH_AT_BUF1_PROGRAM);
 		break;
 	}
 
@@ -298,23 +384,28 @@ sflash_write(chipcregs_t *cc, uint offse
  * Caller should poll for completion.
  */
 int
-sflash_erase(chipcregs_t *cc, uint offset)
+sflash_erase(sb_t *sbh, chipcregs_t *cc, uint offset)
 {
 	struct sflash *sfl;
+	osl_t *osh;
 
-	if (offset >= sflash.size)
-		return -22;
+	ASSERT(sbh);
+
+	osh = sb_osh(sbh);
 
 	sfl = &sflash;
+	if (offset >= sfl->size)
+		return -22;
+
 	switch (sfl->type) {
 	case SFLASH_ST:
-		sflash_cmd(cc, SFLASH_ST_WREN);
-		W_REG(NULL, &cc->flashaddress, offset);
-		sflash_cmd(cc, SFLASH_ST_SE);
+		sflash_cmd(osh, cc, SFLASH_ST_WREN);
+		W_REG(osh, &cc->flashaddress, offset);
+		sflash_cmd(osh, cc, SFLASH_ST_SE);
 		return sfl->blocksize;
 	case SFLASH_AT:
-		W_REG(NULL, &cc->flashaddress, offset << 1);
-		sflash_cmd(cc, SFLASH_AT_PAGE_ERASE);
+		W_REG(osh, &cc->flashaddress, offset << 1);
+		sflash_cmd(osh, cc, SFLASH_AT_PAGE_ERASE);
 		return sfl->blocksize;
 	}
 
@@ -326,13 +417,18 @@ sflash_erase(chipcregs_t *cc, uint offse
  * the region of flash
  */
 int
-sflash_commit(chipcregs_t *cc, uint offset, uint len, const uchar *buf)
+sflash_commit(sb_t *sbh, chipcregs_t *cc, uint offset, uint len, const uchar *buf)
 {
 	struct sflash *sfl;
 	uchar *block = NULL, *cur_ptr, *blk_ptr;
 	uint blocksize = 0, mask, cur_offset, cur_length, cur_retlen, remainder;
 	uint blk_offset, blk_len, copied;
 	int bytes, ret = 0;
+	osl_t *osh;
+
+	ASSERT(sbh);
+
+	osh = sb_osh(sbh);
 
 	/* Check address range */
 	if (len <= 0)
@@ -346,7 +442,7 @@ sflash_commit(chipcregs_t *cc, uint offs
 	mask = blocksize - 1;
 
 	/* Allocate a block of mem */
-	if (!(block = MALLOC(NULL, blocksize)))
+	if (!(block = MALLOC(osh, blocksize)))
 		return -1;
 
 	while (len) {
@@ -371,7 +467,7 @@ sflash_commit(chipcregs_t *cc, uint offs
 
 				/* Copy entire block */
 				while (blk_len) {
-					copied = sflash_read(cc, blk_offset, blk_len, blk_ptr); 
+					copied = sflash_read(sbh, cc, blk_offset, blk_len, blk_ptr);
 					blk_offset += copied;
 					blk_len -= copied;
 					blk_ptr += copied;
@@ -383,9 +479,9 @@ sflash_commit(chipcregs_t *cc, uint offs
 		}
 
 		/* Erase block */
-		if ((ret = sflash_erase(cc, (uint) cur_offset)) < 0)
+		if ((ret = sflash_erase(sbh, cc, (uint) cur_offset)) < 0)
 			goto done;
-		while (sflash_poll(cc, (uint) cur_offset));
+		while (sflash_poll(sbh, cc, (uint) cur_offset));
 
 		/* buf == NULL means erase only */
 		if (!buf) {
@@ -396,14 +492,14 @@ sflash_commit(chipcregs_t *cc, uint offs
 
 		/* Write holding block */
 		while (cur_length > 0) {
-			if ((bytes = sflash_write(cc,
+			if ((bytes = sflash_write(sbh, cc,
 						  (uint) cur_offset,
 						  (uint) cur_length,
 						  (uchar *) cur_ptr)) < 0) {
 				ret = bytes;
 				goto done;
 			}
-			while (sflash_poll(cc, (uint) cur_offset));
+			while (sflash_poll(sbh, cc, (uint) cur_offset));
 			cur_offset += bytes;
 			cur_length -= bytes;
 			cur_ptr += bytes;
@@ -417,6 +513,6 @@ sflash_commit(chipcregs_t *cc, uint offs
 	ret = len;
 done:
 	if (block)
-		MFREE(NULL, block, blocksize);
+		MFREE(osh, block, blocksize);
 	return ret;
 }
diff -urBwp src/shared/load.c shared/load.c
--- src/shared/load.c	2007-11-19 07:01:01.000000000 +0300
+++ src.3034/shared/load.c	2008-07-21 13:20:53.000000000 +0400
@@ -57,7 +57,7 @@ fill_inbuf(void)
 
 	for (insize = 0; insize < INBUFSIZ; insize += bytes, inoff += bytes) {
 		if (sflash) {
-			if ((bytes = sflash_read(cc, inoff, INBUFSIZ - insize,
+			if ((bytes = sflash_read(sbh, cc, inoff, INBUFSIZ - insize,
 			                         &inbuf[insize])) < 0)
 				return bytes;
 		} else {
@@ -259,19 +259,19 @@ sflash_self(chipcregs_t *cc)
 	while (cur < end) {
 		/* Erase sector */
 		printf("Erasing sector 0x%x...", (cur - start));
-		if ((erasesize = sflash_erase(cc, cur - start)) < 0) {
+		if ((erasesize = sflash_erase(sbh, cc, cur - start)) < 0) {
 			printf("error\n");
 			break;
 		}
-		while (sflash_poll(cc, cur - start));
+		while (sflash_poll(sbh, cc, cur - start));
 		printf("done\n");
 
 		/* Write sector */
 		printf("Writing sector 0x%x...", (cur - start));
 		while (erasesize) {
-			if ((len = sflash_write(cc, cur - start, erasesize, cur)) < 0)
+			if ((len = sflash_write(sbh, cc, cur - start, erasesize, cur)) < 0)
 				break;
-			while (sflash_poll(cc, cur - start));
+			while (sflash_poll(sbh, cc, cur - start));
 			cur += len;
 			erasesize -= len;
 		}
@@ -297,7 +297,7 @@ c_main(unsigned long ra)
 	cc = sb_setcore(sbh, SB_CC, 0);
 
 	/* Initialize serial flash */
-	sflash = cc ? sflash_init(cc) : NULL;
+	sflash = cc ? sflash_init(sbh, cc) : NULL;
 
 	/* Copy self to flash if we booted from SDRAM */
 	if (PHYSADDR(ra) < SB_FLASH1) {
