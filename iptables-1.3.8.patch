diff -BurN iptables-1.2.7a/extensions/libipt_autofw.c iptables/extensions/libipt_autofw.c
--- iptables-1.2.7a/extensions/libipt_autofw.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_autofw.c	2004-11-11 10:28:20.000000000 +0300
@@ -0,0 +1,192 @@
+/*
+ * Automatic port forwarding target. When this target is entered, a
+ * related connection to a port in the reply direction will be
+ * expected. This connection may be mapped to a different port.
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+/* Shared library add-on to iptables to add masquerade support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_autofw.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"autofw v%s options:\n"
+" --related-proto proto\n"
+"				Related protocol\n"
+" --related-dport port[-port]\n"
+"				Related destination port range\n"
+" --related-to port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "related-proto", 1, 0, '1' },
+	{ "related-dport", 1, 0, '2' },
+	{ "related-to", 1, 0, '3' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	const char *dash;
+	int port;
+
+	port = atoi(arg);
+	if (port == 0 || port > 65535)
+		exit_error(PARAMETER_PROBLEM, "Port `%s' not valid\n", arg);
+
+	dash = strchr(arg, '-');
+	if (!dash)
+		ports[0] = ports[1] = htons(port);
+	else {
+		int maxport;
+
+		maxport = atoi(dash + 1);
+		if (maxport == 0 || maxport > 65535)
+			exit_error(PARAMETER_PROBLEM,
+				   "Port `%s' not valid\n", dash+1);
+		if (maxport < port)
+			/* People are stupid. */
+			exit_error(PARAMETER_PROBLEM,
+				   "Port range `%s' funky\n", arg);
+		ports[0] = htons(port);
+		ports[1] = htons(maxport);
+	}
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (!strcasecmp(optarg, "tcp"))
+			info->proto = IPPROTO_TCP;
+		else if (!strcasecmp(optarg, "udp"))
+			info->proto = IPPROTO_UDP;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "unknown protocol `%s' specified", optarg);
+		return 1;
+
+	case '2':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --related-dport");
+
+		parse_ports(optarg, info->dport);
+		return 1;
+
+	case '3':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --related-to");
+
+		parse_ports(optarg, info->to);
+		*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)target->data;
+
+	printf("autofw ");
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+	printf("dpt:%hu", ntohs(info->dport[0]));
+	if (ntohs(info->dport[1]) > ntohs(info->dport[0]))
+		printf("-%hu", ntohs(info->dport[1]));
+	printf(" ");
+	printf("to:%hu", ntohs(info->to[0]));
+	if (ntohs(info->to[1]) > ntohs(info->to[0]))
+		printf("-%hu", ntohs(info->to[1]));
+	printf(" ");
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)target->data;
+
+	printf("--related-proto ");
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+	printf("--related-dport %hu-%hu ", ntohs(info->dport[0]), ntohs(info->dport[1]));
+	printf("--related-to %hu-%hu ", ntohs(info->to[0]), ntohs(info->to[1]));
+}
+
+struct iptables_target autofw = {
+	.next		=     NULL,
+	.name		=     "autofw",
+	.version	=     IPTABLES_VERSION,
+	.size		=     IPT_ALIGN(sizeof(struct ip_autofw_info)),
+	.userspacesize	=     IPT_ALIGN(sizeof(struct ip_autofw_info)),
+	.help		=     &help,
+	.init		=     &init,
+	.parse		=     &parse,
+	.final_check	=     &final_check,
+	.print		=     &print,
+	.save		=     &save,
+	.extra_opts	=     opts
+};
+
+void _init(void)
+{
+	register_target(&autofw);
+}
diff -BurN iptables-1.2.7a/extensions/libipt_time.c iptables/extensions/libipt_time.c
--- iptables-1.2.7a/extensions/libipt_time.c	2002-05-29 17:08:16.000000000 +0400
+++ iptables/extensions/libipt_time.c	2004-11-11 10:28:21.000000000 +0300
@@ -0,0 +1,199 @@
+/* Shared library add-on to iptables to add TIME matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <time.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TIME v%s options:\n"
+" --timestart value --timestop value --days listofdays\n"
+"          timestart value : HH:MM:SS\n"
+"          timestop  value : HH:MM:SS\n"
+"          listofdays value: a list of days to apply -> ie. Mon,Tue,Wed,Thu,Fri. Case sensitive\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "timestart", 1, 0, '1' },
+	{ "timestop", 1, 0, '2' },
+	{ "days", 1, 0, '3'},
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* caching not yet implemented */
+        *nfcache |= NFC_UNKNOWN;
+}
+
+static int
+parse_time(const char *time)
+{
+	int hours, minutes, seconds;
+
+	if (sscanf(time, "%d:%d:%d", &hours, &minutes, &seconds) == 3)
+		return (hours * 60 * 60 + minutes * 60 + seconds);
+
+	/* If we are here, there was a problem ..*/
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid time `%s' specified, should be HH:MM:SS format", time);
+}
+
+static const char *days[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
+
+static int
+parse_days(const char *string)
+{
+	char *comma;
+	int i, mask = 0;
+
+	do {
+		for (i = 0; i < 7; i++)
+			if (!strncasecmp(string, days[i], 3))
+				mask |= 1 << i;
+		comma = strchr(string, ',');
+		string = comma + 1;
+	} while (comma);
+
+	return mask;
+}
+
+#define IPT_TIME_START 0x01
+#define IPT_TIME_STOP  0x02
+#define IPT_TIME_DAYS  0x04
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(*match)->data;
+
+	switch (c)
+	{
+		/* timestart */
+	case '1':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestart");
+		if (*flags & IPT_TIME_START)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestart twice");
+		timeinfo->time_start = parse_time(optarg);
+		*flags |= IPT_TIME_START;
+		break;
+		/* timestop */
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestop");
+		if (*flags & IPT_TIME_STOP)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestop twice");
+		timeinfo->time_stop = parse_time(optarg);
+		*flags |= IPT_TIME_STOP;
+		break;
+
+		/* days */
+	case '3':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --days");
+		if (*flags & IPT_TIME_DAYS)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --days twice");
+		timeinfo->days_match = parse_days(optarg);
+		*flags |= IPT_TIME_DAYS;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; must have specified --timestart --timestop --days. */
+static void
+final_check(unsigned int flags)
+{
+	if (flags != (IPT_TIME_START | IPT_TIME_STOP | IPT_TIME_DAYS))
+		exit_error(PARAMETER_PROBLEM,
+			   "TIME match: You must specify `--timestart --timestop and --days'");
+}
+
+static void
+print_days(const struct ipt_time_info *time)
+{
+	int i;
+	char *sep = "";
+
+	for (i = 0; i < 7; i++) {
+		if (time->days_match & (1 << i)) {
+			printf("%s%s", sep, days[i]);
+			sep = ",";
+		}
+	}
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+
+	printf(" TIME from %02d:%02d:%02d to %02d:%02d:%02d on ",
+	       time->time_start / (60 * 60), (time->time_start / 60) % 60, time->time_start % 60,
+	       time->time_stop / (60 * 60), (time->time_stop / 60) % 60, time->time_stop % 60);
+	print_days(time);
+	printf(" ");
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+
+	printf(" --timestart %02d:%02d:%02d --timestop %02d:%02d:%02d --days ",
+	       time->time_start / (60 * 60), (time->time_start / 60) % 60, time->time_start % 60,
+	       time->time_stop / (60 * 60), (time->time_stop / 60) % 60, time->time_stop % 60);
+	print_days(time);
+	printf(" ");
+}
+
+static
+struct iptables_match timestruct = {
+	.next		=    NULL,
+	.name		=    "time",
+	.version	=    IPTABLES_VERSION,
+	.size		=    IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.userspacesize	=    IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.help		=    &help,
+	.init		=    &init,
+	.parse		=    &parse,
+	.final_check	=    &final_check,
+	.print		=    &print,
+	.save		=    &save,
+	.extra_opts	=    opts
+};
+
+void _init(void)
+{
+	register_match(&timestruct);
+}
diff -BurN iptables-1.2.7a/extensions/Makefile iptables/extensions/Makefile
--- iptables-1.2.7a/extensions/Makefile	2002-08-09 11:44:10.000000000 +0400
+++ iptables/extensions/Makefile	2004-11-11 10:28:20.000000000 +0300
@@ -5,7 +5,8 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah addrtype comment connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype policy realm sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TCPMSS TOS TTL ULOG
+#PF_EXT_SLIB:=ah addrtype comment connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype policy realm sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TCPMSS TOS TTL ULOG
+PF_EXT_SLIB:=tcp udp mac standard state SNAT DNAT REDIRECT REJECT MASQUERADE TCPMSS LOG autofw mark MARK limit tcpmss icmp TTL TARPIT MIRROR conntrack connmark multiport CONNMARK NETMAP time POOL pool iplimit nth psd random quota
 PF6_EXT_SLIB:=connmark eui64 hl icmp6 length limit mac mark multiport owner physdev policy standard state tcp udp CONNMARK HL LOG NFQUEUE MARK TCPMSS
 
 ifeq ($(DO_SELINUX), 1)
@@ -44,7 +45,6 @@
 PF6_EXT_SLIB+=$(PF6_EXT_SLIB_OPTS)
 
 OPTIONALS+=$(patsubst %,IPv4:%,$(PF_EXT_SLIB_OPTS))
-OPTIONALS+=$(patsubst %,IPv6:%,$(PF6_EXT_SLIB_OPTS))
 
 ifndef NO_SHARED_LIBS
 SHARED_LIBS+=$(foreach T,$(PF_EXT_SLIB),extensions/libipt_$(T).so)
@@ -53,6 +53,7 @@
 EXTRA_INSTALLS+=$(foreach T, $(PF_EXT_SE_SLIB), $(DESTDIR)$(LIBDIR)/iptables/libipt_$(T).so)
 
 ifeq ($(DO_IPV6), 1)
+OPTIONALS+=$(patsubst %,IPv6:%,$(PF6_EXT_SLIB_OPTS))
 SHARED_LIBS+=$(foreach T,$(PF6_EXT_SLIB),extensions/libip6t_$(T).so)
 SHARED_SE_LIBS+=$(foreach T,$(PF6_EXT_SE_SLIB),extensions/libip6t_$(T).so)
 EXTRA_INSTALLS+=$(foreach T, $(PF6_EXT_SLIB), $(DESTDIR)$(LIBDIR)/iptables/libip6t_$(T).so)
diff -BurN iptables-1.2.7a/Makefile iptables/Makefile
--- iptables-1.2.7a/Makefile	2002-08-26 17:04:39.000000000 +0400
+++ iptables/Makefile	2004-11-11 10:28:22.000000000 +0300
@@ -27,7 +27,7 @@
 RELEASE_DIR:=/tmp
 
 # Need libc6 for this.  FIXME: Should covert to autoconf.
-ifeq ($(shell [ -f /usr/include/netinet/ip6.h ] && echo YES), YES)
+ifeq ($(CONFIG_IPV6),y)
 DO_IPV6:=1
 endif
 
@@ -123,7 +123,9 @@
 
 .PHONY: print-extensions
 print-extensions:
-	@[ -n "$(OPTIONALS)" ] && echo Extensions found: $(OPTIONALS)
+ifneq ($(OPTIONALS),)
+	echo Extensions found: $(OPTIONALS)
+endif
 
 iptables.o: iptables.c
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" -c -o $@ $<
diff -BurN iptables-1.2.7a/extensions/libipt_TARPIT.c iptables/extensions/libipt_TARPIT.c
--- iptables-1.2.7a/extensions/libipt_TARPIT.c	1970-01-01 00:00:00.000000000 +0000
+++ iptables/extensions/libipt_TARPIT.c	2005-05-05 20:44:31.050000000 +0000
@@ -0,0 +1,67 @@
+/* Shared library add-on to iptables for TARPIT support */
+#include <stdio.h>
+#include <getopt.h>
+#include <iptables.h>
+
+static void
+help(void)
+{
+	fputs(
+"TARPIT takes no options\n"
+"\n", stdout);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+}
+
+static
+struct iptables_target tarpit = {
+	.next		=     NULL,
+	.name		=     "TARPIT",
+	.version	=     IPTABLES_VERSION,
+	.size		=     IPT_ALIGN(0),
+	.userspacesize	=     IPT_ALIGN(0),
+	.help		=     &help,
+	.init		=     &init,
+	.parse		=     &parse,
+	.final_check	=     &final_check,
+	.print		=     &print,
+	.save		=     &save,
+	.extra_opts	=     opts
+};
+
+void _init(void)
+{
+	register_target(&tarpit);
+}
diff -BurN iptables-1.3.8/extensions/libipt_iplimit.c iptables/extensions/libipt_iplimit.c
--- iptables-1.3.8/extensions/libipt_iplimit.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_iplimit.c	2002-05-29 17:08:16.000000000 +0400
@@ -0,0 +1,132 @@
+/* Shared library add-on to iptables to add state tracking support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_iplimit.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"iplimit v%s options:\n"
+"[!] --iplimit-above n		match if the number of existing tcp connections is (not) above n\n"
+" --iplimit-mask n		group hosts using mask\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "iplimit-above", 1, 0, '1' },
+	{ "iplimit-mask",  1, 0, '2' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)(*match)->data;
+
+	if (0 == (*flags & 2)) {
+		/* set default mask unless we've already seen a mask option */
+		info->mask = htonl(0xFFFFFFFF);
+	}
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->limit = atoi(argv[optind-1]);
+		info->inverse = invert;
+		*flags |= 1;
+		break;
+
+	case '2':
+		info->mask = htonl(0xFFFFFFFF << (32 - atoi(argv[optind-1])));
+		*flags |= 2;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check */
+static void final_check(unsigned int flags)
+{
+	if (!flags & 1)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--iplimit-above'");
+}
+
+static int
+count_bits(u_int32_t mask)
+{
+	int i, bits;
+
+	for (bits = 0, i = 31; i >= 0; i--) {
+		if (mask & htonl((u_int32_t)1 << i)) {
+			bits++;
+			continue;
+		}
+		break;
+	}
+	return bits;
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)match->data;
+
+	printf("#conn/%d %s %d ", count_bits(info->mask),
+	       info->inverse ? "<" : ">", info->limit);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)match->data;
+
+	printf("%s--iplimit-above %d ",info->inverse ? "! " : "",info->limit);
+	printf("--iplimit-mask %d ",count_bits(info->mask));
+}
+
+static struct iptables_match iplimit = {
+	name:		"iplimit",
+	version:	IPTABLES_VERSION,
+	size:		IPT_ALIGN(sizeof(struct ipt_iplimit_info)),
+	userspacesize:	offsetof(struct ipt_iplimit_info,data),
+	help:		help,
+	init:		init,
+	parse:		parse,
+	final_check:	final_check,
+	print:		print,
+	save: 		save,
+	extra_opts:	opts
+};
+
+void _init(void)
+{
+	register_match(&iplimit);
+}
diff -BurN iptables-1.3.8/extensions/libipt_nth.c iptables/extensions/libipt_nth.c
--- iptables-1.3.8/extensions/libipt_nth.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_nth.c	2002-05-29 17:08:16.000000000 +0400
@@ -0,0 +1,239 @@
+/* 
+   Shared library add-on to iptables to add match support for every Nth packet
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-07-17 Fabrice MARIE <fabrice@celestix.com> : initial development.
+   2001-09-20 Richard Wagner (rwagner@cloudnet.com)
+        * added support for multiple counters
+        * added support for matching on individual packets
+          in the counter cycle
+
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_nth.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"nth v%s options:\n"
+"   --every     Nth              Match every Nth packet\n"
+"  [--counter]  num              Use counter 0-%u (default:0)\n"
+"  [--start]    num              Initialize the counter at the number 'num'\n"
+"                                instead of 0. Must be between 0 and Nth-1\n"
+"  [--packet]   num              Match on 'num' packet. Must be between 0\n"
+"                                and Nth-1.\n\n"
+"                                If --packet is used for a counter than\n"
+"                                there must be Nth number of --packet\n"
+"                                rules, covering all values between 0 and\n"
+"                                Nth-1 inclusively.\n",
+IPTABLES_VERSION, IPT_NTH_NUM_COUNTERS-1);
+}
+
+static struct option opts[] = {
+	{ "every", 1, 0, '1' },
+	{ "start", 1, 0, '2' },
+        { "counter", 1, 0, '3' },
+        { "packet", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+#define IPT_NTH_OPT_EVERY	0x01
+#define IPT_NTH_OPT_NOT_EVERY	0x02
+#define IPT_NTH_OPT_START	0x04
+#define IPT_NTH_OPT_COUNTER     0x08
+#define IPT_NTH_OPT_PACKET      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_nth_info *nthinfo = (struct ipt_nth_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if ((!invert) && (*flags & IPT_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every twice");
+		if (invert && (*flags & IPT_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every twice");
+		if ((!invert) && (*flags & IPT_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every with ! --every");
+		if (invert && (*flags & IPT_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every with --every");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 2, 100, &num) == -1 || num < 2)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --every `%s', must be between 2 and 100", optarg);
+
+		/* assign the values */
+		nthinfo->every = num-1;
+		nthinfo->startat = 0;
+                nthinfo->packet = 0xFF;
+                if(!(*flags & IPT_NTH_OPT_EVERY))
+                {
+                        nthinfo->counter = 0;
+                }
+		if (invert)
+		{
+			*flags |= IPT_NTH_OPT_NOT_EVERY;
+			nthinfo->not = 1;
+		}
+		else
+		{
+			*flags |= IPT_NTH_OPT_EVERY;
+			nthinfo->not = 0;
+		}
+		break;
+	case '2':
+		/* check for common mistakes... */
+		if (!((*flags & IPT_NTH_OPT_EVERY) ||
+		      (*flags & IPT_NTH_OPT_NOT_EVERY)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start before --every");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify with ! --start");
+		if (*flags & IPT_NTH_OPT_START)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start twice");
+		if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --start `%s', must between 0 and %u", optarg, nthinfo->every);
+		*flags |= IPT_NTH_OPT_START;
+		nthinfo->startat = num;
+		break;
+        case '3':
+                /* check for common mistakes... */
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --counter");
+                if (*flags & IPT_NTH_OPT_COUNTER)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --counter twice");
+                if (string_to_number(optarg, 0, IPT_NTH_NUM_COUNTERS-1, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --counter `%s', must between 0 and %u", optarg, IPT_NTH_NUM_COUNTERS-1);
+                /* assign the values */
+                *flags |= IPT_NTH_OPT_COUNTER;
+                nthinfo->counter = num;
+                break;
+        case '4':
+                /* check for common mistakes... */
+                if (!((*flags & IPT_NTH_OPT_EVERY) ||
+                      (*flags & IPT_NTH_OPT_NOT_EVERY)))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet before --every");
+                if ((*flags & IPT_NTH_OPT_NOT_EVERY))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet with ! --every");
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --packet");
+                if (*flags & IPT_NTH_OPT_PACKET)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet twice");
+                if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --packet `%s', must between 0 and %u", optarg, nthinfo->every);
+                *flags |= IPT_NTH_OPT_PACKET;
+                nthinfo->packet = num;
+                break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_nth_info *nthinfo
+		= (const struct ipt_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf(" !");
+	printf("every %uth ", (nthinfo->every +1));
+	if (nthinfo->counter != 0) 
+		printf("counter #%u ", (nthinfo->counter));
+        if (nthinfo->packet != 0xFF)
+                printf("packet #%u ", nthinfo->packet);
+	if (nthinfo->startat != 0)
+		printf("start at %u ", nthinfo->startat);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_nth_info *nthinfo
+		= (const struct ipt_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf("! ");
+	printf("--every %u ", (nthinfo->every +1));
+	printf("--counter %u ", (nthinfo->counter));
+	if (nthinfo->startat != 0)
+		printf("--start %u ", nthinfo->startat );
+        if (nthinfo->packet != 0xFF)
+                printf("--packet %u ", nthinfo->packet );
+}
+
+struct iptables_match nth = {
+    .next          =    NULL,
+    .name          =    "nth",
+    .version       =    IPTABLES_VERSION,
+    .size          =    IPT_ALIGN(sizeof(struct ipt_nth_info)),
+    .userspacesize =    IPT_ALIGN(sizeof(struct ipt_nth_info)),
+    .help          =    &help,
+    .init          =    &init,
+    .parse         =    &parse,
+    .final_check   =    &final_check,
+    .print         =    &print,
+    .save          =    &save,
+    .extra_opts    =    opts
+};
+
+void _init(void)
+{
+	register_match(&nth);
+}
diff -BurN iptables-1.3.8/extensions/libipt_pool.c iptables/extensions/libipt_pool.c
--- iptables-1.3.8/extensions/libipt_pool.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_pool.c	2002-05-29 17:08:16.000000000 +0400
@@ -0,0 +1,144 @@
+/* Shared library add-on to iptables to add IP address pool matching. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_pool.h>
+
+#include <libippool/ip_pool_support.h>
+
+/* FIXME --RR */
+#include "../ippool/libippool.c"
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"pool v%s options:\n"
+" [!] --srcpool NAME|INDEX\n"
+" [!] --dstpool NAME|INDEX\n"
+"			Pool index (or name from %s) to match\n"
+"\n", IPTABLES_VERSION, IPPOOL_CONF);
+}
+
+static struct option opts[] = {
+	{ "srcpool", 1, 0, '1' },
+	{ "dstpool", 1, 0, '2' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	info->src = IP_POOL_NONE;
+	info->dst = IP_POOL_NONE;
+	info->flags = 0;
+	/* Can't cache this - XXX */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->src = ip_pool_get_index(argv[optind-1]);
+		if (invert) info->flags |= IPT_POOL_INV_SRC;
+		*flags = 1;
+		break;
+	case '2':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->dst = ip_pool_get_index(argv[optind-1]);
+		if (invert) info->flags |= IPT_POOL_INV_DST;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --srcpool or --dstpool. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "You must specify either `--srcpool or --dstpool'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	char buf[256];
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	if (info->src != IP_POOL_NONE)
+		printf("%ssrcpool %s ",
+			(info->flags & IPT_POOL_INV_SRC) ? "!" : "",
+			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
+	if (info->dst != IP_POOL_NONE)
+		printf("%sdstpool %s ",
+			(info->flags & IPT_POOL_INV_DST) ? "!" : "",
+			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	char buf[256];
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	if (info->src != IP_POOL_NONE)
+		printf("%s--srcpool %s",
+			(info->flags & IPT_POOL_INV_SRC) ? "! " : "",
+			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
+	if (info->dst != IP_POOL_NONE)
+		printf("%s--dstpool %s",
+			(info->flags & IPT_POOL_INV_DST) ? "! " : "",
+			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
+}
+
+static
+struct iptables_match pool = {
+    .next          =    NULL,
+    .name          =    "pool",
+    .version       =    IPTABLES_VERSION,
+    .size          =    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    .userspacesize =    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    .help          =    &help,
+    .init          =    &init,
+    .parse         =    &parse,
+    .final_check   =    &final_check,
+    .print         =    &print,
+    .save          =    &save,
+    .extra_opts    =    opts
+};
+
+void _init(void)
+{
+	register_match(&pool);
+}
diff -BurN iptables-1.3.8/extensions/libipt_POOL.c iptables/extensions/libipt_POOL.c
--- iptables-1.3.8/extensions/libipt_POOL.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_POOL.c	2002-06-04 21:25:38.000000000 +0400
@@ -0,0 +1,155 @@
+/* Shared library add-on to iptables to add IP pool mangling target. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_pool.h>
+#include <linux/netfilter_ipv4/ipt_pool.h>
+
+#include <libippool/ip_pool_support.h>
+
+/* FIXME --RR */
+#define ip_pool_init           ip_POOL_init
+#define ip_pool_get_index      ip_POOL_get_index
+#define ip_pool_get_name       ip_POOL_get_name
+#include "../ippool/libippool.c"
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"POOL v%s options:\n"
+" --add-srcip <pool>\n"
+" --del-srcip <pool>\n"
+" --add-dstip <pool>\n"
+" --del-dstip <pool>\n"
+"				add/del src/dst IP from pool.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "add-srcip", 1, 0, '1' },
+	{ "del-srcip", 1, 0, '2' },
+	{ "add-dstip", 1, 0, '3' },
+	{ "del-dstip", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *target, unsigned int *nfcache)
+{
+	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
+
+	ipi->src = ipi->dst = IP_POOL_NONE;
+	ipi->flags = 0;
+
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_pool_info *ipi = (struct ipt_pool_info *) (*target)->data;
+	switch (c) {
+	case '1':	/* --add-srcip <pool> */
+		ipi->src = ip_pool_get_index(optarg);
+		ipi->flags &= ~IPT_POOL_DEL_SRC;
+		break;
+	case '2':	/* --del-srcip <pool> */
+		ipi->src = ip_pool_get_index(optarg);
+		ipi->flags |= IPT_POOL_DEL_SRC;
+		break;
+	case '3':	/* --add-dstip <pool> */
+		ipi->dst = ip_pool_get_index(optarg);
+		ipi->flags &= ~IPT_POOL_DEL_DST;
+		break;
+	case '4':	/* --del-dstip <pool> */
+		ipi->dst = ip_pool_get_index(optarg);
+		ipi->flags |= IPT_POOL_DEL_DST;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	char buf[256];
+	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
+
+	printf("POOL");
+	if (ipi->src != IP_POOL_NONE) {
+		printf(" --%s-srcip %s",
+			(ipi->flags & IPT_POOL_DEL_SRC) ? "del" : "add",
+			ip_pool_get_name(buf, sizeof(buf), ipi->src, numeric));
+	}
+	if (ipi->dst != IP_POOL_NONE) {
+		printf(" --%s-dstip %s",
+			(ipi->flags & IPT_POOL_DEL_DST) ? "del" : "add",
+			ip_pool_get_name(buf, sizeof(buf), ipi->dst, numeric));
+	}
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	char buf[256];
+	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
+
+	printf("-j POOL");
+	if (ipi->src != IP_POOL_NONE) {
+		printf(" --%s-srcip %s",
+			(ipi->flags & IPT_POOL_DEL_SRC) ? "del" : "add",
+			ip_pool_get_name(buf, sizeof(buf), ipi->src, 0));
+	}
+	if (ipi->dst != IP_POOL_NONE) {
+		printf(" --%s-dstip %s",
+			(ipi->flags & IPT_POOL_DEL_DST) ? "del" : "add",
+			ip_pool_get_name(buf, sizeof(buf), ipi->dst, 0));
+	}
+}
+
+static
+struct iptables_target ipt_pool_target = {
+    .next          =    NULL,
+    .name          =    "POOL",
+    .version       =    IPTABLES_VERSION,
+    .size          =    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    .userspacesize =    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    .help          =    &help,
+    .init          =    &init,
+    .parse         =    &parse,
+    .final_check   =    &final_check,
+    .print         =    &print,
+    .save          =    &save,
+    .extra_opts    =    opts
+};
+
+void _init(void)
+{
+	register_target(&ipt_pool_target);
+}
diff -BurN iptables-1.3.8/extensions/libipt_psd.c iptables/extensions/libipt_psd.c
--- iptables-1.3.8/extensions/libipt_psd.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_psd.c	2002-05-29 17:08:16.000000000 +0400
@@ -0,0 +1,201 @@
+/* 
+  Shared library add-on to iptables to add PSD support 
+   
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_psd.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"psd v%s options:\n"
+" --psd-weight-threshold threshhold  Portscan detection weight threshold\n\n"
+" --psd-delay-threshold  delay       Portscan detection delay threshold\n\n"
+" --psd-lo-ports-weight  lo          Privileged ports weight\n\n"
+" --psd-hi-ports-weight  hi          High ports weight\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "psd-weight-threshold", 1, 0, '1' },
+	{ "psd-delay-threshold", 1, 0, '2' },
+	{ "psd-lo-ports-weight", 1, 0, '3' },
+	{ "psd-hi-ports-weight", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)m->data;
+
+	psdinfo->weight_threshold = SCAN_WEIGHT_THRESHOLD;  
+	psdinfo->delay_threshold = SCAN_DELAY_THRESHOLD;
+	psdinfo->lo_ports_weight = PORT_WEIGHT_PRIV;
+	psdinfo->hi_ports_weight = PORT_WEIGHT_HIGH;
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+
+typedef struct _code {
+	char	*c_name;
+	int	c_val;
+} CODE;
+
+
+
+#define IPT_PSD_OPT_CTRESH 0x01
+#define IPT_PSD_OPT_DTRESH 0x02
+#define IPT_PSD_OPT_LPWEIGHT 0x04
+#define IPT_PSD_OPT_HPWEIGHT 0x08
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)(*match)->data;
+	unsigned int num;
+	char storage[strlen(optarg) + 2];
+
+	/* string_to_number needs a leading space */
+	storage[0] = ' ';
+	strcpy(&storage[1], optarg);
+
+	switch (c) {
+	/* PSD-weight-threshold */
+	case '1':
+		if (*flags & IPT_PSD_OPT_CTRESH)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-weight-threshold "
+				   "twice");
+                if (string_to_number(storage, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-weight-threshold `%s'", optarg);
+		psdinfo->weight_threshold = num;
+		*flags |= IPT_PSD_OPT_CTRESH;
+		break;
+
+	/* PSD-delay-threshold */
+	case '2':
+		if (*flags & IPT_PSD_OPT_DTRESH)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-delay-threshold twice");
+                if (string_to_number(storage, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-delay-threshold `%s'", optarg);
+		psdinfo->delay_threshold = num;
+		*flags |= IPT_PSD_OPT_DTRESH;
+		break;
+
+	/* PSD-lo-ports-weight */
+	case '3':
+		if (*flags & IPT_PSD_OPT_LPWEIGHT)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-lo-ports-weight twice");
+                if (string_to_number(storage, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-lo-ports-weight `%s'", optarg);
+		psdinfo->lo_ports_weight = num;
+		*flags |= IPT_PSD_OPT_LPWEIGHT;
+		break;
+
+	/* PSD-hi-ports-weight */
+	case '4':
+		if (*flags & IPT_PSD_OPT_HPWEIGHT)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-hi-ports-weight twice");
+                if (string_to_number(storage, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-hi-ports-weight `%s'", optarg);
+		psdinfo->hi_ports_weight = num;
+		*flags |= IPT_PSD_OPT_HPWEIGHT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_psd_info *psdinfo
+		= (const struct ipt_psd_info *)match->data;
+
+	printf("psd ");
+	printf("weight-threshold: %u ",psdinfo->weight_threshold);
+	printf("delay-threshold: %u ",psdinfo->delay_threshold);
+	printf("lo-ports-weight: %u ",psdinfo->lo_ports_weight);
+	printf("hi-ports-weight: %u ",psdinfo->hi_ports_weight);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_psd_info *psdinfo
+		= (const struct ipt_psd_info *)match->data;
+
+	printf("--psd-weight-threshold %u ", psdinfo->weight_threshold);
+	printf("--psd-delay-threshold %u ", psdinfo->delay_threshold);
+	printf("--psd-lo-ports-weight %u ",psdinfo->lo_ports_weight);
+	printf("--psd-hi-ports-weight %u ",psdinfo->hi_ports_weight);
+}
+
+static
+struct iptables_match psd = {
+    .next          =    NULL,
+    .name          =    "psd",
+    .version       =    IPTABLES_VERSION,
+    .size          =    IPT_ALIGN(sizeof(struct ipt_psd_info)),
+    .userspacesize =    IPT_ALIGN(sizeof(struct ipt_psd_info)),
+    .help          =    &help,
+    .init          =    &init,
+    .parse         =    &parse,
+    .final_check   =    &final_check,
+    .print         =    &print,
+    .save          =    &save,
+    .extra_opts    =    opts
+};
+
+void _init(void)
+{
+	register_match(&psd);
+}
diff -BurN iptables-1.3.8/extensions/libipt_random.c iptables/extensions/libipt_random.c
--- iptables-1.3.8/extensions/libipt_random.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_random.c	2002-05-29 17:08:16.000000000 +0400
@@ -0,0 +1,151 @@
+/* 
+   Shared library add-on to iptables to add match support for random match.
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-10-14 Fabrice MARIE <fabrice@celestix.com> : initial development.
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_random.h>
+
+/**
+ * The kernel random routing returns numbers between 0 and 255.
+ * To ease the task of the user in choosing the probability
+ * of matching, we want him to be able to use percentages.
+ * Therefore we have to accept numbers in percentage here,
+ * turn them into number between 0 and 255 for the kernel module,
+ * and turn them back to percentages when we print/save
+ * the rule.
+ */
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"random v%s options:\n"
+"  [--average]     percent      The probability in percentage of the match\n"
+"                               If ommited, a probability of 50%% percent is set.\n"
+"                               Percentage must be within : 1 <= percent <= 99.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "average", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_rand_info *randinfo = (struct ipt_rand_info *)(m)->data;
+	*nfcache |= NFC_UNKNOWN;
+
+	/* We assign the average to be 50 which is our default value */
+	/* 50 * 2.55 = 128 */
+	randinfo->average = 128;
+}
+
+#define IPT_RAND_OPT_AVERAGE	0x01
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_rand_info *randinfo = (struct ipt_rand_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --average");
+		if (*flags & IPT_RAND_OPT_AVERAGE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --average twice");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 1, 99, &num) == -1 || num < 1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --average `%s', must be between 1 and 99", optarg);
+
+		/* assign the values */
+		randinfo->average = (int)(num * 2.55);
+		*flags |= IPT_RAND_OPT_AVERAGE;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_rand_info *randinfo
+		= (const struct ipt_rand_info *)match->data;
+	div_t result = div((randinfo->average*100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf(" random %u%% ", result.quot);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_rand_info *randinfo
+		= (const struct ipt_rand_info *)match->data;
+	div_t result = div((randinfo->average *100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf("--average %u ", result.quot);
+}
+
+struct iptables_match rand_match = {
+    .next          =    NULL,
+    .name          =    "random",
+    .version       =    IPTABLES_VERSION,
+    .size          =    IPT_ALIGN(sizeof(struct ipt_rand_info)),
+    .userspacesize =    IPT_ALIGN(sizeof(struct ipt_rand_info)),
+    .help          =    &help,
+    .init          =    &init,
+    .parse         =    &parse,
+    .final_check   =    &final_check,
+    .print         =    &print,
+    .save          =    &save,
+    .extra_opts    =    opts
+};
+
+void _init(void)
+{
+	register_match(&rand_match);
+}
diff -BurN iptables-1.3.8/include/libippool/ip_pool_support.h iptables/include/libippool/ip_pool_support.h
--- iptables-1.3.8/include/libippool/ip_pool_support.h	1970-01-01 03:00:00.000000000 +0300
+++ iptables/include/libippool/ip_pool_support.h	2000-08-27 11:47:46.000000000 +0400
@@ -0,0 +1,26 @@
+/* support function prototypes for IP pool management (config file, mostly) */
+#ifndef _IP_POOL_SUPPORT_H
+#define _IP_POOL_SUPPORT_H
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ip_pool.h>
+
+#ifndef IPPOOL_CONF
+#define IPPOOL_CONF "/etc/ippool.conf"
+#endif
+
+/* called just to draw in this support .o */
+void ip_pool_init(void);
+
+/* given a pool name (or number), return pool index, possibly reading .conf */
+ip_pool_t ip_pool_get_index(char *name);
+
+/* given a pool index, and a buffer to store a name, search for the index
+ * in the .conf file, and give the textual name, if present; if not, the
+ * numeric index is returned. If numeric_flag == 1, the numeric index is
+ * always returned
+ */
+char *ip_pool_get_name(char *buf, int size, ip_pool_t index, int numeric_flag);
+
+#endif /*_IP_POOL_SUPPORT_H*/
diff -BurN iptables-1.3.8/include/linux/netfilter_ipv4/ipt_iplimit.h iptables/include/linux/netfilter_ipv4/ipt_iplimit.h
--- iptables-1.3.8/include/linux/netfilter_ipv4/ipt_iplimit.h	1970-01-01 03:00:00.000000000 +0300
+++ iptables/include/linux/netfilter_ipv4/ipt_iplimit.h	2001-02-28 14:21:54.000000000 +0300
@@ -0,0 +1,12 @@
+#ifndef _IPT_IPLIMIT_H
+#define _IPT_IPLIMIT_H
+
+struct ipt_iplimit_data;
+
+struct ipt_iplimit_info {
+	int limit;
+	int inverse;
+	u_int32_t mask;
+	struct ipt_iplimit_data *data;
+};
+#endif /* _IPT_IPLIMIT_H */
diff -BurN iptables-1.3.8/ippool/ippool.c iptables/ippool/ippool.c
--- iptables-1.3.8/ippool/ippool.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/ippool/ippool.c	2000-08-27 11:47:46.000000000 +0400
@@ -0,0 +1,589 @@
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <arpa/inet.h>
+#include <linux/netfilter_ipv4/ip_pool.h>
+#include <libippool/ip_pool_support.h>
+
+/* translate errnos, as returned by our *sockopt() functions */
+static char *errno2msg(int op, int err)
+{
+	switch(err) {
+	case ERANGE:
+		return "Address out of pool range";
+	}
+	return strerror(err);
+}
+
+static void usage(char *msg)
+{
+	if (msg) fprintf(stderr, "ERROR: %s\n", msg);
+	fprintf(stderr,
+"Usage: ippool [-LADCNF] [POOL] [args]\n"
+"The POOL argument is either a number, or a name from %s\n"
+, IPPOOL_CONF);
+	fprintf(stderr,
+"ippool [-n] [-l|-L POOL] [-u] [-v]\n"
+	"\tLists all (-l), or a single (-L) pool.\n"
+	"\tWith -u, summarized usage counts are listed.\n"
+	"\tWith -v, each pool membership is shown, one per line.\n"
+"ippool [-n] [-f|-F [POOL]]\n"
+	"\tflushes POOL (or all pools.)\n"
+"ippool [-n] [-x|-X [POOL]]\n"
+	"\tremoves POOL (or all pools.)\n"
+"ippool [-n] -B\n"
+	"\tcreates all fully specified pools found in the config file.\n"
+"ippool [-n] -N POOL [-t type] [FIRST LAST]\n"
+	"\tcreates POOL of IP addresses FIRST to LAST (inclusive).  If a\n"
+	"\tpool name from the config file %s is used, type and\n"
+	"\taddress information can be defined there.  The -t argument\n"
+	"\tgives the type (default bitmap).\n"
+"ippool [-n] -A POOL ADDR\n"
+	"\tadds ADDR to POOL\n"
+"ippool [-n] -D POOL ADDR\n"
+	"\tremoves ADDR from POOL\n"
+"ippool [-n] -C POOL ADDR\n"
+	"\ttests ADDR against membership in POOL\n"
+, IPPOOL_CONF);
+	exit(1);
+}
+
+/* config file parsing */
+
+#define IP_POOL_T_NONE		0
+#define IP_POOL_T_BITMAP	1
+
+static int conf_type = IP_POOL_T_NONE;
+static unsigned long conf_addr = 0;
+static unsigned long conf_addr2 = 0;
+
+#define SCAN_EOF (IP_POOL_NONE-1)
+
+static ip_pool_t get_index_line(
+	FILE *fp,
+	char **namep,
+	char **typep,
+	char **argp
+) {
+	char *p;
+	ip_pool_t index;
+	static char buf[256];
+
+	if (namep) *namep = 0;
+	if (typep) *typep = 0;
+	if (argp) *argp = 0;
+
+	if (!fgets(buf, sizeof(buf), fp)) return SCAN_EOF;
+
+	p = strtok(buf, " \t\n");
+	if (!p || *p == '#') return IP_POOL_NONE;
+	index = atoi(p);
+
+	p = strtok(0, " \t\n");
+	if (!p || *p == '#') return index;
+	if (namep) *namep = p;
+
+	p = strtok(0, " \t\n");
+	if (!p || *p == '#') return index;
+	if (typep) *typep = p;
+
+	p = strtok(0, "#\n");
+	if (argp) *argp = p;
+
+	return index;
+}
+
+static ip_pool_t get_index(char *name)
+{
+	FILE *fp;
+	char *poolname, *type, *arg, *p;
+	ip_pool_t res;
+
+	if (isdigit(*name))
+		return atoi(name);
+	fp = fopen(IPPOOL_CONF, "r");
+	if (!fp) {
+		fprintf(stderr, "cannot open %s - no pool names", IPPOOL_CONF);
+		exit(1);
+	}
+	while (SCAN_EOF != (res=get_index_line(fp, &poolname, &type, &arg))) {
+		if (poolname && 0 == strcmp(poolname, name)) {
+			if (!type || (0 == strcmp(type, "bitmap"))) {
+				conf_type = IP_POOL_T_BITMAP;
+				p = strtok(arg, " \t");
+				if (p) {
+					conf_addr = inet_addr(p);
+					p = strtok(0, " \t");
+					if (p)
+						conf_addr2 = inet_addr(p);
+					else
+						conf_addr = 0;
+				}
+			}
+			break;
+		}
+	}
+	fclose(fp);
+	if (res == SCAN_EOF) {
+		fprintf(stderr, "pool '%s' not found in %s\n",
+			name, IPPOOL_CONF);
+		exit(1);
+	}
+	return res;
+}
+
+static char *get_name(ip_pool_t index)
+{
+	FILE *fp;
+	static char sbuf[256];
+	int ok = 0;
+
+	fp = fopen(IPPOOL_CONF, "r");
+	if (fp) {
+		while (fgets(sbuf, sizeof(sbuf), fp)) {
+			char *p = strtok(sbuf, " \t\n");
+
+			if (!p || *p == '#') continue;
+			if (index != atoi(p)) continue;
+			p = strtok(0, " \t\n");
+			if (!p || *p == '#') continue;
+			memmove(sbuf, p, strlen(p)+1);
+			ok = 1;
+			break;
+		}
+		fclose(fp);
+	}
+	if (!ok) sprintf(sbuf, "%d", index);
+	return sbuf;
+}
+
+/* user/kernel interaction */
+
+static int fd = -1;
+static int flag_n = 0;		/* do not do anything; just brag about it */
+static int flag_v = 0;		/* be verbose (list members) */
+static int flag_q = 0;		/* be quiet */
+static int flag_u = 0;		/* show usage counts in listings */
+static char *flag_t = "bitmap";	/* pool type */
+
+static ip_pool_t high_nr(void)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+
+	req.op = IP_POOL_HIGH_NR;
+	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		fprintf(stderr,
+			"IP_POOL_HIGH_NR failed: %s\n",
+			errno2msg(IP_POOL_HIGH_NR, errno));
+		exit(1);
+	}
+	return req.index;
+}
+
+static void do_list(ip_pool_t pool)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+	u_int32_t first_ip;
+	u_int32_t last_ip;
+
+	req.op = IP_POOL_LOOKUP;
+	req.index = pool;
+	req.addr = req.addr2 = 0;
+	reqlen = sizeof(req);
+	if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		struct in_addr ina;
+		ina.s_addr = req.addr;
+		printf("%s %s", get_name(req.index), inet_ntoa(ina));
+		ina.s_addr = req.addr2;
+		printf(" %s", inet_ntoa(ina));
+		first_ip = ntohl(req.addr);
+		last_ip = ntohl(req.addr2);
+		if (flag_u) {
+			req.op = IP_POOL_USAGE;
+			req.index = pool;
+			reqlen = sizeof(req);
+			if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL,
+						&req, &reqlen)) {
+				printf(" %d %d", req.addr, req.addr2);
+			} else {
+				printf(" - -");
+			}
+		}
+		printf("\n");
+		if (flag_v) {
+			while (first_ip <= last_ip) {
+				req.op = IP_POOL_TEST_ADDR;
+				req.index = pool;
+				ina.s_addr = req.addr = htonl(first_ip);
+				reqlen = sizeof(req);
+				if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL,
+							&req, &reqlen)) {
+					if (req.addr) printf("\t%s\n",
+							inet_ntoa(ina));
+				}
+				first_ip++;
+			}
+		}
+	}
+}
+
+static void do_list_all(void)
+{
+	ip_pool_t i, highest = high_nr();
+
+	for (i=0; i<=highest; i++)
+		do_list(i);
+}
+
+static void do_flush(ip_pool_t pool)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+
+	req.op = IP_POOL_FLUSH;
+	req.index = pool;
+	if (flag_n) {
+		printf("ippool -F %d\n", req.index);
+		return;
+	}
+	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		int err = errno;
+		fprintf(stderr,
+			"IP_POOL_FLUSH %s failed: %s\n",
+			get_name(pool), errno2msg(IP_POOL_FLUSH, err));
+		exit(1);
+	}
+}
+
+static void do_flush_all(void)
+{
+	ip_pool_t i, highest = high_nr();
+
+	for (i=0; i<=highest; i++)
+		do_flush(i);
+}
+
+static void do_destroy(ip_pool_t pool)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+
+	req.op = IP_POOL_DESTROY;
+	req.index = pool;
+	if (flag_n) {
+		printf("ippool -X %d\n", req.index);
+		return;
+	}
+	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		int err = errno;
+		fprintf(stderr,
+			"IP_POOL_DESTROY %s failed: %s\n",
+			get_name(pool), errno2msg(IP_POOL_DESTROY, err));
+		exit(1);
+	}
+}
+
+static void do_destroy_all(void)
+{
+	ip_pool_t i, highest = high_nr();
+
+	for (i=0; i<=highest; i++)
+		do_destroy(i);
+}
+
+static int do_adddel(ip_pool_t pool, char *straddr, int op)
+{
+	struct ip_pool_request req;
+	int res;
+	int reqlen = sizeof(req);
+
+	req.op = op;
+	req.index = pool;
+	req.addr = inet_addr(straddr);
+	req.addr2 = 0;
+	if (flag_n) {
+		printf("ippool -%c %s %s\n",
+				(op == IP_POOL_ADD_ADDR) ? 'A' : 'D',
+				get_name(req.index), straddr);
+		return 0;
+	}
+	res = getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen);
+	if (0 > res) {
+		int err = errno;
+		fprintf(stderr,
+			"IP_POOL_ADD/DEL %s in %s failed: %s\n",
+			straddr, get_name(pool), errno2msg(op, err));
+		exit(1);
+	}
+	if (!flag_q)
+		printf("%s %s %d %d\n", get_name(pool), straddr, req.addr,
+			op == IP_POOL_ADD_ADDR ? 1 : 0);
+	return req.addr;
+}
+
+static int do_check(ip_pool_t pool, char *straddr)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+
+	req.op = IP_POOL_TEST_ADDR;
+	req.index = pool;
+	req.addr = inet_addr(straddr);
+	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		int err = errno;
+		fprintf(stderr,
+			"IP_POOL_TEST_ADDR %s in %s failed: %s\n",
+			straddr, get_name(pool),
+			errno2msg(IP_POOL_TEST_ADDR, err));
+		exit(1);
+	}
+	if (!flag_q)
+		printf("%s %s %d\n", get_name(req.index), straddr, req.addr);
+	return !req.addr;
+}
+
+static void do_new(ip_pool_t pool, int argc, char **argv)
+{
+	struct ip_pool_request req;
+	int reqlen = sizeof(req);
+
+	req.op = IP_POOL_INIT;
+	req.index = pool;
+	if (argc >= 2) {
+		conf_type = IP_POOL_T_BITMAP;
+		conf_addr = inet_addr(argv[0]);
+		conf_addr2 = inet_addr(argv[1]);
+	}
+	if (conf_type != IP_POOL_T_BITMAP || conf_addr == 0 || conf_addr2 == 0)
+		usage("bad pool specification");
+	req.addr = conf_addr;
+	req.addr2 = conf_addr2;
+	if (flag_n) {
+		printf("ippool -N %s [-T %s] ...\n", get_name(pool),
+					conf_type == IP_POOL_T_BITMAP
+						? "bitmap"
+						: "???");
+		return;
+	}
+	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
+		struct in_addr ina;
+		int err = errno;
+		ina.s_addr = conf_addr;
+		fprintf(stderr,
+			"IP_POOL_INIT %s [%s-",
+			get_name(pool), inet_ntoa(ina));
+		ina.s_addr = conf_addr2;
+		fprintf(stderr,
+			"%s] failed: %s\n",
+			inet_ntoa(ina), errno2msg(IP_POOL_INIT, err));
+		exit(1);
+	}
+}
+
+static void do_new_all(void)
+{
+	FILE *fp;
+	char *poolname, *type, *arg, *p;
+	int res;
+
+	fp = fopen(IPPOOL_CONF, "r");
+	if (!fp) {
+		fprintf(stderr, "cannot open %s - no pool names", IPPOOL_CONF);
+		exit(1);
+	}
+	while (SCAN_EOF != (res=get_index_line(fp, &poolname, &type, &arg))) {
+		if (poolname && type && (0 == strcmp(type, "bitmap"))) {
+			conf_type = IP_POOL_T_BITMAP;
+			p = strtok(arg, " \t");
+			if (p) {
+				conf_addr = inet_addr(p);
+				p = strtok(0, " \t");
+				if (p)
+					conf_addr2 = inet_addr(p);
+				else
+					conf_addr = 0;
+			}
+			if (conf_addr != 0) {
+				if (flag_v)
+					printf("ippool -N %s (%s) [%s]\n",
+						poolname, type, arg);
+				do_new(res, 0, 0);
+			}
+		}
+	}
+	fclose(fp);
+}
+
+int main(int argc, char **argv)
+{
+	int opt;
+	int op;
+#define OP_NONE		0
+#define OP_LIST		1
+#define OP_LIST_ALL	2
+#define OP_FLUSH	3
+#define OP_FLUSH_ALL	4
+#define OP_DESTROY	5
+#define OP_DESTROY_ALL	6
+#define OP_ADD		7
+#define OP_DEL		8
+#define OP_CHECK	9
+#define OP_NEW		10
+#define OP_NEW_ALL	11
+#define OP_HIGHEST	12
+	char *op_pool;
+
+	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		fprintf(stderr, "cannot get DGRAM socket: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+	op_pool = 0;
+	op = OP_NONE;
+	/* GRRR. I thought getopt() would allow an "L*" specifier, for an -L
+	 * taking an optional argument. Does not work. Bad.
+	 * Adding -l for -L without argument, also -f/-F and -x/-X.
+	 */
+	while (EOF != (opt=getopt( argc, argv, "HhnvuqA:D:C:N:t:L:F:X:lfxB")))
+	switch(opt) {
+		case 'l':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_LIST_ALL;
+			break;
+		case 'L':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_LIST;
+			op_pool = optarg;
+			break;
+		case 'f':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_FLUSH_ALL;
+			break;
+		case 'F':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_FLUSH;
+			op_pool = optarg;
+			break;
+		case 'x':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_DESTROY_ALL;
+			break;
+		case 'X':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_DESTROY;
+			op_pool = optarg;
+			break;
+		case 'A':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_ADD;
+			op_pool = optarg;
+			break;
+		case 'D':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_DEL;
+			op_pool = optarg;
+			break;
+		case 'C':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_CHECK;
+			op_pool = optarg;
+			break;
+		case 'B':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_NEW_ALL;
+			break;
+		case 'N':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_NEW;
+			op_pool = optarg;
+			break;
+		case 'H':
+			if (op != OP_NONE) usage("conflicting operations");
+			op = OP_HIGHEST;
+			break;
+		case 't':
+			flag_t = optarg;
+			break;
+		case 'n':
+			flag_n = 1;
+			break;
+		case 'v':
+			flag_v = 1;
+			break;
+		case 'u':
+			flag_u = 1;
+			break;
+		case 'q':
+			flag_q = 1;
+			break;
+		case 'h':
+			usage(0);
+		default:
+			usage("bad option");
+	}
+	if (op == OP_NONE)
+		usage("no operation specified");
+	if (op == OP_LIST_ALL) {
+		do_list_all();
+		return 0;
+	}
+	if (op == OP_LIST) {
+		do_list(get_index(op_pool));
+		return 0;
+	}
+	if (op == OP_FLUSH_ALL) {
+		do_flush_all();
+		return 0;
+	}
+	if (op == OP_FLUSH) {
+		do_flush(get_index(op_pool));
+		return 0;
+	}
+	if (op == OP_DESTROY_ALL) {
+		do_destroy_all();
+		return 0;
+	}
+	if (op == OP_DESTROY) {
+		do_destroy(get_index(op_pool));
+		return 0;
+	}
+	if (op == OP_CHECK) {
+		if (optind >= argc)
+			usage("missing address to check");
+		return do_check(get_index(op_pool), argv[optind]);
+	}
+	if (op == OP_NEW_ALL) {
+		do_new_all();
+		return 0;
+	}
+	if (op == OP_NEW) {
+		do_new(get_index(op_pool), argc-optind, argv+optind);
+		return 0;
+	}
+	if (op == OP_ADD) {
+		if (optind >= argc)
+			usage("missing address to add");
+		return do_adddel(get_index(op_pool),
+				argv[optind], IP_POOL_ADD_ADDR);
+	}
+	if (op == OP_DEL) {
+		if (optind >= argc)
+			usage("missing address to delete");
+		return do_adddel(get_index(op_pool),
+				argv[optind], IP_POOL_DEL_ADDR);
+	}
+	if (op == OP_HIGHEST) {
+		printf("%d\n", high_nr());
+		return 0;
+	}
+	usage("no operation specified");
+	return 0;
+}
diff -BurN iptables-1.3.8/ippool/libippool.c iptables/ippool/libippool.c
--- iptables-1.3.8/ippool/libippool.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/ippool/libippool.c	2000-08-27 11:47:46.000000000 +0400
@@ -0,0 +1,72 @@
+/* support functions for ip_pool modules */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#include <libippool/ip_pool_support.h>
+
+void ip_pool_init(void)
+{
+}
+
+ip_pool_t ip_pool_get_index(char *name)
+{
+	FILE *fp;
+	char buf[256];
+
+	if (isdigit(*name))
+		return atoi(name);
+	fp = fopen(IPPOOL_CONF, "r");
+	if (!fp) exit_error(PARAMETER_PROBLEM,
+			"cannot open %s - no pool names", IPPOOL_CONF);
+	while (fgets(buf, sizeof(buf), fp)) {
+		char *p = strtok(buf, " \t\n");
+		ip_pool_t index;
+
+		if (!p || *p == '#') continue;
+		index = atoi(p);
+		p = strtok(0, " \t\n");
+		if (p && 0 == strcmp(p, name)) {
+			fclose(fp);
+			return index;
+		}
+	}
+	exit_error(PARAMETER_PROBLEM,
+		"pool '%s' not found in %s\n", name, IPPOOL_CONF);
+}
+
+char *ip_pool_get_name(char *buf, int size, ip_pool_t index, int numeric)
+{
+	FILE *fp;
+	int ok = 0;
+
+	/* make sure we have enough room, at least for a %d */
+	if (size < 16)
+		exit_error(PARAMETER_PROBLEM,
+			"ip_pool_support:get_name buf too small (%d vs. 16)\n",
+			size);
+	if (numeric)
+		goto do_numeric;
+	fp = fopen(IPPOOL_CONF, "r");
+	if (fp) {
+		while (fgets(buf, size, fp)) {
+			char *p = strtok(buf, " \t\n");
+
+			if (!p || *p == '#') continue;
+			if (index != atoi(p)) continue;
+			p = strtok(0, " \t\n");
+			if (!p || *p == '#') continue;
+			memmove(buf, p, strlen(p)+1);
+			ok = 1;
+			break;
+		}
+		fclose(fp);
+	}
+	if (!ok) {
+do_numeric:
+		sprintf(buf, "%d", index);
+	}
+	return buf;
+}
diff -BurN iptables-1.3.8/ippool/Makefile iptables/ippool/Makefile
--- iptables-1.3.8/ippool/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ iptables/ippool/Makefile	2000-08-27 11:47:46.000000000 +0400
@@ -0,0 +1,18 @@
+EXTRAS+=$(shell [ -f $(KERNEL_DIR)/include/linux/netfilter_ipv4/ip_pool.h ] && echo ippool/libippool.a ippool/ippool)
+
+ifndef TOPLEVEL_INCLUDED
+local:
+	cd .. && $(MAKE) $(KERN_TARGETS) $(SHARED_LIBS) $(EXTRAS)
+
+else
+EXTRA_DEPENDS+=$(shell [ -f $(KERNEL_DIR)/include/linux/netfilter_ipv4/ip_pool.h ] && echo ippool/libippool.d)
+
+ippool/libippool.a: ippool/libippool.a(ippool/libippool.o)
+
+ippool/libippool.d: %.d: %.c
+	@-$(CC) -M -MG $(CFLAGS) $< | sed -e 's@^.*\.o:@$*.d $*.a($*.o):@' > $@
+
+ippool/ippool.o: ippool/ippool.c
+ippool/ippool: ippool/ippool.o ippool/libippool.a
+	$(CC) $(CFLAGS) -o $@ $^
+endif
diff -Bur iptables-1.3.8/extensions/libipt_quota.c iptables/extensions/libipt_quota.c
--- iptables-1.3.8/extensions/libipt_quota.c	2007-01-23 15:50:00.000000000 +0300
+++ iptables/extensions/libipt_quota.c	2007-12-27 16:18:05.000000000 +0300
@@ -9,7 +9,7 @@
 #include <getopt.h>
 #include <iptables.h>
 
-#include <linux/netfilter/xt_quota.h>
+#include <linux/netfilter_ipv4/ipt_quota.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 
 static struct option opts[] = {
@@ -29,7 +29,7 @@
 static void
 print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
 {
-        struct xt_quota_info *q = (struct xt_quota_info *) match->data;
+        struct ipt_quota_info *q = (struct ipt_quota_info *) match->data;
         printf("quota: %llu bytes", (unsigned long long) q->quota);
 }
 
@@ -37,7 +37,7 @@
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
-        struct xt_quota_info *q = (struct xt_quota_info *) match->data;
+        struct ipt_quota_info *q = (struct ipt_quota_info *) match->data;
         printf("--quota %llu ", (unsigned long long) q->quota);
 }
 
@@ -63,7 +63,7 @@
       const struct ipt_entry *entry,
       unsigned int *nfcache, struct ipt_entry_match **match)
 {
-        struct xt_quota_info *info = (struct xt_quota_info *) (*match)->data;
+        struct ipt_quota_info *info = (struct ipt_quota_info *) (*match)->data;
 
         switch (c) {
         case '1':
@@ -90,8 +90,8 @@
 	.next		= NULL,
 	.name		= "quota",
 	.version	= IPTABLES_VERSION,
-	.size		= IPT_ALIGN(sizeof (struct xt_quota_info)),
-	.userspacesize	= offsetof(struct xt_quota_info, quota),
+	.size		= IPT_ALIGN(sizeof (struct ipt_quota_info)),
+	.userspacesize	= offsetof(struct ipt_quota_info, quota),
 	.help		= &help,
 	.parse		= &parse,
 	.final_check	= &final_check,
diff -urbB iptables-1.3.8/extensions/libipt_set.h iptables/extensions/libipt_set.h
--- iptables-1.3.8/extensions/libipt_set.h	2007-01-23 15:50:00.000000000 +0300
+++ iptables/extensions/libipt_set.h	2008-12-19 12:15:51.000000000 +0300
@@ -66,7 +66,7 @@
 	if (size != sizeof(struct ip_set_req_get_set))
 		exit_error(OTHER_PROBLEM,
 			   "Incorrect return size from kernel during ipset lookup, "
-			   "(want %ld, got %ld)\n",
+			   "(want %d, got %d)\n",
 			   sizeof(struct ip_set_req_get_set), size);
 	if (req.set.index == IP_SET_INVALID_ID)
 		exit_error(PARAMETER_PROBLEM,
@@ -92,7 +92,7 @@
 	if (size != sizeof(struct ip_set_req_get_set))
 		exit_error(OTHER_PROBLEM,
 			   "Incorrect return size from kernel during ipset lookup, "
-			   "(want %ld, got %ld)\n",
+			   "(want %d, got %d)\n",
 			   sizeof(struct ip_set_req_get_set), size);
 	if (req.set.name[0] == '\0')
 		exit_error(PARAMETER_PROBLEM,
