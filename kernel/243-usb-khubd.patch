Improve startup/shutdown routines in khubd, like in 2.6

Protect khubd from ability to be killed from user space.
Also fix of infinite loop, occured in case of active requests
to disconnected hub (due to driver unload or hardware lost).

diff -BurpN linux-2.4.37.6/drivers/usb/hub.h linux/drivers/usb/hub.h
--- linux-2.4.37.6/drivers/usb/hub.h	2009-09-22 18:41:56.000000000 +0000
+++ linux/drivers/usb/hub.h	2009-09-22 18:38:10.000000000 +0000
@@ -144,6 +144,8 @@ struct usb_hub {
 
 	struct semaphore khubd_sem;
 	struct usb_tt		tt;		/* Transaction Translator */
+
+	unsigned	disconnected:1;
 };
 
 #endif /* __LINUX_HUB_H */
diff -BurpN linux-2.4.37.6/drivers/usb/hub.c linux/drivers/usb/hub.c
--- linux-2.4.37.6/drivers/usb/hub.c	2009-09-22 18:41:56.000000000 +0000
+++ linux/drivers/usb/hub.c	2009-09-22 18:50:28.000000000 +0000
@@ -38,7 +38,7 @@ static LIST_HEAD(hub_event_list);	/* Lis
 static LIST_HEAD(hub_list);		/* List containing all of the hubs (for cleanup) */
 
 static DECLARE_WAIT_QUEUE_HEAD(khubd_wait);
-static pid_t khubd_pid = 0;			/* PID of khubd */
+static int khubd_terminated = 0;
 static DECLARE_COMPLETION(khubd_exited);
 
 #ifdef	DEBUG
@@ -132,7 +132,7 @@ static void hub_irq(struct urb *urb)
 
 	/* Something happened, let khubd figure it out */
 	spin_lock_irqsave(&hub_event_lock, flags);
-	if (list_empty(&hub->event_list)) {
+	if (!hub->disconnected && list_empty(&hub->event_list)) {
 		list_add(&hub->event_list, &hub_event_list);
 		wake_up(&khubd_wait);
 	}
@@ -405,6 +405,7 @@ static void *hub_probe(struct usb_device
 	/* Delete it and then reset it */
 	list_del(&hub->event_list);
 	INIT_LIST_HEAD(&hub->event_list);
+	hub->disconnected = 1;
 	list_del(&hub->hub_list);
 	INIT_LIST_HEAD(&hub->hub_list);
 
@@ -839,6 +840,9 @@ static void usb_hub_events(void)
 		down(&hub->khubd_sem); /* never blocks, we were on list */
 		spin_unlock_irqrestore(&hub_event_lock, flags);
 
+		if (unlikely(hub->disconnected))
+			goto loop;
+
 		if (hub->error) {
 			dbg("resetting hub %d for error %d", dev->devnum, hub->error);
 
@@ -920,13 +924,14 @@ static void usb_hub_events(void)
 			}
 			kfree(hubsts);
 		}
+loop:
 		up(&hub->khubd_sem);
         } /* end while (1) */
 
 	spin_unlock_irqrestore(&hub_event_lock, flags);
 }
 
-static int usb_hub_thread(void *__hub)
+static int usb_hub_thread(void *startup)
 {
 	lock_kernel();
 
@@ -938,14 +943,23 @@ static int usb_hub_thread(void *__hub)
 	daemonize();
 	reparent_to_init();
 
+ 	/* Block all signals */
+ 	spin_lock_irq(&current->sigmask_lock);
+ 	sigfillset(&current->blocked);
+ 	recalc_sigpending(current);
+ 	spin_unlock_irq(&current->sigmask_lock);
+
 	/* Setup a nice name */
 	strcpy(current->comm, "khubd");
 
-	/* Send me a signal to get me die (for debugging) */
+ 	khubd_terminated = 0;
+ 	complete((struct completion *)startup);
+ 
+ 	/* Set khubd_terminated=1 to get me die */
 	do {
 		usb_hub_events();
-		wait_event_interruptible(khubd_wait, !list_empty(&hub_event_list)); 
-	} while (!signal_pending(current));
+ 		wait_event_interruptible(khubd_wait, !list_empty(&hub_event_list) || khubd_terminated);
+ 	} while (!khubd_terminated || !list_empty(&hub_event_list));
 
 	dbg("usb_hub_thread exiting");
 
@@ -974,17 +988,16 @@ static struct usb_driver hub_driver = {
  */
 int usb_hub_init(void)
 {
-	pid_t pid;
+	DECLARE_COMPLETION(startup);
 
 	if (usb_register(&hub_driver) < 0) {
 		err("Unable to register USB hub driver");
 		return -1;
 	}
 
-	pid = kernel_thread(usb_hub_thread, NULL,
-		CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
-	if (pid >= 0) {
-		khubd_pid = pid;
+	if (kernel_thread(usb_hub_thread, &startup,
+		CLONE_FS | CLONE_FILES | CLONE_SIGHAND) >= 0) {
+		wait_for_completion(&startup);
 
 		return 0;
 	}
@@ -998,10 +1011,9 @@ int usb_hub_init(void)
 
 void usb_hub_cleanup(void)
 {
-	int ret;
-
 	/* Kill the thread */
-	ret = kill_proc(khubd_pid, SIGTERM, 1);
+ 	khubd_terminated = 1;
+ 	wake_up(&khubd_wait);
 
 	wait_for_completion(&khubd_exited);
 
