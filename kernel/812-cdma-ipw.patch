 
 http://www.neology.co.za/products/opensource/ipwireless/
 
diff -urB linux-2.4.37.orig/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.37.orig/Documentation/Configure.help	2009-01-14 14:29:40.000000000 +0300
+++ linux/Documentation/Configure.help	2009-01-20 15:10:50.000000000 +0300
@@ -15957,6 +15972,14 @@
   The module will be called io_edgeport.o.  If you want to compile it
   as a module, say M here and read <file:Documentation/modules.txt>.
 
+USB IPWireless (3G UMTS TDD) Driver (EXPERIMENTAL)
+CONFIG_USB_SERIAL_IPW
+  Say Y here if you want to use a IPWireless USB modem such as
+  the ones supplied by Axity3G/Sentech South Africa.
+
+  To compile this driver as a module, choose M here: the
+  module will be called ipw.
+
 USB PalmConnect (and other KL5KUSB105-based) Single Port Serial Driver
 CONFIG_USB_SERIAL_KLSI
   Say Y here if you want to use a KL5KUSB105 - based single port
diff -urBp linux-2.4.37.orig/drivers/usb/serial/Config.in linux/drivers/usb/serial/Config.in
--- linux-2.4.37.orig/drivers/usb/serial/Config.in	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/usb/serial/Config.in	2009-01-20 15:08:05.000000000 +0300
@@ -42,6 +42,7 @@
    dep_tristate '  USB Sierra Wireless Driver' CONFIG_USB_SERIAL_SIERRAWIRELESS $CONFIG_USB_SERIAL
    dep_tristate '  USB Xircom / Entregra Single Port Serial Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_XIRCOM $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
    dep_tristate '  USB ZyXEL omni.net LCD Plus Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_OMNINET $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
+   dep_tristate '  USB IPWireless (3G UMTS TDD) Driver (EXPERIMENTAL)' CONFIG_USB_SERIAL_IPW $CONFIG_USB_SERIAL $CONFIG_EXPERIMENTAL
 fi
 
 endmenu
diff -urBp linux-2.4.37.orig/drivers/usb/serial/Makefile linux/drivers/usb/serial/Makefile
--- linux-2.4.37.orig/drivers/usb/serial/Makefile	2008-12-29 14:35:51.000000000 +0300
+++ linux/drivers/usb/serial/Makefile	2009-01-20 15:27:02.000000000 +0300
@@ -27,6 +27,7 @@ obj-$(CONFIG_USB_SERIAL_IR)			+= ir-usb.
 obj-$(CONFIG_USB_SERIAL_KLSI)			+= kl5kusb105.o
 obj-$(CONFIG_USB_SERIAL_KOBIL_SCT)		+= kobil_sct.o
 obj-$(CONFIG_USB_SERIAL_SIERRAWIRELESS)	+= sierra.o
+obj-$(CONFIG_USB_SERIAL_IPW)			+= ipw.o
 
 # Objects that export symbols.
 export-objs	:= usbserial.o
diff -uBN linux-2.4.37.orig/drivers/usb/serial/ipw.h linux/drivers/usb/serial/ipw.h
--- linux-2.4.37.orig/drivers/usb/serial/ipw.h	1970-01-01 03:00:00.000000000 +0300
+++ linux/drivers/usb/serial/ipw.h	2005-10-10 19:35:32.000000000 +0400
@@ -0,0 +1,98 @@
+/*
+ * Definitions for the IPWireless 3G UMTS TDD, USB connected modem
+ */
+
+/* vendor/product pairs that are known work with this driver*/
+/* to add a supported device, define the id's here and modify the */
+/* id_table in ipw.c */
+
+#define IPW_VID		0x0bc3
+#define IPW_PID1	0x0001 // modem uses this product id in "normal" mode
+#define IPW_PID2	0x0002 // modem uses this product id in "composite" mode
+
+
+/* Vendor commands: */
+
+
+
+/* baud rates */
+
+enum {
+  ipw_sio_b256000 = 0x000e,
+  ipw_sio_b128000 = 0x001d,
+  ipw_sio_b115200 = 0x0020,
+  ipw_sio_b57600  = 0x0040,
+  ipw_sio_b56000  = 0x0042,
+  ipw_sio_b38400  = 0x0060,
+  ipw_sio_b19200  = 0x00c0,
+  ipw_sio_b14400  = 0x0100,
+  ipw_sio_b9600   = 0x0180,
+  ipw_sio_b4800   = 0x0300,   
+  ipw_sio_b2400   = 0x0600,   
+  ipw_sio_b1200   = 0x0c00, 
+  ipw_sio_b600    = 0x1800
+};
+
+/* data bits */
+#define ipw_dtb_7   0x700
+#define ipw_dtb_8   0x810	// ok so the define is misleading, I know, but forces 8,n,1
+				// I mean, is there a point to any other setting these days? :)	
+
+
+
+/* usb control request types : */
+#define IPW_SIO_RXCTL	  0x00 // control bulk rx channel transmissions, value=1/0 (on/off)
+#define IPW_SIO_SET_BAUD  0x01 // set baud, value=requested ipw_sio_bxxxx
+#define IPW_SIO_SET_LINE  0x03 // set databits, parity. value=ipw_dtb_x
+#define IPW_SIO_SET_PIN   0x07 // set/clear dtr/rts value=ipw_pin_xxx
+#define IPW_SIO_POLL	  0x08 // get serial port status byte, call with value=0
+
+#define IPW_SIO_FETCH_UNK 0x10 // fetches some unknown data, typicall 32 bytes of gumph
+
+#define IPW_SIO_INIT	  0x11 // initializes ? value=0 (appears as first thing todo on open)
+#define IPW_SIO_PURGE	  0x12 // purge all transmissions?, call with value=numchar_to_purge
+#define IPW_SIO_HANDFLOW  0x13 // set xon/xoff limits value=0, and a buffer of 0x10 bytes
+#define IPW_SIO_SETCHARS  0x19 // set the flowcontrol special chars, value=0, buf=6 bytes, 
+			       // last 2 bytes contain flowcontrol chars e.g. 00 00 00 00 11 13
+
+
+/* values used for request IPW_SIO_SET_PIN*/
+#define IPW_PIN_SETDTR	0x101
+#define IPW_PIN_SETRTS	0x202
+#define IPW_PIN_CLRDTR	0x100
+#define IPW_PIN_CLRRTS	0x200 // unconfirmed
+
+/* values used for request IPW_SIO_RXCTL*/
+#define IPW_RXBULK_ON		1
+#define IPW_RXBULK_OFF		0
+
+
+/* various 16 byte hardcoded transferbuffers used by flow control */
+#define IPW_BYTES_FLOWINIT	{ 0x01, 0, 0, 0, 0x40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+#define IPW_BYTES_SETCHARSINIT_XONXOFF	{ 0, 0, 0, 0, 0x11, 0x13 } //set flow control chars to STX/ETX
+#define IPW_BYTES_SETCHARSINIT_NONE	{ 0, 0, 0, 0, 0, 0 } //no flow control characters please
+
+/* Interpretation of modem status lines */
+/* These need sorting out by individually connecting pins and checking
+ * results. FIXME!
+ * When data is being sent we see 0x30 in the lower byte; this must
+ * contain DSR and CTS ...
+ */
+#define IPW_DSR			((1<<4) | (1<<5))
+#define IPW_CTS			((1<<5) | (1<<4))
+
+#define IPW_WANTS_TO_SEND	0x30
+//#define IPW_DTR			/* Data Terminal Ready */
+//#define IPW_CTS			/* Clear To Send */
+//#define IPW_CD			/* Carrier Detect */
+//#define IPW_DSR			/* Data Set Ready */
+//#define IPW_RxD			/* Receive pin */
+
+//#define IPW_LE
+//#define IPW_RTS		
+//#define IPW_ST		
+//#define IPW_SR		
+//#define IPW_RI			/* Ring Indicator */
+
+/* vim: set ts=8 sts=8: */
+
diff -urBNp -x'*.o' -x'.*' linux-2.4.37.orig/drivers/usb/serial/ipw.c linux/drivers/usb/serial/ipw.c
--- linux-2.4.37.orig/drivers/usb/serial/ipw.c	1970-01-01 03:00:00.000000000 +0300
+++ linux/drivers/usb/serial/ipw.c	2009-01-23 10:36:52.000000000 +0300
@@ -0,0 +1,655 @@
+/*
+ * IPWireless 3G UMTS TDD Modem driver (USB connected)
+ *
+ *   Copyright (C) 2004 Roelf Diedericks <roelfd@inet.co.za>
+ *   Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ * All information about the device was acquired using SnoopyPro
+ * on MSFT's O/S, and examing the MSFT drivers' debug output 
+ * (insanely left _on_ in the enduser version)
+ *
+ * It was written out of frustration with the IPWireless USB modem
+ * supplied by Axity3G/Sentech South Africa not supporting
+ * Linux whatsoever.
+ *
+ * Nobody provided any proprietary information that was not already 
+ * available for this device.
+ * 
+ * The modem adheres to the "3GPP TS  27.007 AT command set for 3G 
+ * User Equipment (UE)" standard, available from 
+ * http://www.3gpp.org/ftp/Specs/html-info/27007.htm
+ *
+ * The code was only tested the IPWireless handheld modem distributed
+ * in South Africa by Sentech.
+ * 
+ * It may work for Woosh Inc in .nz too, as it appears they use the
+ * same kit.
+ *
+ * There is still some work to be done in terms of handling 
+ * DCD, DTR, RTS, CTS which are currently faked.
+ * It's good enough for PPP at this point. It's based off all kinds of
+ * code found in usb/serial and usb/class
+ *
+ * Revision history:
+ *	Date:		Ver:	Notes:
+ *	2004/04/24	0.1	First public release
+ *	2004/04/29	0.2	use softirq for rx processing, as needed by tty layer
+ *				change completely to using spinlocks instead of down()
+ *	2005/09/10	0.3	Updated for >=2.6.11 kernels. Fix uninitialized spinlock
+ *	2005/10/10	0.4	Added functionality for modem's "console" device
+ *				Changed initialisation on device open() to toggle DTR,
+ *				this appears to reset the AT command parser to a sane state.
+ *				Modprobe argument "debug=1" will now provide debugging on 
+ *				demand.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_USB_SERIAL_DEBUG
+        static int debug = 1;
+#else
+        static int debug;
+#endif
+
+#include "usb-serial.h"
+#include "ipw.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION	"v0.4a"
+#define DRIVER_AUTHOR	"Roelf Diedericks"
+#define DRIVER_DESC	"IPWireless tty driver"
+
+#define IPW_TTY_MAJOR	240	/* real device node major id, experimental range */
+#define IPW_TTY_MINORS	256	/* we support 256 devices, dunno why, it'd be insane :) */
+
+#define USB_IPW_MAGIC	0x6d02	/* magic number for ipw struct */
+#define IPW_URB_TIMEOUT (HZ * 200)
+
+
+/* Message sizes */
+#define EVENT_BUFFER_SIZE       0xFF
+#define CHAR2INT16(c1,c0)       (((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))
+#define NUM_BULK_URBS           24
+#define NUM_CONTROL_URBS        16
+
+
+static struct usb_device_id usb_ipw_ids[] = {
+	{ USB_DEVICE(IPW_VID, IPW_PID1) },
+	{ USB_DEVICE(IPW_VID, IPW_PID2) },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
+
+struct ipw_private {
+	int		magic;
+
+	spinlock_t	lock;
+	int		write_urb_busy;
+
+	u16		ifnum;   /* type of interface: 0=modem, or 1=console */
+	unsigned int    control_lines; /* dsr/cts/rts status bits */
+};
+
+static LIST_HEAD(usb_serial_driver_list);
+
+static void show_status(struct usb_serial_port *port)
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ipw_private *priv = usb_get_serial_port_data(port);
+	unsigned char buf[10];
+	int response;
+
+	response = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			IPW_SIO_POLL,
+			USB_TYPE_VENDOR|USB_DIR_IN|USB_RECIP_INTERFACE,  // Request type
+			0x0000,
+			priv->ifnum,
+			buf, sizeof(buf), IPW_URB_TIMEOUT);
+	if (response >= 1)
+		dbg("status = 0x%02d", (int) buf[0]);
+	else
+		info("failed to read status: %d\n", (int) response);
+}
+
+static int ipw_set_pins (struct usb_serial_port *port, unsigned int set, unsigned int clear) 
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ipw_private *priv = usb_get_serial_port_data(port);
+	unsigned int control = 0;
+	int response;
+	unsigned long flags; /* for spinlock */
+
+	dbg("%s", __FUNCTION__);
+/*
+	if (!ipw->open_count) {
+		dbg ("%s - device not open", __FUNCTION__);
+		return -EINVAL;
+	}
+*/
+	// The Request 0x07 holds the modem control signals.
+	// 
+	//   wValue: B0 DTR State
+	//           B1 RTS State
+	//           B2..B7 Reserved
+	//           B8 DTR Mask (if clear do not act on DTR state)
+	//           B9 RTS Mask (if clear do not act on RTS state)
+	//           B10..B15 Reserved
+	//
+
+	spin_lock_irqsave( &priv->lock, flags ); 
+	priv->control_lines &= ~clear;
+	priv->control_lines |= set;
+        spin_unlock_irqrestore( &priv->lock, flags );
+
+	if (set & TIOCM_RTS) {
+		control |= 0x202;
+		dbg("port %d set RTS", port->number);
+	}
+	if (set & TIOCM_DTR) {
+		control |= 0x101;
+		dbg("port %d set DTR", port->number);
+	}
+	if (clear & TIOCM_RTS) {
+		control |= 0x200;
+		dbg("port %d clear RTS", port->number);
+	}
+	if (clear & TIOCM_DTR) {
+		control |= 0x100;
+		dbg("port %d clear DTR", port->number);
+	}
+
+	if (control == 0)
+		response = 0;
+	else
+		response = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_SET_PIN,
+				USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,  // Request type
+				control,
+				priv->ifnum,
+				NULL, 0, IPW_URB_TIMEOUT);
+	if (response < 0)
+		err("tiocmset failed: response to serial pins change = %d", response);
+
+        return response;
+
+}
+
+
+static void ipw_read_bulk_callback(struct urb *urb)
+{
+	struct usb_serial_port *port = urb->context;
+	unsigned char *data = urb->transfer_buffer;
+	struct tty_struct *tty;
+	int i, result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (urb->status) {
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+		return;
+	}
+
+	usb_serial_debug_data(__FILE__, __FUNCTION__, urb->actual_length, data);
+
+	tty = port->tty;
+	if (tty && urb->actual_length) {
+//2.6		tty_buffer_request_room(tty, urb->actual_length);
+//2.6		tty_insert_flip_string(tty, data, urb->actual_length);
+		for (i = 0; i < urb->actual_length ; ++i) {
+			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
+			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			/* this doesn't actually push the data through unless tty->low_latency is set */
+			tty_insert_flip_char(tty, data[i], 0);
+		}
+		tty_flip_buffer_push(tty);
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb (port->read_urb, port->serial->dev,
+			   usb_rcvbulkpipe(port->serial->dev,
+					   port->bulk_in_endpointAddress),
+			   port->read_urb->transfer_buffer,
+			   port->read_urb->transfer_buffer_length,
+			   ipw_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result)
+		err("%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+	return;
+}
+
+static char* ipw_iftype_name (u16 ifnum) {
+	return ifnum == 0 ? "modem" : "console";
+}
+
+static int ipw_startup(struct usb_serial *serial)
+{
+	struct ipw_private *priv;
+	u16 ifnum = serial->interface->altsetting->bInterfaceNumber;
+	int i;
+
+        for (i = 0; i < serial->num_ports; ++i) {                               
+ 		priv = kmalloc (sizeof (struct ipw_private), GFP_KERNEL);
+		if (!priv)
+			goto cleanup;
+		memset (priv, 0x00, sizeof (struct ipw_private));
+		priv->magic = USB_IPW_MAGIC;
+		priv->ifnum = ifnum;
+		spin_lock_init(&priv->lock);
+		usb_set_serial_port_data(&serial->port[i], priv);
+	}
+	info("IPWireless USB (%s) found",ipw_iftype_name(ifnum));
+	return 0;
+
+cleanup:
+	for (--i; i>=0; --i) {
+		priv = usb_get_serial_port_data(&serial->port[i]);              
+		kfree(priv);                                                    
+		usb_set_serial_port_data(&serial->port[i], NULL);               
+	}                                                                       
+	return -ENOMEM;                                                         
+}
+
+static int ipw_open(struct usb_serial_port *port, struct file *filp)
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ipw_private *priv = usb_get_serial_port_data(port);
+	u8 buf_flow_init[16] = IPW_BYTES_FLOWINIT;
+	u8 buf_setchars_init[6] = IPW_BYTES_SETCHARSINIT_NONE;
+	unsigned char buf[32];
+	int result;
+
+	dbg("%s", __FUNCTION__);
+
+	if (port->tty)
+		port->tty->low_latency = 1;
+
+	/* --1: Tell the modem to initialize (we think) From sniffs this is always the
+	 * first thing that gets sent to the modem during opening of the device */
+	dbg("%s: Sending SIO_INIT (we guess)",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev,0),
+				 IPW_SIO_INIT,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0,
+				 priv->ifnum, /* index */
+				 NULL,
+				 0,
+				 100000);
+	if (result < 0)
+		err("%s Init of modem failed (error = %d)", __FUNCTION__, result);
+
+	/* reset the bulk pipes */
+	usb_clear_halt(dev, usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
+	usb_clear_halt(dev, usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
+
+	/*--2: Start reading from the device */	
+	dbg("%s: setting up bulk read callback",__FUNCTION__);
+	usb_fill_bulk_urb(port->read_urb, dev,
+			  usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
+			  port->read_urb->transfer_buffer,
+			  port->read_urb->transfer_buffer_length,
+			  ipw_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb);
+	if (result < 0)
+		dbg("%s - usb_submit_urb(read bulk) failed with status %d", __FUNCTION__, result);
+
+	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
+	dbg("%s:asking modem for RxRead (RXBULK_ON)",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_RXCTL,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_RXBULK_ON,
+				 priv->ifnum, /* index */
+				 NULL,
+				 0,
+				 100000);
+	if (result < 0) 
+		err("%s - Enabling bulk RxRead failed (error = %d)", __FUNCTION__, result);
+
+	/*--4: setup the initial flowcontrol */
+	dbg("%s:setting init flowcontrol (%s)",__FUNCTION__,buf_flow_init);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_HANDFLOW,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0,
+				 priv->ifnum, /* index */
+				 buf_flow_init,
+				 0x10,
+				 200000);
+	if (result < 0)
+		err("%s - initial flowcontrol failed (error = %d)", __FUNCTION__, result);
+
+	show_status(port);
+	if (priv->ifnum == 0x01) { //console 
+		dbg("raise dtr for modem");
+		dbg("%s:raising dtr",__FUNCTION__);
+		result = ipw_set_pins(port, TIOCM_DTR, 0); //raise DTR
+		if (result<0)
+			err("raising dtr failed (error = %d)", result);
+
+	} else {
+		dbg("not raising dtr for console");
+	}
+
+	/*--5: fetch some unkn buffer */
+	dbg("%s:fetching unk_buffer",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_FETCH_UNK,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_IN,
+				0x0000,
+				priv->ifnum, /* index */
+				buf,
+				sizeof(buf),
+				IPW_URB_TIMEOUT);
+	if (result>=0)
+		info("fetch unk_buffer got %d bytes.", result);
+	else
+		dbg("fetch unk_buffer failed (error = %d)", result);
+
+	/*--6: purge */
+	dbg("%s:sending purge",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_PURGE,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				0x0f,
+				priv->ifnum,
+				NULL,
+				0,
+				IPW_URB_TIMEOUT);
+	if (result<0)
+		err("purge failed (error = %d)", result);
+
+	/*--7: set bitrate*/
+	dbg("%s:setting bitrate ",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_SET_BAUD,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				0x0180,
+				priv->ifnum,
+				NULL,
+				0,
+				IPW_URB_TIMEOUT);
+	if (result<0)
+		err("setting bitrate failed (error = %d)", result);
+
+
+	/*--11: raise the rts */
+	dbg("%s:raising rts",__FUNCTION__);
+	result = ipw_set_pins(port, TIOCM_RTS, 0); //raise RTS
+	if (result<0)
+		err("raising rts failed (error = %d)", result);
+
+	dbg("%s:raising dtr",__FUNCTION__);
+	result = ipw_set_pins(port, TIOCM_DTR, 0); //raise DTR
+	if (result<0)
+		err("raising dtr failed (error = %d)", result);
+
+
+	/*--8: set parity/databits*/
+	dbg("%s:setting parity ",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_SET_LINE,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				0x800,
+				priv->ifnum,
+				NULL,
+				0,
+				IPW_URB_TIMEOUT);
+	if (result<0)
+		err("setting bitrate failed (error = %d)", result);
+
+
+	/*--9: setup the flow control characters*/
+	dbg("%s:setting init setflow characters",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_SETCHARS,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				0x0000,
+				priv->ifnum, /* index */
+				buf_setchars_init,
+				sizeof(buf_setchars_init),
+				IPW_URB_TIMEOUT);
+	if (result<0)
+		err("initial setflow characters failed (error = %d)", result);
+
+	dbg("%s:setting second flowcontrol",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				IPW_SIO_HANDFLOW,
+				USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				0x0000,
+				priv->ifnum, /* index */
+				buf_flow_init,
+				sizeof(buf_flow_init),
+				IPW_URB_TIMEOUT);
+
+	return result;
+}
+
+static void ipw_close(struct usb_serial_port *port, struct file * filp)
+{
+	struct usb_device *dev = port->serial->dev;
+	int result;
+
+	if (tty_hung_up_p(filp)) {
+		dbg("%s: tty_hung_up_p ...", __FUNCTION__);
+		return;
+	}
+
+	/*--1: drop the dtr */
+	dbg("%s:dropping dtr",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_CLRDTR,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		err("%s - dropping dtr failed (error = %d)", __FUNCTION__, result);
+
+	/*--2: drop the rts */
+	dbg("%s:dropping rts",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_CLRRTS,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		err("%s - dropping rts failed (error = %d)", __FUNCTION__, result);
+
+
+	/*--3: purge */
+	dbg("%s:sending purge",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_PURGE, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0x03,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		err("%s - purge failed (error = %d)", __FUNCTION__, result);
+
+
+	/* send RXBULK_off (tell modem to stop transmitting bulk data on rx chan) */
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_RXCTL,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_RXBULK_OFF,
+				 0, /* index */
+				 NULL,
+				 0,
+				 100000);
+
+	if (result < 0)
+		err("%s - Disabling bulk RxRead failed (error = %d)", __FUNCTION__, result);
+
+	/* shutdown any in-flight urbs that we know about */
+	usb_unlink_urb(port->read_urb);
+	usb_unlink_urb(port->write_urb);
+}
+
+static int ipw_tiocmset(struct usb_serial_port *port, struct file *file, 
+			unsigned int set, unsigned int clear)                
+{                                                                               
+	return ipw_set_pins(port, set, clear);
+}
+
+static void ipw_write_bulk_callback(struct urb *urb)
+{
+	struct usb_serial_port *port = urb->context;
+	struct ipw_private *priv = usb_get_serial_port_data(port);
+
+	dbg("%s", __FUNCTION__);
+
+	priv->write_urb_busy = 0;
+
+	if (urb->status)
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+
+        queue_task(&port->tqueue, &tq_immediate);
+        mark_bh(IMMEDIATE_BH);
+}
+
+static int ipw_write(struct usb_serial_port *port, int from_user,
+		     const unsigned char *buf, int count)
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ipw_private *priv = usb_get_serial_port_data(port);
+	int ret;
+
+	dbg("%s: TOP: count=%d, in_interrupt=%d", __FUNCTION__,
+		count, in_interrupt() );
+
+	if (count == 0) {
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
+		return 0;
+	}
+
+	spin_lock(&priv->lock);
+	if (priv->write_urb_busy) {
+		spin_unlock(&priv->lock);
+		dbg("%s - already writing", __FUNCTION__);
+		return 0;
+	}
+	priv->write_urb_busy = 1;
+	spin_unlock(&priv->lock);
+
+	count = min(count, port->bulk_out_size);
+	memcpy(port->bulk_out_buffer, buf, count);
+
+	dbg("%s count now:%d", __FUNCTION__, count);
+
+	usb_fill_bulk_urb(port->write_urb, dev,
+			  usb_sndbulkpipe(dev, port->bulk_out_endpointAddress),
+			  port->write_urb->transfer_buffer,
+			  count,
+			  ipw_write_bulk_callback,
+			  port);
+
+	ret = usb_submit_urb(port->write_urb);
+	if (ret != 0) {
+		priv->write_urb_busy = 0;
+		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __FUNCTION__, ret);
+		return ret;
+	}
+
+	dbg("%s returning %d", __FUNCTION__, count);
+	return count;
+} 
+
+static void ipw_disconnect(struct usb_serial *serial)
+{
+	struct usb_serial_port *port;
+	struct ipw_private *priv;
+
+	if (serial) {
+		port = &serial->port[0];
+		if (port->tty)
+			tty_hangup(port->tty);
+		priv = usb_get_serial_port_data(port);
+		kfree(priv);
+		usb_set_serial_port_data(port, NULL);
+		if (serial->dev) {
+                /* shutdown any bulk reads that might be going on */
+			if (serial->num_bulk_out)
+				usb_unlink_urb (port->write_urb);
+			if (serial->num_bulk_in)
+				usb_unlink_urb (port->read_urb);
+		}
+//2.6		usb_serial_generic_shutdown(serial);
+		kfree(serial);
+	}
+}
+
+static struct usb_serial_device_type ipw_device = {
+//	.driver = {
+		.owner =	THIS_MODULE,
+		.name =		"IPWireless converter",
+//	},
+	.id_table =		usb_ipw_ids,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.startup = 		ipw_startup,
+	.shutdown =		ipw_disconnect,
+	.open =			ipw_open,
+	.close =		ipw_close,
+//2.6	.port_probe = 		ipw_probe,
+	.write =		ipw_write,
+	.write_bulk_callback =	ipw_write_bulk_callback,
+	.read_bulk_callback =	ipw_read_bulk_callback,
+};
+
+
+
+static int usb_ipw_init(void)
+{
+	int retval;
+
+	retval = usb_serial_register(&ipw_device);
+	if (retval)
+		return retval;
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+}
+
+static void usb_ipw_exit(void)
+{
+	usb_serial_deregister(&ipw_device);
+}
+
+module_init(usb_ipw_init);
+module_exit(usb_ipw_exit);
+
+/* Module information */
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, "Debug enabled or not");
