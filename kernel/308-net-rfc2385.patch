Latest 2.4 RFC 2385 (TCP MD5) patch.

(c) Hasso Teppe

http://hasso.linux.ee/doku.php/english:network:kernel24

diff -Nur kernel-source-2.4.30/CREDITS kernel-source-2.4.30-md5/CREDITS
--- kernel-source-2.4.30/CREDITS	2005-01-19 16:09:22.000000000 +0200
+++ kernel-source-2.4.30-md5/CREDITS	2005-05-07 15:54:59.000000000 +0300
@@ -2368,6 +2368,11 @@
 S: Prague 8
 S: 182 00 Czech Republic
 
+N: Rick Payne
+E: rickp@rossfell.co.uk
+W: http://www.rossfell.co.uk/~rickp/
+D: RFC2385 Support for TCP
+
 N: Barak A. Pearlmutter
 E: bap@cs.unm.edu
 W: http://www.cs.unm.edu/~bap/
diff -Nur kernel-source-2.4.30/Documentation/Configure.help kernel-source-2.4.30-md5/Documentation/Configure.help
--- kernel-source-2.4.30/Documentation/Configure.help	2005-04-04 04:42:19.000000000 +0300
+++ kernel-source-2.4.30-md5/Documentation/Configure.help	2005-05-07 15:54:59.000000000 +0300
@@ -3683,6 +3683,15 @@
 
   If unsure, say N.
 
+RFC2385 Support for TCP
+CONFIG_TCP_RFC2385
+  RFC2385 specifies a method of giving MD5 protection to TCP
+  sessions. It is commonly used to protect BGP sessions between core
+  routers on the Internet.
+
+  If you will be running something like Zebra to talk BGP to routers,
+  you may want to say 'Y' here.
+
 # Choice: alphatype
 Alpha system type
 CONFIG_ALPHA_GENERIC
diff -Nur kernel-source-2.4.30/include/linux/tcp.h kernel-source-2.4.30-md5/include/linux/tcp.h
--- kernel-source-2.4.30/include/linux/tcp.h	2001-11-22 21:47:11.000000000 +0200
+++ kernel-source-2.4.30-md5/include/linux/tcp.h	2005-05-07 16:29:29.000000000 +0300
@@ -127,6 +127,8 @@
 #define TCP_WINDOW_CLAMP	10	/* Bound advertised window */
 #define TCP_INFO		11	/* Information about this connection. */
 #define TCP_QUICKACK		12	/* Block/reenable quick acks */
+/* This is defined in the tcp_rfc2385.h file - this comment is just a placeholder */
+/* #define TCP_RFC2385             13      */
 
 #define TCPI_OPT_TIMESTAMPS	1
 #define TCPI_OPT_SACK		2
diff -Nur kernel-source-2.4.30/include/linux/tcp_rfc2385.h kernel-source-2.4.30-md5/include/linux/tcp_rfc2385.h
--- kernel-source-2.4.30/include/linux/tcp_rfc2385.h	1970-01-01 03:00:00.000000000 +0300
+++ kernel-source-2.4.30-md5/include/linux/tcp_rfc2385.h	2005-05-07 15:54:59.000000000 +0300
@@ -0,0 +1,50 @@
+/* Copyright 2001 AYR Networks, Inc.
+ *
+ * Author: Rick Payne
+ *
+ * This is a free document; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation:
+ *     http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * Structures and function calls used for the RFC2385 code
+ *
+ * This is #included in both kernel and userland code,
+ * so use __KERNEL__ appropriately.
+ */
+
+#ifndef __LINUX__TCP_RFC2385_H__
+#define __LINUX__TCP_RFC2385_H__
+
+/* setsockopt Number */
+#define TCP_RFC2385 13
+
+/* Commands (used in the structure passed from userland) */
+#define TCP_RFC2385_ADD 1
+#define TCP_RFC2385_DEL 2
+
+struct tcp_rfc2385_cmd {
+	u_int8_t     command;    /* Command - Add/Delete */
+	u_int32_t    address;    /* IPV4 address associated */
+	u_int8_t     keylen;     /* MD5 Key len (do NOT assume 0 terminated ascii) */
+	void         *key;       /* MD5 Key */
+};
+
+#ifdef __KERNEL__
+struct tcp_rfc2385 *tcp_v4_md5_lookup (struct sock *, __u32);
+int tcp_v4_md5_do_add (struct sock *, __u32, char *, __u8);
+int tcp_v4_parse_md5_keys (struct sock *, char *, int);
+int tcp_v4_calc_md5_hash (char *, struct tcp_rfc2385 *,
+						  __u32, __u32,
+						  struct tcphdr *, int, int);
+
+struct tcp_rfc2385 {
+	__u32   addr;      /* The IPv4 Address for this key */
+	__u8    keylen;    /* The Key Length */
+	__u8    *key;      /* The key itself - not null terminated */
+};
+#endif
+
+#endif /* __LINUX__TCP_RFC2385_H__ */
diff -Nur kernel-source-2.4.30/include/net/sock.h kernel-source-2.4.30-md5/include/net/sock.h
--- kernel-source-2.4.30/include/net/sock.h	2004-11-17 13:54:22.000000000 +0200
+++ kernel-source-2.4.30-md5/include/net/sock.h	2005-05-07 16:29:29.000000000 +0300
@@ -109,6 +109,10 @@
 #include <asm/atomic.h>
 #include <net/dst.h>
 
+#ifdef CONFIG_TCP_RFC2385
+#include <linux/tcp_rfc2385.h>
+#endif
+
 
 /* The AF_UNIX specific socket options */
 struct unix_opt {
@@ -374,6 +378,11 @@
 	__u8	nonagle;	/* Disable Nagle algorithm?             */
 	__u8	keepalive_probes; /* num of allowed keep alive probes	*/
 
+#ifdef CONFIG_TCP_RFC2385
+	__u16   md5_db_entries; /* Number of entries in the database */
+	struct tcp_rfc2385 *md5_db; /* MD5 Key Database */
+#endif
+
 /*	PAWS/RTTM data	*/
         __u32	rcv_tsval;	/* Time stamp value             	*/
         __u32	rcv_tsecr;	/* Time stamp echo reply        	*/
diff -Nur kernel-source-2.4.30/include/net/tcp.h kernel-source-2.4.30-md5/include/net/tcp.h
--- kernel-source-2.4.30/include/net/tcp.h	2005-04-04 04:42:20.000000000 +0300
+++ kernel-source-2.4.30-md5/include/net/tcp.h	2005-05-07 16:31:57.000000000 +0300
@@ -191,6 +191,10 @@
 	struct in6_addr		v6_daddr;
 	struct in6_addr		v6_rcv_saddr;
 #endif
+#ifdef CONFIG_TCP_RFC2385
+	__u8                    *md5_key;
+	__u8                    md5_keylen;
+#endif
 };
 
 extern kmem_cache_t *tcp_timewait_cachep;
@@ -201,6 +205,14 @@
 #ifdef INET_REFCNT_DEBUG
 		printk(KERN_DEBUG "tw_bucket %p released\n", tw);
 #endif
+#ifdef CONFIG_TCP_RFC2385
+		/* Free the memory used for any md5 key */
+		if (tw->md5_key) {
+			kfree (tw->md5_key);
+			tw->md5_key = NULL;
+			tw->md5_keylen = 0;
+		}
+#endif
 		kmem_cache_free(tcp_timewait_cachep, tw);
 	}
 }
@@ -424,6 +436,7 @@
 #define TCPOPT_SACK_PERM        4       /* SACK Permitted */
 #define TCPOPT_SACK             5       /* SACK Block */
 #define TCPOPT_TIMESTAMP	8	/* Better RTT estimations/PAWS */
+#define TCPOPT_RFC2385          19      /* MD5 protection */
 
 /*
  *     TCP option lengths
@@ -433,6 +446,7 @@
 #define TCPOLEN_WINDOW         3
 #define TCPOLEN_SACK_PERM      2
 #define TCPOLEN_TIMESTAMP      10
+#define TCPOLEN_RFC2385        18
 
 /* But this is what stacks really send out. */
 #define TCPOLEN_TSTAMP_ALIGNED		12
@@ -441,6 +455,7 @@
 #define TCPOLEN_SACK_BASE		2
 #define TCPOLEN_SACK_BASE_ALIGNED	4
 #define TCPOLEN_SACK_PERBLOCK		8
+#define TCPOLEN_RFC2385_ALIGNED         20
 
 #define TCP_TIME_RETRANS	1	/* Retransmit timer */
 #define TCP_TIME_DACK		2	/* Delayed ack timer */
@@ -505,7 +520,7 @@
 	int  (*rtx_syn_ack)	(struct sock *sk, struct open_request *req, struct dst_entry*);
 	void (*send_ack)	(struct sk_buff *skb, struct open_request *req);
 	void (*destructor)	(struct open_request *req);
-	void (*send_reset)	(struct sk_buff *skb);
+	void (*send_reset)	(struct sock *sk, struct sk_buff *skb);
 };
 
 struct tcp_v4_open_req {
@@ -726,6 +741,9 @@
 static inline void tcp_clear_options(struct tcp_opt *tp)
 {
  	tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
+#ifdef CONFIG_TCP_RFC2385
+	tp->md5_db_entries = 0;
+#endif
 }
 
 enum tcp_tw_status
@@ -946,6 +964,12 @@
 	if (tp->eff_sacks)
 		mss_now -= (TCPOLEN_SACK_BASE_ALIGNED +
 			    (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK));
+
+#ifdef CONFIG_TCP_RFC2385
+	if (tcp_v4_md5_lookup (sk, sk->daddr))
+		mss_now -= TCPOLEN_RFC2385_ALIGNED;
+#endif
+
 	return mss_now;
 }
 
@@ -1528,7 +1552,11 @@
 	tp->num_sacks = 0;
 }
 
+#ifdef CONFIG_TCP_RFC2385
+static __inline__ void tcp_build_and_update_options(__u32 *ptr, struct tcp_opt *tp, __u32 tstamp, int md5, __u8 **md5_hash)
+#else
 static __inline__ void tcp_build_and_update_options(__u32 *ptr, struct tcp_opt *tp, __u32 tstamp)
+#endif
 {
 	if (tp->tstamp_ok) {
 		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) |
@@ -1556,6 +1584,14 @@
 			tp->eff_sacks--;
 		}
 	}
+
+#ifdef CONFIG_TCP_RFC2385
+	if (md5) {
+		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+					  (TCPOPT_RFC2385 << 8) | 18);
+		*md5_hash = (__u8 *)ptr;
+	}
+#endif
 }
 
 /* Construct a tcp options header for a SYN or SYN_ACK packet.
@@ -1563,8 +1599,19 @@
  * MAX_SYN_SIZE to match the new maximum number of options that you
  * can generate.
  */
+/*
+ * Note - that with the CONFIG_TCP_RFC2385 option, we make room for the
+ * 16 byte MD5 hash. This will be filled in later, so the pointer for the
+ * location to be filled is passed back up
+ */
+#ifdef CONFIG_TCP_RFC2385
+static inline void tcp_syn_build_options(__u32 *ptr, int mss, int ts, int sack,
+					 int offer_wscale, int wscale, __u32 tstamp, __u32 ts_recent,
+					 __u8 md5_enabled, __u8 **md5_hash)
+#else
 static inline void tcp_syn_build_options(__u32 *ptr, int mss, int ts, int sack,
-					     int offer_wscale, int wscale, __u32 tstamp, __u32 ts_recent)
+					 int offer_wscale, int wscale, __u32 tstamp, __u32 ts_recent)
+#endif
 {
 	/* We always get an MSS option.
 	 * The option bytes which will be seen in normal data
@@ -1594,6 +1641,17 @@
 					  (TCPOPT_SACK_PERM << 8) | TCPOLEN_SACK_PERM);
 	if (offer_wscale)
 		*ptr++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_WINDOW << 16) | (TCPOLEN_WINDOW << 8) | (wscale));
+
+#ifdef CONFIG_TCP_RFC2385
+	/* If MD5 is enabled, then we set the option, and include the size
+	 * (always 18). The actual MD5 hash is added just before the
+	 * packet is sent */
+	if (md5_enabled) {
+		*ptr++ = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+					  (TCPOPT_RFC2385 << 8) | 18);
+		*md5_hash = (__u8 *)ptr;
+	}
+#endif
 }
 
 /* Determine a window scaling and initial window to offer.
diff -Nur kernel-source-2.4.30/net/ipv4/Config.in kernel-source-2.4.30-md5/net/ipv4/Config.in
--- kernel-source-2.4.30/net/ipv4/Config.in	2003-11-28 20:26:21.000000000 +0200
+++ kernel-source-2.4.30-md5/net/ipv4/Config.in	2005-05-07 15:54:59.000000000 +0300
@@ -40,6 +40,7 @@
 fi
 bool '  IP: TCP Explicit Congestion Notification support' CONFIG_INET_ECN
 bool '  IP: TCP syncookie support (disabled per default)' CONFIG_SYN_COOKIES
+bool '  IP: TCP RFC2385 MD5 Support' CONFIG_TCP_RFC2385
 if [ "$CONFIG_NETFILTER" != "n" ]; then
    source net/ipv4/netfilter/Config.in
 fi
diff -Nur kernel-source-2.4.30/net/ipv4/tcp.c kernel-source-2.4.30-md5/net/ipv4/tcp.c
--- kernel-source-2.4.30/net/ipv4/tcp.c	2004-08-08 02:26:07.000000000 +0300
+++ kernel-source-2.4.30-md5/net/ipv4/tcp.c	2005-05-07 15:54:59.000000000 +0300
@@ -2401,6 +2401,13 @@
 		}
 		break;
 
+#ifdef CONFIG_TCP_RFC2385
+	case TCP_RFC2385:
+		/* Read the IP->Key mappings from usermode */
+		err = tcp_v4_parse_md5_keys (sk, optval, optlen);
+		break;
+#endif
+
 	default:
 		err = -ENOPROTOOPT;
 		break;
diff -Nur kernel-source-2.4.30/net/ipv4/tcp_input.c kernel-source-2.4.30-md5/net/ipv4/tcp_input.c
--- kernel-source-2.4.30/net/ipv4/tcp_input.c	2005-04-04 04:42:20.000000000 +0300
+++ kernel-source-2.4.30-md5/net/ipv4/tcp_input.c	2005-05-07 15:54:59.000000000 +0300
@@ -70,6 +70,9 @@
 #include <net/tcp.h>
 #include <net/inet_common.h>
 #include <linux/ipsec.h>
+#ifdef CONFIG_TCP_RFC2385
+#include <linux/tcp_rfc2385.h>
+#endif
 
 int sysctl_tcp_timestamps = 1;
 int sysctl_tcp_window_scaling = 1;
@@ -2944,6 +2947,14 @@
 					   tp->sack_ok) {
 						TCP_SKB_CB(skb)->sacked = (ptr - 2) - (unsigned char *)th;
 					}
+
+#ifdef CONFIG_TCP_RFC2385
+				case TCPOPT_RFC2385:
+					/* The MD5 Hash has already been checked
+					 * (see tcp_v4_do_rcv)
+					 */
+					break;
+#endif
 	  			};
 	  			ptr+=opsize-2;
 	  			length-=opsize;
diff -Nur kernel-source-2.4.30/net/ipv4/tcp_ipv4.c kernel-source-2.4.30-md5/net/ipv4/tcp_ipv4.c
--- kernel-source-2.4.30/net/ipv4/tcp_ipv4.c	2004-11-17 13:54:22.000000000 +0200
+++ kernel-source-2.4.30-md5/net/ipv4/tcp_ipv4.c	2005-05-07 15:54:59.000000000 +0300
@@ -68,6 +68,10 @@
 #include <linux/stddef.h>
 #include <linux/ipsec.h>
 
+#ifdef CONFIG_TCP_RFC2385
+#include <asm/scatterlist.h>
+#include <linux/crypto.h>
+#endif
 extern int sysctl_ip_dynaddr;
 extern int sysctl_ip_default_ttl;
 int sysctl_tcp_tw_reuse = 0;
@@ -83,6 +87,13 @@
 void tcp_v4_send_check(struct sock *sk, struct tcphdr *th, int len, 
 		       struct sk_buff *skb);
 
+#ifdef CONFIG_TCP_RFC2385
+/* #define MD5_DEBUG 1 */
+static void tcp_v4_clear_md5_list (struct sock *sk);
+static int tcp_v4_inbound_md5_hash (struct sock *sk, struct sk_buff *skb);
+/* static long md5_rate_limit; */
+#endif
+
 /*
  * ALL members must be initialised to prevent gcc-2.7.2.3 miscompilation
  */
@@ -1151,11 +1162,19 @@
  *	Exception: precedence violation. We do not implement it in any case.
  */
 
-static void tcp_v4_send_reset(struct sk_buff *skb)
+/* Okay, so we do need the sock structure, to add teh MD5 key if applicable */
+static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
 {
 	struct tcphdr *th = skb->h.th;
-	struct tcphdr rth;
+	struct {
+		struct tcphdr th;
+		/* Make room for Timestamp option and possible MD5 Hash */
+		u32 tsopt[(TCPOLEN_RFC2385_ALIGNED >> 2)];
+	} rep;
 	struct ip_reply_arg arg;
+#ifdef CONFIG_TCP_RFC2385
+	struct tcp_rfc2385 *key;
+#endif
 
 	/* Never send a reset in response to a reset. */
 	if (th->rst)
@@ -1165,23 +1184,51 @@
 		return;
 
 	/* Swap the send and the receive. */
-	memset(&rth, 0, sizeof(struct tcphdr)); 
-	rth.dest = th->source;
-	rth.source = th->dest; 
-	rth.doff = sizeof(struct tcphdr)/4;
-	rth.rst = 1;
+	memset(&rep, 0, sizeof(rep)); 
+	rep.th.dest = th->source;
+	rep.th.source = th->dest; 
+	rep.th.doff = sizeof(struct tcphdr)/4;
+	rep.th.rst = 1;
 
 	if (th->ack) {
-		rth.seq = th->ack_seq;
+		rep.th.seq = th->ack_seq;
 	} else {
-		rth.ack = 1;
-		rth.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin
-				    + skb->len - (th->doff<<2));
+		rep.th.ack = 1;
+		rep.th.ack_seq = htonl(ntohl(th->seq) + th->syn + th->fin
+				       + skb->len - (th->doff<<2));
 	}
 
 	memset(&arg, 0, sizeof arg); 
-	arg.iov[0].iov_base = (unsigned char *)&rth; 
-	arg.iov[0].iov_len  = sizeof rth;
+	arg.iov[0].iov_base = (unsigned char *)&rep; 
+	arg.iov[0].iov_len  = sizeof (struct tcphdr);
+
+#ifdef CONFIG_TCP_RFC2385
+	if (sk) {
+		key = tcp_v4_md5_lookup (sk, skb->nh.iph->daddr);
+	} else {
+		key = NULL;
+	}
+
+	if (key) {
+		int offset = 0;
+
+		rep.tsopt[offset++] = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+						       (TCPOPT_RFC2385 << 8) | 18);
+
+		/* Update length, and the length the header thinks exists */
+		arg.iov[0].iov_len += TCPOLEN_RFC2385_ALIGNED;
+		rep.th.doff = arg.iov[0].iov_len/4;
+
+		tcp_v4_calc_md5_hash ((__u8 *)&rep.tsopt[offset],
+				      key,
+				      skb->nh.iph->daddr,
+				      skb->nh.iph->saddr,
+				      &rep.th, IPPROTO_TCP,
+				      arg.iov[0].iov_len);
+	}
+#endif
+
+
 	arg.csum = csum_tcpudp_nofold(skb->nh.iph->daddr, 
 				      skb->nh.iph->saddr, /*XXX*/
 				      sizeof(struct tcphdr),
@@ -1191,7 +1238,7 @@
 	arg.csumoffset = offsetof(struct tcphdr, check) / 2; 
 
 	tcp_socket->sk->protinfo.af_inet.ttl = sysctl_ip_default_ttl;
-	ip_send_reply(tcp_socket->sk, skb, &arg, sizeof rth);
+	ip_send_reply(tcp_socket->sk, skb, &arg, arg.iov[0].iov_len);
 
 	TCP_INC_STATS_BH(TcpOutSegs);
 	TCP_INC_STATS_BH(TcpOutRsts);
@@ -1201,14 +1248,19 @@
    outside socket context is ugly, certainly. What can I do?
  */
 
-static void tcp_v4_send_ack(struct sk_buff *skb, u32 seq, u32 ack, u32 win, u32 ts)
+static void tcp_v4_send_ack(struct tcp_tw_bucket *tw, struct sk_buff *skb, u32 seq, u32 ack, u32 win, u32 ts)
 {
 	struct tcphdr *th = skb->h.th;
 	struct {
 		struct tcphdr th;
-		u32 tsopt[3];
+		/* Make room for Timestamp option and possible MD5 Hash */
+		u32 tsopt[3 + (TCPOLEN_RFC2385_ALIGNED >> 2)];
 	} rep;
 	struct ip_reply_arg arg;
+#ifdef CONFIG_TCP_RFC2385
+	struct tcp_rfc2385 *key;
+	struct tcp_rfc2385 tw_key;
+#endif
 
 	memset(&rep.th, 0, sizeof(struct tcphdr));
 	memset(&arg, 0, sizeof arg);
@@ -1223,7 +1275,7 @@
 				     TCPOLEN_TIMESTAMP);
 		rep.tsopt[1] = htonl(tcp_time_stamp);
 		rep.tsopt[2] = htonl(ts);
-		arg.iov[0].iov_len = sizeof(rep);
+		arg.iov[0].iov_len += (3 << 2);
 	}
 
 	/* Swap the send and the receive. */
@@ -1235,6 +1287,43 @@
 	rep.th.ack = 1;
 	rep.th.window = htons(win);
 
+#ifdef CONFIG_TCP_RFC2385
+	/* The SKB holds an incoming packet, but may NOT have a valid ->sk pointer.
+	 * This is especially teh case when we're dealign with a TIME_WAIT ack, because
+	 * the sk structure is long gone, and only the tcp_tw_bucket remains.
+	 * So the md5 key is stashed in that structure, and we use it in preference.
+	 * I believe that (tw || skb->sk) holds true, but we program defensively.
+	 */
+
+	if (!tw && skb->sk) {
+		key = tcp_v4_md5_lookup (skb->sk, skb->nh.iph->daddr);
+	} else if (tw && tw->md5_key) {
+		tw_key.key = tw->md5_key;
+		tw_key.keylen = tw->md5_keylen;
+		key = &tw_key;
+	} else {
+		key = NULL;
+	}
+
+	if (key) {
+		int offset = (ts) ? 3 : 0;
+
+		rep.tsopt[offset++] = __constant_htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+						       (TCPOPT_RFC2385 << 8) | 18);
+
+		/* Update length, and the length the header thinks exists */
+		arg.iov[0].iov_len += TCPOLEN_RFC2385_ALIGNED;
+		rep.th.doff = arg.iov[0].iov_len/4;
+
+		tcp_v4_calc_md5_hash ((__u8 *)&rep.tsopt[offset],
+				      key,
+				      skb->nh.iph->daddr,
+				      skb->nh.iph->saddr,
+				      &rep.th, IPPROTO_TCP,
+				      arg.iov[0].iov_len);
+	}
+#endif
+
 	arg.csum = csum_tcpudp_nofold(skb->nh.iph->daddr, 
 				      skb->nh.iph->saddr, /*XXX*/
 				      arg.iov[0].iov_len,
@@ -1251,7 +1340,7 @@
 {
 	struct tcp_tw_bucket *tw = (struct tcp_tw_bucket *)sk;
 
-	tcp_v4_send_ack(skb, tw->snd_nxt, tw->rcv_nxt,
+	tcp_v4_send_ack(tw, skb, tw->snd_nxt, tw->rcv_nxt,
 			tw->rcv_wnd>>tw->rcv_wscale, tw->ts_recent);
 
 	tcp_tw_put(tw);
@@ -1259,7 +1348,7 @@
 
 static void tcp_v4_or_send_ack(struct sk_buff *skb, struct open_request *req)
 {
-	tcp_v4_send_ack(skb, req->snt_isn+1, req->rcv_isn+1, req->rcv_wnd,
+	tcp_v4_send_ack(NULL, skb, req->snt_isn+1, req->rcv_isn+1, req->rcv_wnd,
 			req->ts_recent);
 }
 
@@ -1435,6 +1524,10 @@
 	tp.mss_clamp = 536;
 	tp.user_mss = sk->tp_pinfo.af_tcp.user_mss;
 
+#ifdef CONFIG_TCP_RFC2385
+	tp.md5_db_entries = 0;
+#endif
+
 	tcp_parse_options(skb, &tp, 0);
 
 	if (want_cookie) {
@@ -1536,6 +1629,8 @@
  * The three way handshake has completed - we got a valid synack - 
  * now create the new socket. 
  */
+ 
+
 struct sock * tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
 				   struct open_request *req,
 				   struct dst_entry *dst)
@@ -1574,6 +1669,27 @@
 	newtp->advmss = dst->advmss;
 	tcp_initialize_rcv_mss(newsk);
 
+#ifdef CONFIG_TCP_RFC2385
+	/* Copy over the MD5 key from the original socket */
+	{
+		struct tcp_rfc2385 *key;
+		
+		if ((key = tcp_v4_md5_lookup (sk, sk->daddr))) {
+			/* We're using one, so create a matching key
+			 * on the newsk structure. If we fail to get
+			 * memory, then we end up not copying the key
+			 * across. Shucks.
+			 */
+			char *newkey = kmalloc (key->keylen, GFP_ATOMIC);
+			if (newkey) {
+				memcpy (newkey, key->key, key->keylen);
+				tcp_v4_md5_do_add (newsk, sk->daddr,
+						   newkey, key->keylen);
+			}
+		}
+	}
+#endif
+	
 	__tcp_v4_hash(newsk, 0);
 	__tcp_inherit_port(sk, newsk);
 
@@ -1659,12 +1775,25 @@
  */
 int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
 {
+	struct sock *rsk;
   	IP_INC_STATS_BH(IpInDelivers);
 
+#ifdef CONFIG_TCP_RFC2385
+	/* We really want to reject the packet as early as possible
+	 * if:
+	 *   o We're expecting an MD5'd packet, and there is no MD5 TCP option
+	 *   o There is an MD5 option, and we're not expecting one.
+	 */
+	if (tcp_v4_inbound_md5_hash (sk, skb))
+		goto discard;
+#endif
+
 	if (sk->state == TCP_ESTABLISHED) { /* Fast path */
 		TCP_CHECK_TIMER(sk);
-		if (tcp_rcv_established(sk, skb, skb->h.th, skb->len))
+		if (tcp_rcv_established(sk, skb, skb->h.th, skb->len)) {
+			rsk = sk;
 			goto reset;
+		}
 		TCP_CHECK_TIMER(sk);
 		return 0; 
 	}
@@ -1678,20 +1807,24 @@
 			goto discard;
 
 		if (nsk != sk) {
-			if (tcp_child_process(sk, nsk, skb))
+			if (tcp_child_process(sk, nsk, skb)) {
+				rsk = nsk;
 				goto reset;
+			}
 			return 0;
 		}
 	}
 
 	TCP_CHECK_TIMER(sk);
-	if (tcp_rcv_state_process(sk, skb, skb->h.th, skb->len))
+	if (tcp_rcv_state_process(sk, skb, skb->h.th, skb->len)) {
+		rsk = sk;
 		goto reset;
+	}
 	TCP_CHECK_TIMER(sk);
 	return 0;
 
 reset:
-	tcp_v4_send_reset(skb);
+	tcp_v4_send_reset(rsk, skb);
 discard:
 	kfree_skb(skb);
 	/* Be careful here. If this function gets more complicated and
@@ -1785,7 +1918,7 @@
 bad_packet:
 		TCP_INC_STATS_BH(TcpInErrs);
 	} else {
-		tcp_v4_send_reset(skb);
+		tcp_v4_send_reset(NULL, skb);
 	}
 
 discard_it:
@@ -2041,6 +2174,11 @@
 	sk->sndbuf = sysctl_tcp_wmem[1];
 	sk->rcvbuf = sysctl_tcp_rmem[1];
 
+#ifdef CONFIG_TCP_RFC2385
+	tp->md5_db_entries = 0;
+	tp->md5_db = NULL;
+#endif
+
 	atomic_inc(&tcp_sockets_allocated);
 
 	return 0;
@@ -2055,6 +2193,11 @@
 	/* Cleanup up the write buffer. */
   	tcp_writequeue_purge(sk);
 
+#ifdef CONFIG_TCP_RFC2385
+	/* Clean up the MD5 key list */
+	tcp_v4_clear_md5_list (sk);
+#endif
+
 	/* Cleans up our, hopefully empty, out_of_order_queue. */
   	__skb_queue_purge(&tp->out_of_order_queue);
 
@@ -2074,6 +2217,385 @@
 	return 0;
 }
 
+#ifdef CONFIG_TCP_RFC2385
+/* RFC2385 MD5 checksumming requires a mapping of
+ * IP address->MD5 Key.
+ * We need to maintain these in the sk structure.
+ */
+
+struct tcp_rfc2385 *tcp_v4_md5_lookup (struct sock *sk, __u32 addr)
+{
+	/* Find the Key structure for an address */
+	int i;
+	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
+
+	if (tp->md5_db_entries == 0)
+		return NULL;
+
+	for (i = 0; i < tp->md5_db_entries; i++) {
+		if (tp->md5_db[i].addr == addr) {
+			return &tp->md5_db[i];
+		}
+	}
+	return NULL;
+}
+
+static int tcp_v4_md5_add (struct sock *sk, struct tcp_rfc2385_cmd *cmd)
+{
+	unsigned char *newkey;
+
+	/* Was a key already defined for this address?
+	 * if so, change it.
+	 * Note, GFP_KERNEL is acceptable here.
+	 */
+	newkey = kmalloc (cmd->keylen, GFP_KERNEL);
+	if (newkey) {
+		if (copy_from_user (newkey, cmd->key, cmd->keylen)) {
+			/* Failed to copy the key over, so -EFAULT */
+			/* printk ("Failed to copy key from userland"); */
+			return -EFAULT;
+		}
+	} else {
+		return -ENOMEM;
+	}
+
+	return tcp_v4_md5_do_add (sk, cmd->address, newkey, cmd->keylen);
+
+	return 0;
+}
+
+/* This can be called on a newly created socket, from other files */
+int tcp_v4_md5_do_add (struct sock *sk, __u32 addr, char *newkey, __u8 newkeylen)
+{
+	/* Add Key to the list */
+	struct tcp_rfc2385 *key;
+	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
+	struct tcp_rfc2385 *keys;
+
+	key = tcp_v4_md5_lookup (sk, addr);
+	if (key) {
+		/* Pre-existing entry - just update that one. */
+		kfree (key->key);
+		key->key = newkey;
+		key->keylen = newkeylen;
+	} else {
+		/* Use ATOMIC, 'cos this can be called from deep inside the tcp code */
+		keys = kmalloc (sizeof (struct tcp_rfc2385) * (tp->md5_db_entries + 1),
+				GFP_ATOMIC);
+		if (! keys)
+			return -ENOMEM;
+		
+		if (tp->md5_db_entries)
+			memcpy (keys, tp->md5_db, sizeof (struct tcp_rfc2385) * tp->md5_db_entries);
+	
+		/* Free old key list, and reference new one */
+		kfree (tp->md5_db);
+		tp->md5_db = keys;
+		tp->md5_db_entries++;
+		tp->md5_db[tp->md5_db_entries - 1].addr = addr;
+		tp->md5_db[tp->md5_db_entries - 1].key = newkey;
+		tp->md5_db[tp->md5_db_entries - 1].keylen = newkeylen;
+	}
+
+	return 0;
+}
+
+static int tcp_v4_md5_del (struct sock *sk, struct tcp_rfc2385_cmd *cmd)
+{
+	int i;
+	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
+
+	for (i = 0; i < tp->md5_db_entries; i++) {
+		if (tp->md5_db[i].addr == cmd->address) {
+			/* Free the key */
+			kfree (tp->md5_db[i].key);
+			tp->md5_db_entries--;
+
+			if (tp->md5_db_entries == 0) {
+				/* Now the DB */
+				kfree (tp->md5_db);
+				tp->md5_db = NULL;
+				return 0;
+			} else {
+				/* Need to do some manipulation */
+				if (tp->md5_db_entries != i)
+					memcpy (&tp->md5_db[i],
+						&tp->md5_db[i+1],
+						(tp->md5_db_entries - i)
+						* sizeof (struct tcp_rfc2385));
+			}
+
+		}
+	}
+	return -ENOENT;
+}
+
+int tcp_v4_parse_md5_keys (struct sock *sk, char *optval, int optlen)
+{
+  struct tcp_rfc2385_cmd cmd;
+  struct crypto_tfm *tfm;
+
+  /* Check we can get the md5 crypto */
+  tfm = crypto_alloc_tfm("md5", 0);
+  if (! tfm)
+	  return -EPROTONOSUPPORT;
+  crypto_free_tfm(tfm);
+
+  if (optlen != sizeof(cmd))
+	  return -ENOSPC;
+
+  if (copy_from_user (&cmd, optval, sizeof (cmd))) {
+	  return -EFAULT;
+  }
+
+  switch (cmd.command) {
+  case TCP_RFC2385_ADD:
+	  return tcp_v4_md5_add (sk, &cmd);
+
+  case TCP_RFC2385_DEL:
+	  return tcp_v4_md5_del (sk, &cmd);
+
+  default:
+	  return -ENOENT;
+  }
+
+  return 0;
+}
+
+int tcp_v4_calc_md5_hash (char *md5_hash, struct tcp_rfc2385 *key,
+			   __u32 saddr, __u32 daddr,
+			   struct tcphdr *th, int protocol,
+			   int tcplen)
+{
+	struct crypto_tfm *tfm;
+	struct scatterlist sg[4];
+	__u16 data_len;
+	int block = 0;
+#ifdef MD5_DEBUG
+	int i;
+#endif
+	__u16 old_checksum;
+	/* A structure to simplify the md5-ing */
+	struct {
+		__u32 saddr;
+		__u32 daddr;
+		__u8 pad;
+		__u8 protocol;
+		__u16 len;
+	} md5_block;
+
+
+	/* Okay, so RFC2385 is turned on for this connection,
+	 * so we need to generate the MD5 hash for the packet now.
+	 * Use the crypto API (may fail, we may not have md5).
+	 */
+	tfm = crypto_alloc_tfm("md5", 0);
+	if (!tfm) {
+		memset(md5_hash, 0, 16);
+		return -1;
+	}
+	
+	/* 1. the TCP pseudo-header (in the order: source IP address,
+	 * destination IP address, zero-padded protocol number, and
+	 * segment length)
+	 */
+	md5_block.saddr = saddr;
+	md5_block.daddr = daddr;
+	md5_block.pad = 0;
+	md5_block.protocol = protocol;
+	md5_block.len = htons(tcplen);
+	sg[block].page = virt_to_page(&md5_block);
+	sg[block].offset = ((long)(&md5_block) & ~PAGE_MASK);
+	sg[block++].length = sizeof(md5_block);
+
+#ifdef MD5_DEBUG
+	printk("Calcuating hash for: ");
+ 	for (i = 0; i < sizeof (md5_block); i++)
+		printk ("%x ", ((unsigned char *)&md5_block)[i]);
+#endif
+	
+	/* 2. the TCP header, excluding options, and assuming a
+	 * checksum of zero
+	 */
+	old_checksum = th->check;
+	th->check = 0;
+	sg[block].page = virt_to_page(th);
+	sg[block].offset = ((long)(th) & ~PAGE_MASK);
+	sg[block++].length = sizeof(struct tcphdr);
+#ifdef MD5_DEBUG
+	for (i = 0; i < sizeof (struct tcphdr); i++)
+		printk ("%x ", ((unsigned char *)th)[i]);
+#endif
+
+	/* 3. the TCP segment data (if any) */
+	data_len = tcplen - (th->doff << 2);
+	if (data_len > 0) {
+		unsigned char *data = (unsigned char *)th + (th->doff << 2);
+		
+		sg[block].page = virt_to_page(data);
+		sg[block].offset = ((long)data & ~PAGE_MASK);
+		sg[block++].length = data_len;
+	}
+	
+	/* 4. an independently-specified key or password, known to both
+	 * TCPs and presumably connection-specific
+	 */
+	sg[block].page = virt_to_page(key->key);
+	sg[block].offset = ((long)key->key & ~PAGE_MASK);
+	sg[block++].length = key->keylen;
+
+#ifdef MD5_DEBUG
+	printk ("and password: ");
+	for (i = 0; i < key->keylen; i++)
+		printk ("%x ", (unsigned char *)key->key[i]);
+#endif
+	
+	/* Now store the Hash into the packet */
+	crypto_digest_init(tfm);
+	crypto_digest_update(tfm, sg, block);
+	crypto_digest_final(tfm, md5_hash);
+	
+	/* Reset header, and free up the crypto */
+	th->check = old_checksum;
+	crypto_free_tfm(tfm);
+	return 0;
+}
+
+static int tcp_v4_inbound_md5_hash (struct sock *sk, struct sk_buff *skb)
+{
+	/* This gets called for each TCP segment that arrives
+	 * so we want to be efficient.
+	 * We have 3 drop cases:
+	 * o No MD5 hash and one expected.
+	 * o MD5 hash and we're not expecting one.
+	 * o MD5 hash and its wrong.
+	 */
+	__u8 *hash_location = NULL;
+	struct tcp_rfc2385 *hash_expected;
+	struct iphdr *iph = skb->nh.iph;
+	struct tcphdr *th = skb->h.th;
+	int length = (th->doff << 2) - sizeof (struct tcphdr);
+	int genhash;
+	unsigned char *ptr;
+	unsigned char newhash[16];
+
+	hash_expected = tcp_v4_md5_lookup (sk, iph->saddr);
+
+	/* If the TCP option length is less than the TCP_RFC2385
+	 * option length, then we can shortcut
+	 */
+	if (length < TCPOLEN_RFC2385) {
+		if (hash_expected)
+			return 1;
+		else
+			return 0;
+	}
+
+	/* Okay, we can't shortcut - we have to grub through the options */
+	ptr = (unsigned char *)(th + 1);
+	while (length > 0) {
+		int opcode = *ptr++;
+		int opsize;
+
+		switch (opcode) {
+		case TCPOPT_EOL:
+			goto done_opts;
+		case TCPOPT_NOP:
+			length--;
+			continue;
+		default:
+			opsize = *ptr++;
+			if (opsize < 2)
+				goto done_opts;
+			if (opsize > length)
+				goto done_opts;
+			
+			if (opcode == TCPOPT_RFC2385) {
+				hash_location = ptr;
+				goto done_opts;
+			}
+			
+		}
+		ptr += opsize-2;
+		length-=opsize;
+	}
+
+ done_opts:
+	/* We've parsed the options - do we have a hash? */
+	if (!hash_expected && !hash_location)
+		return 0;
+
+	if (hash_expected && !hash_location) {
+		if (net_ratelimit()) {
+			printk (KERN_INFO "MD5 Hash expected but NOT found (%d.%d.%d.%d, %d)->(%d.%d.%d.%d, %d)\n",
+				NIPQUAD (iph->saddr), ntohs(th->source),
+				NIPQUAD (iph->daddr), ntohs(th->dest));
+		}
+		return 1;
+	}
+
+	if (!hash_expected && hash_location) {
+		if (net_ratelimit()) {
+			printk (KERN_INFO "MD5 Hash NOT expected but found (%d.%d.%d.%d, %d)->(%d.%d.%d.%d, %d)\n",
+				NIPQUAD (iph->saddr), ntohs(th->source),
+				NIPQUAD (iph->daddr), ntohs(th->dest));
+		}
+		return 1;
+	}
+
+	/* Okay, so this is hash_expected and hash_location - 
+	 * so we need to calculate the checksum.
+	 */
+	genhash = tcp_v4_calc_md5_hash (newhash,
+									hash_expected,
+									iph->saddr, iph->daddr,
+									th, sk->protocol,
+									skb->len);
+	if (genhash || memcmp (hash_location, newhash, 16) != 0) {
+		if (net_ratelimit()) {
+			printk (KERN_INFO "MD5 Hash failed for (%d.%d.%d.%d, %d)->(%d.%d.%d.%d, %d)%s\n",
+					NIPQUAD (iph->saddr), ntohs(th->source),
+					NIPQUAD (iph->daddr), ntohs(th->dest),
+					genhash ? " tcp_v4_calc_md5_hash failed" : "");
+#ifdef MD5_DEBUG
+			{
+				int i;
+
+				printk("Received: ");
+				for (i = 0; i < 16; i++)
+					printk ("%x ", (unsigned char *)hash_location[i]);
+				printk("\n");
+				printk("Calculated: ");
+				for (i = 0; i < 16; i++)
+					printk ("%x ", (unsigned char *)newhash[i]);
+				printk("\n");
+			}
+#endif
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static void tcp_v4_clear_md5_list (struct sock *sk)
+{
+	int i;
+	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
+
+	if (tp->md5_db_entries == 0)
+		return;
+
+	for (i = 0; i < tp->md5_db_entries; i++)
+		kfree (tp->md5_db[i].key);
+
+	kfree (tp->md5_db);
+        tp->md5_db = NULL;
+	tp->md5_db_entries = 0;
+}
+#endif
+
+
 /* Proc filesystem TCP sock list dumping. */
 static void get_openreq(struct sock *sk, struct open_request *req, char *tmpbuf, int i, int uid)
 {
diff -Nur kernel-source-2.4.30/net/ipv4/tcp_minisocks.c kernel-source-2.4.30-md5/net/ipv4/tcp_minisocks.c
--- kernel-source-2.4.30/net/ipv4/tcp_minisocks.c	2004-11-17 13:54:22.000000000 +0200
+++ kernel-source-2.4.30-md5/net/ipv4/tcp_minisocks.c	2005-05-07 15:54:59.000000000 +0300
@@ -390,6 +390,28 @@
 			       sizeof(struct in6_addr));
 		}
 #endif
+
+#ifdef CONFIG_TCP_RFC2385
+		/* The timewait bucket does not have the key DB from the
+		 * sock structure. We just make a quick copy of the
+		 * md5 key being used (if indeed we are using one)
+		 * so the timewait ack generating code has the key.
+		 */
+		{
+			struct tcp_rfc2385 *key;
+			
+			tw->md5_key = NULL;
+			tw->md5_keylen  = 0;
+			if ((key = tcp_v4_md5_lookup (sk, sk->daddr))) {
+				char *newkey = kmalloc (key->keylen, GFP_ATOMIC);
+				if (newkey) {
+					memcpy (newkey, key->key, key->keylen);
+					tw->md5_key = newkey;
+					tw->md5_keylen = key->keylen;
+				}
+			}
+		}
+#endif
 		/* Linkage updates. */
 		__tcp_tw_hashdance(sk, tw);
 
@@ -742,6 +764,11 @@
 		/* Deinitialize syn_wait_lock to trap illegal accesses. */
 		memset(&newtp->syn_wait_lock, 0, sizeof(newtp->syn_wait_lock));
 
+#ifdef CONFIG_TCP_RFC2385
+		newtp->md5_db = NULL;
+		newtp->md5_db_entries = 0;
+#endif
+
 		/* Back to base struct sock members. */
 		newsk->err = 0;
 		newsk->priority = 0;
@@ -783,6 +810,12 @@
 			newtp->ts_recent_stamp = 0;
 			newtp->tcp_header_len = sizeof(struct tcphdr);
 		}
+
+#ifdef CONFIG_TCP_RFC2385
+		if (tcp_v4_md5_lookup (sk, sk->daddr))
+		    	newtp->tcp_header_len += TCPOLEN_RFC2385_ALIGNED;
+#endif
+
 		if (skb->len >= TCP_MIN_RCVMSS+newtp->tcp_header_len)
 			newtp->ack.last_seg_size = skb->len-newtp->tcp_header_len;
 		newtp->mss_clamp = req->mss;
@@ -963,6 +996,27 @@
 	if (child == NULL)
 		goto listen_overflow;
 
+#ifdef CONFIG_TCP_RFC2385
+	/* Copy over the MD5 key from the original socket */
+	{
+		struct tcp_rfc2385 *key;
+		
+		if ((key = tcp_v4_md5_lookup (sk, child->daddr))) {
+			/* We're using one, so create a matching key
+			 * on the newsk structure. If we fail to get
+			 * memory, then we end up not copying the key
+			 * across. Shucks.
+			 */
+			char *newkey = kmalloc (key->keylen, GFP_ATOMIC);
+			if (newkey) {
+				memcpy (newkey, key->key, key->keylen);
+				tcp_v4_md5_do_add (child, child->daddr,
+						   newkey, key->keylen);
+			}
+		}
+	}
+#endif
+
 	tcp_synq_unlink(tp, req, prev);
 	tcp_synq_removed(sk, req);
 
@@ -978,7 +1032,7 @@
 embryonic_reset:
 	NET_INC_STATS_BH(EmbryonicRsts);
 	if (!(flg & TCP_FLAG_RST))
-		req->class->send_reset(skb);
+		req->class->send_reset(sk, skb);
 
 	tcp_synq_drop(sk, req, prev);
 	return NULL;
diff -Nur kernel-source-2.4.30/net/ipv4/tcp_output.c kernel-source-2.4.30-md5/net/ipv4/tcp_output.c
--- kernel-source-2.4.30/net/ipv4/tcp_output.c	2004-11-17 13:54:22.000000000 +0200
+++ kernel-source-2.4.30-md5/net/ipv4/tcp_output.c	2005-05-07 15:59:10.000000000 +0300
@@ -41,6 +41,10 @@
 #include <linux/compiler.h>
 #include <linux/smp_lock.h>
 
+#ifdef CONFIG_TCP_RFC2385
+#include <linux/tcp_rfc2385.h>
+#endif
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse = 1;
 
@@ -198,6 +202,10 @@
 		struct tcphdr *th;
 		int sysctl_flags;
 		int err;
+#ifdef CONFIG_TCP_RFC2385
+		struct tcp_rfc2385 *md5 = NULL;
+		__u8 *md5_hash_location;
+#endif
 
 #define SYSCTL_FLAG_TSTAMPS	0x1
 #define SYSCTL_FLAG_WSCALE	0x2
@@ -226,7 +234,15 @@
 			tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
 					    (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK));
 		}
-		
+
+#ifdef CONFIG_TCP_RFC2385
+		/* Are we doing MD5 on this segment? If so - make room for it */
+		md5 = tcp_v4_md5_lookup (sk, sk->daddr);
+		if (md5) {
+			tcp_header_size += TCPOLEN_RFC2385_ALIGNED;
+		}
+#endif
+
 		/*
 		 * If the connection is idle and we are restarting,
 		 * then we don't want to do any Vegas calculations
@@ -274,13 +290,34 @@
 					      (sysctl_flags & SYSCTL_FLAG_WSCALE),
 					      tp->rcv_wscale,
 					      tcb->when,
-		      			      tp->ts_recent);
+		      			      tp->ts_recent
+#ifdef CONFIG_TCP_RFC2385
+					      , md5 ? 1 : 0,
+					      &md5_hash_location
+#endif
+					      );
 		} else {
 			tcp_build_and_update_options((__u32 *)(th + 1),
-						     tp, tcb->when);
+						     tp, tcb->when
+#ifdef CONFIG_TCP_RFC2385
+						     , md5 ? 1 : 0,
+						     &md5_hash_location
+#endif
+						     );
 
 			TCP_ECN_send(sk, tp, skb, tcp_header_size);
 		}
+
+#ifdef CONFIG_TCP_RFC2385
+		/* Calculate the MD5 hash, as we have all we need now */
+		if (md5) {
+			tcp_v4_calc_md5_hash (md5_hash_location,
+					      md5,
+					      sk->saddr, sk->daddr,
+					      skb->h.th, sk->protocol,
+					      skb->len);
+		}
+#endif
 		tp->af_specific->send_check(sk, th, skb->len, skb);
 
 		if (tcb->flags & TCPCB_FLAG_ACK)
@@ -1117,6 +1154,11 @@
 	struct tcphdr *th;
 	int tcp_header_size;
 	struct sk_buff *skb;
+#ifdef CONFIG_TCP_RFC2385
+	struct rtable *rt = (struct rtable *)dst;
+	struct tcp_rfc2385 *md5 = NULL;
+	__u8 *md5_hash_location;
+#endif
 
 	skb = sock_wmalloc(sk, MAX_TCP_HEADER + 15, 1, GFP_ATOMIC);
 	if (skb == NULL)
@@ -1132,6 +1174,15 @@
 			   (req->wscale_ok ? TCPOLEN_WSCALE_ALIGNED : 0) +
 			   /* SACK_PERM is in the place of NOP NOP of TS */
 			   ((req->sack_ok && !req->tstamp_ok) ? TCPOLEN_SACKPERM_ALIGNED : 0));
+
+#ifdef CONFIG_TCP_RFC2385
+	/* Are we doing MD5 on this segment? If so - make room for it */
+	md5 = tcp_v4_md5_lookup (sk, rt->rt_dst);
+	if (md5) {
+		tcp_header_size += TCPOLEN_RFC2385_ALIGNED;
+	}
+#endif
+
 	skb->h.th = th = (struct tcphdr *) skb_push(skb, tcp_header_size);
 
 	memset(th, 0, sizeof(struct tcphdr));
@@ -1165,11 +1216,27 @@
 	tcp_syn_build_options((__u32 *)(th + 1), dst->advmss, req->tstamp_ok,
 			      req->sack_ok, req->wscale_ok, req->rcv_wscale,
 			      TCP_SKB_CB(skb)->when,
-			      req->ts_recent);
+			      req->ts_recent
+#ifdef CONFIG_TCP_RFC2385
+			      , (md5 ? 1 : 0) , &md5_hash_location
+#endif
+			      );
 
 	skb->csum = 0;
 	th->doff = (tcp_header_size >> 2);
 	TCP_INC_STATS(TcpOutSegs);
+
+#ifdef CONFIG_TCP_RFC2385
+	/* Okay, we have all we need - do the md5 hash if needed */
+	if (md5) {
+		tcp_v4_calc_md5_hash (md5_hash_location,
+				      md5,
+				      rt->rt_src, rt->rt_dst,
+				      skb->h.th, sk->protocol,
+				      skb->len);
+	}
+#endif
+
 	return skb;
 }
 
@@ -1187,6 +1254,11 @@
 	tp->tcp_header_len = sizeof(struct tcphdr) +
 		(sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
 
+#ifdef CONFIG_TCP_RFC2385
+	if (tcp_v4_md5_lookup (sk, sk->daddr))
+		tp->tcp_header_len += TCPOLEN_RFC2385_ALIGNED;
+#endif
+
 	/* If user gave his TCP_MAXSEG, record it to clamp */
 	if (tp->user_mss)
 		tp->mss_clamp = tp->user_mss;
diff -Nur kernel-source-2.4.30/net/ipv6/tcp_ipv6.c kernel-source-2.4.30-md5/net/ipv6/tcp_ipv6.c
--- kernel-source-2.4.30/net/ipv6/tcp_ipv6.c	2004-11-17 13:54:22.000000000 +0200
+++ kernel-source-2.4.30-md5/net/ipv6/tcp_ipv6.c	2005-05-07 15:54:59.000000000 +0300
@@ -53,7 +53,7 @@
 
 #include <asm/uaccess.h>
 
-static void	tcp_v6_send_reset(struct sk_buff *skb);
+static void	tcp_v6_send_reset(struct sock *sk, struct sk_buff *skb);
 static void	tcp_v6_or_send_ack(struct sk_buff *skb, struct open_request *req);
 static void	tcp_v6_send_check(struct sock *sk, struct tcphdr *th, int len, 
 				  struct sk_buff *skb);
@@ -961,7 +961,7 @@
 }
 
 
-static void tcp_v6_send_reset(struct sk_buff *skb)
+static void tcp_v6_send_reset(struct sock *sk, struct sk_buff *skb)
 {
 	struct tcphdr *th = skb->h.th, *t1; 
 	struct sk_buff *buff;
@@ -1518,7 +1518,7 @@
 	return 0;
 
 reset:
-	tcp_v6_send_reset(skb);
+	tcp_v6_send_reset(sk, skb);
 discard:
 	if (opt_skb)
 		__kfree_skb(opt_skb);
@@ -1628,7 +1628,7 @@
 bad_packet:
 		TCP_INC_STATS_BH(TcpInErrs);
 	} else {
-		tcp_v6_send_reset(skb);
+		tcp_v6_send_reset(NULL, skb);
 	}
 
 discard_it:
