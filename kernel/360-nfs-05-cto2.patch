Reduce the number of getattr/lookup calls in nfs_lookup_revalidate() by
making the latter rely on the ordinary attribute cache, and moving the
close-to-open data consistency checking into nfs_open().

This does mean that we can end up calling GETATTR twice: once in
nfs_lookup_revalidate() then immediately after in nfs_open(), however
it also means that sys_stat() and friends now use cached attributes.


 dir.c   |   13 +++----------
 inode.c |   13 +++++++++++--
 2 files changed, 14 insertions(+), 12 deletions(-)

diff -u --recursive --new-file --show-c-function linux-2.4.26-04-pathconf/fs/nfs/dir.c linux-2.4.26-05-cto2/fs/nfs/dir.c
--- linux-2.4.26-04-pathconf/fs/nfs/dir.c	2004-04-16 09:35:26.000000000 -0700
+++ linux-2.4.26-05-cto2/fs/nfs/dir.c	2004-04-16 09:35:34.000000000 -0700
@@ -455,16 +455,9 @@ static inline void nfs_renew_times(struc
 }
 
 static inline
-int nfs_lookup_verify_inode(struct inode *inode, int flags)
+int nfs_lookup_verify_inode(struct inode *inode)
 {
-	struct nfs_server *server = NFS_SERVER(inode);
-	/*
-	 * If we're interested in close-to-open cache consistency,
-	 * then we revalidate the inode upon lookup.
-	 */
-	if (!(server->flags & NFS_MOUNT_NOCTO) && !(flags & LOOKUP_CONTINUE))
-		NFS_CACHEINV(inode);
-	return nfs_revalidate_inode(server, inode);
+	return nfs_revalidate_inode(NFS_SERVER(inode), inode);
 }
 
 /*
@@ -518,7 +511,7 @@ static int nfs_lookup_revalidate(struct 
 
 	/* Force a full look up iff the parent directory has changed */
 	if (nfs_check_verifier(dir, dentry)) {
-		if (nfs_lookup_verify_inode(inode, flags))
+		if (nfs_lookup_verify_inode(inode))
 			goto out_bad;
 		goto out_valid;
 	}
diff -u --recursive --new-file --show-c-function linux-2.4.26-04-pathconf/fs/nfs/inode.c linux-2.4.26-05-cto2/fs/nfs/inode.c
--- linux-2.4.26-04-pathconf/fs/nfs/inode.c	2004-04-16 09:35:30.000000000 -0700
+++ linux-2.4.26-05-cto2/fs/nfs/inode.c	2004-04-16 09:35:34.000000000 -0700
@@ -865,15 +865,23 @@ int nfs_open(struct inode *inode, struct
 {
 	struct rpc_auth *auth;
 	struct rpc_cred *cred;
+	int err = 0;
 
 	lock_kernel();
+	/* Ensure that we revalidate the data cache */
+	if (!(NFS_SERVER(inode)->flags & NFS_MOUNT_NOCTO)) {
+		err = __nfs_revalidate_inode(NFS_SERVER(inode),inode);
+		if (err)
+			goto out;
+	}
 	auth = NFS_CLIENT(inode)->cl_auth;
 	cred = rpcauth_lookupcred(auth, 0);
 	filp->private_data = cred;
 	if (filp->f_mode & FMODE_WRITE)
 		nfs_set_mmcred(inode, cred);
+out:
 	unlock_kernel();
-	return 0;
+	return err;
 }
 
 int nfs_release(struct inode *inode, struct file *filp)
@@ -1075,7 +1083,8 @@ __nfs_refresh_inode(struct inode *inode,
 	inode->i_atime = new_atime;
 
 	if (NFS_CACHE_MTIME(inode) != new_mtime) {
-		NFS_MTIME_UPDATE(inode) = jiffies;
+		if (invalid)
+			NFS_MTIME_UPDATE(inode) = jiffies;
 		NFS_CACHE_MTIME(inode) = new_mtime;
 		inode->i_mtime = nfs_time_to_secs(new_mtime);
 	}
