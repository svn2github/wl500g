diff '-x.*' -urBp linux/include/linux/netfilter_ipv6/ip6_conntrack_core.h linuz/include/linux/netfilter_ipv6/ip6_conntrack_core.h
--- linux/include/linux/netfilter_ipv6/ip6_conntrack_core.h	2010-02-20 23:07:15.000000000 +0300
+++ linuz/include/linux/netfilter_ipv6/ip6_conntrack_core.h	2010-02-28 15:48:22.000000000 +0300
@@ -34,11 +34,6 @@ extern struct ip6_conntrack_protocol *ip
 extern struct ip6_conntrack_protocol *__ip6_ct_find_proto(u_int8_t protocol);
 extern struct list_head ip6_protocol_list;
 
-/* Returns conntrack if it dealt with ICMP, and filled in skb->nfct */
-extern struct ip6_conntrack *icmp6_error_track(struct sk_buff *skb,
-					       unsigned int icmp6off,
-					       enum ip_conntrack_info *ctinfo,
-					       unsigned int hooknum);
 extern int ip6_get_tuple(const struct ipv6hdr *ipv6h,
 			 const struct sk_buff *skb,
 			 unsigned int protoff,
diff '-x.*' -urBp linux/include/linux/netfilter_ipv6/ip6_conntrack.h linuz/include/linux/netfilter_ipv6/ip6_conntrack.h
--- linux/include/linux/netfilter_ipv6/ip6_conntrack.h	2010-02-20 23:02:16.000000000 +0300
+++ linuz/include/linux/netfilter_ipv6/ip6_conntrack.h	2010-02-28 15:28:14.000000000 +0300
@@ -237,6 +237,9 @@ extern void ip6_ct_refresh(struct ip6_co
 /* Call me when a conntrack is destroyed. */
 extern void (*ip6_conntrack_destroyed)(struct ip6_conntrack *conntrack);
 
+/* Fake conntrack entry for untracked connections */
+extern struct ip6_conntrack ip6_conntrack_untracked;
+
 /* Returns new sk_buff, or NULL */
 struct sk_buff *
 ip6_ct_gather_frags(struct sk_buff *skb);
diff '-x.*' -urBp linux/net/ipv6/netfilter/ip6_conntrack_core.c linuz/net/ipv6/netfilter/ip6_conntrack_core.c
--- linux/net/ipv6/netfilter/ip6_conntrack_core.c	2010-02-20 23:13:03.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6_conntrack_core.c	2010-02-28 17:39:27.000000000 +0300
@@ -81,6 +81,7 @@ static atomic_t ip6_conntrack_count = AT
 struct list_head *ip6_conntrack_hash;
 static kmem_cache_t *ip6_conntrack_cachep;
 static LIST_HEAD(unconfirmed);
+struct ip6_conntrack ip6_conntrack_untracked;
 
 extern struct ip6_conntrack_protocol ip6_conntrack_generic_protocol;
 
@@ -619,8 +620,19 @@ ip6_conntrack_tuple_taken(const struct i
 	return h != NULL;
 }
 
+static const u_int8_t noct_valid_new[] = {
+	[ICMPV6_MGM_QUERY - 130] = 1,
+	[ICMPV6_MGM_REPORT - 130] = 1,
+	[ICMPV6_MGM_REDUCTION - 130] = 1,
+	[NDISC_ROUTER_SOLICITATION - 130] = 1,
+	[NDISC_ROUTER_ADVERTISEMENT - 130] = 1,
+	[NDISC_NEIGHBOUR_SOLICITATION - 130] = 1,
+	[NDISC_NEIGHBOUR_ADVERTISEMENT - 130] = 1,
+	[ICMPV6_MLD2_REPORT - 130] = 1,
+};
+
-/* Returns conntrack if it dealt with ICMP, and filled in skb fields */
-struct ip6_conntrack *
+/* Returns non-zero if it dealt with ICMP, and filled in skb fields */
+static int
 icmp6_error_track(struct sk_buff *skb,
 		  unsigned int icmp6off,
 		  enum ip6_conntrack_info *ctinfo,
@@ -635,13 +647,14 @@ icmp6_error_track(struct sk_buff *skb,
 	struct ip6_conntrack_protocol *inproto;
 	u_int8_t inprotonum;
 	unsigned int inprotoff;
+	int type;
 
 	IP6_NF_ASSERT(skb->nfct == NULL);
 
 	ip6h = skb->nh.ipv6h;
 	if (skb_copy_bits(skb, icmp6off, &hdr, sizeof(hdr))) {
 		DEBUGP("icmp6_error_track: Can't copy ICMPv6 hdr.\n");
-		return NULL;
+		return 0;
 	}
 
 	/* Why not check checksum in IPv4 conntrack ? - kozakai */
@@ -652,7 +665,16 @@ icmp6_error_track(struct sk_buff *skb,
 			    skb_checksum(skb, icmp6off,
 					 skb->len - icmp6off, 0))) {
 		DEBUGP("ICMPv6 checksum failed\n");
-		return NULL;
+		return 0;
+	}
+
+	type = hdr.icmp6_type - 130;
+	if (type >= 0 && type < sizeof(noct_valid_new)
+	    && noct_valid_new[type]) {
+		*ctinfo = IP_CT_NEW;
+		skb->nfct = &ip6_conntrack_untracked.infos[IP_CT_NEW];
+		nf_conntrack_get(skb->nfct);
+		return NF_ACCEPT;
 	}
 
 	/*
@@ -661,12 +683,12 @@ icmp6_error_track(struct sk_buff *skb,
 	 * - kozakai
 	 */
 	if (hdr.icmp6_type >= 128)
-		return NULL;
+		return NF_ACCEPT;
 
 	inip6off = icmp6off + sizeof(hdr);
 	if (skb_copy_bits(skb, inip6off, &inip6h, sizeof(inip6h))) {
 		DEBUGP("icmp6_error_track: Can't copy inner IPv6 hdr.\n");
-		return NULL;
+		return 0;
 	}
 
 	inprotonum = inip6h.nexthdr;
@@ -677,7 +699,7 @@ icmp6_error_track(struct sk_buff *skb,
 	if (inprotoff < 0 || inprotoff > skb->len
 	    || inprotonum == NEXTHDR_FRAGMENT) {
 		DEBUGP("icmp6_error_track: Can't find protocol header in ICMPv6 payload.\n");
-		return NULL;
+		return 0;
 	}
 
 	inproto = ip6_ct_find_proto(inprotonum);
@@ -686,14 +708,14 @@ icmp6_error_track(struct sk_buff *skb,
 	if (!ip6_get_tuple(&inip6h, skb, inprotoff, inprotonum,
 			   &origtuple, inproto)) {
 		DEBUGP("icmp6_error_track: ! get_tuple p=%u\n", inprotonum);
-		return NULL;
+		return 0;
 	}
 
 	/* Ordinarily, we'd expect the inverted tupleproto, but it's
 	   been preserved inside the ICMP. */
 	if (!invert_tuple(&intuple, &origtuple, inproto)) {
 		DEBUGP("icmp6_error_track: Can't invert tuple\n");
-		return NULL;
+		return 0;
 	}
 
 	*ctinfo = IP_CT_RELATED;
@@ -701,7 +723,7 @@ icmp6_error_track(struct sk_buff *skb,
 	h = ip6_conntrack_find_get(&intuple, NULL);
 	if (!h) {
 		DEBUGP("icmp6_error_track: no match\n");
-		return NULL;
+		return 0;
 	} else {
 		if (DIRECTION(h) == IP_CT_DIR_REPLY)
 			*ctinfo += IP_CT_IS_REPLY;
@@ -709,7 +731,7 @@ icmp6_error_track(struct sk_buff *skb,
 
 	/* Update skb to refer to this connection */
 	skb->nfct = &h->ctrack->infos[*ctinfo];
-	return h->ctrack;
+	return NF_ACCEPT;
 }
 
 /* There's a small race here where we may free a just-assured
@@ -981,8 +1003,8 @@ unsigned int ip6_conntrack_in(unsigned i
 
 	/* It may be an icmp error... */
 	if (protonum == IPPROTO_ICMPV6
-	    && icmp6_error_track(*pskb, protoff, &ctinfo, hooknum))
-		return NF_ACCEPT;
+	    && icmp6_error_track(*pskb, protoff, &ctinfo, hooknum) <= 0)
+		return -NF_ACCEPT;
 
 	proto = ip6_ct_find_proto(protonum);
 
@@ -1492,6 +1514,8 @@ void ip6_conntrack_cleanup(void)
 		schedule();
 		goto i_see_dead_people;
 	}
+	while (atomic_read(&ip6_conntrack_untracked.ct_general.use) > 1)
+		schedule();
 
 	kmem_cache_destroy(ip6_conntrack_cachep);
 	vfree(ip6_conntrack_hash);
@@ -1570,6 +1594,18 @@ int __init ip6_conntrack_init(void)
 
 	/* For use by ip6t_REJECT */
 	ip6_ct_attach = ip6_conntrack_attach;
+
+	/* Set up fake conntrack:
+	 	- never to be deleted, not in any hashes */
+	atomic_set(&ip6_conntrack_untracked.ct_general.use, 1);
+	/*	- and let it look as if it's a confirmed connection */
+	set_bit(IPS_CONFIRMED_BIT, &ip6_conntrack_untracked.status);
+	/*	- and prepare the ctinfo field for REJECT. */
+        ip6_conntrack_untracked.infos[IP_CT_NEW].master =
+        ip6_conntrack_untracked.infos[IP_CT_RELATED].master =
+        ip6_conntrack_untracked.infos[IP_CT_RELATED + IP_CT_IS_REPLY].master =
+                &ip6_conntrack_untracked.ct_general;
+
 	return ret;
 
 #ifdef CONFIG_SYSCTL
diff '-x.*' -urBp linux/net/ipv6/netfilter/ip6_conntrack_standalone.c linuz/net/ipv6/netfilter/ip6_conntrack_standalone.c
--- linux/net/ipv6/netfilter/ip6_conntrack_standalone.c	2010-02-20 23:13:14.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6_conntrack_standalone.c	2010-02-28 15:07:11.000000000 +0300
@@ -493,5 +493,6 @@ EXPORT_SYMBOL(ip6_conntrack_tuple_taken)
 EXPORT_SYMBOL(ip6_conntrack_htable_size);
 EXPORT_SYMBOL(ip6_conntrack_expect_list);
 EXPORT_SYMBOL(ip6_conntrack_lock);
+EXPORT_SYMBOL(ip6_conntrack_untracked);
 EXPORT_SYMBOL_GPL(ip6_conntrack_find_get);
 EXPORT_SYMBOL_GPL(ip6_conntrack_put);
diff '-x.*' -urBp linux/net/ipv6/netfilter/ip6t_state.c linuz/net/ipv6/netfilter/ip6t_state.c
--- linux/net/ipv6/netfilter/ip6t_state.c	2010-02-14 16:47:22.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6t_state.c	2010-02-28 15:31:40.000000000 +0300
@@ -37,7 +37,9 @@ match(const struct sk_buff *skb,
 	enum ip6_conntrack_info ctinfo;
 	unsigned int statebit;
 
-	if (!ip6_conntrack_get(skb, &ctinfo))
+	if (skb->nfct == &ip6_conntrack_untracked.infos[IP_CT_NEW])
+		statebit = IPT_STATE_UNTRACKED;
+	else if (!ip6_conntrack_get(skb, &ctinfo))
 		statebit = IPT_STATE_INVALID;
 	else
 		statebit = IPT_STATE_BIT(ctinfo);
