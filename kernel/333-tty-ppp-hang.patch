Subject: [PATCH] tty: Fix PPP hang under load
From c9b3976e3fec266be25c5001a70aa0a890b6c476
From: Alan Cox
Date: Fri, 2 Jan 2009 13:44:56 +0000
---

Subject: [PATCH] remove TTY_DONT_FLIP
From 817d6d3bceaf34c99f5343820f9b9e6021f0655c
From: Paul Fulghum
Date: Wed, 28 Jun 2006 04:26:47 -0700
---

Subject: [PATCH] [PATCH] pty_chars_in_buffer oops fix
From ff55fe2075e3901db4dbdc00e0b44a71bef97afd
From: Jason Baron
Date: Fri, 9 Sep 2005 13:01:57 -0700
---

diff --git a/drivers/char/tty_ldisc.c b/drivers/char/tty_ldisc.c
--- a/drivers/char/tty_io.c
+++ b/drivers/char/tty_io.c
@@ -403,6 +403,7 @@ struct tty_ldisc *tty_ldisc_ref_wait(str
 {
 	/* wait_event is a macro */
 	wait_event(tty_ldisc_wait, tty_ldisc_try(tty));
+	WARN_ON(tty->ldisc.refcount == 0);
 	return &tty->ldisc;
 }
 
@@ -452,15 +453,17 @@ EXPORT_SYMBOL_GPL(tty_ldisc_deref);
   *     @tty: terminal to activate ldisc on
   *
   *     Set the TTY_LDISC flag when the line discipline can be called
-  *     again. Do neccessary wakeups for existing sleepers.
+  *     again. Do neccessary wakeups for existing sleepers. Clear the LDISC
+  *	changing flag to indicate any ldisc change is now over.
   *
-  *     Note: nobody should set this bit except via this function. Clearing
-  *     directly is allowed.
+  *     Note: nobody should set the TTY_LDISC bit except via this function.
+  *     Clearing directly is allowed.
   */
 
 static void tty_ldisc_enable(struct tty_struct *tty)
 {
 	set_bit(TTY_LDISC, &tty->flags);
+	clear_bit(TTY_LDISC_CHANGING, &tty->flags);
 	wake_up(&tty_ldisc_wait);
 }
 
@@ -480,15 +483,13 @@ static int tty_set_ldisc(struct tty_stru
 	char buf[64];
 	unsigned long flags;
 	struct tty_ldisc *ld;
+	struct tty_struct *o_tty;
 
 	if ((ldisc < N_TTY) || (ldisc >= NR_LDISCS))
 		return -EINVAL;
 
 restart:
 
-	if (tty->ldisc.num == ldisc)
-		return 0; /* We are already in the desired discipline */
-
 	ld = tty_ldisc_get(ldisc);
 	/* Eduardo Blanco <ejbs@cs.cs.com.uy> */
 	/* Cyrus Durgin <cider@speakeasy.org> */
@@ -503,37 +504,78 @@ restart:
 	if (ld == NULL)
 		return -EINVAL;
 
-	
-	o_ldisc = tty->ldisc;
 	tty_wait_until_sent(tty, 0);
 
+	if (tty->ldisc.num == ldisc) {
+		tty_ldisc_put(ldisc);
+		return 0;
+	}
+
+	o_ldisc = tty->ldisc;
+	o_tty = tty->link;
+
 	/*
 	 *      Make sure we don't change while someone holds a
 	 *      reference to the line discipline. The TTY_LDISC bit
 	 *      prevents anyone taking a reference once it is clear.
 	 *      We need the lock to avoid racing reference takers.
+	 *
+	 *      We must clear the TTY_LDISC bit here to avoid a livelock
+	 *      with a userspace app continually trying to use the tty in
+	 *      parallel to the change and re-referencing the tty.
 	 */
+	clear_bit(TTY_LDISC, &tty->flags);
+	if (o_tty)
+		clear_bit(TTY_LDISC, &o_tty->flags);
 
 	spin_lock_irqsave(&tty_ldisc_lock, flags);
-	if(tty->ldisc.refcount)
+	if(tty->ldisc.refcount || (o_tty && o_tty->ldisc.refcount))
 	{
-		/* Free the new ldisc we grabbed. Must drop the lock
-		   first. */
+		if (tty->ldisc.refcount) {
+			/* Free the new ldisc we grabbed. Must drop the lock
+			   first. */
+			spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+			tty_ldisc_put(ldisc);
+			/*
+			 * There are several reasons we may be busy, including
+			 * random momentary I/O traffic. We must therefore
+			 * retry. We could distinguish between blocking ops
+			 * and retries if we made tty_ldisc_wait() smarter. That
+			 * is up for discussion.
+			 */
+			if(wait_event_interruptible(tty_ldisc_wait, tty->ldisc.refcount == 0) < 0)
+				return -ERESTARTSYS;
+			goto restart;
+		}
+		if (o_tty && o_tty->ldisc.refcount) {
+			spin_unlock_irqrestore(&tty_ldisc_lock, flags);
+			tty_ldisc_put(o_tty->ldisc.num);
+			if (wait_event_interruptible(tty_ldisc_wait, o_tty->ldisc.refcount == 0) < 0)
+				return -ERESTARTSYS;
+			goto restart;
+		}
+	}
+
+	/*
+	 *	If the TTY_LDISC_CHANGING bit is set, then we are racing against
+	 *	another ldisc change
+	 */
+	if (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {
 		spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 		tty_ldisc_put(ldisc);
-		/*
-		 * There are several reasons we may be busy, including
-		 * random momentary I/O traffic. We must therefore
-		 * retry. We could distinguish between blocking ops
-		 * and retries if we made tty_ldisc_wait() smarter. That
-		 * is up for discussion.
-		 */
-		if(wait_event_interruptible(tty_ldisc_wait, tty->ldisc.refcount == 0) < 0)
-			return -ERESTARTSYS;
+		ld = tty_ldisc_ref_wait(tty);
+		tty_ldisc_deref(ld);
 		goto restart;
 	}
-	clear_bit(TTY_LDISC, &tty->flags);
-	clear_bit(TTY_DONT_FLIP, &tty->flags);
+
+	/*
+	 *      This flag is used to avoid two parallel ldisc changes. Once
+	 *      open and close are fine grained locked this may work better
+	 *      as a mutex shared with the open/close/hup paths
+	 */
+	set_bit(TTY_LDISC_CHANGING, &tty->flags);
+	if (o_tty)
+		set_bit(TTY_LDISC_CHANGING, &o_tty->flags);
 	spin_unlock_irqrestore(&tty_ldisc_lock, flags);
 
 	/*
@@ -591,6 +633,8 @@ restart:
 	 *      ldisc callback completes.
 	 */
 	tty_ldisc_enable(tty);
+	if (o_tty)
+		tty_ldisc_enable(o_tty);
 
 	return retval;
 }
@@ -1613,7 +1657,6 @@ static void release_dev(struct file * fi
 	 * race with the set_ldisc code path.
 	 */
 	clear_bit(TTY_LDISC, &tty->flags);
-	clear_bit(TTY_DONT_FLIP, &tty->flags);
 
 	/*
 	 * Wait for ->hangup_work and ->flip.work handlers to terminate
@@ -2338,10 +2381,6 @@ static void flush_to_ldisc(void *private
 	if (disc == NULL)       /*  !TTY_LDISC */
 		return;
 
-	if (test_bit(TTY_DONT_FLIP, &tty->flags)) {
-		queue_task(&tty->flip.tqueue, &tq_timer);
-		goto out;
-	}
 	if (tty->flip.buf_num) {
 		cp = tty->flip.char_buf + TTY_FLIPBUF_SIZE;
 		fp = tty->flip.flag_buf + TTY_FLIPBUF_SIZE;
@@ -2364,7 +2403,6 @@ static void flush_to_ldisc(void *private
 	restore_flags(flags);
 	
 	disc->receive_buf(tty, cp, fp, count);
-out:
 	tty_ldisc_deref(disc);
 }
 
@@ -2379,9 +2417,7 @@ int tty_push_data(struct tty_struct *tty
 	struct tty_ldisc *disc;
 	
 	disc = tty_ldisc_ref(tty);
-	if(test_bit(TTY_DONT_FLIP, &tty->flags))
-		ret = -EAGAIN;
-	else if(disc == NULL)
+	if (disc == NULL)
 		ret = -EIO;
 	else
 		disc->receive_buf(tty, cp, fp, count);
diff --git a/include/linux/tty.h b/include/linux/tty.h
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -331,8 +331,8 @@ struct tty_struct {
 #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
 #define TTY_PUSH 		6	/* n_tty private */
 #define TTY_CLOSING 		7	/* ->close() in progress */
-#define TTY_DONT_FLIP 		8	/* Defer buffer flip */
 #define TTY_LDISC 		9	/* Line discipline attached */
+#define TTY_LDISC_CHANGING 	10	/* Line discipline changing */
 #define TTY_HW_COOK_OUT 	14	/* Hardware can do output cooking */
 #define TTY_HW_COOK_IN 	15	/* Hardware can do input cooking */
 #define TTY_PTY_LOCK 		16	/* pty private */
diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -463,17 +463,14 @@ static void rfcomm_dev_data_ready(struct
 
 	BT_DBG("dlc %p tty %p len %d", dlc, tty, skb->len);
 
-	if (test_bit(TTY_DONT_FLIP, &tty->flags)) {
-		register int i;
-		for (i = 0; i < skb->len; i++) {
-			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-				tty_flip_buffer_push(tty);
+	register int i;
+	for (i = 0; i < skb->len; i++) {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			tty_flip_buffer_push(tty);
 
-			tty_insert_flip_char(tty, skb->data[i], 0);
-		}
-		tty_flip_buffer_push(tty);
-	} else
-		tty->ldisc.receive_buf(tty, skb->data, NULL, skb->len);
+		tty_insert_flip_char(tty, skb->data[i], 0);
+	}
+	tty_flip_buffer_push(tty);
 
 	kfree_skb(skb);
 }
diff -urBp a/drivers/char/n_tty.c linux/drivers/char/n_tty.c
--- a/drivers/char/n_tty.c	2010-02-02 00:04:46.000000000 +0300
+++ b/drivers/char/n_tty.c	2010-05-06 12:40:21.000000000 +0400
@@ -1085,7 +1085,7 @@ static inline int input_available_p(stru
  *	buffer, and once to drain the space from the (physical) beginning of
  *	the buffer to head pointer.
  *
- *	Called under the tty->atomic_read sem and with TTY_DONT_FLIP set
+ *	Called under the tty->atomic_read sem
  *
  */
  
@@ -1222,7 +1222,6 @@ do_it_again:
 	}
 
 	add_wait_queue(&tty->read_wait, &wait);
-	set_bit(TTY_DONT_FLIP, &tty->flags);
 	while (nr) {
 		/* First test for status change. */
 		if (tty->packet && tty->link->ctrl_status) {
@@ -1261,9 +1260,7 @@ do_it_again:
 				retval = -ERESTARTSYS;
 				break;
 			}
-			clear_bit(TTY_DONT_FLIP, &tty->flags);
 			timeout = schedule_timeout(timeout);
-			set_bit(TTY_DONT_FLIP, &tty->flags);
 			continue;
 		}
 		current->state = TASK_RUNNING;
@@ -1328,7 +1325,6 @@ do_it_again:
 		if (time)
 			timeout = time;
 	}
-	clear_bit(TTY_DONT_FLIP, &tty->flags);
 	up(&tty->atomic_read);
 	remove_wait_queue(&tty->read_wait, &wait);
 
diff -urBp a/drivers/char/pty.c b/drivers/char/pty.c
--- a/drivers/char/pty.c	2010-02-02 00:04:46.000000000 +0300
+++ b/drivers/char/pty.c	2010-05-06 12:37:01.000000000 +0400
@@ -137,7 +137,7 @@ static void pty_unthrottle(struct tty_st
  *
  * FIXME: Our pty_write method is called with our ldisc lock held but
  * not our partners. We can't just take the other one blindly without
- * risking deadlocks.  There is also the small matter of TTY_DONT_FLIP
+ * risking deadlocks.
  */
 static int pty_write(struct tty_struct * tty, int from_user,
 		       const unsigned char *buf, int count)
@@ -218,15 +218,14 @@ static int pty_write_room(struct tty_str
 static int pty_chars_in_buffer(struct tty_struct *tty)
 {
 	struct tty_struct *to = tty->link;
-	ssize_t (*chars_in_buffer)(struct tty_struct *);
 	int count;
 
 	/* We should get the line discipline lock for "tty->link" */
-	if (!to || !(chars_in_buffer = to->ldisc.chars_in_buffer))
+	if (!to || !to->ldisc.chars_in_buffer)
 		return 0;
 
 	/* The ldisc must report 0 if no characters available to be read */
-	count = chars_in_buffer(to);
+	count = to->ldisc.chars_in_buffer(to);
 
 	if (tty->driver.subtype == PTY_TYPE_SLAVE) return count;
 
diff -urBp a/drivers/char/serial.c b/drivers/char/serial.c
--- a/drivers/char/serial.c	2006-10-02 23:19:59.000000000 +0400
+++ b/drivers/char/serial.c	2010-05-06 12:37:30.000000000 +0400
@@ -615,7 +615,7 @@ static _INLINE_ void receive_chars(struc
 					icount->overrun++;
 					*status = serial_inp(info, UART_LSR);
 				} while ((*status & UART_LSR_DR) && (max_count-- > 0));
-				return;		// if TTY_DONT_FLIP is set
+				return;
 			}
 		}
 		ch = serial_inp(info, UART_RX);
diff -urBp a/drivers/char/serial_txx9.c b/drivers/char/serial_txx9.c
--- a/drivers/char/serial_txx9.c	2010-02-02 00:04:46.000000000 +0300
+++ b/drivers/char/serial_txx9.c	2010-05-06 12:36:37.000000000 +0400
@@ -332,7 +332,7 @@ static inline void receive_chars(struct 
 		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
 			tty->flip.tqueue.routine((void *) tty);
 			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-				return;		// if TTY_DONT_FLIP is set
+				return;
 		}
 		ch = sio_in(port, TXX9_SIRFIFO);
 		*tty->flip.char_buf_ptr = ch;
diff -urBp a/drivers/net/wan/8253x/8253xsyn.c b/drivers/net/wan/8253x/8253xsyn.c
--- a/drivers/net/wan/8253x/8253xsyn.c	2010-02-02 00:04:46.000000000 +0300
+++ b/drivers/net/wan/8253x/8253xsyn.c	2010-05-06 12:37:51.000000000 +0400
@@ -55,11 +55,6 @@ static void sab8253x_flush_to_ldiscS(voi
 		return;
 	}
 	
-	if (test_bit(TTY_DONT_FLIP, &tty->flags)) 
-	{
-		queue_task(&tty->flip.tqueue, &tq_timer);
-		return;
-	}
 	/* note that a hangup may have occurred -- perhaps should check for that */
 	port->DoingInterrupt = 1;
 	while(port->sab8253xc_rcvbuflist && (skb_queue_len(port->sab8253xc_rcvbuflist) > 0))
diff -urBp a/drivers/net/wan/8253x/8253xtty.c b/drivers/net/wan/8253x/8253xtty.c
--- a/drivers/net/wan/8253x/8253xtty.c	2010-02-02 00:04:46.000000000 +0300
+++ b/drivers/net/wan/8253x/8253xtty.c	2010-05-06 12:37:57.000000000 +0400
@@ -95,11 +95,6 @@ static void sab8253x_flush_to_ldisc(void
 		return;
 	}
 	
-	if (test_bit(TTY_DONT_FLIP, &tty->flags)) 
-	{
-		queue_task(&tty->flip.tqueue, &tq_timer);
-		return;
-	}
 	/* note that a hangup may have occurred -- perhaps should check for that */
 	port->DoingInterrupt = 1;
 	while(port->sab8253xc_rcvbuflist && (skb_queue_len(port->sab8253xc_rcvbuflist) > 0))
