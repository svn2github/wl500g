diff -urbBN linux-2.4.37/drivers/usb/devpath.c linux.cdma/drivers/usb/devpath.c
--- linux-2.4.37/drivers/usb/devpath.c	1970-01-01 03:00:00.000000000 +0300
+++ linux.cdma/drivers/usb/devpath.c	2008-12-04 19:16:06.000000000 +0300
@@ -0,0 +1,186 @@
+/*
+ * devpath.c
+ * (C) Copyright 2008 Jiri Engelthaler
+ *
+ * $id$
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *************************************************************
+ *
+ * 2008-07-25: Jiri Engelthaler (engy@centrum.cz)
+ *
+ * $Id: devpath.c,v 1.3 2000/01/11 13:58:24 tom Exp $
+ */
+
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/usb.h>
+#include <linux/usbdevice_fs.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+
+LIST_HEAD(usb_devpath_list);
+struct semaphore usb_devpath_list_lock;
+
+struct usb_devpath {
+  struct list_head devpath_list;
+  struct usb_device *dev;
+  char index;
+  char devfs[16];
+};
+
+void usb_register_devpath(struct usb_device *dev, char index, char *devfs)
+{
+	struct usb_devpath *newdevpath;
+	
+	down(&usb_devpath_list_lock);
+	newdevpath = kmalloc(sizeof(*newdevpath), GFP_KERNEL);
+	newdevpath->dev = dev;
+	newdevpath->index = index;
+	strcpy(newdevpath->devfs, devfs);
+	list_add_tail(&newdevpath->devpath_list, &usb_devpath_list);
+	up(&usb_devpath_list_lock);
+}
+
+void usb_deregister_devpath(struct usb_device *dev)
+{
+	struct list_head *tmp;
+
+	down(&usb_devpath_list_lock);
+	for (tmp = usb_devpath_list.next; tmp != &usb_devpath_list; tmp = tmp->next) {
+		struct usb_devpath *devpath = list_entry(tmp, struct usb_devpath, devpath_list);
+		if (devpath->dev == dev)
+		{
+			tmp = tmp->prev;
+			list_del(&devpath->devpath_list);
+			kfree(devpath);
+		}
+	}	
+	up(&usb_devpath_list_lock);
+}
+
+/*****************************************************************/
+
+/*
+ * Dump usb_devpath_list.
+ *
+ * We now walk the list of registered USB device paths.
+ */
+static ssize_t usb_devpath_read(struct file *file, char *buf, size_t nbytes, loff_t *ppos)
+{
+	struct list_head *tmp;
+	char *page, *start, *end;
+	ssize_t ret = 0;
+	loff_t n = *ppos;
+	unsigned int pos = n, len;
+	char  *infobuf;
+	
+	if (pos != n)
+		return -EINVAL;
+	if (nbytes <= 0)
+		return 0;
+	if (!access_ok(VERIFY_WRITE, buf, nbytes))
+		return -EFAULT;
+	if (!(page = (char*) __get_free_page(GFP_KERNEL)))
+		return -ENOMEM;
+	start = page;
+	end = page + (PAGE_SIZE - 100);
+
+	infobuf = kmalloc(128, GFP_KERNEL);
+
+	start += sprintf(start, "Device         : Location : Info\n");
+	
+	down(&usb_devpath_list_lock);
+	
+	for (tmp = usb_devpath_list.next; tmp != &usb_devpath_list; tmp = tmp->next) {
+		struct usb_devpath *devpath = list_entry(tmp, struct usb_devpath, devpath_list);
+		
+		start += sprintf(start, "/dev/%s : %s.%d ", devpath->devfs, devpath->dev->devpath, devpath->index);
+		
+		if (devpath->dev->descriptor.iManufacturer) {
+			if (usb_string(devpath->dev, devpath->dev->descriptor.iManufacturer, infobuf, 128) > 0)
+				start += sprintf(start, ": Manufacturer=\"%.100s\" ", infobuf);
+		}
+		
+		if (devpath->dev->descriptor.iProduct) {
+			if (usb_string(devpath->dev, devpath->dev->descriptor.iProduct, infobuf, 128) > 0)
+				start += sprintf(start, ": Product=\"%.100s\" ", infobuf);
+		}
+#ifdef ALLOW_SERIAL_NUMBER
+		if (devpath->dev->descriptor.iSerialNumber) {
+			if (usb_string(devpath->dev, devpath->dev->descriptor.iSerialNumber, infobuf, 128) > 0)
+				start += sprintf(start, ": SerialNumber=\"%.100s\" ", infobuf);
+		}
+#endif
+		start += sprintf(start, "\n");
+/*		int minor = driver->fops ? driver->minor : -1;
+		if (minor == -1)
+			start += sprintf (start, "         %s\n", driver->name);
+		else
+			start += sprintf (start, "%3d-%3d: %s\n", minor, minor + 15, driver->name);*/
+		if (start > end) {
+			start += sprintf(start, "(truncated)\n");
+			break;
+		}
+	}
+	if (start == page)
+		start += sprintf(start, "(none)\n");
+	len = start - page;
+	if (len > pos) {
+		len -= pos;
+		if (len > nbytes)
+			len = nbytes;
+		ret = len;
+		if (copy_to_user(buf, page + pos, len))
+			ret = -EFAULT;
+		else
+			*ppos = pos + len;
+	}
+	
+	up(&usb_devpath_list_lock);
+	
+	kfree(infobuf);
+	free_page((unsigned long)page);
+	return ret;
+}
+
+static loff_t usb_devpath_lseek(struct file * file, loff_t offset, int orig)
+{
+	switch (orig) {
+	case 0:
+		file->f_pos = offset;
+		return file->f_pos;
+
+	case 1:
+		file->f_pos += offset;
+		return file->f_pos;
+
+	case 2:
+		return -EINVAL;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+struct file_operations usbdevfs_devpath_fops = {
+	llseek:		usb_devpath_lseek,
+	read:		usb_devpath_read,
+};
+
+EXPORT_SYMBOL(usb_register_devpath);
+EXPORT_SYMBOL(usb_deregister_devpath);
diff -urbBN linux-2.4.37/drivers/usb/inode.c linux.cdma/drivers/usb/inode.c
--- linux-2.4.37/drivers/usb/inode.c	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/drivers/usb/inode.c	2008-12-04 19:16:06.000000000 +0300
@@ -62,7 +62,10 @@
 
 static struct special special[] = { 
 	{ "devices", &usbdevfs_devices_fops,  },
-	{ "drivers", &usbdevfs_drivers_fops,  }
+	{ "drivers", &usbdevfs_drivers_fops,  },
+#ifdef CONFIG_USB_DEVPATH
+	{ "devpath", &usbdevfs_devpath_fops,  },
+#endif
 };
 
 #define NRSPECIAL (sizeof(special)/sizeof(special[0]))
diff -urbB linux-2.4.37/drivers/usb/Config.in linux/drivers/usb/Config.in
--- linux-2.4.37/drivers/usb/Config.in	2008-12-05 21:56:50.000000000 +0300
+++ linux/drivers/usb/Config.in	2008-12-14 19:57:52.000000000 +0300
@@ -15,6 +15,11 @@
    else
       define_bool CONFIG_USB_BANDWIDTH n
    fi
+   if [ "$CONFIG_USB_DEVICEFS" = "y" ]; then
+      bool '  Add support for /proc/bus/usb/devpath' CONFIG_USB_DEVPATH
+   else
+      define_bool CONFIG_USB_DEVPATH n
+   fi
 
    source drivers/usb/host/Config.in
 
diff -urbBN linux-2.4.37/drivers/usb/Makefile linux.cdma/drivers/usb/Makefile
--- linux-2.4.37/drivers/usb/Makefile	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/drivers/usb/Makefile	2008-12-04 19:16:06.000000000 +0300
@@ -10,7 +10,10 @@
 
 # Objects that export symbols.
 
 export-objs		:= hcd.o usb.o ov51x.o pwc-uncompress.o
+ifeq ($(CONFIG_USB_DEVPATH),y)
+	export-objs	+= devpath.o
+endif
 
 # Multipart objects.
 
@@ -24,7 +24,10 @@
 # Optional parts of multipart objects.
 
 ifeq ($(CONFIG_USB_DEVICEFS),y)
 	usbcore-objs	+= devio.o inode.o drivers.o devices.o
+ifeq ($(CONFIG_USB_DEVPATH),y)
+	usbcore-objs	+= devpath.o
+endif
 endif
 
 ifeq ($(CONFIG_USB_HIDDEV),y)
diff -BurpN linux-2.4.37.2/drivers/usb/printer.c linux/drivers/usb/printer.c
--- linux-2.4.37.2/drivers/usb/printer.c	2009-06-17 16:53:19.000000000 +0000
+++ linux/drivers/usb/printer.c	2009-06-17 16:52:29.000000000 +0000
@@ -628,6 +628,9 @@ static void usblp_cleanup (struct usblp 
 {
 	devfs_unregister (usblp->devfs);
 	usblp_table [usblp->minor] = NULL;
+#ifdef CONFIG_USB_DEVPATH
+	usb_deregister_devpath(usblp->dev);
+#endif
 	info("usblp%d: removed", usblp->minor);
 
 	kfree (usblp->writebuf);
@@ -1275,6 +1278,9 @@ static void *usblp_probe(struct usb_devi
 	struct usblp *usblp = 0;
 	int protocol;
 	char name[6];
+#ifdef CONFIG_USB_DEVPATH
+	char devfsname[16];
+#endif
 
 	/* Malloc and start initializing usblp structure so we can use it
 	 * directly. */
@@ -1369,6 +1375,10 @@ static void *usblp_probe(struct usb_devi
 				      USBLP_MINOR_BASE + usblp->minor,
 				      S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP |
 				      S_IWGRP, &usblp_fops, NULL);
+#ifdef CONFIG_USB_DEVPATH
+	sprintf(devfsname, "usb/%s", name);
+	usb_register_devpath(dev, ifnum, devfsname);
+#endif
 
 	info("usblp%d: USB %sdirectional printer dev %d "
 		"if %d alt %d proto %d vid 0x%4.4X pid 0x%4.4X",

diff -urbBN linux-2.4.37/drivers/usb/serial/usbserial.c linux.cdma/drivers/usb/serial/usbserial.c
--- linux-2.4.37/drivers/usb/serial/usbserial.c	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/drivers/usb/serial/usbserial.c	2008-12-04 19:16:55.000000000 +0300
@@ -1430,6 +1430,9 @@ static void * usb_serial_probe(
 	int max_endpoints;
 	const struct usb_device_id *id_pattern = NULL;
 	unsigned long flags;
+#ifdef CONFIG_USB_DEVPATH
+	char devfsname[16];
+#endif
 
 	/* loop through our list of known serial converters, and see if this
 	   device matches. */
@@ -1662,6 +1663,10 @@ static void * usb_serial_probe(
 		tty_register_devfs (&serial_tty_driver, 0, serial->port[i].number);
 		info("%s converter now attached to ttyUSB%d (or usb/tts/%d for devfs)", 
 		     type->name, serial->port[i].number, serial->port[i].number);
+#ifdef CONFIG_USB_DEVPATH
+		sprintf(devfsname, serial_tty_driver.name, serial->port[i].number);
+		usb_register_devpath(dev, ifnum+i*10, devfsname);
+#endif
 	}
 
 	return serial; /* success */
@@ -1755,6 +1758,9 @@ static void usb_serial_disconnect(
 
 		for (i = 0; i < serial->num_ports; ++i) {
 			tty_unregister_devfs (&serial_tty_driver, serial->port[i].number);
+#ifdef CONFIG_USB_DEVPATH
+			usb_deregister_devpath(dev);
+#endif
 			info("%s converter now disconnected from ttyUSB%d", serial->type->name, serial->port[i].number);
 		}
 
@@ -1907,7 +1907,7 @@ void usb_serial_deregister(
 		serial = serial_table[i];
 		if ((serial != NULL) && (serial->type == device)) {
 			usb_driver_release_interface (&usb_serial_driver, serial->interface);
-			usb_serial_disconnect (NULL, serial);
+			usb_serial_disconnect (serial->dev, serial);
 		}
 	}
 
diff -urbBN linux-2.4.37/drivers/usb/usb.c linux.cdma/drivers/usb/usb.c
--- linux-2.4.37/drivers/usb/usb.c	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/drivers/usb/usb.c	2008-12-04 19:16:06.000000000 +0300
@@ -2443,6 +2443,9 @@
 static int __init usb_init(void)
 {
 	init_MUTEX(&usb_bus_list_lock);
+#ifdef CONFIG_USB_DEVPATH
+	init_MUTEX(&usb_devpath_list_lock);
+#endif
 	usb_major_init();
 	usbdevfs_init();
 	usb_hub_init();
diff -urbBN linux-2.4.37/include/linux/usbdevice_fs.h linux.cdma/include/linux/usbdevice_fs.h
--- linux-2.4.37/include/linux/usbdevice_fs.h	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/include/linux/usbdevice_fs.h	2008-12-04 19:16:06.000000000 +0300
@@ -183,6 +183,7 @@
 extern struct usb_driver usbdevfs_driver;
 extern struct file_operations usbdevfs_drivers_fops;
 extern struct file_operations usbdevfs_devices_fops;
+extern struct file_operations usbdevfs_devpath_fops;
 extern struct file_operations usbdevfs_device_file_operations;
 extern struct inode_operations usbdevfs_device_inode_operations;
 extern void usbdevfs_conn_disc_event(void);
diff -urbBN linux-2.4.37/include/linux/usb.h linux.cdma/include/linux/usb.h
--- linux-2.4.37/include/linux/usb.h	2008-12-04 19:13:37.000000000 +0300
+++ linux.cdma/include/linux/usb.h	2008-12-04 19:16:06.000000000 +0300
@@ -907,6 +907,9 @@
 extern void usb_inc_dev_use(struct usb_device *);
 #define usb_dec_dev_use usb_free_dev
 
+extern void usb_register_devpath(struct usb_device *, char, char *);
+extern void usb_deregister_devpath(struct usb_device *);
+
 extern int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout);
 
 extern int usb_root_hub_string(int id, int serial, char *type, __u8 *data, int len);
@@ -1114,6 +1117,7 @@
 extern struct list_head usb_driver_list;
 extern struct list_head usb_bus_list;
 extern struct semaphore usb_bus_list_lock;
+extern struct semaphore usb_devpath_list_lock;
 
 /*
  * USB device fs stuff
diff -BurpN linux-2.4.37.2/drivers/usb/scanner.c linux/drivers/usb/scanner.c
--- linux-2.4.37.2/drivers/usb/scanner.c	2009-06-07 19:50:24.000000000 +0000
+++ linux/drivers/usb/scanner.c	2009-06-17 16:35:44.000000000 +0000
@@ -878,6 +878,9 @@ probe_scanner(struct usb_device *dev, un
 	char valid_device = 0;
 	char have_bulk_in, have_bulk_out, have_intr;
 	char name[10];
+#ifdef CONFIG_USB_DEVPATH
+	char devfsname[16];
+#endif
 
 	dbg("probe_scanner: USB dev address:%p", dev);
 	dbg("probe_scanner: ifnum:%u", ifnum);
@@ -1110,6 +1113,11 @@ probe_scanner(struct usb_device *dev, un
 	if (scn->devfs == NULL)
 		dbg("scanner%d: device node registration failed", scn_minor);
 
+#ifdef CONFIG_USB_DEVPATH
+	sprintf(devfsname, "usb/%s", name);
+	usb_register_devpath(dev, ifnum, devfsname);
+#endif
+
 	info ("USB scanner device (0x%04x/0x%04x) now attached to %s",
 	      dev->descriptor.idVendor, dev->descriptor.idProduct, name);
 	p_scn_table[scn_minor] = scn;
@@ -1145,6 +1153,9 @@ disconnect_scanner(struct usb_device *de
 	dbg("disconnect_scanner: De-allocating minor:%d", scn->scn_minor);
 	devfs_unregister(scn->devfs);
 	p_scn_table[scn->scn_minor] = NULL;
+#ifdef CONFIG_USB_DEVPATH
+	usb_deregister_devpath(scn->scn_dev);
+#endif
 
 	if (scn->isopen) {
 		/* The device is still open - cleanup must be delayed */
