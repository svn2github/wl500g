Subject: [NETFILTER]: Fix ip6_tables protocol bypass bug
From 51d8b1a65291a6956b79374b6adbbadc2263bcf6
From: Patrick McHardy
Date: Tue, 24 Oct 2006 16:14:04 -0700

As reported by Mark Dowd <Mark_Dowd@McAfee.com>, ip6_tables is susceptible
to a fragmentation attack causing false negatives on protocol matches.

When the protocol header doesn't follow the fragment header immediately,
the fragment header contains the protocol number of the next extension
header. When the extension header and the protocol header are sent in
a second fragment a rule like "ip6tables .. -p udp -j DROP" will never
match.

Drop fragments that are at offset 0 and don't contain the final protocol
header regardless of the ruleset, since this should not happen normally.

With help from Yasuyuki KOZAKAI <yasuyuki.kozakai@toshiba.co.jp>.

Signed-off-by: Patrick McHardy <kaber@trash.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
---

Also, done backport of ipv6_find_hdr() implementation from 2.6.32

Signed-off-by: Leonid Lisovskiy <lly.dev@gmail.com>
---

diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/include/linux/netfilter_ipv6/ip6_tables.h linuz/include/linux/netfilter_ipv6/ip6_tables.h
--- linux-2.4.37.9/include/linux/netfilter_ipv6/ip6_tables.h	2010-02-02 00:04:46.000000000 +0300
+++ linuz/include/linux/netfilter_ipv6/ip6_tables.h	2010-02-22 16:40:59.000000000 +0300
@@ -451,6 +451,9 @@ extern unsigned int ip6t_do_table(struct
 
 /* Check for an extension */
 extern int ip6t_ext_hdr(u8 nexthdr);
+/* find specified header and get offset to it */
+extern int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+			 int target, u_int16_t *fragoff);
 
 #define IP6T_ALIGN(s) (((s) + (__alignof__(struct ip6t_entry)-1)) & ~(__alignof__(struct ip6t_entry)-1))
 
diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/net/ipv6/netfilter/ip6_tables.c linuz/net/ipv6/netfilter/ip6_tables.c
--- linux-2.4.37.9/net/ipv6/netfilter/ip6_tables.c	2010-02-02 00:04:46.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6_tables.c	2010-02-22 18:35:55.000000000 +0300
@@ -154,7 +154,7 @@ ip6_packet_match(const struct sk_buff *s
 		 const char *outdev,
 		 const struct ip6t_ip6 *ip6info,
 		 unsigned int *protoff,
-		 int *fragoff)
+		 int *fragoff, int *hotdrop)
 {
 	size_t i;
 	unsigned long ret;
@@ -208,59 +208,15 @@ ip6_packet_match(const struct sk_buff *s
 
 	/* look for the desired protocol header */
 	if((ip6info->flags & IP6T_F_PROTO)) {
-		u_int8_t currenthdr = ipv6->nexthdr;
-		struct ipv6_opt_hdr *hdrptr;
-		u_int16_t ptr;		/* Header offset in skb */
-		u_int16_t hdrlen;	/* Header */
-		u_int16_t foff = 0;
-
-		ptr = IPV6_HDR_LEN;
-
-		while (ip6t_ext_hdr(currenthdr)) {
-	                /* Is there enough space for the next ext header? */
-	                if (skb->len - ptr < IPV6_OPTHDR_LEN)
-	                        return 0;
-
-			/* NONE or ESP: there isn't protocol part */
-			/* If we want to count these packets in '-p all',
-			 * we will change the return 0 to 1*/
-			if ((currenthdr == IPPROTO_NONE) || 
-				(currenthdr == IPPROTO_ESP))
-				break;
-
-	                hdrptr = (struct ipv6_opt_hdr *)(skb->data + ptr);
+		int currenthdr;
+		u_int16_t foff;
 
-			/* Size calculation */
-	                if (currenthdr == IPPROTO_FRAGMENT) {
-				unsigned int foff_off;
-
-				foff_off = ptr + offsetof(struct frag_hdr,
-							  frag_off);
-				if (skb->len - foff_off < sizeof(foff))
-					return 0;
-
-				foff = ntohs(*(u_int16_t *)(skb->data
-							    + foff_off))
-				       & ~0x7;
-	                        hdrlen = 8;
-	                } else if (currenthdr == IPPROTO_AH)
-	                        hdrlen = (hdrptr->hdrlen+2)<<2;
-	                else
-	                        hdrlen = ipv6_optlen(hdrptr);
-
-			currenthdr = hdrptr->nexthdr;
-	                ptr += hdrlen;
-			/* ptr is too large */
-	                if ( ptr > skb->len ) 
-				return 0;
-			if (foff) {
-				if (ip6t_ext_hdr(currenthdr))
-					return 0;
-				break;
-			}
+		currenthdr = ipv6_find_hdr(skb, protoff, -1, &foff);
+		if (currenthdr < 0) {
+			if (foff == 0)
+				*hotdrop = 1;
+			return 0;
 		}
-
-		*protoff = ptr;
 		*fragoff = foff;
 
 		/* currenthdr contains the protocol header */
@@ -398,7 +354,7 @@ ip6t_do_table(struct sk_buff **pskb,
 		IP_NF_ASSERT(back);
 		(*pskb)->nfcache |= e->nfcache;
 		if (ip6_packet_match(*pskb, indev, outdev, &e->ipv6,
-				     &protoff, &offset)) {
+				     &protoff, &offset, &hotdrop)) {
 			struct ip6t_entry_target *t;
 
 			if (IP6T_MATCH_ITERATE(e, do_match,
@@ -1927,6 +1883,87 @@ static void __exit fini(void)
 #endif
 }
 
+/*
+ * find the offset to specified header or the protocol number of last header
+ * if target < 0. "last header" is transport protocol header, ESP, or
+ * "No next header".
+ *
+ * If target header is found, its offset is set in *offset and return protocol
+ * number. Otherwise, return -1.
+ *
+ * If the first fragment doesn't contain the final protocol header or
+ * NEXTHDR_NONE it is considered invalid.
+ *
+ * Note that non-1st fragment is special case that "the protocol number
+ * of last header" is "next header" field in Fragment header. In this case,
+ * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
+ * isn't NULL.
+ *
+ */
+int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+		  int target, unsigned short *fragoff)
+{
+	unsigned int start = IPV6_HDR_LEN;
+	u8 nexthdr = skb->nh.ipv6h->nexthdr;
+	unsigned int len = skb->len - start;
+
+	if (fragoff)
+		*fragoff = 0;
+
+	while (nexthdr != target) {
+		struct ipv6_opt_hdr *hp;
+		unsigned int hdrlen;
+
+		if ((!ip6t_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {
+			if (target < 0)
+				break;
+			return -ENOENT;
+		}
+
+		/* Is there enough space for the next ext header? */
+                if (len < IPV6_OPTHDR_LEN)
+			return -EBADMSG;
+
+		hp = (struct ipv6_opt_hdr *)(skb->data + start);
+
+		/* Size calculation */
+		if (nexthdr == NEXTHDR_FRAGMENT) {
+			unsigned short _frag_off;
+			unsigned int foff_off;
+
+			foff_off = start + offsetof(struct frag_hdr, frag_off);
+
+			if (skb->len - foff_off < sizeof(_frag_off))
+				return -EBADMSG;
+
+			_frag_off = ntohs(*(u_int16_t *)(skb->data
+							 + foff_off))
+				    & ~0x7;
+			if (_frag_off) {
+				if (target < 0 &&
+				    ((!ip6t_ext_hdr(hp->nexthdr)) ||
+				     hp->nexthdr == NEXTHDR_NONE)) {
+					if (fragoff)
+						*fragoff = _frag_off;
+					return hp->nexthdr;
+				}
+				return -ENOENT;
+			}
+			hdrlen = 8;
+		} else if (nexthdr == NEXTHDR_AUTH)
+			hdrlen = (hp->hdrlen + 2) << 2;
+		else
+			hdrlen = ipv6_optlen(hp);
+
+		nexthdr = hp->nexthdr;
+		len -= hdrlen;
+		start += hdrlen;
+	}
+
+	*offset = start;
+	return nexthdr;
+}
+
 EXPORT_SYMBOL(ip6t_register_table);
 EXPORT_SYMBOL(ip6t_unregister_table);
 EXPORT_SYMBOL(ip6t_do_table);
@@ -1936,6 +1973,7 @@ EXPORT_SYMBOL(ip6t_unregister_match);
 EXPORT_SYMBOL(ip6t_register_target);
 EXPORT_SYMBOL(ip6t_unregister_target);
 EXPORT_SYMBOL(ip6t_ext_hdr);
+EXPORT_SYMBOL(ipv6_find_hdr);
 
 module_init(init);
 module_exit(fini);
diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/net/ipv6/netfilter/ip6t_ah.c linuz/net/ipv6/netfilter/ip6t_ah.c
--- linux-2.4.37.9/net/ipv6/netfilter/ip6t_ah.c	2010-02-02 00:04:46.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6t_ah.c	2010-02-22 17:02:04.000000000 +0300
@@ -51,91 +51,25 @@ match(const struct sk_buff *skb,
 {
        struct ahhdr *ah = NULL;
        const struct ip6t_ah *ahinfo = matchinfo;
-       unsigned int temp;
-       int len;
-       u8 nexthdr;
        unsigned int ptr;
-       unsigned int hdrlen = 0;
+       unsigned int hdrlen;
+       int err;
 
        /*DEBUGP("IPv6 AH entered\n");*/
        /* if (opt->auth == 0) return 0;
        * It does not filled on output */
 
-       /* type of the 1st exthdr */
-       nexthdr = skb->nh.ipv6h->nexthdr;
-       /* pointer to the 1st exthdr */
-       ptr = sizeof(struct ipv6hdr);
-       /* available length */
-       len = skb->len - ptr;
-       temp = 0;
-
-        while (ip6t_ext_hdr(nexthdr)) {
-               struct ipv6_opt_hdr *hdr;
-
-              DEBUGP("ipv6_ah header iteration \n");
-
-              /* Is there enough space for the next ext header? */
-                if (len < (int)sizeof(struct ipv6_opt_hdr))
-                        return 0;
-              /* No more exthdr -> evaluate */
-                if (nexthdr == NEXTHDR_NONE) {
-                     break;
-              }
-              /* ESP -> evaluate */
-                if (nexthdr == NEXTHDR_ESP) {
-                     break;
-              }
-
-              hdr=(struct ipv6_opt_hdr *)skb->data+ptr;
-
-              /* Calculate the header length */
-                if (nexthdr == NEXTHDR_FRAGMENT) {
-                        hdrlen = 8;
-                } else if (nexthdr == NEXTHDR_AUTH)
-                        hdrlen = (hdr->hdrlen+2)<<2;
-                else
-                        hdrlen = ipv6_optlen(hdr);
-
-              /* AH -> evaluate */
-                if (nexthdr == NEXTHDR_AUTH) {
-                     temp |= MASK_AH;
-                     break;
-              }
-
-
-              /* set the flag */
-              switch (nexthdr){
-                     case NEXTHDR_HOP:
-                     case NEXTHDR_ROUTING:
-                     case NEXTHDR_FRAGMENT:
-                     case NEXTHDR_AUTH:
-                     case NEXTHDR_DEST:
-                            break;
-                     default:
-                            DEBUGP("ipv6_ah match: unknown nextheader %u\n",nexthdr);
-                            return 0;
-                            break;
-              }
-
-                nexthdr = hdr->nexthdr;
-                len -= hdrlen;
-                ptr += hdrlen;
-		if ( ptr > skb->len ) {
-			DEBUGP("ipv6_ah: new pointer too large! \n");
-			break;
-		}
-        }
-
-       /* AH header not found */
-       if ( temp != MASK_AH ) return 0;
-
-       if (len < (int)sizeof(struct ahhdr)){
-	       *hotdrop = 1;
+       err = ipv6_find_hdr(skb, &ptr, NEXTHDR_AUTH, NULL);
+       if (err < 0) {
+		if (err != -ENOENT)
+			*hotdrop = 1;
        		return 0;
        }
 
        ah = (struct ahhdr *) (skb->data + ptr);
 
+       hdrlen = (ah->hdrlen + 2) << 2;
+
        DEBUGP("IPv6 AH LEN %u %u ", hdrlen, ah->hdrlen);
        DEBUGP("RES %04X ", ah->reserved);
        DEBUGP("SPI %u %08X\n", ntohl(ah->spi), ntohl(ah->spi));
diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/net/ipv6/netfilter/ip6t_frag.c linuz/net/ipv6/netfilter/ip6t_frag.c
--- linux-2.4.37.9/net/ipv6/netfilter/ip6t_frag.c	2010-02-02 00:04:46.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6t_frag.c	2010-02-22 16:49:16.000000000 +0300
@@ -46,83 +46,14 @@ match(const struct sk_buff *skb,
 {
        struct frag_hdr *frag = NULL;
        const struct ip6t_frag *fraginfo = matchinfo;
-       unsigned int temp;
-       int len;
-       u8 nexthdr;
        unsigned int ptr;
+       int err;
-       unsigned int hdrlen = 0;
 
-       /* type of the 1st exthdr */
-       nexthdr = skb->nh.ipv6h->nexthdr;
-       /* pointer to the 1st exthdr */
-       ptr = sizeof(struct ipv6hdr);
-       /* available length */
-       len = skb->len - ptr;
-       temp = 0;
-
-        while (ip6t_ext_hdr(nexthdr)) {
-               struct ipv6_opt_hdr *hdr;
-
-              DEBUGP("ipv6_frag header iteration \n");
-
-              /* Is there enough space for the next ext header? */
-                if (len < (int)sizeof(struct ipv6_opt_hdr))
-                        return 0;
-              /* No more exthdr -> evaluate */
-                if (nexthdr == NEXTHDR_NONE) {
-                     break;
-              }
-              /* ESP -> evaluate */
-                if (nexthdr == NEXTHDR_ESP) {
-                     break;
-              }
-
-              hdr=(struct ipv6_opt_hdr *)(skb->data+ptr);
-
-              /* Calculate the header length */
-                if (nexthdr == NEXTHDR_FRAGMENT) {
-                        hdrlen = 8;
-                } else if (nexthdr == NEXTHDR_AUTH)
-                        hdrlen = (hdr->hdrlen+2)<<2;
-                else
-                        hdrlen = ipv6_optlen(hdr);
-
-              /* FRAG -> evaluate */
-                if (nexthdr == NEXTHDR_FRAGMENT) {
-                     temp |= MASK_FRAGMENT;
-                     break;
-              }
-
-
-              /* set the flag */
-              switch (nexthdr){
-                     case NEXTHDR_HOP:
-                     case NEXTHDR_ROUTING:
-                     case NEXTHDR_FRAGMENT:
-                     case NEXTHDR_AUTH:
-                     case NEXTHDR_DEST:
-                            break;
-                     default:
-                            DEBUGP("ipv6_frag match: unknown nextheader %u\n",nexthdr);
-                            return 0;
-                            break;
-              }
-
-                nexthdr = hdr->nexthdr;
-                len -= hdrlen;
-                ptr += hdrlen;
-		if ( ptr > skb->len ) {
-			DEBUGP("ipv6_frag: new pointer too large! \n");
-			break;
-		}
-        }
-
-       /* FRAG header not found */
-       if ( temp != MASK_FRAGMENT ) return 0;
-
-       if (len < sizeof(struct frag_hdr)){
-	       *hotdrop = 1;
-       		return 0;
+       err = ipv6_find_hdr(skb, &ptr, NEXTHDR_FRAGMENT, NULL);
+       if (err < 0) {
+		if (err != -ENOENT)
+			*hotdrop = 1;
+		return 0;
        }
 
        frag = (struct frag_hdr *) (skb->data + ptr);
diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/net/ipv6/netfilter/ip6t_hbh.c linuz/net/ipv6/netfilter/ip6t_hbh.c
--- linux-2.4.37.9/net/ipv6/netfilter/ip6t_hbh.c	2010-02-02 00:04:46.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6t_hbh.c	2010-02-22 17:10:28.000000000 +0300
@@ -57,103 +57,32 @@ match(const struct sk_buff *skb,
        struct ipv6_opt_hdr *optsh = NULL;
        const struct ip6t_opts *optinfo = matchinfo;
        unsigned int temp;
-       unsigned int len;
-       u8 nexthdr;
        unsigned int ptr;
        unsigned int hdrlen = 0;
        unsigned int ret = 0;
        u8 *opttype = NULL;
        unsigned int optlen;
+       int err;
        
-       /* type of the 1st exthdr */
-       nexthdr = skb->nh.ipv6h->nexthdr;
-       /* pointer to the 1st exthdr */
-       ptr = sizeof(struct ipv6hdr);
-       /* available length */
-       len = skb->len - ptr;
-       temp = 0;
-
-        while (ip6t_ext_hdr(nexthdr)) {
-               struct ipv6_opt_hdr *hdr;
-
-              DEBUGP("ipv6_opts header iteration \n");
-
-              /* Is there enough space for the next ext header? */
-                if (len < (int)sizeof(struct ipv6_opt_hdr))
-                        return 0;
-              /* No more exthdr -> evaluate */
-                if (nexthdr == NEXTHDR_NONE) {
-                     break;
-              }
-              /* ESP -> evaluate */
-                if (nexthdr == NEXTHDR_ESP) {
-                     break;
-              }
-
-	      hdr = (void *)(skb->data + ptr);
-
-              /* Calculate the header length */
-                if (nexthdr == NEXTHDR_FRAGMENT) {
-                        hdrlen = 8;
-                } else if (nexthdr == NEXTHDR_AUTH)
-                        hdrlen = (hdr->hdrlen+2)<<2;
-                else
-                        hdrlen = ipv6_optlen(hdr);
-
-              /* OPTS -> evaluate */
 #if HOPBYHOP
-                if (nexthdr == NEXTHDR_HOP) {
-                     temp |= MASK_HOPOPTS;
+       err = ipv6_find_hdr(skb, &ptr, NEXTHDR_HOP, NULL);
 #else
-                if (nexthdr == NEXTHDR_DEST) {
-                     temp |= MASK_DSTOPTS;
+       err = ipv6_find_hdr(skb, &ptr, NEXTHDR_DEST, NULL);
 #endif
-                     break;
-              }
-
-
-              /* set the flag */
-              switch (nexthdr){
-                     case NEXTHDR_HOP:
-                     case NEXTHDR_ROUTING:
-                     case NEXTHDR_FRAGMENT:
-                     case NEXTHDR_AUTH:
-                     case NEXTHDR_DEST:
-                            break;
-                     default:
-                            DEBUGP("ipv6_opts match: unknown nextheader %u\n",nexthdr);
-                            return 0;
-                            break;
-              }
-
-                nexthdr = hdr->nexthdr;
-                len -= hdrlen;
-                ptr += hdrlen;
-		if ( ptr > skb->len ) {
-			DEBUGP("ipv6_opts: new pointer is too large! \n");
-			break;
-		}
-        }
-
-       /* OPTIONS header not found */
-#if HOPBYHOP
-       if ( temp != MASK_HOPOPTS ) return 0;
-#else
-       if ( temp != MASK_DSTOPTS ) return 0;
-#endif
-
-       if (len < (int)sizeof(struct ipv6_opt_hdr)){
-	       *hotdrop = 1;
-       		return 0;
-       }
-
-       if (len < hdrlen){
-	       /* Packet smaller than it's length field */
+       if (err < 0) {
+		if (err != -ENOENT)
+			*hotdrop = 1;
        		return 0;
        }
 
        optsh = (void *)(skb->data + ptr);
 
+       hdrlen = ipv6_optlen(optsh);
+       if (skb->len - ptr < hdrlen) {
+		/* Packet smaller than it's length field */
+		return 0;
+       }
+
        DEBUGP("IPv6 OPTS LEN %u %u ", hdrlen, optsh->hdrlen);
 
        DEBUGP("len %02X %04X %02X ",
diff '-x.*' '-x*.o' -urBp linux-2.4.37.9/net/ipv6/netfilter/ip6t_rt.c linuz/net/ipv6/netfilter/ip6t_rt.c
--- linux-2.4.37.9/net/ipv6/netfilter/ip6t_rt.c	2010-02-02 00:04:46.000000000 +0300
+++ linuz/net/ipv6/netfilter/ip6t_rt.c	2010-02-22 16:58:09.000000000 +0300
@@ -48,86 +48,17 @@ match(const struct sk_buff *skb,
        const struct ip6t_rt *rtinfo = matchinfo;
        unsigned int temp;
        unsigned int len;
-       u8 nexthdr;
        unsigned int ptr;
        unsigned int hdrlen = 0;
        unsigned int ret = 0;
+       int err;
 
-       /* type of the 1st exthdr */
-       nexthdr = skb->nh.ipv6h->nexthdr;
-       /* pointer to the 1st exthdr */
-       ptr = sizeof(struct ipv6hdr);
-       /* available length */
-       len = skb->len - ptr;
        temp = 0;
 
-        while (ip6t_ext_hdr(nexthdr)) {
-               struct ipv6_opt_hdr *hdr;
-
-              DEBUGP("ipv6_rt header iteration \n");
-
-              /* Is there enough space for the next ext header? */
-                if (len < (int)sizeof(struct ipv6_opt_hdr))
-                        return 0;
-              /* No more exthdr -> evaluate */
-                if (nexthdr == NEXTHDR_NONE) {
-                     break;
-              }
-              /* ESP -> evaluate */
-                if (nexthdr == NEXTHDR_ESP) {
-                     break;
-              }
-
-              hdr=(struct ipv6_opt_hdr *)(skb->data+ptr);
-
-              /* Calculate the header length */
-                if (nexthdr == NEXTHDR_FRAGMENT) {
-                        hdrlen = 8;
-                } else if (nexthdr == NEXTHDR_AUTH)
-                        hdrlen = (hdr->hdrlen+2)<<2;
-                else
-                        hdrlen = ipv6_optlen(hdr);
-
-              /* ROUTING -> evaluate */
-                if (nexthdr == NEXTHDR_ROUTING) {
-                     temp |= MASK_ROUTING;
-                     break;
-              }
-
-
-              /* set the flag */
-              switch (nexthdr){
-                     case NEXTHDR_HOP:
-                     case NEXTHDR_ROUTING:
-                     case NEXTHDR_FRAGMENT:
-                     case NEXTHDR_AUTH:
-                     case NEXTHDR_DEST:
-                            break;
-                     default:
-                            DEBUGP("ipv6_rt match: unknown nextheader %u\n",nexthdr);
-                            return 0;
-                            break;
-              }
-
-                nexthdr = hdr->nexthdr;
-                len -= hdrlen;
-                ptr += hdrlen;
-		if ( ptr > skb->len ) {
-			DEBUGP("ipv6_rt: new pointer is too large! \n");
-			break;
-		}
-        }
-
-       /* ROUTING header not found */
-       if ( temp != MASK_ROUTING ) return 0;
-
-       if (len < (int)sizeof(struct ipv6_rt_hdr)){
-	       *hotdrop = 1;
-       		return 0;
-       }
-
-       if (len < hdrlen){
-	       /* Pcket smaller than its length field */
+       err = ipv6_find_hdr(skb, &ptr, NEXTHDR_ROUTING, NULL);
+       if (err < 0) {
+		if (err != -ENOENT)
+			*hotdrop = 1;
        		return 0;
        }
 
