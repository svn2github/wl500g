Patch from RHEL3 63.EL - NFS performance enhancements and miscellaneous fixes

 fs/nfs/dir.c      |   55 +++++++++++++++++++++++++++++++++++++-----------------
 fs/nfs/inode.c    |   12 ++++++++---
 net/sunrpc/clnt.c |   12 ++++++++---
 3 files changed, 56 insertions(+), 23 deletions(-)

diff -urNp linux-6060/fs/nfs/dir.c linux-6065/fs/nfs/dir.c
--- linux-6060/fs/nfs/dir.c
+++ linux-6065/fs/nfs/dir.c
@@ -402,34 +402,44 @@ static int nfs_readdir(struct file *filp
 {
 	struct dentry	*dentry = filp->f_dentry;
 	struct inode	*inode = dentry->d_inode;
-	nfs_readdir_descriptor_t my_desc,
-			*desc = &my_desc;
-	struct nfs_entry my_entry;
-	struct nfs_fh	fh;
-	struct nfs_fattr fattr;
+	nfs_readdir_descriptor_t *desc;
+	struct nfs_entry *my_entry;
+	struct nfs_fh	*fh;
+	struct nfs_fattr *fattr;
 	long		res;
+	void *mem;
+	int error, memlen = sizeof(struct nfs_fh) +
+		sizeof(struct nfs_fattr) + sizeof(struct nfs_entry) +
+		sizeof(nfs_readdir_descriptor_t);
 
 	res = nfs_revalidate_inode(NFS_SERVER(inode), inode);
 	if (res < 0)
 		return res;
 
+	if ((mem = kmalloc(memlen, GFP_USER)) == NULL)
+		return -ENOMEM;
+	memset(mem, 0, memlen);
+	fattr = (struct nfs_fattr *)mem;
+	my_entry = (struct nfs_entry *)(mem + sizeof(struct nfs_fattr));
+	desc = (nfs_readdir_descriptor_t *)(mem + sizeof(struct nfs_fattr) +
+		sizeof(struct nfs_entry));
+	fh = (struct nfs_fh *)(mem + sizeof(struct nfs_fattr) +
+		sizeof(struct nfs_entry) + sizeof(nfs_readdir_descriptor_t));
+
 	/*
 	 * filp->f_pos points to the file offset in the page cache.
 	 * but if the cache has meanwhile been zapped, we need to
 	 * read from the last dirent to revalidate f_pos
 	 * itself.
 	 */
-	memset(desc, 0, sizeof(*desc));
 	desc->file = filp;
 	desc->target = filp->f_pos;
 	desc->decode = NFS_PROTO(inode)->decode_dirent;
 	desc->plus = NFS_USE_READDIRPLUS(inode);
 
-	my_entry.cookie = my_entry.prev_cookie = 0;
-	my_entry.eof = 0;
-	my_entry.fh = &fh;
-	my_entry.fattr = &fattr;
-	desc->entry = &my_entry;
+	my_entry->fh = fh;
+	my_entry->fattr = fattr;
+	desc->entry = my_entry;
 
 	while(!desc->entry->eof) {
 		res = readdir_search_pagecache(desc);
@@ -452,8 +462,11 @@ static int nfs_readdir(struct file *filp
 			break;
 		}
 	}
-	if (desc->error < 0)
-		return desc->error;
+
+	error = desc->error;
+	kfree(mem);
+	if (error < 0)
+		return error;
 	if (res < 0)
 		return res;
 	return 0;
@@ -529,7 +542,7 @@ static int nfs_lookup_revalidate(struct 
 	struct inode *inode;
 	int error;
 	struct nfs_fh fhandle;
-	struct nfs_fattr fattr;
+	struct nfs_fattr *fattr = NULL;
 
 	lock_kernel();
 	dir = dentry->d_parent->d_inode;
@@ -554,7 +567,11 @@ static int nfs_lookup_revalidate(struct 
 		goto out_valid;
 	}
 
-	error = nfs_cached_lookup(dir, dentry, &fhandle, &fattr);
+	fattr = kmalloc(sizeof(*fattr), GFP_KERNEL);
+	if (fattr == NULL)
+		goto out_bad;
+
+	error = nfs_cached_lookup(dir, dentry, &fhandle, fattr);
 	if (!error) {
 		if (memcmp(NFS_FH(inode), &fhandle, sizeof(struct nfs_fh))!= 0)
 			goto out_bad;
@@ -566,18 +583,20 @@ static int nfs_lookup_revalidate(struct 
 	if (NFS_STALE(inode))
 		goto out_bad;
 
-	error = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, &fhandle, &fattr);
+	error = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, &fhandle, fattr);
 	if (error)
 		goto out_bad;
 	if (memcmp(NFS_FH(inode), &fhandle, sizeof(struct nfs_fh))!= 0)
 		goto out_bad;
-	if ((error = nfs_refresh_inode(inode, &fattr)) != 0)
+	if ((error = nfs_refresh_inode(inode, fattr)) != 0)
 		goto out_bad;
 
  out_valid_renew:
 	nfs_renew_times(dentry);
  out_valid:
 	unlock_kernel();
+	if (fattr)
+		kfree(fattr);
 	return 1;
  out_zap_parent:
 	nfs_zap_caches(dir);
@@ -591,6 +610,8 @@ static int nfs_lookup_revalidate(struct 
 	}
 	d_drop(dentry);
 	unlock_kernel();
+	if (fattr)
+		kfree(fattr);
 	return 0;
 }
 
diff -urNp linux-6060/fs/nfs/inode.c linux-6065/fs/nfs/inode.c
--- linux-6060/fs/nfs/inode.c
+++ linux-6065/fs/nfs/inode.c
@@ -1068,7 +1068,7 @@ int
 __nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)
 {
 	int		 status = -ESTALE;
-	struct nfs_fattr fattr;
+	struct nfs_fattr *fattr = NULL;
 
 	dfprintk(PAGECACHE, "NFS: revalidating (%x/%Ld)\n",
 		inode->i_dev, (long long)NFS_FILEID(inode));
@@ -1090,7 +1090,11 @@ __nfs_revalidate_inode(struct nfs_server
 	}
 	NFS_FLAGS(inode) |= NFS_INO_REVALIDATING;
 
-	status = NFS_PROTO(inode)->getattr(inode, &fattr);
+	fattr = kmalloc(sizeof(*fattr), GFP_KERNEL);
+	if (fattr == NULL)
+		goto out;
+
+	status = NFS_PROTO(inode)->getattr(inode, fattr);
 	if (status) {
 		dfprintk(PAGECACHE, "nfs_revalidate_inode: (%x/%Ld) getattr failed, error=%d\n",
 			 inode->i_dev, (long long)NFS_FILEID(inode), status);
@@ -1102,7 +1106,7 @@ __nfs_revalidate_inode(struct nfs_server
 		goto out;
 	}
 
-	status = nfs_refresh_inode(inode, &fattr);
+	status = nfs_refresh_inode(inode, fattr);
 	if (status) {
 		dfprintk(PAGECACHE, "nfs_revalidate_inode: (%x/%Ld) refresh failed, error=%d\n",
 			 inode->i_dev, (long long)NFS_FILEID(inode), status);
@@ -1113,6 +1117,8 @@ __nfs_revalidate_inode(struct nfs_server
 
 	NFS_FLAGS(inode) &= ~NFS_INO_STALE;
 out:
+	if (fattr)
+		kfree(fattr);
 	NFS_FLAGS(inode) &= ~NFS_INO_REVALIDATING;
 	wake_up(&inode->i_wait);
  out_nowait:
diff -urNp linux-6060/net/sunrpc/clnt.c linux-6065/net/sunrpc/clnt.c
--- linux-6060/net/sunrpc/clnt.c
+++ linux-6065/net/sunrpc/clnt.c
@@ -240,7 +240,7 @@ void rpc_clnt_sigunmask(struct rpc_clnt 
  */
 int rpc_call_sync(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 {
-	struct rpc_task	my_task, *task = &my_task;
+	struct rpc_task	*task;
 	sigset_t	oldset;
 	int		status;
 
@@ -253,10 +253,15 @@ int rpc_call_sync(struct rpc_clnt *clnt,
 		flags &= ~RPC_TASK_ASYNC;
 	}
 
+	task = rpc_new_task(clnt, NULL, flags);
+	if (task == NULL) {
+		status = -ENOMEM;
+		goto out;
+	}
+
+	/* Mask signals on RPC calls _and_ GSS_AUTH upcalls */
 	rpc_clnt_sigmask(clnt, &oldset);		
 
-	/* Create/initialize a new RPC task */
-	rpc_init_task(task, clnt, NULL, flags);
 	rpc_call_setup(task, msg, 0);
 
 	/* Set up the call info struct and execute the task */
@@ -269,6 +274,7 @@ int rpc_call_sync(struct rpc_clnt *clnt,
 
 	rpc_clnt_sigunmask(clnt, &oldset);		
 
+out:
 	return status;
 }
 
