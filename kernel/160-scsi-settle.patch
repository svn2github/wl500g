With these fixes, the timings between the kernel and the hotplug agent
have all been fixed.  The "wait for device to settle" is now all done
in the kernel, where it should have been all along.  And it's
accuraet--not merely a long constant worst-case delay.  It doesn't wait any
longer than it needs to.  Fast device = small delay.  Slow device =
long delay.

ray123

--- tomato-srcs/v41/linux/drivers/scsi/scsi.c	2009-11-29 18:30:45.000000000 -0600
+++ linux/drivers/scsi/scsi.c	2009-12-08 13:54:39.000000000 -0600
@@ -1603,6 +1603,7 @@ int scsi_add_single_device(struct Scsi_Host *shpnt,
 		}
 	}
 	if (scd) {
+		scd->online = TRUE;  /* Say that it's back online. */
 		up(&scsi_host_internals_lock);
 		return -ENOSYS;
 	}
@@ -1666,6 +1667,7 @@ int scsi_remove_single_device(struct Scsi_Host *shpnt,
 	/* See if the specified device is busy.  Doesn't this race with
 	 * sd_open(), sd_release() and similar?  Why don't they lock
 	 * things when they increment/decrement the access_count? */
+        scd->online = FALSE;        /* Don't attempt to spin it up or read capacity---it's gone! Or to read from it. */
 	if (scd->access_count) {
 		up(&scsi_host_internals_lock);
 		return -EBUSY;
--- tomato-srcs/v41/linux/drivers/scsi/sd.c	2009-11-29 18:30:45.000000000 -0600
+++ linux/drivers/scsi/sd.c	2009-12-08 11:27:03.000000000 -0600
@@ -42,6 +42,7 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/delay.h>
 
 #include <linux/smp.h>
 
@@ -813,6 +812,22 @@
 	return retval;
 }
 
+/** scsi_status_is_good - check the status return.
+ *  Taken from 2.6
+ *
+ * This returns true for known good conditions that may be treated as
+ * command completed normally
+ */
+static inline int scsi_status_is_good(int status)
+{
+        status &= 0xfe;
+        return ((status == SAM_STAT_GOOD) ||
+                (status == SAM_STAT_INTERMEDIATE) ||
+                (status == SAM_STAT_INTERMEDIATE_CONDITION_MET) ||
+                /* FIXME: this is obsolete in SAM-3 */
+                (status == SAM_STAT_COMMAND_TERMINATED));
+}
+
 static int sd_init_onedisk(int i)
 {
 	unsigned char cmd[10];
@@ -823,6 +838,7 @@ static int sd_init_onedisk(int i)
 	unsigned int the_result;
 	int sector_size;
 	Scsi_Request *SRpnt;
+	int tur_retry_cnt;
 
 	/*
 	 * Get the name of the disk, in case we need to log it somewhere.
@@ -837,11 +853,12 @@ static int sd_init_onedisk(int i)
 		return i;
 
 	/*
-	 * We need to retry the READ_CAPACITY because a UNIT_ATTENTION is
+	 * We need to retry the READ_CAPACITY because a UNIT_ATTENTION (0x06) is
 	 * considered a fatal error, and many devices report such an error
 	 * just after a scsi bus reset.
 	 */
 
+	printk("%s: Waiting for disc %d to settle.\n", nbuff, i);
 	SRpnt = scsi_allocate_request(rscsi_disks[i].device);
 	if (!SRpnt) {
 		printk(KERN_WARNING "(sd_init_onedisk:) Request allocation failure.\n");
@@ -856,12 +873,18 @@ static int sd_init_onedisk(int i)
 	}
 
 	spintime = 0;
+	tur_retry_cnt = 40;
 
 	/* Spin up drives, as required.  Only do this at boot time */
 	/* Spinup needs to be done for module loads too. */
+	/* Some USB units have slow firmware and take a long time to become ready.
+	 * This is particularly the case for older devices or those with several
+	 * luns, such as camera card readers.
+	 * The worst I've seen for a valid disk is NOT_READY (0x02) for 300 msec, then
+	 * UNIT_ATTENTION (0x06) once or twice, then success.
+	 * Keep trying for 2 seconds with 50 msec delay between checks. */
 	do {
-		retries = 0;
-
+		retries = tur_retry_cnt;
 		do {
 			cmd[0] = TEST_UNIT_READY;
 			cmd[1] = (rscsi_disks[i].device->scsi_level <= SCSI_2) ?
@@ -876,18 +899,19 @@ static int sd_init_onedisk(int i)
 				0/*512*/, SD_TIMEOUT, MAX_RETRIES);
 
 			the_result = SRpnt->sr_result;
-			retries++;
-		} while (retries < 3
-			 && (the_result !=0
+			if (the_result == 0 || --retries < 0)
+			   break;
+			msleep(50);
+		} while (!scsi_status_is_good(the_result)
 			     || ((driver_byte(the_result) & DRIVER_SENSE)
-				 && SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION)));
+				 && SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION));
 
 		/*
 		 * If the drive has indicated to us that it doesn't have
 		 * any media in it, don't bother with any of the rest of
 		 * this crap.
 		 */
-		if( the_result != 0
+		if (scsi_status_is_good(the_result)
 		    && ((driver_byte(the_result) & DRIVER_SENSE) != 0)
 		    && SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION
 		    && SRpnt->sr_sense_buffer[12] == 0x3A ) {
@@ -921,6 +945,7 @@ static int sd_init_onedisk(int i)
 		    SRpnt->sr_sense_buffer[12] == 4 /* not ready */ &&
 		    SRpnt->sr_sense_buffer[13] == 3) {
 			break;		/* manual intervention required */
+
 		/* Look for non-removable devices that return NOT_READY.
 		 * Issue command to spin up drive for these cases. */
 		} else if (the_result && !rscsi_disks[i].device->removable &&
@@ -944,12 +969,9 @@ static int sd_init_onedisk(int i)
 				spintime_value = jiffies;
 			}
 			spintime = 1;
+			tur_retry_cnt = 0;
 			time1 = HZ;
-			/* Wait 1 second for next try */
-			do {
-				current->state = TASK_UNINTERRUPTIBLE;
-				time1 = schedule_timeout(time1);
-			} while(time1);
+			ssleep(1);	/* Wait 1 second for next try */
 			printk(".");
 		} else {
 			/* we don't understand the sense code, so it's
@@ -961,14 +983,14 @@ static int sd_init_onedisk(int i)
 			break;
 		}
 	} while (the_result && spintime &&
-		 time_after(spintime_value + 100 * HZ, jiffies));
+		 time_after(spintime_value + 15 * HZ, jiffies));
 	if (spintime) {
 		if (the_result)
 			printk("not responding...\n");
 		else
 			printk("ready\n");
 	}
-	retries = 3;
+	retries = 5;
 	do {
 		cmd[0] = READ_CAPACITY;
 		cmd[1] = (rscsi_disks[i].device->scsi_level <= SCSI_2) ?
@@ -984,9 +1006,10 @@ static int sd_init_onedisk(int i)
 			    8, SD_TIMEOUT, MAX_RETRIES);
 
 		the_result = SRpnt->sr_result;
-		retries--;
-
-	} while (the_result && retries);
+		if (the_result == 0 || --retries < 0)
+		   break;
+		msleep(100);
+	} while (!scsi_status_is_good(the_result));
 
 	/*
 	 * The SCSI standard says:
