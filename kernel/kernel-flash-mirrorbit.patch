 ASUS/Broadcom mtd chips minipatch from GPL 1.9.8.5 WL500W
  originally for kernel 2.4.20, modified against 2.4.36
  
--- linuz/drivers/mtd/chips/cfi_cmdset_0001.c	2001-10-05 02:14:59.000000000 +0400
+++ linux/drivers/mtd/chips/cfi_cmdset_0001.c	2004-12-03 05:56:56.000000000 +0300
@@ -1721,6 +1721,8 @@
 			chip->state = chip->oldstate;
 			wake_up(&chip->wq);
 		}
+		/* make absolutely sure that chip is out of lock/suspend state */
+		cfi_write(map, CMD(0xFF), 0);
 		spin_unlock(chip->mutex);
 	}
 }
@@ -1839,6 +1841,7 @@
 	}
 	
 	/* Done and happy. */
+	cfi_write(map, CMD(0x70), adr);
 	chip->state = FL_STATUS;
 	DISABLE_VPP(map);
 	wake_up(&chip->wq);
--- linuz/drivers/mtd/chips/cfi_cmdset_0002.c	2007-04-29 20:41:24.667451024 +0400
+++ linux/drivers/mtd/chips/cfi_cmdset_0002.c	2007-04-29 20:37:17.475029984 +0400
@@ -347,9 +346,22 @@
 
 	cfi_write(map, datum, adr);
 
+/*
+bhupesh.
+Disabled the first timeout wait.
+This was probably done this way to find out the typical timeout for the flash part and
+then wait for that amount for the first time.  If the chip was still not programmed,
+then we wait for a little longer in the for loop below.  The for loop is long enough
+for most of the chips and hence, there is no need for this extra waiting.
+This modification was done specifially to overcome the long timeout (128us) for the
+AM29LV641M mirror bit parts.  Ideally, there should be a driver that supports
+the buffere writes for these parts.
+*/
+#if 0 /* BCM94780 */
 	cfi_spin_unlock(chip->mutex);
 	cfi_udelay(chip->word_write_time);
 	cfi_spin_lock(chip->mutex);
+#endif
 
 	/* Polling toggle bits instead of reading back many times
 	   This ensures that write operation is really completed,
@@ -539,10 +554,10 @@
 			oldstatus = cfi_read(map, adr);
 			status = cfi_read(map, adr);
 		    
-			if ( (oldstatus & 0x00FF) == (status & 0x00FF) ) {
-				printk(KERN_WARNING "Warning: DQ5 raised while program operation was in progress, however operation completed OK\n" );
-			} else { 
-				/* DQ5 is active so we can do a reset and stop the erase */
+			if ( (oldstatus & 0x00FF) != (status & 0x00FF) ) {
+//				printk(KERN_WARNING "Warning: DQ5 raised while program operation was in progress, however operation completed OK\n" );
+//			} else { 
+				/* DQ5 is active and DQ6 is toggling too, so we should do a reset and stop the erase */
 				cfi_write(map, CMD(0xF0), chip->start);
 				printk(KERN_WARNING "Internal flash device timeout occurred or write operation was performed while flash was programming.\n" );
 			}
