1. Add missed urb->interval initialization for usbdevfs.

2. Add (1-shot) interrupts to usbdevfs & HCDs. Idea by Dan Streetman <ddstreet@us.ibm.com>


diff -urBp linux-2.4.37/include/linux/usb.h linux//include/linux/usb.h
--- linux-2.4.37/include/linux/usb.h	2009-08-18 20:46:28.000000000 +0400
+++ linux/include/linux/usb.h	2009-08-18 20:48:13.000000000 +0400
@@ -582,6 +582,7 @@
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
 					/* ... less overhead for QUEUE_BULK */
 #define USB_TIMEOUT_KILLED	0x1000	// only set by HCD!
+#define URB_NO_RESUBMIT		0x0200	/* don't resubmit interrupt urb */
 #define URB_NO_TRANSFER_DMA_MAP	0x0400	/* urb->transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0800	/* urb->setup_dma valid on submit */
 
diff -urBp linux-2.4.37.orig/drivers/usb/devio.c linux/drivers/usb/devio.c
--- linux-2.4.37.orig/drivers/usb/devio.c	2009-06-07 23:50:24.000000000 +0400
+++ linux/drivers/usb/devio.c	2009-06-11 22:09:36.000000000 +0400
@@ -813,11 +813,11 @@ static int proc_submiturb(struct dev_sta
 		if ((ret = checkintf(ps, intf)))
 			return ret;
 	}
+	if (!(ep_desc = usb_epnum_to_ep_desc(ps->dev, uurb.endpoint)))
+		return -ENOENT;
 	switch(uurb.type) {
 	case USBDEVFS_URB_TYPE_CONTROL:
 		if ((uurb.endpoint & ~USB_ENDPOINT_DIR_MASK) != 0) {
-			if (!(ep_desc = usb_epnum_to_ep_desc(ps->dev, uurb.endpoint)))
-				return -ENOENT;
 			if ((ep_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_CONTROL)
 				return -EINVAL;
 		}
@@ -887,6 +887,7 @@ static int proc_submiturb(struct dev_sta
 			return -EINVAL;
 		if (!access_ok((uurb.endpoint & USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb.buffer, uurb.buffer_length))
 			return -EFAULT;   
+		uurb.flags |= URB_NO_RESUBMIT;
 		break;
 
 	default:
@@ -915,6 +916,11 @@ static int proc_submiturb(struct dev_sta
 	as->urb.setup_packet = (unsigned char*)dr;
 	as->urb.start_frame = uurb.start_frame;
 	as->urb.number_of_packets = uurb.number_of_packets;
+	if (uurb.type == USBDEVFS_URB_TYPE_ISO ||
+			ps->dev->speed == USB_SPEED_HIGH)
+		as->urb.interval = 1 << min(15, ep_desc->bInterval - 1);
+	else
+		as->urb.interval = ep_desc->bInterval;
         as->urb.context = as;
         as->urb.complete = async_completed;
 	for (totlen = u = 0; u < uurb.number_of_packets; u++) {
diff -urBp linux-2.4.37.orig/drivers/usb/host/ehci-q.c linux/drivers/usb/host/ehci-q.c
--- linux-2.4.37.orig/drivers/usb/host/ehci-q.c	2009-08-16 04:00:00.000000000 +0400
+++ linux/drivers/usb/host/ehci-q.c	2009-08-18 20:56:36.000000000 +0400
@@ -261,7 +261,8 @@ ehci_urb_done (struct ehci_hcd *ehci, st
 
 #ifdef	INTR_AUTOMAGIC
 	if (resubmit && ((urb->status == -ENOENT)
-				|| (urb->status == -ECONNRESET))) {
+				|| (urb->status == -ECONNRESET)
+				|| (urb->transfer_flags & URB_NO_RESUBMIT))) {
 		usb_put_urb (resubmit);
 		resubmit = 0;
 	}
diff -urBp linux-2.4.37.orig/drivers/usb/host/uhci.c linux/drivers/usb/host/uhci.c
--- linux-2.4.37.orig/drivers/usb/host/uhci.c	2009-08-14 02:04:00.000000000 +0400
+++ linux/drivers/usb/host/uhci.c	2009-08-18 21:00:06.000000000 +0400
@@ -1656,7 +1656,7 @@ static void uhci_transfer_result(struct
 		break;
 	case PIPE_INTERRUPT:
 		/* Interrupts are an exception */
-		if (urb->interval)
+		if (urb->interval && !(URB_NO_RESUBMIT & urb->transfer_flags))
 			goto out_complete;
 
 		/* Release bandwidth for Interrupt or Isoc. transfers */
@@ -2319,6 +2319,7 @@ static void uhci_call_completion(struct
 	killed = (urb->status == -ENOENT || urb->status == -ECONNABORTED ||
 			urb->status == -ECONNRESET);
 	resubmit_interrupt = (usb_pipetype(urb->pipe) == PIPE_INTERRUPT &&
+			!(URB_NO_RESUBMIT & urb->transfer_flags) &&
 			urb->interval);
 
 	nurb = urb->next;
diff -urBp linux-2.4.37.orig/drivers/usb/host/usb-ohci.c linux/drivers/usb/host/usb-ohci.c
--- linux-2.4.37.orig/drivers/usb/host/usb-ohci.c	2009-08-14 02:04:00.000000000 +0400
+++ linux/drivers/usb/host/usb-ohci.c	2009-08-18 21:03:56.000000000 +0400
@@ -531,7 +531,8 @@ static int sohci_return_urb (struct ohci
 				usb_pipeout (urb->pipe)
 					? PCI_DMA_TODEVICE
 					: PCI_DMA_FROMDEVICE);
-			if (urb->interval) {
+			if (urb->interval &&
+				 !(URB_NO_RESUBMIT & urb->transfer_flags)) {
 				urb->complete (urb);
 
 				/* implicitly requeued */
diff -urBp linux-2.4.37.orig/drivers/usb/host/usb-uhci.c linux/drivers/usb/host/usb-uhci.c
--- linux-2.4.37.orig/drivers/usb/host/usb-uhci.c	2009-08-14 02:04:00.000000000 +0400
+++ linux/drivers/usb/host/usb-uhci.c	2009-08-18 21:16:16.000000000 +0400
@@ -2497,7 +2497,7 @@ _static int process_interrupt (uhci_t *s
 			urb->status = -EINPROGRESS;
 
 			// Recycle INT-TD if interval!=0, else mark TD as one-shot
-			if (urb->interval) {
+			if (urb->interval && !(URB_NO_RESUBMIT & urb->transfer_flags)) {
 				
 				desc->hw.td.info &= cpu_to_le32(~(1 << TD_TOKEN_TOGGLE));
 				if (status==0) {
@@ -2631,7 +2631,8 @@ _static int process_urb (uhci_t *s, stru
 		if (urb->bandwidth) {
 			if (usb_pipetype(urb->pipe)==PIPE_ISOCHRONOUS)
 				usb_release_bandwidth (urb->dev, urb, 1);
-			else if (usb_pipetype(urb->pipe)==PIPE_INTERRUPT && urb->interval)
+			else if (usb_pipetype(urb->pipe)==PIPE_INTERRUPT
+				 && urb->interval && !(URB_NO_RESUBMIT & urb->transfer_flags))
 				usb_release_bandwidth (urb->dev, urb, 0);
 		}
 
