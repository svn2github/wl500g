--- oldlinux/drivers/net/ppp_generic.c	2008-03-30 14:00:43.000000000 +0200
+++ linux/drivers/net/ppp_generic.c	2008-03-30 22:19:50.000000000 +0200
@@ -23,37 +23,39 @@
  */
 
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/devfs_fs_kernel.h>
 #include <linux/netdevice.h>
+#include <linux/inetdevice.h>
 #include <linux/poll.h>
 #include <linux/ppp_defs.h>
 #include <linux/filter.h>
 #include <linux/if_ppp.h>
 #include <linux/ppp_channel.h>
 #include <linux/ppp-comp.h>
 #include <linux/skbuff.h>
 #include <linux/rtnetlink.h>
 #include <linux/if_arp.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
 #include <linux/rwsem.h>
 #include <linux/stddef.h>
 #include <net/slhc_vj.h>
 #include <asm/atomic.h>
+#include <linux/sysctl.h>
 
 #define PPP_VERSION	"2.4.2"
 
 /*
  * Network protocols we support.
  */
 #define NP_IP	0		/* Internet Protocol V4 */
 #define NP_IPV6	1		/* Internet Protocol V6 */
 #define NP_IPX	2		/* IPX protocol */
 #define NP_AT	3		/* Appletalk protocol */
@@ -165,20 +167,24 @@
 
 /*
  * SMP locking issues:
  * Both the ppp.rlock and ppp.wlock locks protect the ppp.channels
  * list and the ppp.n_channels field, you need to take both locks
  * before you modify them.
  * The lock ordering is: channel.upl -> ppp.wlock -> ppp.rlock ->
  * channel.downl.
  */
 
+static int ppp_filter = 0;
+static ctl_table ppp_filter_root_table[];
+static struct ctl_table_header *ppp_filter_sysctl_header;
+
 /*
  * A cardmap represents a mapping from unsigned integers to pointers,
  * and provides a fast "find lowest unused number" operation.
  * It uses a broad (32-way) tree with a bitmap at each level.
  * It is designed to be space-efficient for small numbers of entries
  * and time-efficient for large numbers of entries.
  */
 #define CARDMAP_ORDER	5
 #define CARDMAP_WIDTH	(1U << CARDMAP_ORDER)
 #define CARDMAP_MASK	(CARDMAP_WIDTH - 1)
@@ -788,20 +794,23 @@
 
 	printk(KERN_INFO "PPP generic driver version " PPP_VERSION "\n");
 	err = devfs_register_chrdev(PPP_MAJOR, "ppp", &ppp_device_fops);
 	if (err)
 		printk(KERN_ERR "failed to register PPP device (%d)\n", err);
 	devfs_handle = devfs_register(NULL, "ppp", DEVFS_FL_DEFAULT,
 				      PPP_MAJOR, 0,
 				      S_IFCHR | S_IRUSR | S_IWUSR,
 				      &ppp_device_fops, NULL);
 
+	ppp_filter_sysctl_header
+		= register_sysctl_table(ppp_filter_root_table, 0);
+
 	return 0;
 }
 
 /*
  * Network interface unit routines.
  */
 static int
 ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ppp *ppp = (struct ppp *) dev->priv;
@@ -985,20 +994,32 @@
 		/* for data packets, record the time */
 		ppp->last_xmit = jiffies;
 #endif /* CONFIG_PPP_FILTER */
 	}
 
 	++ppp->stats.tx_packets;
 	ppp->stats.tx_bytes += skb->len - 2;
 
 	switch (proto) {
 	case PPP_IP:
+		if (ppp_filter &&
+		    (((struct iphdr *)(skb->data + 2))->saddr & 
+		     ((struct in_device *)(ppp->dev->ip_ptr))->ifa_list->ifa_mask)
+		    !=
+		    (((struct in_device *)(ppp->dev->ip_ptr))->ifa_list->ifa_local &
+		     ((struct in_device *)(ppp->dev->ip_ptr))->ifa_list->ifa_mask)
+		   )
+		{
+			kfree_skb(skb);
+			return;
+		}
+		
 		if (ppp->vj == 0 || (ppp->flags & SC_COMP_TCP) == 0)
 			break;
 		/* try to do VJ TCP header compression */
 		new_skb = alloc_skb(skb->len + ppp->dev->hard_header_len - 2,
 				    GFP_ATOMIC);
 		if (new_skb == 0) {
 			printk(KERN_ERR "PPP: no memory (VJ comp pkt)\n");
 			goto drop;
 		}
 		skb_reserve(new_skb, ppp->dev->hard_header_len - 2);
@@ -2557,20 +2578,21 @@
 
 static void __exit ppp_cleanup(void)
 {
 	/* should never happen */
 	if (atomic_read(&ppp_unit_count) || atomic_read(&channel_count))
 		printk(KERN_ERR "PPP: removing module but units remain!\n");
 	cardmap_destroy(&all_ppp_units);
 	if (devfs_unregister_chrdev(PPP_MAJOR, "ppp") != 0)
 		printk(KERN_ERR "PPP: failed to unregister PPP device\n");
 	devfs_unregister(devfs_handle);
+	unregister_sysctl_table(ppp_filter_sysctl_header);
 }
 
 /*
  * Cardmap implementation.
  */
 static void *cardmap_get(struct cardmap *map, unsigned int nr)
 {
 	struct cardmap *p;
 	int i;
 
@@ -2667,20 +2689,40 @@
 				p->ptr[i] = NULL;
 				continue;
 			}
 		}
 		np = p->parent;
 		kfree(p);
 	}
 	*pmap = NULL;
 }
 
+#define NET_PPP_FILTER 2091
+#define NET_PPP_FILTER_NAME "ppp_filter"
+
+static ctl_table ppp_filter_table[] = {
+	{ NET_PPP_FILTER, NET_PPP_FILTER_NAME, &ppp_filter,
+	  sizeof(ppp_filter), 0644,  NULL, proc_dointvec },
+ 	{ 0 }
+};
+
+static ctl_table ppp_filter_dir_table[] = {
+	{NET_IPV4, "ipv4", NULL, 0, 0555, ppp_filter_table, 0, 0, 0, 0, 0},
+	{ 0 }
+};
+
+static ctl_table ppp_filter_root_table[] = {
+	{CTL_NET, "net", NULL, 0, 0555, ppp_filter_dir_table, 0, 0, 0, 0, 0},
+	{ 0 }
+};
+
+
 /* Module/initialization stuff */
 
 module_init(ppp_init);
 module_exit(ppp_cleanup);
 
 EXPORT_SYMBOL(ppp_register_channel);
 EXPORT_SYMBOL(ppp_unregister_channel);
 EXPORT_SYMBOL(ppp_channel_index);
 EXPORT_SYMBOL(ppp_unit_number);
 EXPORT_SYMBOL(ppp_input);
