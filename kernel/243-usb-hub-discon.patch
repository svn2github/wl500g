Backport fix of infinite loop in khubd, occured in case of active requests
to disconnected hub (due to driver unload or hardware lost).

diff -urBp linux-2.4.37/drivers/usb/hub.h linux/drivers/usb/hub.h
--- linux-2.4.37/drivers/usb/hub.h	2009-08-14 02:04:00.000000000 +0400
+++ linux/drivers/usb/hub.h	2009-08-16 22:01:18.000000000 +0400
@@ -144,6 +144,8 @@ struct usb_hub {
 
 	struct semaphore khubd_sem;
 	struct usb_tt		tt;		/* Transaction Translator */
+
+	unsigned	disconnected:1;
 };
 
 #endif /* __LINUX_HUB_H */
diff -urBp linux-2.4.37/drivers/usb/hub.c linux/drivers/usb/hub.c
--- linux-2.4.37/drivers/usb/hub.c	2009-08-14 02:04:00.000000000 +0400
+++ linux/drivers/usb/hub.c	2009-08-16 22:12:48.000000000 +0400
@@ -132,7 +132,7 @@ static void hub_irq(struct urb *urb)
 
 	/* Something happened, let khubd figure it out */
 	spin_lock_irqsave(&hub_event_lock, flags);
-	if (list_empty(&hub->event_list)) {
+	if (!hub->disconnected && list_empty(&hub->event_list)) {
 		list_add(&hub->event_list, &hub_event_list);
 		wake_up(&khubd_wait);
 	}
@@ -425,6 +425,7 @@ static void hub_disconnect(struct usb_de
 	/* Delete it and then reset it */
 	list_del(&hub->event_list);
 	INIT_LIST_HEAD(&hub->event_list);
+	hub->disconnected = 1;
 	list_del(&hub->hub_list);
 	INIT_LIST_HEAD(&hub->hub_list);
 
@@ -839,6 +839,9 @@ static void usb_hub_events(void)
 		down(&hub->khubd_sem); /* never blocks, we were on list */
 		spin_unlock_irqrestore(&hub_event_lock, flags);
 
+		if (unlikely(hub->disconnected))
+			goto loop;
+
 		if (hub->error) {
 			dbg("resetting hub %d for error %d", dev->devnum, hub->error);
 
@@ -920,6 +920,7 @@ static void usb_hub_events(void)
 			}
 			kfree(hubsts);
 		}
+loop:
 		up(&hub->khubd_sem);
         } /* end while (1) */
 
@@ -1003,7 +1003,8 @@ void usb_hub_cleanup(void)
 	/* Kill the thread */
 	ret = kill_proc(khubd_pid, SIGTERM, 1);
 
-	wait_for_completion(&khubd_exited);
+	if (ret != -ESRCH)
+		wait_for_completion(&khubd_exited);
 
 	/*
 	 * Hub resources are freed for us by usb_deregister. It calls
