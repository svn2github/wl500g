Backport from 2.6 upstream [NET]: Fix bugs in "Whether sock accept queue is full"

 8488df894d05d6fa41c2bd298c335f944bb0e401 [NET]: Fix bugs in "Whether sock accept queue is full" checking
 248f06726e866942b3d8ca8f411f9067713b7ff8 [AF_UNIX]: Test against sk_max_ack_backlog properly.

---
 include/net/tcp.h  |    2 +-
 net/unix/af_unix.c |    6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/include/net/tcp.h b/include/net/tcp.h
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1745,7 +1745,7 @@ static inline void tcp_acceptq_added(struct sock *sk)
 
 static inline int tcp_acceptq_is_full(struct sock *sk)
 {
-	return sk->ack_backlog > sk->max_ack_backlog;
+	return sk->ack_backlog >= sk->max_ack_backlog;
 }
 
 static inline void tcp_acceptq_queue(struct sock *sk, struct open_request *req,
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -832,7 +832,7 @@ static long unix_wait_for_peer(unix_sock
 
 	sched = (!other->dead &&
 		 !(other->shutdown&RCV_SHUTDOWN) &&
-		 skb_queue_len(&other->receive_queue) > other->max_ack_backlog);
+		 skb_queue_len(&other->receive_queue) >= other->max_ack_backlog);
 
 	unix_state_runlock(other);
 
@@ -908,7 +908,7 @@ restart:
 	if (other->shutdown & RCV_SHUTDOWN)
 		goto out_unlock;
 
-	if (skb_queue_len(&other->receive_queue) > other->max_ack_backlog) {
+	if (skb_queue_len(&other->receive_queue) >= other->max_ack_backlog) {
 		err = -EAGAIN;
 		if (!timeo)
 			goto out_unlock;
@@ -1255,7 +1255,7 @@ restart:
 		goto out_unlock;
 
 	if (unix_peer(other) != sk &&
-	    skb_queue_len(&other->receive_queue) > other->max_ack_backlog) {
+	    skb_queue_len(&other->receive_queue) >= other->max_ack_backlog) {
 		if (!timeo) {
 			err = -EAGAIN;
 			goto out_unlock;
-- 
1.7.3
