 Patch author: Jiri Engelthaler <engy@centrum.cz>
 
 Firmware CDMA 1.71 from http://koppel.cz/cdmawifi
 
--- oldlinux/drivers/usb/acm.c	2004-12-03 03:57:26.000000000 +0100
+++ linux/drivers/usb/acm.c	2008-07-22 20:05:17.000000000 +0200
@@ -1,36 +1,41 @@
 /*
- * acm.c  Version 0.21
+ * acm.c  Version 0.23
  *
  * Copyright (c) 1999 Armin Fuerst	<fuerst@in.tum.de>
  * Copyright (c) 1999 Pavel Machek	<pavel@suse.cz>
  * Copyright (c) 1999 Johannes Erdfelt	<johannes@erdfelt.com>
  * Copyright (c) 2000 Vojtech Pavlik	<vojtech@suse.cz>
+ * Copyright (c) 2004 Jiri Engelthaler	<engy@centrum.cz>
  *
  * USB Abstract Control Model driver for USB modems and ISDN adapters
  *
  * Sponsored by SuSE
  *
  * ChangeLog:
  *	v0.9  - thorough cleaning, URBification, almost a rewrite
  *	v0.10 - some more cleanups
  *	v0.11 - fixed flow control, read error doesn't stop reads
  *	v0.12 - added TIOCM ioctls, added break handling, made struct acm kmalloced
  *	v0.13 - added termios, added hangup
  *	v0.14 - sized down struct acm
  *	v0.15 - fixed flow control again - characters could be lost
  *	v0.16 - added code for modems with swapped data and control interfaces
  *	v0.17 - added new style probing
  *	v0.18 - fixed new style probing for devices with more configurations
  *	v0.19 - fixed CLOCAL handling (thanks to Richard Shih-Ping Chan)
  *	v0.20 - switched to probing on interface (rather than device) class
  *	v0.21 - revert to probing on device for devices with multiple configs
+ *	v0.22 - added max_packet_size variable for wMaxPacketSize
+ *	        workaround needed by Qualcomm CDMA modem. Default value is 1024.
+ *              Thanks to David Peroutka for discovering this solution.
+ *	v0.23 - Siemens MC75 modem workaround
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -54,23 +59,30 @@
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 #undef DEBUG
 #include <linux/usb.h>
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.21"
-#define DRIVER_AUTHOR "Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik"
-#define DRIVER_DESC "USB Abstract Control Model driver for USB modems and ISDN adapters"
+#define DRIVER_VERSION "v0.23"
+#define DRIVER_AUTHOR "Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik, Jiri Engelthaler"
+#define DRIVER_DESC "USB Abstract Control Model driver for USB modems and ISDN adapters (patched)"
+
+/* 
+ * QualComm workaround
+ */
+ 
+static int known_max_packet_size = 1024;
+static int maxpacketsize = -1;
 
 /*
  * CMSPAR, some architectures can't have space and mark parity.
  */
 
 #ifndef CMSPAR
 #define CMSPAR			0
 #endif
 
 /*
@@ -117,20 +129,31 @@
 
 #define ACM_CTRL_DCD		0x01
 #define ACM_CTRL_DSR		0x02
 #define ACM_CTRL_BRK		0x04
 #define ACM_CTRL_RI		0x08
 
 #define ACM_CTRL_FRAMING	0x10
 #define ACM_CTRL_PARITY		0x20
 #define ACM_CTRL_OVERRUN	0x40
 
+/* 
+ * Qualcomm ids 
+ */
+ 
+#define QUALCOMM_VENDOR_ID   0x05c6
+#define QUALCOMM_PRODUCT_ID  0x3196	// GTRAN GPC-6420
+#define CMOTECH_VENDOR_ID    0x16D8
+#define CMOTECH_PRODUCT_ID   0x5533
+#define SIEMENS_VENDOR_ID    0x0681
+#define SIEMENS_PRODUCT_ID   0x0034	// MC75
+
 /*
  * Line speed and caracter encoding.
  */
 
 struct acm_line {
 	__u32 speed;
 	__u8 stopbits;
 	__u8 parity;
 	__u8 databits;
 } __attribute__ ((packed));
@@ -508,20 +531,23 @@
 
 static void *acm_probe(struct usb_device *dev, unsigned int ifnum,
 		       const struct usb_device_id *id)
 {
 	struct acm *acm;
 	struct usb_config_descriptor *cfacm;
 	struct usb_interface_descriptor *ifcom, *ifdata;
 	struct usb_endpoint_descriptor *epctrl, *epread, *epwrite;
 	int readsize, ctrlsize, minor, i, j;
 	unsigned char *buf;
+#ifdef CONFIG_USB_DEVPATH
+	char devfsname[16];
+#endif
 
 	for (i = 0; i < dev->descriptor.bNumConfigurations; i++) {
 
 		cfacm = dev->config + i;
 
 		dbg("probing config %d", cfacm->bConfigurationValue);
 
 		for (j = 0; j < cfacm->bNumInterfaces - 1; j++) {
 
 			if (usb_interface_claimed(cfacm->interface + j) ||
@@ -552,73 +576,115 @@
 			    ((epread->bEndpointAddress & 0x80) ^ (epwrite->bEndpointAddress & 0x80)) != 0x80)
 				continue;
 
 			dbg("using interface %d\n", j);
 
 			if ((epread->bEndpointAddress & 0x80) != 0x80) {
 				epread = ifdata->endpoint + 1;
 				epwrite = ifdata->endpoint + 0;
 			}
 
-			usb_set_configuration(dev, cfacm->bConfigurationValue);
-
+			if(dev->descriptor.idVendor  != SIEMENS_VENDOR_ID ||
+			   dev->descriptor.idProduct != SIEMENS_PRODUCT_ID) {
+				usb_set_configuration(dev, cfacm->bConfigurationValue);
+			}
+			
 			for (minor = 0; minor < ACM_TTY_MINORS && acm_table[minor]; minor++);
 			if (acm_table[minor]) {
 				err("no more free acm devices");
 				return NULL;
 			}
 
 			if (!(acm = kmalloc(sizeof(struct acm), GFP_KERNEL))) {
 				err("out of memory");
 				return NULL;
 			}
 			memset(acm, 0, sizeof(struct acm));
 
-			ctrlsize = epctrl->wMaxPacketSize;
-			readsize = epread->wMaxPacketSize;
-			acm->writesize = epwrite->wMaxPacketSize;
+			/* Qualcomm workaround. Some Quallcom devices (surely Gtran GPC-6420 CDMA
+			 * modem) reports bad wMaxPacketSize (64). That causes max transfer rate
+			 * about 256 kbps.  This code forces better wMaxPacketSize value
+			 */
+			
+			if ((dev->descriptor.idVendor  == QUALCOMM_VENDOR_ID &&
+			     dev->descriptor.idProduct == QUALCOMM_PRODUCT_ID) ||
+			    (dev->descriptor.idVendor  == CMOTECH_VENDOR_ID &&
+			     dev->descriptor.idProduct == CMOTECH_PRODUCT_ID) ||
+			    (dev->descriptor.idVendor  == SIEMENS_VENDOR_ID &&
+			     dev->descriptor.idProduct == SIEMENS_PRODUCT_ID)
+			   ) {
+				ctrlsize = readsize = acm->writesize = known_max_packet_size;
+				printk("forcing new wMaxPacketSize for modem device: %d\n", ctrlsize);
+			} 
+			else {
+				if (maxpacketsize > 0)
+				{
+					ctrlsize = readsize = acm->writesize = maxpacketsize;
+					printk("forcing new wMaxPacketSize for modem device: %d\n", ctrlsize);
+				}
+				else {
+					ctrlsize = epctrl->wMaxPacketSize;
+					readsize = epread->wMaxPacketSize;
+					acm->writesize = epwrite->wMaxPacketSize;
+				}
+			}
+			
 			acm->iface = cfacm->interface + j;
 			acm->minor = minor;
 			acm->dev = dev;
 
 			acm->tqueue.routine = acm_softint;
 			acm->tqueue.data = acm;
 
 			if (!(buf = kmalloc(ctrlsize + readsize + acm->writesize, GFP_KERNEL))) {
 				err("out of memory");
 				kfree(acm);
 				return NULL;
 			}
 
 			FILL_INT_URB(&acm->ctrlurb, dev, usb_rcvintpipe(dev, epctrl->bEndpointAddress),
 				     buf, ctrlsize, acm_ctrl_irq, acm, epctrl->bInterval);
 
 			FILL_BULK_URB(&acm->readurb, dev, usb_rcvbulkpipe(dev, epread->bEndpointAddress),
 				      buf += ctrlsize, readsize, acm_read_bulk, acm);
-			acm->readurb.transfer_flags |= USB_NO_FSBR;
+/*			if (!(dev->descriptor.idVendor  == QUALCOMM_VENDOR_ID &&
+			      dev->descriptor.idProduct == QUALCOMM_PRODUCT_ID) &&
+			    !(dev->descriptor.idVendor  == CMOTECH_VENDOR_ID &&
+			      dev->descriptor.idProduct == CMOTECH_PRODUCT_ID)
+			   )*/
+				acm->readurb.transfer_flags |= USB_NO_FSBR;
 
 			FILL_BULK_URB(&acm->writeurb, dev, usb_sndbulkpipe(dev, epwrite->bEndpointAddress),
 				      buf += readsize, acm->writesize, acm_write_bulk, acm);
-			acm->writeurb.transfer_flags |= USB_NO_FSBR;
+/*			if (!(dev->descriptor.idVendor  == QUALCOMM_VENDOR_ID &&
+			      dev->descriptor.idProduct == QUALCOMM_PRODUCT_ID) &&
+			    !(dev->descriptor.idVendor  == CMOTECH_VENDOR_ID &&
+			      dev->descriptor.idProduct == CMOTECH_PRODUCT_ID)
+			   )*/
+				acm->writeurb.transfer_flags |= USB_NO_FSBR;
 
 			printk(KERN_INFO "ttyACM%d: USB ACM device\n", minor);
 
 			acm_set_control(acm, acm->ctrlout);
 
 			acm->line.speed = cpu_to_le32(9600);
 			acm->line.databits = 8;
 			acm_set_line(acm, &acm->line);
 
 			usb_driver_claim_interface(&acm_driver, acm->iface + 0, acm);
 			usb_driver_claim_interface(&acm_driver, acm->iface + 1, acm);
 
 			tty_register_devfs(&acm_tty_driver, 0, minor);
+#ifdef CONFIG_USB_DEVPATH
+			sprintf(devfsname, acm_tty_driver.name, minor);
+			usb_register_devpath(dev, 0, devfsname);
+#endif
 			return acm_table[minor] = acm;
 		}
 	}
 
 	return NULL;
 }
 
 static void acm_disconnect(struct usb_device *dev, void *ptr)
 {
 	struct acm *acm = ptr;
@@ -632,27 +696,31 @@
 
 	usb_unlink_urb(&acm->ctrlurb);
 	usb_unlink_urb(&acm->readurb);
 	usb_unlink_urb(&acm->writeurb);
 
 	kfree(acm->ctrlurb.transfer_buffer);
 
 	usb_driver_release_interface(&acm_driver, acm->iface + 0);
 	usb_driver_release_interface(&acm_driver, acm->iface + 1);
 
+#ifdef CONFIG_USB_DEVPATH
+	usb_deregister_devpath(dev);
+#endif
+
 	if (!acm->used) {
 		tty_unregister_devfs(&acm_tty_driver, acm->minor);
 		acm_table[acm->minor] = NULL;
 		kfree(acm);
 		return;
 	}
-
+	
 	if (acm->tty)
 		tty_hangup(acm->tty);
 }
 
 /*
  * USB driver structure.
  */
 
 static struct usb_device_id acm_ids[] = {
 	{ USB_DEVICE(0x22B8, 0x1005) },		/* Motorola TimePort 280 */
@@ -737,10 +803,12 @@
 	tty_unregister_driver(&acm_tty_driver);
 }
 
 module_init(acm_init);
 module_exit(acm_exit);
 
 MODULE_AUTHOR( DRIVER_AUTHOR );
 MODULE_DESCRIPTION( DRIVER_DESC );
 MODULE_LICENSE("GPL");
 
+MODULE_PARM(maxpacketsize, "i");
+MODULE_PARM_DESC(maxpacketsize, "Force MaxPacketSize");
