SIP ALG for Linux kernel 2.4.27 (backported version from 2.6)

 http://atens.blogspot.com/2008/04/sip-alghelper-for-linux-kernel-24.html

Index: include/linux/netfilter_ipv4/ip_conntrack.h
===================================================================
--- a/include/linux/netfilter_ipv4/ip_conntrack.h	(.../sip-alg)	(revision 1)
+++ b/include/linux/netfilter_ipv4/ip_conntrack.h	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -72,6 +72,7 @@ union ip_conntrack_expect_proto {
 #include <linux/netfilter_ipv4/ip_conntrack_irc.h>
 #include <linux/netfilter_ipv4/ip_conntrack_pptp.h>
 #include <linux/netfilter_ipv4/ip_conntrack_h323.h>
+#include <linux/netfilter_ipv4/ip_conntrack_sip.h>
 #include <linux/netfilter_ipv4/ip_conntrack_rtsp.h>
 #include <linux/netfilter_ipv4/ip_conntrack_mms.h>
 #include <linux/netfilter_ipv4/ip_autofw.h>
@@ -84,6 +85,7 @@ union ip_conntrack_expect_help {
 	struct ip_ct_irc_expect exp_irc_info;
 	struct ip_ct_pptp_expect exp_pptp_info;
 	struct ip_ct_h225_expect exp_h225_info;
+	struct ip_ct_sip_expect exp_sip_info;
 	struct ip_ct_rtsp_expect exp_rtsp_info;
 	struct ip_ct_mms_expect exp_mms_info;
         struct ip_autofw_expect exp_autofw_info;
Index: include/linux/netfilter_ipv4/ip_conntrack_tuple.h
===================================================================
--- a/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	(.../sip-alg)	(revision 1)
+++ b/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -101,6 +101,19 @@
 	struct ip_conntrack *ctrack;
 };
 
+
+/* Back ported from Linux 2.6 kernel */
+/* The l3 protocol-specific manipulable parts of the tuple: always in
+   network order! */
+
+#define NF_CT_TUPLE_L3SIZE 128/8
+union ip_conntrack_address {
+        u_int32_t all[NF_CT_TUPLE_L3SIZE];
+        u_int32_t ip;
+        u_int32_t ip6[4];
+};
+
+
 #endif /* __KERNEL__ */
 
 static inline int ip_ct_tuple_src_equal(const struct ip_conntrack_tuple *t1,
@@ -136,4 +149,6 @@
 		     & mask->dst.protonum));
 }
 
+
+
 #endif /* _IP_CONNTRACK_TUPLE_H */
Index: include/linux/netfilter_ipv4/ip_conntrack_sip.h
===================================================================
--- a/include/linux/netfilter_ipv4/ip_conntrack_sip.h	(.../sip-alg)	(revision 0)
+++ b/include/linux/netfilter_ipv4/ip_conntrack_sip.h	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -0,0 +1,54 @@
+#ifndef __IP_CONNTRACK_SIP_H__
+#define __IP_CONNTRACK_SIP_H__
+
+#ifdef __KERNEL__
+#include <linux/netfilter_ipv4/lockhelp.h>
+#endif
+
+#define SIP_PORT	5060
+#define SIP_TIMEOUT	900
+
+enum sip_header_pos {
+	POS_REG_REQ_URI,
+	POS_REQ_URI,
+	POS_FROM,
+	POS_TO,
+	POS_VIA,
+	POS_CONTACT,
+	POS_CONTENT,
+	POS_MEDIA,
+	POS_MEDIA_VIDEO,
+	POS_OWNER_IP4,
+	POS_CONNECTION_IP4,
+	POS_OWNER_IP6,
+	POS_CONNECTION_IP6,
+	POS_SDP_HEADER,
+};
+
+
+struct ip_ct_sip_expect {
+	enum ip_conntrack_dir dir;
+	u_int16_t saved_port;
+	u_int32_t saved_ip;
+};
+#if 0
+extern unsigned int (*ip_nat_sip_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       struct ip_conntrack *ct,
+				       const char **dptr);
+extern unsigned int (*ip_nat_sdp_hook)(struct sk_buff **pskb,
+				       enum ip_conntrack_info ctinfo,
+				       struct ip_conntrack_expect *exp,
+				       const char *dptr);
+#endif				       
+
+extern int ct_sip_get_info(struct ip_conntrack *ct, const char *dptr, size_t dlen,
+			   unsigned int *matchoff, unsigned int *matchlen,
+			   enum sip_header_pos pos);
+extern int ct_sip_lnlen(const char *line, const char *limit);
+extern const char *ct_sip_search(const char *needle, const char *haystack,
+				 size_t needle_len, size_t haystack_len,
+				 int case_sensitive);
+extern int sip_parse_addr(struct ip_conntrack *, const char *, const char **,
+                      union ip_conntrack_address *, const char *);
+#endif /* __IP_CONNTRACK_SIP_H__ */
Index: net/ipv4/netfilter/Makefile
===================================================================
--- a/net/ipv4/netfilter/Makefile	(.../sip-alg)	(revision 1)
+++ b/net/ipv4/netfilter/Makefile	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -57,6 +57,10 @@
 ifdef CONFIG_IP_NF_NAT_H323
        export-objs += ip_conntrack_h323.o
 endif
+obj-$(CONFIG_IP_NF_SIP) += ip_conntrack_sip.o
+ifdef CONFIG_IP_NF_SIP
+       export-objs += ip_conntrack_sip.o
+endif
 obj-$(CONFIG_IP_NF_RTSP) += ip_conntrack_rtsp.o
 ifdef CONFIG_IP_NF_NAT_RTSP
        export-objs += ip_conntrack_rtsp.o
@@ -76,6 +80,7 @@
 obj-$(CONFIG_IP_NF_NAT_PROTO_GRE) += ip_nat_proto_gre.o
 obj-$(CONFIG_IP_NF_NAT_PPTP) += ip_nat_pptp.o
 obj-$(CONFIG_IP_NF_NAT_H323) += ip_nat_h323.o
+obj-$(CONFIG_IP_NF_NAT_SIP) += ip_nat_sip.o
 obj-$(CONFIG_IP_NF_NAT_RTSP) += ip_nat_rtsp.o
 obj-$(CONFIG_IP_NF_NAT_MMS) += ip_nat_mms.o
 obj-$(CONFIG_IP_NF_NAT_STARCRAFT) += ip_nat_starcraft.o
Index: net/ipv4/netfilter/ip_nat_sip.c
===================================================================
--- a/net/ipv4/netfilter/ip_nat_sip.c	(.../sip-alg)	(revision 0)
+++ b/net/ipv4/netfilter/ip_nat_sip.c	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -0,0 +1,909 @@
+/* SIP extension for UDP NAT alteration.
+ *
+ * (C) 2005 by Christian Hentschel <chentschel@arnet.com.ar>
+ * based on RR's ip_nat_ftp.c and other modules.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 4 Apr 2008 : 
+ *      atens <atens.huang@gmail.com>
+ * 	 - Back ported to Linux 2.4 based on Rusty's FTP ALG
+ * 	 - Add sip nat helper to help sip protocol setting up the nat 
+ * 	   tunnel for incoming rtp traffic
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <net/ip.h>
+#include <linux/udp.h>
+
+#include <linux/netfilter_ipv4/ip_nat.h>
+#include <linux/netfilter_ipv4/ip_nat_helper.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
+#include <linux/netfilter_ipv4/ip_conntrack_sip.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Hentschel <chentschel@arnet.com.ar>");
+MODULE_DESCRIPTION("SIP NAT helper");
+
+#define MAX_PORTS 8
+
+#ifdef DEBUG
+#ifdef DEBUGGER
+#include <linux/spinlock.h>
+#endif
+#endif
+
+
+static unsigned short ports[MAX_PORTS] = { [0 ... MAX_PORTS-1] = 0};
+
+MODULE_PARM(ports, "1-8i");
+MODULE_PARM_DESC(ports, "port number of SIP nat helper");
+
+static char sip_names[MAX_PORTS][sizeof("sip-65535")] /*__read_mostly */;
+
+static struct ip_nat_helper sip[MAX_PORTS];
+
+#ifdef DEBUG /* This is used for disabling IRQ when debugging kernel. */
+#ifdef DEBUGGER
+static spinlock_t lock =  SPIN_LOCK_UNLOCKED;
+#endif
+#endif
+
+unsigned int flags;
+
+struct addr_map {
+	struct {
+		char		src[sizeof("nnn.nnn.nnn.nnn:nnnnn")];
+		char		dst[sizeof("nnn.nnn.nnn.nnn:nnnnn")];
+		unsigned int	srclen, srciplen;
+		unsigned int	dstlen, dstiplen;
+	} addr[IP_CT_DIR_MAX];
+};
+static unsigned int ip_nat_sdp(struct sk_buff **,
+			       enum ip_conntrack_info ,
+			       struct ip_conntrack_expect *,
+			       const char *, int, enum sip_header_pos);
+
+static void addr_map_init(struct ip_conntrack *ct, struct addr_map *map)
+{
+	struct ip_conntrack_tuple *t;
+	enum ip_conntrack_dir dir;
+	unsigned int n;
+
+	for (dir = 0; dir < IP_CT_DIR_MAX; dir++) {
+		t = &ct->tuplehash[dir].tuple;
+
+		n = sprintf(map->addr[dir].src, "%u.%u.%u.%u",
+			    NIPQUAD(t->src.ip));
+		map->addr[dir].srciplen = n;
+		n += sprintf(map->addr[dir].src + n, ":%u",
+			     ntohs(t->src.u.udp.port));
+		map->addr[dir].srclen = n;
+
+		n = sprintf(map->addr[dir].dst, "%u.%u.%u.%u",
+			    NIPQUAD(t->dst.ip));
+		map->addr[dir].dstiplen = n;
+		n += sprintf(map->addr[dir].dst + n, ":%u",
+			     ntohs(t->dst.u.udp.port));
+		map->addr[dir].dstlen = n;
+	}
+}
+
+static int map_sip_addr(struct sk_buff **pskb, enum ip_conntrack_info ctinfo,
+			struct ip_conntrack *ct, const char **dptr, size_t dlen,
+			enum sip_header_pos pos, struct addr_map *map)
+{
+	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
+	unsigned int matchlen, matchoff, addrlen;
+	char *addr;
+	struct iphdr *iph;
+
+	if (ct_sip_get_info(ct, *dptr, dlen, &matchoff, &matchlen, pos) <= 0)
+		return 1;
+
+	/* Decide which IP we should use. 
+	 *
+	 * If the original IP is the same as the tuple, that means we should map 
+	 * that IP to the related IP field in the opposite way.
+	 *
+	 * For instance, if the source IP of this packet is the same with 
+	 * tuple[dir].src.ip, that means, we should map this packet's source
+	 * IP to tuple[!dir].dst.ip (on the opposite way, the related 
+	 * IP position in the IP packet) 
+	 *
+	 * 								--atens 
+	 */
+	if ((matchlen == map->addr[dir].srciplen ||
+	     matchlen == map->addr[dir].srclen) &&
+	    memcmp(*dptr + matchoff, map->addr[dir].src, matchlen) == 0) {
+		addr    = map->addr[!dir].dst;
+		addrlen = map->addr[!dir].dstlen;
+	} else if ((matchlen == map->addr[dir].dstiplen ||
+		    matchlen == map->addr[dir].dstlen) &&
+		   memcmp(*dptr + matchoff, map->addr[dir].dst, matchlen) == 0) {
+		addr    = map->addr[!dir].src;
+		addrlen = map->addr[!dir].srclen;
+	} else
+		return 1;
+
+	/* Then we write the result into packet */
+	if (!ip_nat_mangle_udp_packet(pskb, ct, ctinfo,
+				      matchoff, matchlen, addr, addrlen))
+		return 0;
+	#if 0
+	*dptr = (*pskb)->data + ip_hdrlen(*pskb) + sizeof(struct udphdr);
+	#endif
+	iph = (void *)(*pskb)->data;
+
+	/* 
+	 * Recompute the new data pointer.
+	 * 				--atens 
+	 */
+	*dptr = (*pskb)->data + iph->ihl*4 + sizeof(struct udphdr);
+	return 1;
+
+}
+
+#if 0
+static unsigned int ip_nat_sip(struct sk_buff **pskb,
+			       enum ip_conntrack_info ctinfo,
+			       struct ip_conntrack *ct,
+			       const char **dptr)
+#endif			      
+
+static unsigned int ip_nat_sip_help(struct ip_conntrack *ct,
+                         struct ip_conntrack_expect *exp,
+                         struct ip_nat_info *info,
+                         enum ip_conntrack_info ctinfo,
+                         unsigned int hooknum,
+                         struct sk_buff **pskb)
+{
+	struct addr_map map;
+	int dataoff, datalen;
+
+	enum sip_header_pos pos; 
+
+	uint16_t port = 0;
+	uint16_t video_port = 0;
+
+	int ret; 
+
+	int matchoff, matchlen;
+
+	struct iphdr *iph = (*pskb)->nh.iph;
+	struct udphdr *udph = (void *)iph + iph->ihl*4;
+
+	const char *dptr = NULL;
+
+#if 0
+        struct ip_nat_info *info = &ct->nat.info; 
+#endif
+	int dir=-1; /* the pskb's direction */
+
+#ifdef DEBUG
+#ifdef DEBUGGER
+	spin_lock_irqsave(&lock,flags);
+#endif
+#endif
+
+#ifdef DEBUG
+	printk("%s:%d: ip_nat_sip_help entered\n", __FILE__, __LINE__);
+#endif
+
+        dir = CTINFO2DIR(ctinfo);
+
+
+       /* For ftp client/server model, this is good. Howerver, 
+	* we are implementing the peer model of sip.
+	* 						--atens
+	*
+	* FIXME:How about content filter in filter table?
+	*       If the code listed below works, the fitler table will
+	*       get confused. I think.			--atens
+	*/
+
+       if (!((hooknum == NF_IP_POST_ROUTING && dir == IP_CT_DIR_ORIGINAL)
+             || (hooknum == NF_IP_PRE_ROUTING && dir == IP_CT_DIR_REPLY))) {
+	       ret = NF_ACCEPT;
+	       goto out;
+       }
+
+       
+
+#if 0
+	for (i=0; i<info->num_manips; i++) 
+		if (info->manips[i].direction == dir && info->manips[i].hooknum == hooknum) {
+			/* 
+			 * Make sure that it's appropriate time to handle this skb.
+			 * 							--atens
+			 */
+			helper_doable = 1;
+			break;
+		}
+
+	/* 
+	 * Don't do the manipulation since it's not a good time to do so.
+	 *						          --atens
+	 */
+
+#ifdef DEBUG
+	printk("helper_doable:%d\n", helper_doable);
+#endif
+	if (!helper_doable) {
+#ifdef DEBUG
+		printk("%s:%d:Accept packet, but not handled.\n", __FILE__, __LINE__);
+#endif
+		ret = NF_ACCEPT;
+		goto out;
+	}
+#endif
+	
+
+#if 0
+	 if (info->initialized  != ((1 << IP_NAT_MANIP_SRC) | (1 << IP_NAT_MANIP_DST)) || info->num_manips != 0)     return NF_ACCEPT;
+
+#endif
+
+
+	/* dataoff = ip_hdrlen(*pskb) + sizeof(struct udphdr); */
+	dataoff = iph->ihl*4  + sizeof(struct udphdr);
+	datalen = (*pskb)->len - dataoff;
+	if (datalen < sizeof("SIP/2.0") - 1)  {
+#ifdef DEBUG
+		printk("%s:%d:Accept packet, but not handled.\n", __FILE__, __LINE__);
+#endif
+		ret = NF_ACCEPT; 
+		goto out;
+	}
+
+	addr_map_init(ct, &map);
+
+	dptr = (char *)udph + sizeof(struct udphdr);
+	
+	/* Basic rules: requests and responses. */
+	if (strncmp(dptr, "SIP/2.0", sizeof("SIP/2.0") - 1) != 0) {
+		/* 10.2: Constructing the REGISTER Request:
+		 *
+		 * The "userinfo" and "@" components of the SIP URI MUST NOT
+		 * be present.
+		 */
+		if (datalen >= sizeof("REGISTER") - 1 &&
+		    strncmp(dptr, "REGISTER", sizeof("REGISTER") - 1) == 0)
+			pos = POS_REG_REQ_URI;
+		else
+			pos = POS_REQ_URI;
+
+		if (!map_sip_addr(pskb, ctinfo, ct, (void *)&dptr, datalen, pos, &map)) {
+#ifdef DEBUG
+			printk("%s:%d:Drop packet\n", __FILE__, __LINE__);
+#endif 
+			ret = NF_ACCEPT;
+			goto out;
+		}
+	}
+
+	/* FIXME: These might crash since the datalen is not updated. --atens */
+	if (!map_sip_addr(pskb, ctinfo, ct, (void *)&dptr, datalen, POS_FROM, &map) ||
+	    !map_sip_addr(pskb, ctinfo, ct, (void *)&dptr, datalen, POS_TO, &map) ||
+	    !map_sip_addr(pskb, ctinfo, ct, (void *)&dptr, datalen, POS_VIA, &map) ||
+	    !map_sip_addr(pskb, ctinfo, ct, (void *)&dptr, datalen, POS_CONTACT, &map)) {
+
+#ifdef DEBUG
+		printk("%s:%d:Error in replacing ip addr.\n", __FILE__, __LINE__);
+#endif
+		}
+
+	
+        /* RTP info only in some SDP pkts */
+	       if ( !exp || (memcmp(dptr, "INVITE", sizeof("INVITE") - 1) != 0 &&
+		    memcmp(dptr, "UPDATE", sizeof("UPDATE") - 1) != 0 &&
+		    memcmp(dptr, "SIP/2.0 180", sizeof("SIP/2.0 180") - 1) != 0 &&
+		    memcmp(dptr, "SIP/2.0 183", sizeof("SIP/2.0 183") - 1) != 0 &&
+		    memcmp(dptr, "SIP/2.0 200", sizeof("SIP/2.0 200") - 1) != 0)) {
+
+		#ifdef DEBUG
+		printk("%s:%d:Cannot find RTP info or exp null\n", __FILE__, __LINE__);
+		#endif
+
+		ret = NF_ACCEPT;
+		goto out;
+
+		}
+
+	if (dir == exp->help.exp_sip_info.dir) {
+		ret = NF_ACCEPT;
+		goto out;
+	}
+
+	if (ct_sip_get_info(ct, dptr, datalen, &matchoff, &matchlen, 
+				POS_MEDIA) > 0 ) {
+
+		port = simple_strtoul(dptr + matchoff, NULL, 10);
+	} 
+
+	if (ct_sip_get_info(ct, dptr, datalen, &matchoff, &matchlen, 
+				POS_MEDIA_VIDEO) > 0 ) {
+		video_port = simple_strtoul(dptr + matchoff, NULL, 10);
+	}
+
+	/* Check the exp to see if the saved ip and saved 
+	 * port is the same as this packet.
+	 * 					--atens
+	 * FIXME: Ignore the saved_ip? It's because that the sdp's connection
+	 *        ip will be overwritten to the outboud ip of the nat box. Thus
+	 *        the second check will fail (probably the audio expectation).
+	 *
+	 */
+		if (exp->help.exp_sip_info.saved_port == htons(port) && port !=0) {
+		   pos = POS_MEDIA; 
+		} else if (exp->help.exp_sip_info.saved_port == htons(video_port) && video_port != 0) {
+		   pos = POS_MEDIA_VIDEO;
+		} else {
+			/* There is no meida info in this exp? --atens */
+			ret = NF_ACCEPT;
+			goto out;
+		}
+
+#ifdef DEBUG
+	printk("%s:%d:Now enter ip nat sdp helper for masquerading advertisement packet. Hook number:%d \n", __FILE__, __LINE__, hooknum);
+#endif
+
+	/* If we have any SDP payload, then we parse it and create
+	 * the tunnel for it. 				   --atens
+	 */
+	if (!ip_nat_sdp(pskb, ctinfo, exp, dptr, hooknum, pos)) {
+
+#ifdef DEBUG
+		printk("%s:%d:Drop packet\n", __FILE__, __LINE__);
+#endif
+		ret = NF_DROP;
+		goto out;
+	}
+#ifdef DEBUG
+	printk("%s:%d:sdp mangling succeed.\n", __FILE__, __LINE__);
+#endif
+
+	ret = NF_ACCEPT;
+
+out:
+#ifdef DEBUG
+#ifdef DEBUGGER
+	spin_unlock_irqrestore(&lock, flags);
+#endif
+#endif
+	return ret;
+}
+
+static unsigned int mangle_sip_packet(struct sk_buff **pskb,
+				      enum ip_conntrack_info ctinfo,
+				      struct ip_conntrack *ct,
+				      const char **dptr, size_t dlen,
+				      char *buffer, int bufflen,
+				      enum sip_header_pos pos)
+{
+	unsigned int matchlen, matchoff;
+	struct iphdr *iph = (*pskb)->nh.iph;
+
+	if (ct_sip_get_info(ct, *dptr, dlen, &matchoff, &matchlen, pos) <= 0)
+		return 0;
+
+#ifdef DEBUG
+	int i;
+	
+	printk("%s:%d:mangle udp packet.\nBefore:\n\t", __FILE__, __LINE__);
+
+	for (i= 0; i<matchlen; i++) {
+		printk("%c", *(*dptr+i+matchoff));
+	}
+
+		printk("\nAfter:\n\t");
+	
+	for (i=0; i<bufflen; i++) {
+		printk("%c", buffer[i]);
+	}
+		printk("\n");
+
+#endif
+	if (!ip_nat_mangle_udp_packet(pskb, ct, ctinfo,
+				      matchoff, matchlen, buffer, bufflen))
+		return 0;
+
+	/* We need to reload this. Thanks Patrick. */
+
+	*dptr = (*pskb)->data + iph->ihl*4 + sizeof(struct udphdr);
+	return 1;
+}
+
+static int mangle_content_len(struct sk_buff **pskb,
+			      enum ip_conntrack_info ctinfo,
+			      struct ip_conntrack *ct,
+			      const char *dptr)
+{
+	unsigned int dataoff, matchoff, matchlen;
+	char buffer[sizeof("65536")];
+	int bufflen;
+
+	struct iphdr *iph = (*pskb)->nh.iph;
+
+#if 0
+	dataoff = ip_hdrlen(*pskb) + sizeof(struct udphdr);
+#endif
+	dataoff = iph->ihl*4  + sizeof(struct udphdr);
+
+	/* Get actual SDP lenght */
+	if (ct_sip_get_info(ct, dptr, (*pskb)->len - dataoff, &matchoff,
+			    &matchlen, POS_SDP_HEADER) > 0) {
+
+		/* since ct_sip_get_info() give us a pointer passing 'v='
+		   we need to add 2 bytes in this count. */
+		int c_len = (*pskb)->len - dataoff - matchoff + 2;
+
+		/* Now, update SDP length */
+		if (ct_sip_get_info(ct, dptr, (*pskb)->len - dataoff, &matchoff,
+				    &matchlen, POS_CONTENT) > 0) {
+
+			bufflen = sprintf(buffer, "%u", c_len);
+			return ip_nat_mangle_udp_packet(pskb, ct, ctinfo,
+							matchoff, matchlen,
+							buffer, bufflen);
+		}
+	}
+	return 0;
+}
+
+/* called by another function */ 
+static unsigned int mangle_sdp(struct sk_buff **pskb,
+			       enum ip_conntrack_info ctinfo,
+			       struct ip_conntrack *ct,
+			       u32 newip, u16 port,
+			       const char *dptr, enum sip_header_pos pos)
+{
+	char buffer[sizeof("nnn.nnn.nnn.nnn")];
+	unsigned int dataoff, bufflen;
+
+	struct iphdr *iph = (*pskb)->nh.iph;
+
+#if 0
+	dataoff = ip_hdrlen(*pskb) + sizeof(struct udphdr);
+#endif
+	dataoff = iph->ihl*4  + sizeof(struct udphdr);
+
+	/* Mangle owner and contact info. */
+	bufflen = sprintf(buffer, "%u.%u.%u.%u", NIPQUAD(newip));
+	if (!mangle_sip_packet(pskb, ctinfo, ct,(void *) &dptr, (*pskb)->len - dataoff,
+			       buffer, bufflen, POS_OWNER_IP4))
+		return 0;
+
+	if (!mangle_sip_packet(pskb, ctinfo, ct, (void *)&dptr, (*pskb)->len - dataoff,
+			       buffer, bufflen, POS_CONNECTION_IP4))
+		return 0;
+
+	/* Mangle media port. */
+	bufflen = sprintf(buffer, "%u", port);
+	if (!mangle_sip_packet(pskb, ctinfo, ct, (void *)&dptr, (*pskb)->len - dataoff,
+			       buffer, bufflen, pos))
+		return 0;
+
+	return mangle_content_len(pskb, ctinfo, ct, dptr);
+}
+
+#if 0
+static unsigned int ip_nat_sdp_expect(struct ip_conntrack *ct,
+			      struct ip_conntrack_expect *exp)
+#endif
+static unsigned int ip_nat_sdp_expect(struct sk_buff **pskb,
+	unsigned int hooknum,
+	struct ip_conntrack *ct,
+	struct ip_nat_info *info)
+{
+	int i;
+	struct ip_nat_multi_range mr;
+	struct ip_ct_sip_expect *exp_sip_info;
+
+	struct ip_conntrack *master = master_ct(ct);
+
+#ifdef DEBUG
+#ifdef DEBUGGER
+	spin_lock_irqsave(&lock, flags);
+#endif
+#endif
+
+	IP_NF_ASSERT(master);
+	IP_NF_ASSERT(master->nat.info.initialized);
+	IP_NF_ASSERT(info);
+
+	if (info->initialized){
+#ifdef DEBUG
+#ifdef DEBUGGER
+	spin_unlock_irqrestore(&lock, flags);
+#endif
+#endif
+		return NF_ACCEPT;
+	}
+
+#ifdef DEBUG
+	printk("%s:%s:%d RTP arrived, hooknum=%d\n", __FILE__, __func__, __LINE__, hooknum);
+#endif
+
+#if 0 /* 2.6 */
+	/* This must be a fresh one. */
+	BUG_ON(ct->status & IPS_NAT_DONE_MASK);
+#endif
+
+
+	/* Change src to where master sends to */
+
+	#if 0
+	range.min_ip = range.max_ip
+		= ct->master->tuplehash[!exp->dir].tuple.dst.ip;
+	#endif
+
+	/* Fetch the ip_conntrack_expect help structure from this conntrack 
+	 *
+	 * 							    --atens
+	 */
+	exp_sip_info = &ct->master->help.exp_sip_info;
+	
+
+	/* FIXME: Don't use master's connection, it's not master but the peer's address.
+	 * 	  We should use the contact address, however, the contact address might
+	 * 	  contain domain name that we could not resolve to ip address.
+	 * 	  So, the first candidate ip is contact address. We must check if the 
+	 * 	  incoming source address is the same with the contact address. If not,
+	 * 	  this is a security breach except that the contact address is FQDN.
+	 * 									--atens 
+	 */
+	
+	/* FIXME: Phenomenon but good for Hardware NAT
+	 * 	  Since there are two expectations, however, if we saw one expectation and
+	 * 	  establish a conntrack for it, then the another expectation will be absorbed
+	 * 	  by the first expectation and we will leave up one expectation unseen.
+	 * 	  However, this is good for Hardware NAT. 	 
+	 *									--atens
+	 */
+	#if 0
+	mr.range[0].min_ip = mr.range[0].max_ip = master->tuplehash[!exp_sip_info->dir].tuple.dst.ip;
+	#endif
+
+	for (i=0; i<master->nat.info.num_manips; i++) {
+
+		if (master->nat.info.manips[i].direction == exp_sip_info->dir 
+			&& HOOK2MANIP(master->nat.info.manips[i].hooknum) == IP_NAT_MANIP_SRC) {
+
+				mr.rangesize=1;
+				mr.range[0].flags = IP_NAT_RANGE_MAP_IPS;
+				mr.range[0].min_ip = mr.range[0].max_ip = 
+					master->nat.info.manips[i].manip.ip;
+			break;
+		}
+	}
+
+	if (i != master->nat.info.num_manips) {
+		/* If we cannot find the manips for this exp, that means we 
+		 * don't need to do src ip man 
+		 * 						--atens */
+
+		/* hook doesn't matter, but it has to do source manip */
+		ip_nat_setup_info(ct, &mr, NF_IP_POST_ROUTING);
+	}
+
+
+	/* For DST manip, map port here to where it's expected. */
+	mr.range[0].flags = (IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED);
+
+	/* 
+	 * We don't have these structures, however, we could use the
+	 * legacy structure used by 2.4 ftp alg.
+	 * 				--atens. 
+	 */
+
+	#if 0
+	range.min = range.max = exp->saved_proto; 
+	range.min_ip = range.max_ip = exp->saved_ip;
+	#endif
+	mr.rangesize=1;
+	mr.range[0].min.udp.port = mr.range[0].max.udp.port = exp_sip_info->saved_port;
+	mr.range[0].min_ip = mr.range[0].max_ip = exp_sip_info->saved_ip;
+
+	/* hook doesn't matter, but it has to do destination manip */
+	ip_nat_setup_info(ct, &mr, NF_IP_PRE_ROUTING);
+
+
+#ifdef DEBUG
+#ifdef DEBUGGER
+	spin_unlock_irqrestore(&lock, flags);
+#endif
+#endif
+
+	
+	return NF_ACCEPT;
+
+}
+
+/* 
+ * This function should be translated to be nat helper function 
+ * in Linux kernel 2.4. Note that the most important thing is altering
+ * the expection since we separate nat helper from conntrack helper.   
+ * 								--atens
+ */
+static unsigned int ip_nat_sdp(struct sk_buff **pskb,
+			       enum ip_conntrack_info ctinfo,
+			       struct ip_conntrack_expect *exp,
+			       const char *dptr, int hooknum, enum sip_header_pos pos)
+{
+	struct ip_conntrack *ct = exp->expectant;
+	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
+	u32 newip;
+	/* __be32 newip; */
+	u16 port;
+
+	struct ip_conntrack_tuple new_tuple;
+
+
+	/* Hey, be careful! If we are mainpulating destination IP
+	 * then we don't need to change expectation at all.
+	 * 
+	 * Expectation is expecting the session coming from the
+	 * the opposited way in contrary to the original advertisement packet. 
+	 * Thus, no matter what the desination of the advertisement packet is, 
+	 * we are still expecting the packet whose destination is what we 
+	 * expect.
+	 * 								--atens
+	 */
+
+	if (HOOK2MANIP(hooknum) == IP_NAT_MANIP_SRC) {
+
+	/* Why do we use expectation instead of reply? 
+	 * The nated session should match the second condition.
+	 * Thus, in case of non-nat condition, there might be 
+	 * a situation that the sender use different address instead
+	 * of being the same with sip channel. 
+	 *
+	 * For instance, assume that the sip packet was sent from A 
+	 * to B, however, sdp channel elected by A uses C as source 
+	 * IP, then we should use exp->tuple.dst.ip as newip
+	 *
+	 * For nated session, because we are symmetric nat system, there
+	 * are no problems using the dst ip of the reply session.
+	 * 						    --atens
+	 *
+	 * FIXME: Why would nat helper code has non-nat case?						
+	 * 	  Maybe it's due to the difference between 2.4 and 2.6. 
+	 * 	  Currently, I don't care about the first case...and I
+	 * 	  supppose that it will not happen in my Linux Box.
+	 * 	  					    --atens
+	 */
+
+	/* Connection will come from reply. */
+	if (ct->tuplehash[dir].tuple.src.ip ==
+	    ct->tuplehash[!dir].tuple.dst.ip)
+		newip = exp->tuple.dst.ip;
+	else
+		newip = ct->tuplehash[!dir].tuple.dst.ip;
+
+	#if 0
+	exp->saved_ip = exp->tuple.dst.u3.ip;
+	exp->tuple.dst.u3.ip = newip;
+	exp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;
+	exp->dir = !dir;
+
+	/* When you see the packet, we need to NAT it the same as the
+	   this one. */
+	exp->expectfn = ip_nat_sdp_expect;
+	#endif
+
+	/* We don't have the the structure listed above, therefore, we 
+	 * use legacy structure used by ftp alg in Linux 2.4, and make
+	 * sure that we will not exceed the size of the already existing
+	 * structure in order to keep the vendor's driver statble.
+	 * 						 	--atens
+	 */
+
+
+	/* FIXME:
+	 * Race condition would happen here. Assume that
+	 * we have already establish a expectation and we
+	 * want to re-establilsh a brand new one since the
+	 * expected rtp session did not response.
+	 *
+	 * What we did was sending new sdp that expects the 
+	 * same port & the same IP. However, the expectation
+	 * estatlishment will fail, and will end up with 
+	 * exp->tuple.dst.ip as already translated dst.ip. 
+	 * 
+	 * It caused the the exp->help.exp_sip_info.saved_ip fail
+	 * to setup nat info since the saved ip was wrong (the 
+	 * already translated ip). We move the saved_ip to conntrack
+	 * code in order to avoid this race condition and I hope that
+	 * it will work as I wish.
+	 *
+	 * 					--atens*/
+	IP_NF_ASSERT(exp->help.exp_sip_info.dir == !dir);
+	
+	/* It's time to change our expectation .
+	 * For 2.4, it's really "change" the expectation.
+	 * For 2.6, the expectation is brand new one.
+	 * No need to change expectation in 2.6.
+	 *
+	 * 				-- atens 
+	 */
+
+	/* We don't care about source port and source ip of the expectation 
+	 * at all.
+	 *							--atens  
+	 */
+	new_tuple.src.ip = 0;
+	new_tuple.src.u.udp.port = 0;
+	new_tuple.dst.ip = newip;                               	
+	new_tuple.dst.u.udp.port = exp->tuple.dst.u.udp.port; 
+	/* We don't care, we leave the kernel to choose port. */	
+	new_tuple.dst.protonum  = IPPROTO_UDP;                  	
+
+#ifdef DEBUG
+	printk("%s:%d:new ip %u.%u.%u.%u\n", __FILE__, __LINE__, NIPQUAD(newip));
+	printk("%s:%d:new tuple src ip %u.%u.%u.%u  port:%d dsp ip %u.%u.%u.%u port:%d\n", __FILE__, __LINE__, NIPQUAD(new_tuple.src.ip),ntohs(new_tuple.src.u.udp.port), NIPQUAD(new_tuple.dst.ip), ntohs(new_tuple.dst.u.udp.port));
+#endif	
+
+	/* find a new port, if the original is not accepted.
+	 * 						--atens */
+	
+	/* Try to get same port: if not, try to change it. */
+	for (port = ntohs(exp->tuple.dst.u.udp.port); port != 0; port++) {
+	#if 0 	/* For 2.6, not for 2.4. You don't need to create a brand
+		   new one expectation   
+		   						--atens */
+		exp->tuple.dst.u.udp.port = htons(port);
+	#endif
+		new_tuple.dst.u.udp.port = htons(port);
+
+		if (ip_conntrack_change_expect(exp, &new_tuple) == 0) {
+		
+			break;
+		}
+	#if 0   /* This is for 2.6. --atens */
+		if (ip_ct_expect_related(exp) == 0)
+			break;
+	#endif
+	}
+
+	/* FIXME: Shall we unexpected the expectation? --atens */
+	if (port == 0) {
+
+#ifdef DEBUG
+		printk("%s:%d: Change expectation failed.\n", __FILE__, __LINE__);
+#endif
+		/* We cannot change expectation, that means, we have the same expectation 
+		 * before manipulation.
+		 * 								--atens
+		 */
+
+		return NF_ACCEPT;
+	}
+
+#ifdef DEBUG
+	printk("%s:%d:Change expectation succeeded.\n", __FILE__, __LINE__);
+	printk("%s:%d:new tuple: src %u.%u.%u.%u:%u", __FILE__, __LINE__,NIPQUAD(new_tuple.src.ip), ntohs(new_tuple.src.u.udp.port));
+	printk(" dst:%u.%u.%u.%u:%u\n", NIPQUAD(new_tuple.dst.ip), ntohs(new_tuple.dst.u.udp.port));
+	printk("%s:%d:Mangling sdp to inform that the listening IP & port\n", __FILE__, __LINE__);
+#endif
+
+	if (!mangle_sdp(pskb, ctinfo, ct, newip, port, dptr, pos)) {
+
+		/* To give up the expection changing .
+		 *				-- atens
+		 *
+		 * FIXME: In 2.4.27, unrelated expect is a static function. 
+		 * 	  Thus, I cannot call it directly.
+		 */
+
+		#if 0
+		ip_ct_unexpect_related(exp);
+		/* since the unexpect_related is static, we cannot
+		 * call it directly.
+		 * 				--atens
+		 */
+		unexpect_related(exp);
+		#endif
+
+#ifdef DEBUG
+		printk("%s:%d: failed to mangle SDP \n", __FILE__, __LINE__);
+		printk("%s:%d:Drop packet\n", __FILE__, __LINE__);
+#endif
+		return NF_ACCEPT;
+	}
+	}
+	return NF_ACCEPT;
+}
+
+
+
+static void __exit ip_nat_sip_fini(void)
+{
+	/* no rcu technology now */
+	#if 0
+	rcu_assign_pointer(ip_nat_sip_hook, NULL);
+	rcu_assign_pointer(ip_nat_sdp_hook, NULL);
+	synchronize_rcu();
+	#endif
+
+	/* trying to unregister all nat helper since the 
+	 * module is about to be remove */
+	int i;
+
+	for (i = 0; ports[i]!=0; i++) {
+		ip_nat_helper_unregister(&sip[i]);
+	}
+
+}
+
+static int __init ip_nat_sip_init(void)
+{
+	/* No hook now, we are using Linux Kernel 2.4 */
+	/*
+	BUG_ON(rcu_dereference(nf_nat_sip_hook));
+	BUG_ON(rcu_dereference(nf_nat_sdp_hook));
+	rcu_assign_pointer(nf_nat_sip_hook, ip_nat_sip);
+	rcu_assign_pointer(nf_nat_sdp_hook, ip_nat_sdp);
+	*/
+
+	/* Register nat helper for sip and prepare 
+	 * to manipluating nat address translation 
+	 * for expecting traffic */
+
+	int i;
+	int ret;
+	char *tmpname;
+		
+	if (ports[0]==0) {
+		ports[0]=SIP_PORT;
+	}
+
+	for (i=0; ports[i]!=0; i++) {
+		/* Register the helper */
+		/* Firstly, initialize the helper by memset */
+		memset(&sip[i], 0, sizeof(sip[i]));
+
+		sip[i].tuple.dst.protonum = IPPROTO_UDP;
+		sip[i].tuple.src.u.udp.port = htons(ports[i]);
+		sip[i].mask.src.u.udp.port = htons(0xFFFF);
+		sip[i].mask.dst.protonum = 0xff;
+		sip[i].help = ip_nat_sip_help;
+		sip[i].me = THIS_MODULE;
+		/* For REGISTER, we should toggle this flags */ 
+		sip[i].flags = IP_NAT_HELPER_F_ALWAYS;  
+		sip[i].expect = ip_nat_sdp_expect;
+		
+		tmpname=&sip_names[i][0];
+
+		if (i==0) {
+			sprintf(tmpname, "sip");
+		} else {
+			sprintf(tmpname, "sip-%d", ports[i]);
+		}
+		sip[i].name = tmpname;
+
+		ret = ip_nat_helper_register(&sip[i]);
+
+		if (ret) {
+#ifdef DEBUG
+			printk("ip_nat_sip: error registering sip nat helper for port %d.\n", ports[i]);
+#endif
+
+			ip_nat_sip_fini();
+			return ret;
+
+		}
+
+	}
+
+	
+	return 0;
+}
+
+module_init(ip_nat_sip_init);
+module_exit(ip_nat_sip_fini);
Index: net/ipv4/netfilter/ip_conntrack_sip.c
===================================================================
--- a/net/ipv4/netfilter/ip_conntrack_sip.c	(.../sip-alg)	(revision 0)
+++ b/net/ipv4/netfilter/ip_conntrack_sip.c	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -0,0 +1,713 @@
+/* SIP extension for IP connection tracking.
+ *
+ * (C) 2005 by Christian Hentschel <chentschel@arnet.com.ar>
+ * based on RR's ip_conntrack_ftp.c and other modules.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 
+ * 4 Apr 2008: 
+ * 	Kaihan Huang <Kaihan_Huang@gemtek.com.tw>
+ * 	- Back ported to Linux Kernel 2.4.
+ * 	- Add sip helper for conntrack system.
+ * 	- Remove 2.6 information in order to fit the architecture of 2.4.
+ */
+
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/skbuff.h>
+#include <linux/inet.h>
+#include <linux/in.h>
+#include <linux/udp.h>
+#include <linux/net.h>
+#include <linux/netfilter.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
+#include <linux/netfilter_ipv4/ip_conntrack_sip.h>
+#include <linux/netfilter_ipv4/ip_conntrack_helper.h>
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Hentschel <chentschel@arnet.com.ar>");
+MODULE_DESCRIPTION("SIP connection tracking helper");
+
+
+#define MAX_PORTS	8
+static unsigned short ports[MAX_PORTS] = {[0 ...MAX_PORTS-1] = 0};
+
+MODULE_PARM(ports,"1-8i");
+MODULE_PARM_DESC(ports, "port numbers of SIP servers");
+
+static unsigned short sip_timeout /*__read_mostly*/ = SIP_TIMEOUT;
+/* 2.6? */
+/* module_param(sip_timeout, uint, 0600);*/
+MODULE_PARM(sip_timeout, "h");
+MODULE_PARM_DESC(sip_timeout, "timeout for the master SIP session");
+
+
+static int digits_len(struct ip_conntrack *, const char *, const char *, int *);
+static int epaddr_len(struct ip_conntrack *, const char *, const char *, int *);
+static int skp_digits_len(struct ip_conntrack *, const char *, const char *, int *);
+static int skp_epaddr_len(struct ip_conntrack *, const char *, const char *, int *);
+
+struct sip_header_nfo {
+	const char	*lname;
+	const char	*sname;
+	const char	*ln_str;
+	size_t		lnlen;
+	size_t		snlen;
+	size_t		ln_strlen;
+	int		case_sensitive;
+	int		(*match_len)(struct ip_conntrack *, const char *,
+				     const char *, int *);
+};
+
+static const struct sip_header_nfo ct_sip_hdrs[] = {
+	[POS_REG_REQ_URI] = { 	/* SIP REGISTER request URI */
+		.lname		= "sip:",
+		.lnlen		= sizeof("sip:") - 1,
+		.ln_str		= ":",
+		.ln_strlen	= sizeof(":") - 1,
+		.match_len	= epaddr_len,
+	},
+	[POS_REQ_URI] = { 	/* SIP request URI */
+		.lname		= "sip:",
+		.lnlen		= sizeof("sip:") - 1,
+		.ln_str		= "@",
+		.ln_strlen	= sizeof("@") - 1,
+		.match_len	= epaddr_len,
+	},
+	[POS_FROM] = {		/* SIP From header */
+		.lname		= "From:",
+		.lnlen		= sizeof("From:") - 1,
+		.sname		= "\r\nf:",
+		.snlen		= sizeof("\r\nf:") - 1,
+		.ln_str		= "sip:",
+		.ln_strlen	= sizeof("sip:") - 1,
+		.match_len	= skp_epaddr_len,
+	},
+	[POS_TO] = {		/* SIP To header */
+		.lname		= "To:",
+		.lnlen		= sizeof("To:") - 1,
+		.sname		= "\r\nt:",
+		.snlen		= sizeof("\r\nt:") - 1,
+		.ln_str		= "sip:",
+		.ln_strlen	= sizeof("sip:") - 1,
+		.match_len	= skp_epaddr_len
+	},
+	[POS_VIA] = { 		/* SIP Via header */
+		.lname		= "Via:",
+		.lnlen		= sizeof("Via:") - 1,
+		.sname		= "\r\nv:",
+		.snlen		= sizeof("\r\nv:") - 1, /* rfc3261 "\r\n" */
+		.ln_str		= "UDP ",
+		.ln_strlen	= sizeof("UDP ") - 1,
+		.match_len	= epaddr_len,
+	},
+	[POS_CONTACT] = { 	/* SIP Contact header */
+		.lname		= "Contact:",
+		.lnlen		= sizeof("Contact:") - 1,
+		.sname		= "\r\nm:",
+		.snlen		= sizeof("\r\nm:") - 1,
+		.ln_str		= "sip:",
+		.ln_strlen	= sizeof("sip:") - 1,
+		.match_len	= skp_epaddr_len
+	},
+	[POS_CONTENT] = { 	/* SIP Content length header */
+		.lname		= "Content-Length:",
+		.lnlen		= sizeof("Content-Length:") - 1,
+		.sname		= "\r\nl:",
+		.snlen		= sizeof("\r\nl:") - 1,
+		.ln_str		= ":",
+		.ln_strlen	= sizeof(":") - 1,
+		.match_len	= skp_digits_len
+	},
+	[POS_MEDIA] = {		/* SDP media info */
+		.case_sensitive	= 1,
+		.lname		= "\nm=",
+		.lnlen		= sizeof("\nm=") - 1,
+		.sname		= "\rm=",
+		.snlen		= sizeof("\rm=") - 1,
+		.ln_str		= "audio ",
+		.ln_strlen	= sizeof("audio ") - 1,
+		.match_len	= digits_len
+	},
+	[POS_MEDIA_VIDEO] = {		/* SDP media info */
+		.case_sensitive	= 1,
+		.lname		= "\nm=",
+		.lnlen		= sizeof("\nm=") - 1,
+		.sname		= "\rm=",
+		.snlen		= sizeof("\rm=") - 1,
+		.ln_str		= "video ",
+		.ln_strlen	= sizeof("video ") - 1,
+		.match_len	= digits_len
+	},
+	[POS_OWNER_IP4] = {	/* SDP owner address*/
+		.case_sensitive	= 1,
+		.lname		= "\no=",
+		.lnlen		= sizeof("\no=") - 1,
+		.sname		= "\ro=",
+		.snlen		= sizeof("\ro=") - 1,
+		.ln_str		= "IN IP4 ",
+		.ln_strlen	= sizeof("IN IP4 ") - 1,
+		.match_len	= epaddr_len
+	},
+	[POS_CONNECTION_IP4] = {/* SDP connection info */
+		.case_sensitive	= 1,
+		.lname		= "\nc=",
+		.lnlen		= sizeof("\nc=") - 1,
+		.sname		= "\rc=",
+		.snlen		= sizeof("\rc=") - 1,
+		.ln_str		= "IN IP4 ",
+		.ln_strlen	= sizeof("IN IP4 ") - 1,
+		.match_len	= epaddr_len
+	},
+	[POS_OWNER_IP6] = {	/* SDP owner address*/
+		.case_sensitive	= 1,
+		.lname		= "\no=",
+		.lnlen		= sizeof("\no=") - 1,
+		.sname		= "\ro=",
+		.snlen		= sizeof("\ro=") - 1,
+		.ln_str		= "IN IP6 ",
+		.ln_strlen	= sizeof("IN IP6 ") - 1,
+		.match_len	= epaddr_len
+	},
+	[POS_CONNECTION_IP6] = {/* SDP connection info */
+		.case_sensitive	= 1,
+		.lname		= "\nc=",
+		.lnlen		= sizeof("\nc=") - 1,
+		.sname		= "\rc=",
+		.snlen		= sizeof("\rc=") - 1,
+		.ln_str		= "IN IP6 ",
+		.ln_strlen	= sizeof("IN IP6 ") - 1,
+		.match_len	= epaddr_len
+	},
+	[POS_SDP_HEADER] = { 	/* SDP version header */
+		.case_sensitive	= 1,
+		.lname		= "\nv=",
+		.lnlen		= sizeof("\nv=") - 1,
+		.sname		= "\rv=",
+		.snlen		= sizeof("\rv=") - 1,
+		.ln_str		= "=",
+		.ln_strlen	= sizeof("=") - 1,
+		.match_len	= digits_len
+	}
+};
+
+/* get line lenght until first CR or LF seen. */
+int ct_sip_lnlen(const char *line, const char *limit)
+{
+	const char *k = line;
+
+	while ((line <= limit) && (*line == '\r' || *line == '\n'))
+		line++;
+
+	while (line <= limit) {
+		if (*line == '\r' || *line == '\n')
+			break;
+		line++;
+	}
+	return line - k;
+}
+EXPORT_SYMBOL(ct_sip_lnlen);
+
+/* Linear string search, case sensitive. */
+const char *ct_sip_search(const char *needle, const char *haystack,
+			  size_t needle_len, size_t haystack_len,
+			  int case_sensitive)
+{
+	const char *limit = haystack + (haystack_len - needle_len);
+
+	while (haystack <= limit) {
+		if (case_sensitive) {
+			if (strncmp(haystack, needle, needle_len) == 0)
+				return haystack;
+		} else {
+			if (strnicmp(haystack, needle, needle_len) == 0)
+				return haystack;
+		}
+		haystack++;
+	}
+	return NULL;
+}
+
+EXPORT_SYMBOL(ct_sip_search);
+
+static int digits_len(struct ip_conntrack *ct, const char *dptr,
+		      const char *limit, int *shift)
+{
+	int len = 0;
+	while (dptr <= limit && isdigit(*dptr)) {
+		dptr++;
+		len++;
+	}
+	return len;
+}
+
+/* get digits lenght, skiping blank spaces. */
+static int skp_digits_len(struct ip_conntrack *ct, const char *dptr,
+			  const char *limit, int *shift)
+{
+	for (; dptr <= limit && *dptr == ' '; dptr++)
+		(*shift)++;
+
+	return digits_len(ct, dptr, limit, shift);
+}
+
+int sip_parse_addr(struct ip_conntrack *ct, const char *cp, const char **endp,
+		      union ip_conntrack_address *addr, const char *limit)
+{
+	const char *end;
+	int ret = 0;
+	int family = AF_INET;
+
+	/* But we just leave the original switching code unchange. */
+	switch (family) {
+	case AF_INET:
+		ret = in4_pton(cp, limit - cp, (void *)&(addr->ip), -1, &end);
+		break;
+#if 0
+	case AF_INET6:
+		ret = in6_pton(cp, limit - cp, (void *)&(addr->ip6), -1, &end);
+		break;
+	default:
+		BUG();
+#endif
+		
+	}
+
+	if (ret == 0 || end == cp)
+		return 0;
+	if (endp)
+		*endp = end;
+	return 1;
+}
+
+/* skip ip address. returns its length. */
+static int epaddr_len(struct ip_conntrack *ct, const char *dptr,
+		      const char *limit, int *shift)
+{
+	union ip_conntrack_address addr;
+	const char *aux = dptr;
+
+	if (!sip_parse_addr(ct, dptr, &dptr, &addr, limit)) {
+		pr_debug("ip: %s parse failed.!\n", dptr);
+		return 0;
+	}
+
+	/* Port number */
+	if (*dptr == ':') {
+		dptr++;
+		dptr += digits_len(ct, dptr, limit, shift);
+	}
+	return dptr - aux;
+}
+
+/* get address length, skiping user info. */
+static int skp_epaddr_len(struct ip_conntrack *ct, const char *dptr,
+			  const char *limit, int *shift)
+{
+	const char *start = dptr;
+	int s = *shift;
+
+	/* Search for @, but stop at the end of the line.
+	 * We are inside a sip: URI, so we don't need to worry about
+	 * continuation lines. */
+	while (dptr <= limit &&
+	       *dptr != '@' && *dptr != '\r' && *dptr != '\n') {
+		(*shift)++;
+		dptr++;
+	}
+
+	if (dptr <= limit && *dptr == '@') {
+		dptr++;
+		(*shift)++;
+	} else {
+		dptr = start;
+		*shift = s;
+	}
+
+	return epaddr_len(ct, dptr, limit, shift);
+}
+
+/* Returns 0 if not found, -1 error parsing. */
+int ct_sip_get_info(struct ip_conntrack *ct,
+		    const char *dptr, size_t dlen,
+		    unsigned int *matchoff,
+		    unsigned int *matchlen,
+		    enum sip_header_pos pos)
+{
+	const struct sip_header_nfo *hnfo = &ct_sip_hdrs[pos];
+	const char *limit, *aux, *k = dptr;
+	int shift = 0;
+
+	limit = dptr + (dlen - hnfo->lnlen);
+
+	while (dptr <= limit) {
+		if ((strncmp(dptr, hnfo->lname, hnfo->lnlen) != 0) &&
+		    (hnfo->sname == NULL ||
+		     strncmp(dptr, hnfo->sname, hnfo->snlen) != 0)) {
+			dptr++;
+			continue;
+		}
+		aux = ct_sip_search(hnfo->ln_str, dptr, hnfo->ln_strlen,
+				    ct_sip_lnlen(dptr, limit),
+				    hnfo->case_sensitive);
+		if (!aux) {
+#ifdef DEBUG
+			printk("'%s' not found in '%s'.\n", hnfo->ln_str,
+				 hnfo->lname);
+#endif
+			dptr++;
+			continue;
+		}
+		aux += hnfo->ln_strlen;
+
+		*matchlen = hnfo->match_len(ct, aux, limit, &shift);
+		if (!*matchlen)
+			return -1;
+
+		*matchoff = (aux - k) + shift;
+
+#ifdef DEBUG
+		printk("%s match succeeded! - len: %u\n", hnfo->lname,
+			 *matchlen);
+#endif
+		return 1;
+	}
+#ifdef DEBUG
+	printk("%s header not found.\n", hnfo->lname);
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(ct_sip_get_info);
+EXPORT_SYMBOL(sip_parse_addr);
+
+static int set_expected_rtp(struct ip_conntrack *ct,
+			    enum ip_conntrack_info ctinfo,
+			    union ip_conntrack_address *addr,
+			    u16 port,
+			    const char *dptr)
+{
+	struct ip_conntrack_expect expect, *exp=&expect;
+	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
+	/* No IPV6 now --atens */
+	#if 0
+	int family = ct->tuplehash[!dir].tuple.src.l3num;   
+	#endif
+	int ret;
+	/*  gcc 2.x does not support typeof operator --atens */
+	#if 0
+	typeof(ip_nat_sdp_hook) ip_nat_sdp;
+	#endif
+
+
+	memset(exp, 0, sizeof (expect));
+
+#if 0
+	exp = ip_ct_expect_alloc(ct);
+	if (exp == NULL)
+		return NF_DROP;
+
+	
+	ip_ct_expect_init(exp, family,
+			  &ct->tuplehash[!dir].tuple.src.u3, addr,
+			  IPPROTO_UDP, NULL, &port);
+
+#endif
+        exp->tuple = (struct ip_conntrack_tuple) { 
+		/* FIXME: The server's address or the peer's address? 
+		 *
+		 * 	  Since the media issuer is not expected to 
+		 * 	  restrict the source ip, we, the NAT gateway,
+		 * 	  won't restrict it too.
+		 * 	  				--atens
+		 */
+		/* src.ip & source port (don't care) */
+		#if 0  
+		{ ct->tuplehash[!dir].tuple.src.ip, {0}	},
+		#endif
+		{ 0, {0}},
+		/* dst.ip & dsp.port */
+		{ (u32)addr->ip , { port }, 
+		IPPROTO_UDP
+		}
+	};
+
+	exp->mask = ((struct ip_conntrack_tuple) { 
+		/*	{ 0xFFFFFFFF, { 0 } }, */
+			{ 0x0, { 0 } },
+	                { 0xFFFFFFFF, { .udp = { 0xFFFF } }, 0xFFFF }
+		    });
+
+	/* We want expectfn callback in nat, not now.
+	 * 				     -- atens
+	 */
+	exp->expectfn = NULL;
+
+	exp->help.exp_sip_info.dir=!dir;
+	exp->help.exp_sip_info.saved_ip=exp->tuple.dst.ip;
+	exp->help.exp_sip_info.saved_port=exp->tuple.dst.u.udp.port;
+
+
+#ifdef DEBUG
+	printk("%s:%d:ip_conntrack_expect_related, expected structure\n", __FILE__,__LINE__);
+	printk("%s:%d:source ip: %u.%u.%u.%u source port: %u destination ip: %u.%u.%u.%u\n destination port: %u\n protocol:%u\n", __FILE__, __LINE__,
+	NIPQUAD(exp->tuple.src.ip), ntohs(exp->tuple.src.u.udp.port), 
+	NIPQUAD(exp->tuple.dst.ip), ntohs(exp->tuple.dst.u.udp.port), exp->tuple.dst.protonum);
+#endif
+
+	if (ip_conntrack_expect_related(ct, &expect) != 0) {
+	#ifdef DEBUG
+		printk("Failed to relate the expect\n");
+	#endif
+		ret = NF_DROP;
+	} else {
+	#ifdef DEBUG
+		printk("Succeed to relate the expect\n");
+	#endif
+		ret = NF_ACCEPT;
+	}
+
+	/* No NAT here */
+	#if 0
+	nf_nat_sdp = rcu_dereference(nf_nat_sdp_hook);
+	if (nf_nat_sdp && ct->status & IPS_NAT_MASK)
+		ret = nf_nat_sdp(pskb, ctinfo, exp, dptr);
+	else {
+		if (nf_ct_expect_related(exp) != 0)
+			ret = NF_DROP;
+		else
+			ret = NF_ACCEPT;
+	}
+	nf_ct_expect_put(exp);
+	#endif
+
+	return NF_ACCEPT;
+}
+
+/* 
+ * The help function accept the iph, len, conntrack structure 
+ * and conntrack info for this packet as argments. Using iph, 
+ * len instead of skb means you cannot modify the packet info.
+ *
+ * For 2.6, the helper function combine conntrack helper and
+ * nat helper into one, though you could separate into two as
+ * 2.4.
+ * 						--atens
+ */ 
+#if 0
+static int sip_help(struct sk_buff **pskb,
+		    unsigned int protoff,
+		    struct ip_conntrack *ct,
+		    enum ip_conntrack_info ctinfo)
+#endif		 
+static int sip_help(const struct iphdr *iph, size_t len,
+                struct ip_conntrack *ct,
+                enum ip_conntrack_info ctinfo)
+{
+#if 0
+	int family = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;
+#endif
+	union ip_conntrack_address addr;
+	unsigned int dataoff, datalen;
+	const char *dptr;
+	int ret = NF_ACCEPT;
+	int matchoff, matchlen;
+	u_int16_t port;
+	enum sip_header_pos pos;
+	
+	/* 
+	 * We don't do nat helping in 2.4 now,but leave it to ip_nat_sip.c.
+	 *
+	 *   				   			--atens 
+	 */
+
+
+	unsigned int protoff = iph->ihl * 4;
+	dataoff = protoff + sizeof(struct udphdr);
+
+	/* No Data? */
+	if (len <= iph->ihl*4) {
+		return NF_ACCEPT;
+	}
+
+	/* We have seen this kind of packet, update the timeout value 
+	 * 						     --atens
+	 */
+	ip_ct_refresh_acct(ct, ctinfo, iph, sip_timeout * HZ);
+
+	/* Calculate the dptr here */
+	dptr = (const char *)iph + dataoff;
+
+	/* datalen = (*pskb)->len - dataoff; */
+	datalen = len - dataoff;
+
+	if (datalen < sizeof("SIP/2.0 200") - 1) {
+	#ifdef DEBUG
+		printk("%s:%d:not enough data\n", __FILE__, __LINE__);
+	#endif
+		goto out;
+	}
+
+	/* RTP info only in some SDP pkts */
+	if (memcmp(dptr, "INVITE", sizeof("INVITE") - 1) != 0 &&
+	    memcmp(dptr, "UPDATE", sizeof("UPDATE") - 1) != 0 &&
+	    memcmp(dptr, "SIP/2.0 180", sizeof("SIP/2.0 180") - 1) != 0 &&
+	    memcmp(dptr, "SIP/2.0 183", sizeof("SIP/2.0 183") - 1) != 0 &&
+	    memcmp(dptr, "SIP/2.0 200", sizeof("SIP/2.0 200") - 1) != 0) {
+
+#ifdef DEBUG
+		printk("%s:%d:Cannot find RTP info\n", __FILE__, __LINE__);
+#endif
+
+		goto out;
+	}
+	/* Fetch address and port from SDP packet. --atens */
+
+	pos = POS_CONNECTION_IP4; /* IPV6? Not today. */
+
+	if (ct_sip_get_info(ct, dptr, datalen, &matchoff, &matchlen, pos) > 0) {
+
+#ifdef DEBUG
+		printk("Parse addr inside sip packet.\n");
+#endif
+
+		/* We'll drop only if there are parse problems. */
+		if (!sip_parse_addr(ct, dptr + matchoff, NULL, &addr,
+				dptr + datalen)) {
+			ret = NF_DROP;
+			goto out;
+		}
+
+		
+
+#ifdef DEBUG
+		printk("%s:%d:Get rtp listen address as %u.%u.%u.%u\n", __FILE__, __LINE__, NIPQUAD(addr.ip));
+#endif
+
+		if (ct_sip_get_info(ct, dptr, datalen, &matchoff, &matchlen,
+				    POS_MEDIA) > 0) {
+
+			port = simple_strtoul(dptr + matchoff, NULL, 10);
+			if (port < 1024) {
+				ret = NF_DROP;
+				goto out;
+			}
+
+#ifdef DEBUG
+		printk("%s:%d:Get rtp listen port for audio as %u\n", __FILE__, __LINE__,port);
+#endif
+
+			ret = set_expected_rtp(ct, ctinfo, &addr,
+					       htons(port), dptr);
+
+			if (ret == NF_DROP) {
+				goto out;
+			}
+
+		if (ct_sip_get_info(ct, dptr, datalen, &matchoff, &matchlen, 
+				POS_MEDIA_VIDEO) > 0) {
+
+			port = simple_strtoul(dptr + matchoff, NULL, 10);
+			if (port < 1024) {
+				ret = NF_DROP;
+				goto out;
+			}
+
+#ifdef DEBUG
+		printk("%s:%d:Get rtp listen port for video as %u\n", __FILE__, __LINE__,port);
+#endif
+
+			ret = set_expected_rtp(ct, ctinfo, &addr, htons(port), dptr);
+			
+		}
+
+		}
+	}
+out:
+	/* We have done. The SIP conntrack system is back ported to 2.4 now */
+	return ret;
+}
+
+/* No IPV6 now. --atens */
+static struct ip_conntrack_helper sip[MAX_PORTS] /*__read_mostly */;
+static char sip_names[MAX_PORTS][sizeof("sip-65535")] /*__read_mostly */;
+
+static void ip_conntrack_sip_fini(void)
+{
+	int i;
+
+	for (i = 0; ports[i] != 0; i++) {
+		if (sip[i].me == NULL)
+			continue;
+#ifdef DEBUG
+		printk("Unregister conntrack helper for ports[%d]=%d\n", i, ports[i]);
+#endif
+		ip_conntrack_helper_unregister(&sip[i]);
+	}
+}
+
+static int __init ip_conntrack_sip_init(void)
+{
+	int i, ret;
+	char *tmpname;
+
+
+	if (ports[0] == 0)
+		ports[0] = SIP_PORT;
+
+	for (i = 0; ports[i] != 0; i++) {
+		memset(&sip[i], 0, sizeof(sip[i]));
+
+		sip[i].tuple.dst.protonum = IPPROTO_UDP;
+		sip[i].tuple.src.u.udp.port = htons(ports[i]);
+                sip[i].mask.src.u.udp.port = htons(0xFFFF);
+		sip[i].mask.dst.protonum = 0xff;
+		sip[i].max_expected = 4;
+		#if 0
+		sip[i].timeout = 3 * 60; /* 3 minutes */
+		#endif
+		/* 
+		 * Actually, this timeout is used for expectation instead of SIP timeout.
+		 * SIP timeout is specified whenever the helper sees the SIP packet. 
+		 * 								--atens */
+		sip[i].timeout = 60; /* To avoid too long time expectation */
+		sip[i].me = THIS_MODULE;
+		sip[i].help = sip_help;
+
+		/* Reuse expectation to avoid inconsistency of the helper state machine */
+		sip[i].flags= IP_CT_HELPER_F_REUSE_EXPECT; 
+
+		tmpname = &sip_names[i][0];
+		if (ports[i] == SIP_PORT)
+			sprintf(tmpname, "sip");
+			else
+				sprintf(tmpname, "sip-%u", i);
+			sip[i].name = tmpname;
+
+
+			ret = ip_conntrack_helper_register(&sip[i]);
+			if (ret) {
+#ifdef DEBUG
+				printk("nf_ct_sip: failed to register helper "
+				       "for pf: %u port: %u\n",
+				       AF_INET, ports[i]);
+#endif
+				ip_conntrack_sip_fini();
+				return ret;
+			}
+
+#ifdef DEBUG
+			printk("ports[%d]=%d registered as sip alg\n", i, ports[i]);
+#endif
+	}
+	return 0;
+}
+
+module_init(ip_conntrack_sip_init);
+module_exit(ip_conntrack_sip_fini);
Index: net/ipv4/netfilter/Config.in
===================================================================
--- a/net/ipv4/netfilter/Config.in	(.../sip-alg)	(revision 1)
+++ b/net/ipv4/netfilter/Config.in	(.../linux-2.4.27-sip-alg)	(revision 22)
@@ -17,6 +17,7 @@
   dep_tristate '  GRE protocol support' CONFIG_IP_NF_CT_PROTO_GRE $CONFIG_IP_NF_CONNTRACK
   dep_tristate '   PPTP protocol support' CONFIG_IP_NF_PPTP $CONFIG_IP_NF_CT_PROTO_GRE
   dep_tristate '  H.323 (netmeeting) support' CONFIG_IP_NF_H323 $CONFIG_IP_NF_CONNTRACK
+  dep_tristate '  SIP protocol support' CONFIG_IP_NF_SIP $CONFIG_IP_NF_CONNTRACK
   dep_tristate '  RTSP protocol support' CONFIG_IP_NF_RTSP $CONFIG_IP_NF_CONNTRACK
   dep_tristate '  MMS protocol support' CONFIG_IP_NF_MMS $CONFIG_IP_NF_CONNTRACK
 fi
@@ -165,6 +166,13 @@
           define_tristate CONFIG_IP_NF_NAT_STARCRAFT $CONFIG_IP_NF_NAT
         fi
       fi
+      if [ "$CONFIG_IP_NF_SIP" = "m" ]; then
+	define_tristate CONFIG_IP_NF_NAT_SIP m
+      else
+        if [ "$CONFIG_IP_NF_SIP" = "y" ]; then
+          define_tristate CONFIG_IP_NF_NAT_SIP $CONFIG_IP_NF_NAT
+        fi
+      fi
 
     fi
   fi
