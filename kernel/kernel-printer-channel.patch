diff -ruB linux-2.4.35.5/drivers/usb/printer.c linux/drivers/usb/printer.c
--- linux-2.4.35.5/drivers/usb/printer.c	2007-12-17 02:16:04.000000000 +0300
+++ linux/drivers/usb/printer.c	2007-12-20 13:16:24.029628800 +0300
@@ -330,6 +330,36 @@
 	return newerr;
 }
 
+/* switch HP to channel 0 if 7/1/1 and 7/1/2 are not
+ * available (otherwise it's already defaulted to 
+ * channel 0 or manually switched to 7/1/3)
+ * to be character stream compatible
+ */
+ 
+static int usblp_713_quirk(struct usblp *usblp)
+{
+	int err = 0;
+	
+	if (proto_bias != 3 &&
+	    usblp->dev->descriptor.idVendor == 0x03F0 &&
+	    usblp->protocol[1].alt_setting == -1 &&	/* no 7/1/1 */
+	    usblp->protocol[2].alt_setting == -1 &&	/* no 7/1/2 */
+	    (usblp->quirks & USBLP_QUIRK_BIDIR) == 0) 
+	{
+		int channel;
+		err = usblp_hp_channel_change_request(usblp, 0, &channel);
+		if (err < 0) {
+			err("usblp%d: error = %d setting HP channel to raw",
+				usblp->minor, err);
+		} else {
+			dbg("usblp%d: requested raw data HP channel, got %d",
+				usblp->minor, channel);
+		}
+	}
+	
+	return err;
+}
+
 /*
  * File op functions.
  */
@@ -382,9 +412,13 @@
 			retval = -EIO;
 			usblp->used = 0;
 			file->private_data = NULL;
+ 			goto out;
 		}
 	}
 
+ 	/* switch HP 7/1/3 to channel 0 */
+ 	usblp_713_quirk(usblp);
+
 out:
 	up (&usblp_sem);
 	return retval;
@@ -418,6 +453,8 @@
 	down (&usblp_sem);
 	usblp->used = 0;
 	if (usblp->present) {
+		/* switch HP 7/1/3 to channel 0 to finish printing */
+		usblp_713_quirk(usblp);
 		usblp_unlink_urbs(usblp);
 	} else 		/* finish cleanup from disconnect */
 		usblp_cleanup (usblp);
