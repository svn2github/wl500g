 Originally OpenWRT SVN changeset #1571 - bluetooth fixes from Tomas Vanek
 
  After this patch mtu can be greater than max packet size! Fixed.
  Add another minor fixes.
 
  Signed-off-by: Leonid Lisovskiy <lly.dev@gmail.com>
 
--- linux-2.4.37/drivers/bluetooth/hci_usb.h	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/bluetooth/hci_usb.h	2009-01-26 12:33:39.000000000 +0300
@@ -65,7 +65,7 @@
 	struct urb        urb;
 };
 
-struct _urb *_urb_alloc(int isoc, int gfp);
+static struct _urb *_urb_alloc(int isoc, int gfp);
 
 static inline void _urb_free(struct _urb *_urb)
 {
@@ -105,7 +105,7 @@
 	}
 }
 
-struct _urb *_urb_dequeue(struct _urb_queue *q);
+static struct _urb *_urb_dequeue(struct _urb_queue *q);
 
 #ifndef container_of
 #define container_of(ptr, type, member) ({                      \
--- linux-2.4.37/drivers/bluetooth/hci_usb.c	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/bluetooth/hci_usb.c	2009-01-25 19:32:55.000000000 +0300
@@ -110,7 +110,7 @@ static struct usb_device_id blacklist_id
 	{ }	/* Terminating entry */
 };
 
-struct _urb *_urb_alloc(int isoc, int gfp)
+static struct _urb *_urb_alloc(int isoc, int gfp)
 {
 	struct _urb *_urb = kmalloc(sizeof(struct _urb) +
 				sizeof(struct iso_packet_descriptor) * isoc, gfp);
@@ -121,7 +121,7 @@ struct _urb *_urb_alloc(int isoc, int gf
 	return _urb;
 }
 
-struct _urb *_urb_dequeue(struct _urb_queue *q)
+static struct _urb *_urb_dequeue(struct _urb_queue *q)
 {
 	struct _urb *_urb = NULL;
         unsigned long flags;
@@ -256,9 +256,12 @@ static int hci_usb_isoc_rx_submit(struct
 	struct _urb *_urb;
 	struct urb *urb;
 	int err, mtu, size;
-	void *buf;
+	void __attribute__((aligned(2))) *buf;
 
 	mtu  = husb->isoc_in_ep->wMaxPacketSize;
+#ifdef CONFIG_BCM4710
+	mtu &= ~1;		/* brcm: isoc buffers must be aligned on word boundary */
+#endif
         size = mtu * HCI_MAX_ISOC_FRAMES;
 
 	buf = kmalloc(size, GFP_ATOMIC);
@@ -279,6 +282,7 @@ static int hci_usb_isoc_rx_submit(struct
 	urb->dev      = husb->udev;
 	urb->pipe     = usb_rcvisocpipe(husb->udev, husb->isoc_in_ep->bEndpointAddress);
 	urb->complete = hci_usb_rx_complete;
+	urb->interval = husb->isoc_in_ep->bInterval;
 
 	urb->transfer_buffer_length = size;
 	urb->transfer_buffer = buf;
@@ -512,6 +516,7 @@ static inline int hci_usb_send_isoc(stru
 	urb->pipe     = usb_sndisocpipe(husb->udev, husb->isoc_out_ep->bEndpointAddress);
 	urb->complete = hci_usb_tx_complete;
 	urb->transfer_flags = USB_ISO_ASAP;
+	urb->interval = husb->isoc_in_ep->bInterval;
 
 	urb->transfer_buffer = skb->data;
 	urb->transfer_buffer_length = skb->len;
