diff -urN linux.old/include/linux/netfilter_ipv4/ipt_multiport.h linux.dev/include/linux/netfilter_ipv4/ipt_multiport.h
--- linux.old/include/linux/netfilter_ipv4/ipt_multiport.h	2009-04-19 22:33:42.000000000 +0400
+++ linux.dev/include/linux/netfilter_ipv4/ipt_multiport.h	2007-01-23 15:49:51.000000000 +0300
@@ -1,6 +1,5 @@
 #ifndef _IPT_MULTIPORT_H
 #define _IPT_MULTIPORT_H
-#include <linux/netfilter_ipv4/ip_tables.h>
 
 enum ipt_multiport_flags
 {
@@ -11,11 +10,12 @@
 
 #define IPT_MULTI_PORTS	15
 
-/* Must fit inside union ipt_matchinfo: 16 bytes */
-struct ipt_multiport
+struct ipt_multiport_v1
 {
 	u_int8_t flags;				/* Type of comparison */
 	u_int8_t count;				/* Number of ports */
 	u_int16_t ports[IPT_MULTI_PORTS];	/* Ports */
+	u_int8_t pflags[IPT_MULTI_PORTS];	/* Port flags */
+	u_int8_t invert;			/* Invert flag */
 };
 #endif /*_IPT_MULTIPORT_H*/
diff -urB linux-2.4.37.orig/include/linux/netfilter_ipv6/ip6t_multiport.h linux/include/linux/netfilter_ipv6/ip6t_multiport.h
--- linux-2.4.37.orig/include/linux/netfilter_ipv6/ip6t_multiport.h	2009-04-19 22:33:42.000000000 +0400
+++ linux/include/linux/netfilter_ipv6/ip6t_multiport.h	2009-05-25 14:05:25.000000000 +0400
@@ -11,11 +11,12 @@
 
 #define IP6T_MULTI_PORTS	15
 
-/* Must fit inside union ip6t_matchinfo: 16 bytes */
-struct ip6t_multiport
+struct ip6t_multiport_v1
 {
 	u_int8_t flags;				/* Type of comparison */
 	u_int8_t count;				/* Number of ports */
 	u_int16_t ports[IP6T_MULTI_PORTS];	/* Ports */
+        u_int8_t pflags[IP6T_MULTI_PORTS];      /* Port flags */
+        u_int8_t invert;                        /* Invert flag */
 };
 #endif /*_IPT_MULTIPORT_H*/
diff -urB linux-2.4.37.orig/net/ipv4/netfilter/ipt_multiport.c linux/net/ipv4/netfilter/ipt_multiport.c
--- linux-2.4.37.orig/net/ipv4/netfilter/ipt_multiport.c	2009-04-19 22:33:42.000000000 +0400
+++ linux/net/ipv4/netfilter/ipt_multiport.c	2009-05-25 14:44:13.000000000 +0400
@@ -1,5 +1,15 @@
 /* Kernel module to match one of a list of TCP/UDP ports: ports are in
    the same place so we can treat them as equal. */
+
+/* (C) 1999-2001 Paul `Rusty' Russell
+ * (C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/udp.h>
@@ -8,97 +17,146 @@
 #include <linux/netfilter_ipv4/ipt_multiport.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
+MODULE_DESCRIPTION("iptables multiple port match module");
+
 #if 0
 #define duprintf(format, args...) printk(format , ## args)
 #else
 #define duprintf(format, args...)
 #endif
 
+/* from linux 2.6 skbuff.h */
+static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
+				       int len, void *buffer)
+{
+	int hlen = skb_headlen(skb);
+
+	if (hlen - offset >= len)
+		return skb->data + offset;
+
+	if (skb_copy_bits(skb, offset, buffer, len) < 0)
+		return NULL;
+
+	return buffer;
+}
+
+
 /* Returns 1 if the port is matched by the test, 0 otherwise. */
 static inline int
-ports_match(const u_int16_t *portlist, enum ipt_multiport_flags flags,
-	    u_int8_t count, u_int16_t src, u_int16_t dst)
+ports_match_v1(const struct ipt_multiport_v1 *minfo,
+	       u_int16_t src, u_int16_t dst)
 {
 	unsigned int i;
-	for (i=0; i<count; i++) {
-		if (flags != IPT_MULTIPORT_DESTINATION
-		    && portlist[i] == src)
-			return 1;
-
-		if (flags != IPT_MULTIPORT_SOURCE
-		    && portlist[i] == dst)
-			return 1;
-	}
+	u_int16_t s, e;
+
+	for (i=0; i < minfo->count; i++) {
+		s = minfo->ports[i];
 
-	return 0;
+		if (minfo->pflags[i]) {
+			/* range port matching */
+			e = minfo->ports[++i];
+			duprintf("src or dst matches with %d-%d?\n", s, e);
+
+			if (minfo->flags == IPT_MULTIPORT_SOURCE
+			    && src >= s && src <= e)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IPT_MULTIPORT_DESTINATION
+			    && dst >= s && dst <= e)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IPT_MULTIPORT_EITHER
+			    && ((dst >= s && dst <= e)
+				|| (src >= s && src <= e)))
+				return 1 ^ minfo->invert;
+		} else {
+			/* exact port matching */
+			duprintf("src or dst matches with %d?\n", s);
+
+			if (minfo->flags == IPT_MULTIPORT_SOURCE
+			    && src == s)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IPT_MULTIPORT_DESTINATION
+			    && dst == s)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IPT_MULTIPORT_EITHER
+			    && (src == s || dst == s))
+				return 1 ^ minfo->invert;
+		}
+	}
+ 
+ 	return minfo->invert;
 }
 
 static int
-match(const struct sk_buff *skb,
-      const struct net_device *in,
-      const struct net_device *out,
-      const void *matchinfo,
-      int offset,
-      const void *hdr,
-      u_int16_t datalen,
-      int *hotdrop)
+match_v1(const struct sk_buff *skb,
+	 const struct net_device *in,
+	 const struct net_device *out,
+	 const void *matchinfo,
+	 int offset,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	 const void *hdr,
+	 u_int16_t datalen,
+#endif
+	 int *hotdrop)
 {
-	const struct udphdr *udp = hdr;
-	const struct ipt_multiport *multiinfo = matchinfo;
+	u16 _ports[2], *pptr;
+	const struct ipt_multiport_v1 *multiinfo = matchinfo;
+
+	if (offset)
+		return 0;
 
-	/* Must be big enough to read ports. */
-	if (offset == 0 && datalen < sizeof(struct udphdr)) {
+	pptr = skb_header_pointer(skb, skb->nh.iph->ihl * 4,
+				  sizeof(_ports), _ports);
+	if (pptr == NULL) {
 		/* We've been asked to examine this packet, and we
-		   can't.  Hence, no choice but to drop. */
-			duprintf("ipt_multiport:"
-				 " Dropping evil offset=0 tinygram.\n");
-			*hotdrop = 1;
-			return 0;
+		 * can't.  Hence, no choice but to drop.
+		 */
+		duprintf("ipt_multiport:"
+			 " Dropping evil offset=0 tinygram.\n");
+		*hotdrop = 1;
+		return 0;
 	}
 
-	/* Must not be a fragment. */
-	return !offset
-		&& ports_match(multiinfo->ports,
-			       multiinfo->flags, multiinfo->count,
-			       ntohs(udp->source), ntohs(udp->dest));
+	return ports_match_v1(multiinfo, ntohs(pptr[0]), ntohs(pptr[1]));
 }
 
-/* Called when user tries to insert an entry of this type. */
 static int
-checkentry(const char *tablename,
-	   const struct ipt_ip *ip,
-	   void *matchinfo,
-	   unsigned int matchsize,
-	   unsigned int hook_mask)
+checkentry_v1(const char *tablename,
+	      const struct ipt_ip *ip,
+	      void *matchinfo,
+	      unsigned int matchsize,
+	      unsigned int hook_mask)
 {
-	const struct ipt_multiport *multiinfo = matchinfo;
+	const struct ipt_multiport_v1 *multiinfo = matchinfo;
 
-	if (matchsize != IPT_ALIGN(sizeof(struct ipt_multiport)))
-		return 0;
-
-	/* Must specify proto == TCP/UDP, no unknown flags or bad count */
-	return (ip->proto == IPPROTO_TCP || ip->proto == IPPROTO_UDP)
+	/* Must specify supported protocol, no unknown flags or bad count */
+	return (ip->proto == IPPROTO_TCP || ip->proto == IPPROTO_UDP
+		|| ip->proto == IPPROTO_SCTP)
 		&& !(ip->invflags & IPT_INV_PROTO)
-		&& matchsize == IPT_ALIGN(sizeof(struct ipt_multiport))
+		&& matchsize == IPT_ALIGN(sizeof(struct ipt_multiport_v1))
 		&& (multiinfo->flags == IPT_MULTIPORT_SOURCE
 		    || multiinfo->flags == IPT_MULTIPORT_DESTINATION
 		    || multiinfo->flags == IPT_MULTIPORT_EITHER)
 		&& multiinfo->count <= IPT_MULTI_PORTS;
 }
 
-static struct ipt_match multiport_match
-= { { NULL, NULL }, "multiport", &match, &checkentry, NULL, THIS_MODULE };
+static struct ipt_match multiport_match_v1 = {
+	.name		= "multiport",
+	.match		= &match_v1,
+	.checkentry	= &checkentry_v1,
+	.me		= THIS_MODULE,
+};
 
 static int __init init(void)
 {
-	return ipt_register_match(&multiport_match);
+	return ipt_register_match(&multiport_match_v1);
 }
 
 static void __exit fini(void)
 {
-	ipt_unregister_match(&multiport_match);
+	ipt_unregister_match(&multiport_match_v1);
 }
 
 module_init(init);
 module_exit(fini);
-MODULE_LICENSE("GPL");
diff -urB linux-2.4.37.orig/net/ipv6/netfilter/ip6t_multiport.c linux/net/ipv6/netfilter/ip6t_multiport.c
--- linux-2.4.37.orig/net/ipv6/netfilter/ip6t_multiport.c	2009-04-19 22:33:42.000000000 +0400
+++ linux/net/ipv6/netfilter/ip6t_multiport.c	2009-05-25 14:34:51.000000000 +0400
@@ -1,5 +1,14 @@
 /* Kernel module to match one of a list of TCP/UDP ports: ports are in
    the same place so we can treat them as equal. */
+
+/* (C) 1999-2001 Paul `Rusty' Russell
+ * (C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/udp.h>
@@ -9,6 +18,10 @@
 #include <linux/netfilter_ipv6/ip6t_multiport.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
+MODULE_DESCRIPTION("iptables multiple port match module");
+
 #if 0
 #define duprintf(format, args...) printk(format , ## args)
 #else
@@ -17,35 +30,63 @@
 
 /* Returns 1 if the port is matched by the test, 0 otherwise. */
 static inline int
-ports_match(const u_int16_t *portlist, enum ip6t_multiport_flags flags,
-	    u_int8_t count, u_int16_t src, u_int16_t dst)
+ports_match_v1(const struct ip6t_multiport_v1 *minfo,
+               u_int16_t src, u_int16_t dst)
 {
 	unsigned int i;
-	for (i=0; i<count; i++) {
-		if (flags != IP6T_MULTIPORT_DESTINATION
-		    && portlist[i] == src)
-			return 1;
-
-		if (flags != IP6T_MULTIPORT_SOURCE
-		    && portlist[i] == dst)
-			return 1;
-	}
+	u_int16_t s, e;
 
-	return 0;
+	for (i=0; i < minfo->count; i++) {
+		s = minfo->ports[i];
+
+		if (minfo->pflags[i]) {
+			/* range port matching */
+			e = minfo->ports[++i];
+			duprintf("src or dst matches with %d-%d?\n", s, e);
+
+			if (minfo->flags == IP6T_MULTIPORT_SOURCE
+			    && src >= s && src <= e)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IP6T_MULTIPORT_DESTINATION
+			    && dst >= s && dst <= e)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IP6T_MULTIPORT_EITHER
+			    && ((dst >= s && dst <= e)
+				|| (src >= s && src <= e)))
+				return 1 ^ minfo->invert;
+		} else {
+			/* exact port matching */
+			duprintf("src or dst matches with %d?\n", s);
+
+			if (minfo->flags == IP6T_MULTIPORT_SOURCE
+			    && src == s)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IP6T_MULTIPORT_DESTINATION
+			    && dst == s)
+				return 1 ^ minfo->invert;
+			if (minfo->flags == IP6T_MULTIPORT_EITHER
+			    && (src == s || dst == s))
+				return 1 ^ minfo->invert;
+		}
+	}
+ 
+ 	return minfo->invert;
 }
 
 static int
-match(const struct sk_buff *skb,
+match_v1(const struct sk_buff *skb,
       const struct net_device *in,
       const struct net_device *out,
       const void *matchinfo,
       int offset,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
       const void *hdr,
       u_int16_t datalen,
+#endif
       int *hotdrop)
 {
 	const struct udphdr *udp = hdr;
-	const struct ip6t_multiport *multiinfo = matchinfo;
+	const struct ip6t_multiport_v1 *multiinfo = matchinfo;
 
 	/* Must be big enough to read ports. */
 	if (offset == 0 && datalen < sizeof(struct udphdr)) {
@@ -59,45 +100,46 @@
 
 	/* Must not be a fragment. */
 	return !offset
-		&& ports_match(multiinfo->ports,
-			       multiinfo->flags, multiinfo->count,
-			       ntohs(udp->source), ntohs(udp->dest));
+		&& ports_match_v1(multiinfo,
+			ntohs(udp->source), ntohs(udp->dest));
 }
 
 /* Called when user tries to insert an entry of this type. */
 static int
-checkentry(const char *tablename,
+checkentry_v1(const char *tablename,
 	   const struct ip6t_ip6 *ip,
 	   void *matchinfo,
 	   unsigned int matchsize,
 	   unsigned int hook_mask)
 {
-	const struct ip6t_multiport *multiinfo = matchinfo;
-
-	if (matchsize != IP6T_ALIGN(sizeof(struct ip6t_multiport)))
-		return 0;
+	const struct ip6t_multiport_v1 *multiinfo = matchinfo;
 
-	/* Must specify proto == TCP/UDP, no unknown flags or bad count */
-	return (ip->proto == IPPROTO_TCP || ip->proto == IPPROTO_UDP)
+	/* Must specify supported protocol, no unknown flags or bad count */
+	return (ip->proto == IPPROTO_TCP || ip->proto == IPPROTO_UDP
+		|| ip->proto == IPPROTO_SCTP)
 		&& !(ip->invflags & IP6T_INV_PROTO)
-		&& matchsize == IP6T_ALIGN(sizeof(struct ip6t_multiport))
+		&& matchsize == IP6T_ALIGN(sizeof(struct ip6t_multiport_v1))
 		&& (multiinfo->flags == IP6T_MULTIPORT_SOURCE
 		    || multiinfo->flags == IP6T_MULTIPORT_DESTINATION
 		    || multiinfo->flags == IP6T_MULTIPORT_EITHER)
 		&& multiinfo->count <= IP6T_MULTI_PORTS;
 }
 
-static struct ip6t_match multiport_match
-= { { NULL, NULL }, "multiport", &match, &checkentry, NULL, THIS_MODULE };
+static struct ip6t_match multiport_match_v1 = {
+	.name		= "multiport",
+	.match		= &match_v1,
+	.checkentry	= &checkentry_v1,
+	.me		= THIS_MODULE,
+};
 
 static int __init init(void)
 {
-	return ip6t_register_match(&multiport_match);
+	return ip6t_register_match(&multiport_match_v1);
 }
 
 static void __exit fini(void)
 {
-	ip6t_unregister_match(&multiport_match);
+	ip6t_unregister_match(&multiport_match_v1);
 }
 
 module_init(init);
