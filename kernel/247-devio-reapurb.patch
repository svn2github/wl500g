From 6ff10464096540e14d7575a72c50d0316d003714
From: Alan Stern
Date: Mon, 9 Mar 2009 13:44:02 -0400
Subject: [PATCH] USB: usbfs: keep async URBs until the device file is closed

The usbfs driver manages a list of completed asynchronous URBs.  But
it is too eager to free the entries on this list: destroy_async() gets
called whenever an interface is unbound or a device is removed, and it
deallocates the outstanding struct async entries for all URBs on that
interface or device.  This is wrong; the user program should be able
to reap an URB any time after it has completed, regardless of whether
or not the interface is still bound or the device is still present.

This patch (as1222) moves the code for deallocating the completed list
entries from destroy_async() to usbdev_release().  The outstanding
entries won't be freed until the user program has closed the device
file, thereby eliminating any possibility that the remaining URBs
might still be reaped.

This fixes a bug in which a program can hang in the USBDEVFS_REAPURB
ioctl when the device is unplugged.

Reported-and-tested-by: Martin Poupe <martin.poupe@upek.com>
Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/usb/devio.c
+++ b/drivers/usb/devio.c
@@ -274,8 +274,6 @@ static void destroy_async (struct dev_state *ps, struct list_head *list)
 		spin_lock_irqsave(&ps->lock, flags);
 	}
 	spin_unlock_irqrestore(&ps->lock, flags);
-	while ((as = async_getcompleted(ps)))
-		free_async(as);
 }
 
 static void destroy_async_on_interface (struct dev_state *ps, unsigned int intf)
@@ -529,6 +527,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 {
 	struct dev_state *ps = (struct dev_state *)file->private_data;
 	unsigned int i;
+	struct async *as;
 
 	lock_kernel();
 	list_del_init(&ps->list);
@@ -539,6 +538,8 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	}
 	unlock_kernel();
 	destroy_all_async(ps);
+	while ((as = async_getcompleted(ps)))
+		free_async(as);
 	kfree(ps);
         return 0;
 }
