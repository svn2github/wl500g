diff -BurN router/utils/etc53xx.h gateway/utils/etc53xx.h
--- router/utils/etc53xx.h	1970-01-01 03:00:00.000000000 +0300
+++ gateway/utils/etc53xx.h	2008-03-19 20:07:26.000000000 +0300
@@ -0,0 +1,620 @@
+/*
+ * Broadcom Home Gateway Reference Design
+ * BCM53xx Register definitions
+ *
+ * Copyright 2004, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id: etc53xx.h,v 1.1 2005/05/14 13:15:46 nbd Exp $
+ */
+
+#ifndef __BCM535M_H_
+#define __BCM535M_H_
+
+/* ROBO embedded device type */
+#define ROBO_DEV_5380 1
+#define ROBO_DEV_5365 2
+#define ROBO_DEV_5350 3
+
+/* BCM5325m GLOBAL PAGE REGISTER MAP */
+#ifndef _CFE_
+#pragma pack(1)
+#endif
+
+/* BCM5325m Serial Management Port (SMP) Page offsets */
+#define ROBO_CTRL_PAGE        0x00  /* Control registers */
+#define ROBO_STAT_PAGE        0x01  /* Status register */
+#define ROBO_MGMT_PAGE        0x02  /* Management Mode registers */
+#define ROBO_MIB_AC_PAGE      0x03  /* MIB Autocast registers */
+#define ROBO_ARLCTRL_PAGE     0x04  /* ARL Control Registers */
+#define ROBO_ARLIO_PAGE       0x05  /* ARL Access Registers */
+#define ROBO_FRAMEBUF_PAGE    0x06  /* Management frame access registers */
+#define ROBO_MEM_ACCESS_PAGE  0x08  /* Memory access registers */
+
+/* PHY Registers */
+#define ROBO_PORT0_MII_PAGE    0x10 /* Port 0 MII Registers */
+#define ROBO_PORT1_MII_PAGE    0x11 /* Port 1 MII Registers */
+#define ROBO_PORT2_MII_PAGE    0x12 /* Port 2 MII Registers */
+#define ROBO_PORT3_MII_PAGE    0x13 /* Port 3 MII Registers */
+#define ROBO_PORT4_MII_PAGE    0x14 /* Port 4 MII Registers */
+/* (start) registers only for BCM5380 */
+#define ROBO_PORT5_MII_PAGE    0x15 /* Port 5 MII Registers */
+#define ROBO_PORT6_MII_PAGE    0x16 /* Port 6 MII Registers */
+#define ROBO_PORT7_MII_PAGE    0x17 /* Port 7 MII Registers */
+/* (end) registers only for BCM5380 */
+#define ROBO_IM_PORT_PAGE      0x18 /* Inverse MII Port (to EMAC) */
+#define ROBO_ALL_PORT_PAGE     0x19 /* All ports MII Registers (broadcast)*/
+
+/* MAC Statistics registers */
+#define ROBO_PORT0_MIB_PAGE       0x20 /* Port 0 10/100 MIB Statistics */
+#define ROBO_PORT1_MIB_PAGE       0x21 /* Port 1 10/100 MIB Statistics */
+#define ROBO_PORT2_MIB_PAGE       0x22 /* Port 2 10/100 MIB Statistics */
+#define ROBO_PORT3_MIB_PAGE       0x23 /* Port 3 10/100 MIB Statistics */
+#define ROBO_PORT4_MIB_PAGE       0x24 /* Port 4 10/100 MIB Statistics */
+/* (start) registers only for BCM5380 */
+#define ROBO_PORT5_MIB_PAGE       0x25 /* Port 5 10/100 MIB Statistics */
+#define ROBO_PORT6_MIB_PAGE       0x26 /* Port 6 10/100 MIB Statistics */
+#define ROBO_PORT7_MIB_PAGE       0x27 /* Port 7 10/100 MIB Statistics */
+/* (end) registers only for BCM5380 */
+#define ROBO_IM_PORT_MIB_PAGE     0x28 /* Inverse MII Port MIB Statistics */
+
+/* Quality of Service (QoS) Registers */
+#define ROBO_QOS_PAGE             0x30 /* QoS Registers */
+
+/* VLAN Registers */
+#define ROBO_VLAN_PAGE            0x34 /* VLAN Registers */
+
+/* Note SPI Data/IO Registers not used */
+#define ROBO_SPI_DATA_IO_0_PAGE   0xf0 /* SPI Data I/O 0 */
+#define ROBO_SPI_DATA_IO_1_PAGE   0xf1 /* SPI Data I/O 1 */
+#define ROBO_SPI_DATA_IO_2_PAGE   0xf2 /* SPI Data I/O 2 */
+#define ROBO_SPI_DATA_IO_3_PAGE   0xf3 /* SPI Data I/O 3 */
+#define ROBO_SPI_DATA_IO_4_PAGE   0xf4 /* SPI Data I/O 4 */
+#define ROBO_SPI_DATA_IO_5_PAGE   0xf5 /* SPI Data I/O 5 */
+#define ROBO_SPI_DATA_IO_6_PAGE   0xf6 /* SPI Data I/O 6 */
+#define ROBO_SPI_DATA_IO_7_PAGE   0xf7 /* SPI Data I/O 7 */
+
+#define ROBO_SPI_STATUS_PAGE      0xfe /* SPI Status Registers */
+#define ROBO_PAGE_PAGE            0xff /* Page Registers */
+
+
+/* BCM5325m CONTROL PAGE (0x00) REGISTER MAP : 8bit (byte) registers */
+typedef struct _ROBO_PORT_CTRL_STRUC
+{
+    unsigned char   rx_disable:1;   /* rx disable */
+    unsigned char   tx_disable:1;   /* tx disable */
+    unsigned char   rsvd:3;         /* reserved */
+    unsigned char   stp_state:3;    /* spanning tree state */
+} ROBO_PORT_CTRL_STRUC;
+
+#define ROBO_PORT0_CTRL           0x00 /* 10/100 Port 0 Control */
+#define ROBO_PORT1_CTRL           0x01 /* 10/100 Port 1 Control */
+#define ROBO_PORT2_CTRL           0x02 /* 10/100 Port 2 Control */
+#define ROBO_PORT3_CTRL           0x03 /* 10/100 Port 3 Control */
+#define ROBO_PORT4_CTRL           0x04 /* 10/100 Port 4 Control */
+/* (start) registers only for BCM5380 */
+#define ROBO_PORT5_CTRL           0x05 /* 10/100 Port 5 Control */
+#define ROBO_PORT6_CTRL           0x06 /* 10/100 Port 6 Control */
+#define ROBO_PORT7_CTRL           0x07 /* 10/100 Port 7 Control */
+/* (end) registers only for BCM5380 */
+#define ROBO_IM_PORT_CTRL         0x08 /* 10/100 Port 8 Control */
+#define ROBO_SMP_CTRL             0x0a /* SMP Control register */
+#define ROBO_SWITCH_MODE          0x0b /* Switch Mode Control */
+#define ROBO_PORT_OVERRIDE_CTRL   0x0e /* Port state override */
+#define ROBO_PORT_OVERRIDE_RVMII  (1<<4) /* Bit 4 enables RvMII */
+#define ROBO_PD_MODE_CTRL         0x0f /* Power-down mode control */
+#define ROBO_IP_MULTICAST_CTRL    0x21 /* IP Multicast control */
+
+/* BCM5325m STATUS PAGE (0x01) REGISTER MAP : 16bit/48bit registers */
+#define ROBO_HALF_DUPLEX 0
+#define ROBO_FULL_DUPLEX 1
+
+#define ROBO_LINK_STAT_SUMMARY    0x00 /* Link Status Summary: 16bit */
+#define ROBO_LINK_STAT_CHANGE     0x02 /* Link Status Change: 16bit */
+#define ROBO_SPEED_STAT_SUMMARY   0x04 /* Port Speed Summary: 16bit*/
+#define ROBO_DUPLEX_STAT_SUMMARY  0x06 /* Duplex Status Summary: 16bit */
+#define ROBO_PAUSE_STAT_SUMMARY   0x08 /* PAUSE Status Summary: 16bit */
+#define ROBO_SOURCE_ADDR_CHANGE   0x0C /* Source Address Change: 16bit	*/
+#define ROBO_LSA_PORT0            0x10 /* Last Source Addr, Port 0: 48bits*/
+#define ROBO_LSA_PORT1            0x16 /* Last Source Addr, Port 1: 48bits*/
+#define ROBO_LSA_PORT2            0x1c /* Last Source Addr, Port 2: 48bits*/
+#define ROBO_LSA_PORT3            0x22 /* Last Source Addr, Port 3: 48bits*/
+#define ROBO_LSA_PORT4            0x28 /* Last Source Addr, Port 4: 48bits*/
+#define ROBO_LSA_IM_PORT          0x40 /* Last Source Addr, IM Port: 48bits*/
+
+/* BCM5325m MANAGEMENT MODE REGISTERS (0x02) REGISTER MAP: 8/48 bit regs*/
+typedef struct _ROBO_GLOBAL_CONFIG_STRUC
+{
+    unsigned char   resetMIB:1;         /* reset MIB counters */
+    unsigned char   rxBPDU:1;           /* receive BDPU enable */
+    unsigned char   rsvd1:2;            /* reserved */
+    unsigned char   MIBacHdrCtrl:1;     /* MIB autocast header control */
+    unsigned char   MIBac:1;            /* MIB autocast enable */
+    unsigned char   frameMgmtPort:2;    /* frame management port */
+} ROBO_GLOBAL_CONFIG_STRUC;
+#define ROBO_GLOBAL_CONFIG        0x00 /* Global Management Config: 8bit*/
+#define ROBO_MGMT_PORT_ID         0x02 /* Management Port ID: 8bit*/
+#define ROBO_RMON_MIB_STEER       0x04 /* RMON Mib Steering: 16bit */
+#define ROBO_MIB_MODE_SELECT      0x04 /* MIB Mode select: 16bit (BCM5350) */
+#define ROBO_AGE_TIMER_CTRL       0x06 /* Age time control: 32bit */
+#define ROBO_MIRROR_CAP_CTRL      0x10 /* Mirror Capture : 16bit */
+#define ROBO_MIRROR_ING_CTRL      0x12 /* Mirror Ingress Control: 16bit */
+#define ROBO_MIRROR_ING_DIV_CTRL  0x14 /* Mirror Ingress Divider: 16bit */
+#define ROBO_MIRROR_ING_MAC_ADDR  0x16 /* Ingress Mirror MAC Addr: 48bit*/
+#define ROBO_MIRROR_EGR_CTRL      0x1c /* Mirror Egress Control: 16bit */
+#define ROBO_MIRROR_EGR_DIV_CTRL  0x1e /* Mirror Egress Divider: 16bit */
+#define ROBO_MIRROR_EGR_MAC_ADDR  0x20 /* Egress Mirror MAC Addr: 48bit*/
+
+/* BCM5325m MIB AUTOCAST REGISTERS (0x03) REGISTER MAP: 8/16/48 bit regs */
+#define ROBO_MIB_AC_PORT          0x00 /* MIB Autocast Port: 16bit */
+#define ROBO_MIB_AC_HDR_PTR       0x02 /* MIB Autocast Header pointer:16bit*/ 
+#define ROBO_MIB_AC_HDR_LEN       0x04 /* MIB Autocast Header Len: 16bit */
+#define ROBO_MIB_AC_DA            0x06 /* MIB Autocast DA: 48bit */
+#define ROBO_MIB_AC_SA            0x0c /* MIB Autocast SA: 48bit */
+#define ROBO_MIB_AC_TYPE          0x12 /* MIB Autocast Type: 16bit */
+#define ROBO_MIB_AC_RATE          0x14 /* MIB Autocast Rate: 8bit */
+#define ROBO_GET_AC_RATE(secs) ((secs)*10)
+#define ROBO_AC_RATE_MAX          0xff
+#define ROBO_AC_RATE_DEFAULT      0x64  /* 10 secs */
+typedef struct _ROBO_MIB_AC_STRUCT
+{
+    unsigned char   opcode:4;       /* Tx MIB Autocast opcode */
+    unsigned char   portno:4;       /* zero-based port no. */
+    unsigned char   portstate:8;    /* port state */
+    unsigned long long TxOctets;   
+    unsigned int    TxDropPkts;
+    unsigned int    rsvd;
+    unsigned int    TxBroadcastPkts;
+    unsigned int    TxMulticastPkts;
+    unsigned int    TxUnicastPkts;
+    unsigned int    TxCollisions;
+    unsigned int    TxSingleCollision;
+    unsigned int    TxMultiCollision;
+    unsigned int    TxDeferredTransmit;
+    unsigned int    TxLateCollision;
+    unsigned int    TxExcessiveCollision;
+    unsigned int    TxFrameInDiscards;
+    unsigned int    TxPausePkts;
+    unsigned int    rsvd1[2];
+    unsigned long long RxOctets;
+    unsigned int    RxUndersizePkts;
+    unsigned int    RxPausePkts;
+    unsigned int    RxPkts64Octets;
+    unsigned int    RxPkts64to127Octets;
+    unsigned int    RxPkts128to255Octets;
+    unsigned int    RxPkts256to511Octets;
+    unsigned int    RxPkts512to1023Octets;
+    unsigned int    RxPkts1024to1522Octets;
+    unsigned int    RxOversizePkts;
+    unsigned int    RxJabbers;
+    unsigned int    RxAlignmentErrors;
+    unsigned int    RxFCSErrors;
+    unsigned long long RxGoodOctets;
+    unsigned int    RxDropPkts;
+    unsigned int    RxUnicastPkts;
+    unsigned int    RxMulticastPkts;
+    unsigned int    RxBroadcastPkts;
+    unsigned int    RxSAChanges;
+    unsigned int    RxFragments;
+    unsigned int    RxExcessSizeDisc;
+    unsigned int    RxSymbolError;
+} ROBO_MIB_AC_STRUCT;
+
+/* BCM5325m ARL CONTROL REGISTERS (0x04) REGISTER MAP: 8/16/48/64 bit regs */
+#define ROBO_ARL_CONFIG           0x00 /* ARL Global Configuration: 8bit*/
+#define ROBO_BPDU_MC_ADDR_REG     0x04 /* BPDU Multicast Address Reg:64bit*/
+#define ROBO_MULTIPORT_ADDR_1     0x10 /* Multiport Address 1: 48 bits*/
+#define ROBO_MULTIPORT_VECTOR_1   0x16 /* Multiport Vector 1: 16 bits */
+#define ROBO_MULTIPORT_ADDR_2     0x20 /* Multiport Address 2: 48 bits*/
+#define ROBO_MULTIPORT_VECTOR_2   0x26 /* Multiport Vector 2: 16 bits */
+#define ROBO_SECURE_SRC_PORT_MASK 0x30 /* Secure Source Port Mask: 16 bits*/
+#define ROBO_SECURE_DST_PORT_MASK 0x32 /* Secure Dest Port Mask: 16 bits */
+
+
+/* BCM5325m ARL IO REGISTERS (0x05) REGISTER MAP: 8/16/48/64 bit regs */
+#define ARL_TABLE_WRITE 0              /* for read/write state in control reg */
+#define ARL_TABLE_READ  1              /* for read/write state in control reg */
+#ifdef BCM5380
+#define ARL_VID_BYTES   2              /* number of bytes for VID */
+#else
+#define ARL_VID_BYTES   1              /* number of bytes for VID */
+#endif
+typedef struct _ROBO_ARL_RW_CTRL_STRUC
+{
+    unsigned char   ARLrw:1;    /* ARL read/write (1=read) */
+    unsigned char   rsvd:6;     /* reserved */
+    unsigned char   ARLStart:1; /* ARL start/done (1=start) */
+} ROBO_ARL_RW_CTRL_STRUC;
+typedef struct _ROBO_ARL_SEARCH_CTRL_STRUC
+{
+    unsigned char   valid:1;    /* ARL search result valid */
+    unsigned char   rsvd:6;     /* reserved */
+    unsigned char   ARLStart:1; /* ARL start/done (1=start) */
+} ROBO_ARL_SEARCH_CTRL_STRUC;
+typedef struct _ROBO_ARL_ENTRY_CTRL_STRUC
+{
+    unsigned char   portID:4;   /* port id */
+    unsigned char   chipID:2;   /* chip id */
+    unsigned char   rsvd:5;     /* reserved */
+    unsigned char   prio:2;     /* priority */
+    unsigned char   age:1;      /* age */
+    unsigned char   staticEn:1; /* static */
+    unsigned char   valid:1;    /* valid */
+} ROBO_ARL_ENTRY_CTRL_STRUC;
+typedef struct _ROBO_ARL_SEARCH_RESULT_CTRL_STRUC
+{
+    unsigned char   portID:4;   /* port id */
+    unsigned char   rsvd:1;     /* reserved */
+    unsigned char   vid:8;   	/* vlan id */
+    unsigned char   age:1;      /* age */
+    unsigned char   staticEn:1; /* static */
+    unsigned char   valid:1;    /* valid */
+} ROBO_ARL_SEARCH_RESULT_CTRL_STRUC;
+typedef struct _ROBO_ARL_ENTRY_MAC_STRUC
+{
+    unsigned char   macBytes[6];    /* MAC address */
+} ROBO_ARL_ENTRY_MAC_STRUC;
+
+typedef struct _ROBO_ARL_ENTRY_STRUC
+{
+    ROBO_ARL_ENTRY_MAC_STRUC    mac;    /* MAC address */
+    ROBO_ARL_ENTRY_CTRL_STRUC   ctrl;   /* control bits */
+} ROBO_ARL_ENTRY_STRUC;
+
+typedef struct _ROBO_ARL_SEARCH_RESULT_STRUC
+{
+    ROBO_ARL_ENTRY_MAC_STRUC    mac;    		/* MAC address */
+    ROBO_ARL_SEARCH_RESULT_CTRL_STRUC   ctrl;   /* control bits */
+} ROBO_ARL_SEARCH_RESULT_STRUC;
+
+/* multicast versions of ARL entry structs */
+typedef struct _ROBO_ARL_ENTRY_MCAST_CTRL_STRUC
+{
+    unsigned int    portMask:12;/* multicast port mask */
+    unsigned char   prio:1;     /* priority */
+    unsigned char   gigPort:1;  /* gigabit port 1 mask */
+    unsigned char   staticEn:1; /* static */
+    unsigned char   valid:1;    /* valid */
+} ROBO_ARL_ENTRY_MCAST_CTRL_STRUC;
+typedef struct _ROBO_ARL_SEARCH_RESULT_MCAST_CTRL_STRUC
+{
+    unsigned int    portMask:13;   	/* multicast port mask */
+    unsigned char   age:1;      	/* age */
+    unsigned char   staticEn:1; 	/* static */
+    unsigned char   valid:1;    	/* valid */
+} ROBO_ARL_SEARCH_RESULT_MCAST_CTRL_STRUC;
+/* BCM5350 extension register */
+typedef struct _ROBO_ARL_SEARCH_RESULT_EXTENSION
+{
+    unsigned int    prio:2;         /* priority */
+    unsigned int    portMask:1;     /* MSB (MII) of port mask for multicast */
+    unsigned int    reserved:5;
+} ROBO_ARL_SEARCH_RESULT_EXTENSION;
+
+typedef struct _ROBO_ARL_ENTRY_MCAST_STRUC
+{
+    ROBO_ARL_ENTRY_MAC_STRUC        mac;    /* MAC address */
+    ROBO_ARL_ENTRY_MCAST_CTRL_STRUC ctrl;   /* control bits */
+} ROBO_ARL_ENTRY_MCAST_STRUC;
+typedef struct _ROBO_ARL_SEARCH_RESULT_MCAST_STRUC
+{
+    ROBO_ARL_ENTRY_MAC_STRUC    mac;    				/* MAC address */
+    ROBO_ARL_SEARCH_RESULT_MCAST_CTRL_STRUC   ctrl;   	/* control bits */
+} ROBO_ARL_SEARCH_RESULT_MCAST_STRUC;
+
+#define ROBO_ARL_RW_CTRL          0x00 /* ARL Read/Write Control :  8bit */
+#define ROBO_ARL_MAC_ADDR_IDX     0x02 /* MAC Address Index: 48bit */
+#define ROBO_ARL_VID_TABLE_IDX    0x08 /* VID Table Address Index: 8bit */
+#define ROBO_ARL_ENTRY0           0x10 /* ARL Entry 0 : 64 bit */
+#define ROBO_ARL_ENTRY1           0x18 /* ARL Entry 1 : 64 bit */
+#define ROBO_ARL_SEARCH_CTRL      0x20 /* ARL Search Control: 8bit */
+#define ROBO_ARL_SEARCH_ADDR      0x22 /* ARL Search Address: 16bit */
+#define ROBO_ARL_SEARCH_RESULT    0x24 /* ARL Search Result: 64bit */
+#define ROBO_ARL_SEARCH_RESULT_EXT 0x2c /* ARL Search Result Extension (5350): 8bit */
+#define ROBO_ARL_VID_ENTRY0       0x30 /* ARL VID Entry 0: 64bit */
+#define ROBO_ARL_VID_ENTRY1       0x32 /* ARL VID Entry 1: 64bit */
+
+/* BCM5325m MANAGEMENT FRAME REGISTERS (0x6) REGISTER MAP: 8/16 bit regs */
+#define ROBO_MGMT_FRAME_RD_DATA   0x00 /* Management Frame Read Data :8bit*/
+#define ROBO_MGMT_FRAME_WR_DATA   0x01 /* Management Frame Write Data:8bit*/
+#define ROBO_MGMT_FRAME_WR_CTRL   0x02 /* Write Control: 16bit */
+#define ROBO_MGMT_FRAME_RD_STAT   0x04 /* Read Status: 16bit */
+
+/* BCM5325m MEMORY ACCESS REGISTERS (Page 0x08) REGISTER MAP: 32 bit regs */
+#define MEM_TABLE_READ  1               /* for read/write state in mem access reg */
+#define MEM_TABLE_WRITE 0               /* for read/write state in mem access reg */
+#define MEM_TABLE_ACCESS_START 1        /* for mem access read/write start */
+#define MEM_TABLE_ACCESS_DONE  0        /* for mem access read/write done */
+#define VLAN_TABLE_ADDR 0x3800          /* BCM5380 only */
+#ifdef BCM5380
+#define NUM_ARL_TABLE_ENTRIES 4096      /* number of entries in ARL table */
+#define NUM_VLAN_TABLE_ENTRIES 2048     /* number of entries in VLAN table */
+#define ARL_TABLE_ADDR 0                /* offset of ARL table start */
+#else
+#define NUM_ARL_TABLE_ENTRIES 2048      /* number of entries in ARL table */
+#define NUM_VLAN_TABLE_ENTRIES 256      /* number of entries in VLAN table */
+#define ARL_TABLE_ADDR 0x3800           /* offset of ARL table start */
+/* corresponding values for 5350 */
+#define NUM_ARL_TABLE_ENTRIES_5350 1024 /* number of entries in ARL table (5350) */
+#define NUM_VLAN_TABLE_ENTRIES_5350 16  /* number of entries in VLAN table */
+#define ARL_TABLE_ADDR_5350 0x1c00      /* offset of ARL table start (5350) */
+#endif
+typedef struct _ROBO_MEM_ACCESS_CTRL_STRUC
+{
+    unsigned int    memAddr:14; /* 64-bit memory address */
+    unsigned char   rsvd:4;     /* reserved */
+    unsigned char   readEn:1;   /* read enable (0 == write) */
+    unsigned char   startDone:1;/* memory access start/done */
+    unsigned int    rsvd1:12;   /* reserved */
+} ROBO_MEM_ACCESS_CTRL_STRUC;
+typedef struct _ROBO_MEM_ACCESS_DATA_STRUC
+{
+    unsigned int    memData[2]; /* 64-bit data */
+    unsigned short  rsvd;       /* reserved */
+} ROBO_MEM_ACCESS_DATA_STRUC;
+
+#ifdef BCM5380
+typedef struct _ROBO_ARL_TABLE_DATA_STRUC
+{
+    unsigned char   MACaddr[6]; /* MAC addr */
+    unsigned int    portID:4;   /* port ID */
+    unsigned int    chipID:2;   /* chip ID */
+    unsigned int    rsvd:6;     /* reserved */
+    unsigned int    highPrio:1; /* high priority address */
+    unsigned int    age:1;      /* entry accessed/learned since ageing process */
+    unsigned int    staticAddr:1;/* entry is static */
+    unsigned int    valid:1;    /* entry is valid */
+    unsigned int    vid:12;     /* vlan id */
+    unsigned int    rsvd2:4;    /* reserved */
+} ROBO_ARL_TABLE_DATA_STRUC;
+#else
+typedef struct _ROBO_ARL_TABLE_DATA_STRUC
+{
+    unsigned char   MACaddr[6]; /* MAC addr */
+    unsigned int    portID:4;   /* port ID */
+    unsigned int    chipID:2;   /* chip ID */
+    unsigned int    rsvd:7;     /* reserved */
+    unsigned int    age:1;      /* entry accessed/learned since ageing process */
+    unsigned int    staticAddr:1;/* entry is static */
+    unsigned int    valid:1;    /* entry is valid */
+} ROBO_ARL_TABLE_DATA_STRUC;
+#endif
+
+/* multicast format*/
+typedef struct _ROBO_ARL_TABLE_MCAST_DATA_STRUC
+{
+    unsigned char   MACaddr[6]; /* MAC addr */
+    unsigned int    portMask:12;/* multicast port mask */
+    unsigned char   prio:1;     /* priority */
+    unsigned char   gigPort:1;  /* gigabit port 1 mask */
+    unsigned char   staticEn:1; /* static */
+    unsigned char   valid:1;    /* valid */
+    unsigned int    vid:12;     /* vlan id */
+    unsigned int    rsvd2:4;    /* reserved */
+} ROBO_ARL_TABLE_MCAST_DATA_STRUC;
+#define ROBO_MEM_ACCESS_CTRL      0x00 /* Memory Read/Write Control :32bit*/
+#define ROBO_MEM_ACCESS_DATA      0x04 /* Memory Read/Write Data:64bit*/
+
+/* BCM5325m SWITCH PORT (0x10-18) REGISTER MAP: 8/16 bit regs */
+typedef struct _ROBO_MII_CTRL_STRUC
+{
+    unsigned char   rsvd:8;     /* reserved */
+    unsigned char   duplex:1;   /* duplex mode */
+    unsigned char   restartAN:1;/* restart auto-negotiation */
+    unsigned char   rsvd1:1;    /* reserved */
+    unsigned char   powerDown:1;/* power down */
+    unsigned char   ANenable:1; /* auto-negotiation enable */
+    unsigned char   speed:1;    /* forced speed selection */
+    unsigned char   loopback:1; /* loopback */
+    unsigned char   reset:1;    /* reset */
+} ROBO_MII_CTRL_STRUC;
+typedef struct _ROBO_MII_AN_ADVERT_STRUC
+{
+    unsigned char   selector:5;     /* advertise selector field */
+    unsigned char   T10BaseT:1;     /* advertise 10BaseT */
+    unsigned char   T10BaseTFull:1; /* advertise 10BaseT, full duplex */
+    unsigned char   T100BaseX:1;    /* advertise 100BaseX */
+    unsigned char   T100BaseXFull:1;/* advertise 100BaseX full duplex */
+    unsigned char   noT4:1;         /* do not advertise T4 */
+    unsigned char   pause:1;        /* advertise pause for full duplex */
+    unsigned char   rsvd:2;         /* reserved */
+    unsigned char   remoteFault:1;  /* transmit remote fault */
+    unsigned char   rsvd1:1;        /* reserved */
+    unsigned char   nextPage:1;     /* nex page operation supported */
+} ROBO_MII_AN_ADVERT_STRUC;
+#define ROBO_MII_CTRL                 0x00 /* Port MII Control */
+#define ROBO_MII_STAT                 0x02 /* Port MII Status  */
+/* Fields of link status register */
+#define ROBO_MII_STAT_JABBER          (1<<1) /* Jabber detected */
+#define ROBO_MII_STAT_LINK            (1<<2) /* Link status */
+
+#define ROBO_MII_PHYID_HI             0x04 /* Port PHY ID High */
+#define ROBO_MII_PHYID_LO             0x06 /* Port PHY ID Low */
+#define ROBO_MII_ANA_REG              0x08 /* MII Auto-Neg Advertisement */
+#define ROBO_MII_ANP_REG              0x0a /* MII Auto-Neg Partner Ability */
+#define ROBO_MII_AN_EXP_REG           0x0c /* MII Auto-Neg Expansion */
+#define ROBO_MII_AN_NP_REG            0x0e /* MII next page */
+#define ROBO_MII_ANP_NP_REG           0x10 /* MII Partner next page */
+#define ROBO_MII_100BX_AUX_CTRL       0x20 /* 100BASE-X Auxiliary Control */
+#define ROBO_MII_100BX_AUX_STAT       0x22 /* 100BASE-X Auxiliary Status  */
+#define ROBO_MII_100BX_RCV_ERR_CTR    0x24 /* 100BASE-X Receive Error Ctr */
+#define ROBO_MII_100BX_RCV_FS_ERR     0x26 /* 100BASE-X Rcv False Sense Ctr */
+#define ROBO_MII_AUX_CTRL             0x30 /* Auxiliary Control/Status */
+/* Fields of Auxiliary control register */
+#define ROBO_MII_AUX_CTRL_FD         (1<<0) /* Full duplex link detected*/
+#define ROBO_MII_AUX_CTRL_SP100      (1<<1) /* Speed 100 indication */
+#define ROBO_MII_AUX_STATUS           0x32 /* Aux Status Summary */
+#define ROBO_MII_CONN_STATUS          0x34 /* Aux Connection Status */
+#define ROBO_MII_AUX_MODE2            0x36 /* Aux Mode 2 */
+#define ROBO_MII_AUX_ERR_STATUS       0x38 /* Aux Error and General Status */
+#define ROBO_MII_AUX_MULTI_PHY        0x3c /* Aux Multiple PHY Register*/
+#define ROBO_MII_BROADCOM_TEST        0x3e /* Broadcom Test Register */
+
+
+/* BCM5325m PORT MIB REGISTERS (Pages 0x20-0x24,0x28) REGISTER MAP: 64/32 */
+/* Tranmit Statistics */
+#define ROBO_MIB_TX_OCTETS            0x00 /* 64b: TxOctets */
+#define ROBO_MIB_TX_DROP_PKTS         0x08 /* 32b: TxDropPkts */
+#define ROBO_MIB_TX_BC_PKTS           0x10 /* 32b: TxBroadcastPkts */
+#define ROBO_MIB_TX_MC_PKTS           0x14 /* 32b: TxMulticastPkts */
+#define ROBO_MIB_TX_UC_PKTS           0x18 /* 32b: TxUnicastPkts */
+#define ROBO_MIB_TX_COLLISIONS        0x1c /* 32b: TxCollisions */
+#define ROBO_MIB_TX_SINGLE_COLLISIONS 0x20 /* 32b: TxSingleCollision */
+#define ROBO_MIB_TX_MULTI_COLLISIONS  0x24 /* 32b: TxMultiCollision */
+#define ROBO_MIB_TX_DEFER_TX          0x28 /* 32b: TxDeferred Transmit */
+#define ROBO_MIB_TX_LATE_COLLISIONS   0x2c /* 32b: TxLateCollision */
+#define ROBO_MIB_EXCESS_COLLISIONS    0x30 /* 32b: TxExcessiveCollision*/
+#define ROBO_MIB_FRAME_IN_DISCARDS    0x34 /* 32b: TxFrameInDiscards */
+#define ROBO_MIB_TX_PAUSE_PKTS        0x38 /* 32b: TxPausePkts */
+
+/* Receive Statistics */
+#define ROBO_MIB_RX_OCTETS            0x44 /* 64b: RxOctets */
+#define ROBO_MIB_RX_UNDER_SIZE_PKTS   0x4c /* 32b: RxUndersizePkts(runts)*/
+#define ROBO_MIB_RX_PAUSE_PKTS        0x50 /* 32b: RxPausePkts */
+#define ROBO_MIB_RX_PKTS_64           0x54 /* 32b: RxPkts64Octets */
+#define ROBO_MIB_RX_PKTS_65_TO_127    0x58 /* 32b: RxPkts64to127Octets*/
+#define ROBO_MIB_RX_PKTS_128_TO_255   0x5c /* 32b: RxPkts128to255Octets*/
+#define ROBO_MIB_RX_PKTS_256_TO_511   0x60 /* 32b: RxPkts256to511Octets*/
+#define ROBO_MIB_RX_PKTS_512_TO_1023  0x64 /* 32b: RxPkts512to1023Octets*/
+#define ROBO_MIB_RX_PKTS_1024_TO_1522 0x68 /* 32b: RxPkts1024to1522Octets*/
+#define ROBO_MIB_RX_OVER_SIZE_PKTS    0x6c /* 32b: RxOversizePkts*/
+#define ROBO_MIB_RX_JABBERS           0x70 /* 32b: RxJabbers*/
+#define ROBO_MIB_RX_ALIGNMENT_ERRORS  0x74 /* 32b: RxAlignmentErrors*/
+#define ROBO_MIB_RX_FCS_ERRORS        0x78 /* 32b: RxFCSErrors */
+#define ROBO_MIB_RX_GOOD_OCTETS       0x7c /* 32b: RxGoodOctets */
+#define ROBO_MIB_RX_DROP_PKTS         0x84 /* 32b: RxDropPkts */
+#define ROBO_MIB_RX_UC_PKTS           0x88 /* 32b: RxUnicastPkts */
+#define ROBO_MIB_RX_MC_PKTS           0x8c /* 32b: RxMulticastPkts */
+#define ROBO_MIB_RX_BC_PKTS           0x90 /* 32b: RxBroadcastPkts */
+#define ROBO_MIB_RX_SA_CHANGES        0x94 /* 32b: RxSAChanges */
+#define ROBO_MIB_RX_FRAGMENTS         0x98 /* 32b: RxFragments */
+#define ROBO_MIB_RX_EXCESS_SZ_DISC    0x9c /* 32b: RxExcessSizeDisc*/
+#define ROBO_MIB_RX_SYMBOL_ERROR      0xa0 /* 32b: RxSymbolError */
+
+/* BCM5350 MIB Statistics */
+/* Group 0 */
+#define ROBO_MIB_TX_GOOD_PKTS         0x00 /* 16b: TxGoodPkts */
+#define ROBO_MIB_TX_UNICAST_PKTS      0x02 /* 16b: TxUnicastPkts */
+#define ROBO_MIB_RX_GOOD_PKTS         0x04 /* 16b: RxGoodPkts */
+#define ROBO_MIB_RX_GOOD_UNICAST_PKTS 0x06 /* 16b: RxGoodUnicastPkts */
+/* Group 1 */
+#define ROBO_MIB_TX_COLLISION         0x00 /* 16b: TxCollision */
+#define ROBO_MIB_TX_OCTETS_5350       0x02 /* 16b: TxOctets */
+#define ROBO_MIB_RX_FCS_ERRORS_5350   0x04 /* 16b: RxFCSErrors */
+#define ROBO_MIB_RX_GOOD_OCTETS_5350  0x06 /* 16b: RxGoodOctets */
+
+/* BCM5325m QoS REGISTERS (Page 0x30) REGISTER MAP: 8/16 */
+#define ROBO_QOS_CTRL                 0x00 /* 16b: QoS Control Register */
+#define ROBO_QOS_LOCAL_WEIGHT_CTRL    0x10 /* 8b: Local HQ/LQ Weight Register*/
+#define ROBO_QOS_CPU_WEIGHT_CTRL      0x12 /* 8b: CPU HQ/LQ Weight Register*/
+#define ROBO_QOS_PAUSE_ENA            0x13 /* 16b: Qos Pause Enable Register*/
+#define ROBO_QOS_PRIO_THRESHOLD       0x15 /* 8b: Priority Threshold Register*/
+#define ROBO_QOS_RESERVED             0x16 /* 8b: Qos Reserved Register */
+
+/* BCM5325m VLAN REGISTERS (Page 0x34) REGISTER MAP: 8/16bit */
+typedef struct _ROBO_VLAN_CTRL0_STRUC
+{
+    unsigned char   frameControlP:2;    /* 802.1P frame control */
+    unsigned char   frameControlQ:2;    /* 802.1Q frame control */
+    unsigned char   dropMissedVID:1;    /* enable drop missed VID packet */
+    unsigned char   vidMacHash:1;       /* VID_MAC hash enable */
+    unsigned char   vidMacCheck:1;      /* VID_MAC check enable */
+    unsigned char   VLANen:1;           /* 802.1Q VLAN enable */
+} ROBO_VLAN_CTRL0_STRUC;
+#define VLAN_TABLE_WRITE 1              /* for read/write state in table access reg */
+#define VLAN_TABLE_READ 0               /* for read/write state in table access reg */
+#define VLAN_ID_HIGH_BITS 0             /* static high bits in table access reg */
+#define VLAN_ID_MAX 255                 /* max VLAN id */
+#define VLAN_ID_MAX5350 15              /* max VLAN id (5350) */
+#define VLAN_ID_MASK VLAN_ID_MAX        /* VLAN id mask */
+#ifdef BCM5380
+#define VLAN_UNTAG_SHIFT 13             /* for postioning untag bits in write reg */
+#define VLAN_VALID 0x4000000             /* valid bit in write reg */
+#else
+#define VLAN_UNTAG_SHIFT 7              /* for postioning untag bits in write reg */
+#define VLAN_VALID 0x4000               /* valid bit in write reg */
+/* corresponding values for 5350 */
+#define VLAN_UNTAG_SHIFT_5350 6         /* for postioning untag bits in write reg */
+#define VLAN_VALID_5350 0x00100000      /* valid bit in write reg */
+#endif
+typedef struct _ROBO_VLAN_TABLE_ACCESS_STRUC
+{
+    unsigned char   VLANid:8;           /* VLAN ID (low 8 bits) */
+    unsigned char   VLANidHi:4;         /* VLAN ID (fixed upper portion) */
+    unsigned char   readWriteState:1;   /* read/write state (write = 1) */
+    volatile unsigned char   readWriteEnable:1;  /* table read/write enable */
+    unsigned char   rsvd:2;             /* reserved */
+} ROBO_VLAN_TABLE_ACCESS_STRUC;
+#ifdef BCM5380
+typedef struct _ROBO_VLAN_READ_WRITE_STRUC
+{
+    unsigned int    VLANgroup:13;/* VLAN group mask */
+    unsigned int    VLANuntag:13;/* VLAN untag enable mask */
+    unsigned char   valid:1;     /* valid */
+    unsigned char   rsvd:5;      /* reserved */
+} ROBO_VLAN_READ_WRITE_STRUC;
+#else
+typedef struct _ROBO_VLAN_READ_WRITE_STRUC
+{
+    unsigned char   VLANgroup:7;         /* VLAN group mask */
+    unsigned char   VLANuntag:7;         /* VLAN untag enable mask */
+    unsigned char   valid:1;             /* valid */
+    unsigned char   rsvd:1;              /* reserved */
+} ROBO_VLAN_READ_WRITE_STRUC;
+typedef struct _ROBO_VLAN_READ_WRITE_STRUC_5350
+{
+    unsigned char   VLANgroup:6;         /* VLAN group mask */
+    unsigned char   VLANuntag:6;         /* VLAN untag enable mask */
+    unsigned char   highVID:8;           /* upper bits of vid */
+    unsigned char   valid:1;             /* valid */
+    unsigned int    rsvd:11;             /* reserved */
+} ROBO_VLAN_READ_WRITE_STRUC_5350;
+#endif
+#define ROBO_VLAN_CTRL0             0x00 /* 8b: VLAN Control 0 Register */
+#define ROBO_VLAN_CTRL1             0x01 /* 8b: VLAN Control 1 Register */
+#define ROBO_VLAN_CTRL2             0x02 /* 8b: VLAN Control 2 Register */
+#define ROBO_VLAN_CTRL3             0x03 /* 8b: VLAN Control 3 Register */
+#define ROBO_VLAN_CTRL4             0x04 /* 8b: VLAN Control 4 Register */
+#define ROBO_VLAN_CTRL5             0x05 /* 8b: VLAN Control 5 Register */
+#define ROBO_VLAN_TABLE_ACCESS      0x08 /* 14b: VLAN Table Access Register */
+#define ROBO_VLAN_TABLE_ACCESS_5350 0x06 /* 14b: VLAN Table Access Register (5350) */
+#define ROBO_VLAN_WRITE             0x0a /* 15b: VLAN Write Register */
+#define ROBO_VLAN_WRITE_5350        0x08 /* 15b: VLAN Write Register (5350) */
+#define ROBO_VLAN_READ              0x0c /* 15b: VLAN Read Register */
+#define ROBO_VLAN_PORT0_DEF_TAG     0x10 /* 16b: VLAN Port 0 Default Tag Register */
+#define ROBO_VLAN_PORT1_DEF_TAG     0x12 /* 16b: VLAN Port 1 Default Tag Register */
+#define ROBO_VLAN_PORT2_DEF_TAG     0x14 /* 16b: VLAN Port 2 Default Tag Register */
+#define ROBO_VLAN_PORT3_DEF_TAG     0x16 /* 16b: VLAN Port 3 Default Tag Register */
+#define ROBO_VLAN_PORT4_DEF_TAG     0x18 /* 16b: VLAN Port 4 Default Tag Register */
+#define ROBO_VLAN_PORTMII_DEF_TAG   0x1a /* 16b: VLAN Port MII Default Tag Register */
+/* 5380 only */
+#define ROBO_VLAN_PORT5_DEF_TAG     0x1a /* 16b: VLAN Port 5 Default Tag Register */
+#define ROBO_VLAN_PORT6_DEF_TAG     0x1c /* 16b: VLAN Port 6 Default Tag Register */
+#define ROBO_VLAN_PORT7_DEF_TAG     0x1e /* 16b: VLAN Port 7 Default Tag Register */
+
+/* obsolete */
+#define ROBO_VLAN_PORT0_CTRL       0x00 /* 16b: Port 0 VLAN  Register */
+#define ROBO_VLAN_PORT1_CTRL       0x02 /* 16b: Port 1 VLAN  Register */
+#define ROBO_VLAN_PORT2_CTRL       0x04 /* 16b: Port 2 VLAN  Register */
+#define ROBO_VLAN_PORT3_CTRL       0x06 /* 16b: Port 3 VLAN  Register */
+#define ROBO_VLAN_PORT4_CTRL       0x08 /* 16b: Port 4 VLAN  Register */
+#define ROBO_VLAN_IM_PORT_CTRL     0x10 /* 16b: Inverse MII Port VLAN Reg */
+#define ROBO_VLAN_SMP_PORT_CTRL    0x12 /* 16b: Serial Port VLAN  Register */
+#define ROBO_VLAN_PORTSPI_DEF_TAG  0x1c /* 16b: VLAN Port SPI Default Tag Register */
+#define ROBO_VLAN_PRIORITY_REMAP   0x20 /* 24b: VLAN Priority Re-Map Register */
+
+#ifndef _CFE_
+#pragma pack()
+#endif
+
+
+#endif /* !__BCM535M_H_ */
+
+
+
+
+
diff -BurN router/utils/Makefile gateway/utils/Makefile
--- router/utils/Makefile	2004-10-14 23:11:33.000000000 +0400
+++ gateway/utils/Makefile	2008-12-02 11:10:50.000000000 +0300
@@ -12,7 +12,7 @@
 # $Id$
 #
 
-UTILS := epi_ttcp
+UTILS := wl nas mii-tool robocfg
 CFLAGS += -s -O2 -I$(SRCBASE)/include
 
 vpath %.c $(SRCBASE)/tools/misc
@@ -25,6 +25,11 @@
 
 all: $(UTILS)
 
+wl: $(SRCBASE)/wl/mipsel-uclibc/wl_exe.o
+	$(CC) $(CCFLAGS) -o $@ $<
+
+nas: $(SRCBASE)/wl/mipsel-uclibc/nas_exe.o
+	$(CC) $(CCFLAGS) -o $@ $< -L$(TOP)/shared  -L$(TOP)/nvram -lnvram -lshared
 
 clean:
 	rm -f *.o *~ $(UTILS)
@@ -33,3 +38,4 @@
 	install -d $(INSTALLDIR)/usr/sbin
 	install $(UTILS) $(INSTALLDIR)/usr/sbin
 	$(STRIP) $(foreach file,$(UTILS),$(INSTALLDIR)/usr/sbin/$(file))
+	ln -sf nas $(INSTALLDIR)/usr/sbin/nas4not
diff -BurN router/utils/mii.h gateway/utils/mii.h
--- router/utils/mii.h	1970-01-01 03:00:00.000000000 +0300
+++ gateway/utils/mii.h	2008-06-14 19:51:22.000000000 +0400
@@ -0,0 +1,100 @@
+/*
+ * mii.h 1.4 2000/04/25 22:06:15
+ *
+ * Media Independent Interface support: register layout and ioctl's
+ *
+ * Copyright (C) 2000 David A. Hinds -- dhinds@pcmcia.sourceforge.org
+ */
+
+#ifndef _LINUX_MII_H
+#define _LINUX_MII_H
+
+/* network interface ioctl's for MII commands */
+#ifndef SIOCGMIIPHY
+#define SIOCGMIIPHY (SIOCDEVPRIVATE)	/* Read from current PHY */
+#define SIOCGMIIREG (SIOCDEVPRIVATE+1) 	/* Read any PHY register */
+#define SIOCSMIIREG (SIOCDEVPRIVATE+2) 	/* Write any PHY register */
+#define SIOCGPARAMS (SIOCDEVPRIVATE+3) 	/* Read operational parameters */
+#define SIOCSPARAMS (SIOCDEVPRIVATE+4) 	/* Set operational parameters */
+#endif
+
+#include <linux/types.h>
+
+/* This data structure is used for all the MII ioctl's */
+struct mii_data {
+    __u16	phy_id;
+    __u16	reg_num;
+    __u16	val_in;
+    __u16	val_out;
+};
+
+/* Basic Mode Control Register */
+#define MII_BMCR		0x00
+#define  MII_BMCR_RESET		0x8000
+#define  MII_BMCR_LOOPBACK	0x4000
+#define  MII_BMCR_100MBIT	0x2000
+#define  MII_BMCR_AN_ENA	0x1000
+#define  MII_BMCR_ISOLATE	0x0400
+#define  MII_BMCR_RESTART	0x0200
+#define  MII_BMCR_DUPLEX	0x0100
+#define  MII_BMCR_COLTEST	0x0080
+#define  MII_BMCR_SPEED1000	0x0040
+
+/* Basic Mode Status Register */
+#define MII_BMSR		0x01
+#define  MII_BMSR_CAP_MASK	0xf800
+#define  MII_BMSR_100BASET4	0x8000
+#define  MII_BMSR_100BASETX_FD	0x4000
+#define  MII_BMSR_100BASETX_HD	0x2000
+#define  MII_BMSR_10BASET_FD	0x1000
+#define  MII_BMSR_10BASET_HD	0x0800
+#define  MII_BMSR_NO_PREAMBLE	0x0040
+#define  MII_BMSR_AN_COMPLETE	0x0020
+#define  MII_BMSR_REMOTE_FAULT	0x0010
+#define  MII_BMSR_AN_ABLE	0x0008
+#define  MII_BMSR_LINK_VALID	0x0004
+#define  MII_BMSR_JABBER	0x0002
+#define  MII_BMSR_EXT_CAP	0x0001
+
+#define MII_PHY_ID1		0x02
+#define MII_PHY_ID2		0x03
+
+/* Auto-Negotiation Advertisement Register */
+#define MII_ANAR		0x04
+/* Auto-Negotiation Link Partner Ability Register */
+#define MII_ANLPAR		0x05
+#define  MII_AN_NEXT_PAGE	0x8000
+#define  MII_AN_ACK		0x4000
+#define  MII_AN_REMOTE_FAULT	0x2000
+#define  MII_AN_ABILITY_MASK	0x07e0
+#define  MII_AN_FLOW_CONTROL	0x0400
+#define  MII_AN_100BASET4	0x0200
+#define  MII_AN_100BASETX_FD	0x0100
+#define  MII_AN_100BASETX_HD	0x0080
+#define  MII_AN_10BASET_FD	0x0040
+#define  MII_AN_10BASET_HD	0x0020
+#define  MII_AN_PROT_MASK	0x001f
+#define  MII_AN_PROT_802_3	0x0001
+
+/* Auto-Negotiation Expansion Register */
+#define MII_ANER		0x06
+#define  MII_ANER_MULT_FAULT	0x0010
+#define  MII_ANER_LP_NP_ABLE	0x0008
+#define  MII_ANER_NP_ABLE	0x0004
+#define  MII_ANER_PAGE_RX	0x0002
+#define  MII_ANER_LP_AN_ABLE	0x0001
+
+#define MII_CTRL1000		0x09
+#define   MII_BMCR2_1000FULL	0x0200
+#define   MII_BMCR2_1000HALF	0x0100
+
+#define MII_STAT1000		0x0a
+#define   MII_LPA2_1000LOCALOK  0x2000
+#define   MII_LPA2_1000REMRXOK	0x1000
+#define   MII_LPA2_1000FULL	0x0800
+#define   MII_LPA2_1000HALF	0x0400
+
+/* Last register we need for show_basic_mii() */
+#define MII_BASIC_MAX		(MII_STAT1000+1)
+
+#endif /* _LINUX_MII_H */
diff -BurN router/utils/mii-tool.c gateway/utils/mii-tool.c
--- router/utils/mii-tool.c	1970-01-01 03:00:00.000000000 +0300
+++ gateway/utils/mii-tool.c	2008-06-14 19:47:15.000000000 +0400
@@ -0,0 +1,493 @@
+/*
+
+    mii-tool: monitor and control the MII for a network interface
+
+    Usage:
+
+	mii-tool [-VvRrw] [-A media,... | -F media] [interface ...]
+
+    This program is based on Donald Becker's "mii-diag" program, which
+    is more capable and verbose than this tool, but also somewhat
+    harder to use.
+
+    Copyright (C) 2000 David A. Hinds -- dhinds@pcmcia.sourceforge.org
+
+    mii-diag is written/copyright 1997-2000 by Donald Becker
+        <becker@scyld.com>
+
+    This program is free software; you can redistribute it
+    and/or modify it under the terms of the GNU General Public
+    License as published by the Free Software Foundation.
+
+    Donald Becker may be reached as becker@scyld.com, or C/O
+    Scyld Computing Corporation, 410 Severn Av., Suite 210,
+    Annapolis, MD 21403
+
+    References
+	http://www.scyld.com/diag/mii-status.html
+	http://www.scyld.com/expert/NWay.html
+	http://www.national.com/pf/DP/DP83840.html
+*/
+
+static char version[] =
+"mii-tool.c 1.9 2000/04/28 00:56:08 (David Hinds)\n";
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <time.h>
+#include <syslog.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <linux/sockios.h>
+
+#ifndef __GLIBC__
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#endif
+#include "mii.h"
+
+#define MAX_ETH		8		/* Maximum # of interfaces */
+
+/* Table of known MII's */
+static const struct {
+    u_short	id1, id2;
+    const char	*name;
+} mii_id[] = {
+    { 0x0022, 0x5610, "AdHoc AH101LF" },
+    { 0x0022, 0x5520, "Altimata AC101LF" },
+    { 0x0000, 0x6b90, "AMD 79C901A HomePNA" },
+    { 0x0000, 0x6b70, "AMD 79C901A 10baseT" },
+    { 0x0181, 0xb800, "Davicom DM9101" },
+    { 0x0043, 0x7411, "Enable EL40-331" },
+    { 0x0015, 0xf410, "ICS 1889" },
+    { 0x0015, 0xf420, "ICS 1890" },
+    { 0x0015, 0xf430, "ICS 1892" },
+    { 0x02a8, 0x0150, "Intel 82555" },
+    { 0x7810, 0x0000, "Level One LXT970/971" },
+    { 0x2000, 0x5c00, "National DP83840A" },
+    { 0x0181, 0x4410, "Quality QS6612" },
+    { 0x0282, 0x1c50, "SMSC 83C180" },
+    { 0x0300, 0xe540, "TDK 78Q2120" },
+    { 0x0141, 0x0c20, "Yukon 88E1011" },
+    { 0x0141, 0x0cc0, "Yukon-EC 88E1111" },
+    { 0x0141, 0x0c90, "Yukon-2 88E1112" },
+};
+#define NMII (sizeof(mii_id)/sizeof(mii_id[0]))
+
+/*--------------------------------------------------------------------*/
+
+struct option longopts[] = {
+ /* { name  has_arg  *flag  val } */
+    {"advertise",	1, 0, 'A'},	/* Change capabilities advertised. */
+    {"force",		1, 0, 'F'},	/* Change capabilities advertised. */
+    {"phy",		1, 0, 'p'},	/* Set PHY (MII address) to report. */
+    {"log",		0, 0, 'l'},	/* Set PHY (MII address) to report. */
+    {"restart",		0, 0, 'r'},	/* Restart link negotiation */
+    {"reset",		0, 0, 'R'},	/* Reset the transceiver. */
+    {"verbose", 	0, 0, 'v'},	/* Report each action taken.  */
+    {"version", 	0, 0, 'V'},	/* Emit version information.  */
+    {"watch", 		0, 0, 'w'},	/* Constantly monitor the port.  */
+    {"help", 		0, 0, '?'},	/* Give help */
+    { 0, 0, 0, 0 }
+};
+
+static unsigned int
+    verbose = 0,
+    opt_version = 0,
+    opt_restart = 0,
+    opt_reset = 0,
+    opt_log = 0,
+    opt_watch = 0;
+static int nway_advertise = 0;
+static int fixed_speed = 0;
+static int override_phy = -1;
+
+static int skfd = -1;		/* AF_INET socket for ioctl() calls. */
+static struct ifreq ifr;
+
+/*--------------------------------------------------------------------*/
+
+static int mdio_read(int skfd, int location)
+{
+    struct mii_data *mii = (struct mii_data *)&ifr.ifr_data;
+    mii->reg_num = location;
+    if (ioctl(skfd, SIOCGMIIREG, &ifr) < 0) {
+	fprintf(stderr, "SIOCGMIIREG on %s failed: %s\n", ifr.ifr_name,
+		strerror(errno));
+	return -1;
+    }
+    return mii->val_out;
+}
+
+static void mdio_write(int skfd, int location, int value)
+{
+    struct mii_data *mii = (struct mii_data *)&ifr.ifr_data;
+    mii->reg_num = location;
+    mii->val_in = value;
+    if (ioctl(skfd, SIOCSMIIREG, &ifr) < 0) {
+	fprintf(stderr, "SIOCSMIIREG on %s failed: %s\n", ifr.ifr_name,
+		strerror(errno));
+    }
+}
+
+/*--------------------------------------------------------------------*/
+
+const struct {
+    char	*name;
+    u_short	value[2];
+} media[] = {
+    /* The order through 100baseT4 matches bits in the BMSR */
+    { "10baseT-HD",	{MII_AN_10BASET_HD} },
+    { "10baseT-FD",	{MII_AN_10BASET_FD} },
+    { "100baseTx-HD",	{MII_AN_100BASETX_HD} },
+    { "100baseTx-FD",	{MII_AN_100BASETX_FD} },
+    { "100baseT4",	{MII_AN_100BASET4} },
+    { "100baseTx",	{MII_AN_100BASETX_FD | MII_AN_100BASETX_HD} },
+    { "10baseT",	{MII_AN_10BASET_FD | MII_AN_10BASET_HD} },
+
+    { "1000baseT-HD",	{0, MII_BMCR2_1000HALF} },
+    { "1000baseT-FD",	{0, MII_BMCR2_1000FULL} },
+    { "1000baseT",	{0, MII_BMCR2_1000HALF|MII_BMCR2_1000FULL} },
+};
+#define NMEDIA (sizeof(media)/sizeof(media[0]))
+	
+/* Parse an argument list of media types */
+static int parse_media(char *arg, unsigned *bmcr2)
+{
+    int mask, i;
+    char *s;
+    mask = strtoul(arg, &s, 16);
+    if ((*arg != '\0') && (*s == '\0')) {
+	if ((mask & MII_AN_ABILITY_MASK) &&
+	    !(mask & ~MII_AN_ABILITY_MASK)) {
+		*bmcr2 = 0;
+		return mask;
+	}
+	goto failed;
+    }
+    mask = 0;
+    *bmcr2 = 0;
+    s = strtok(arg, ", ");
+    do {
+	    for (i = 0; i < NMEDIA; i++)
+		if (strcasecmp(media[i].name, s) == 0) break;
+	    if (i == NMEDIA) goto failed;
+	    mask |= media[i].value[0];
+	    *bmcr2 |= media[i].value[1];
+    } while ((s = strtok(NULL, ", ")) != NULL);
+
+    return mask;
+failed:
+    fprintf(stderr, "Invalid media specification '%s'.\n", arg);
+    return -1;
+}
+
+/*--------------------------------------------------------------------*/
+
+static const char *media_list(unsigned mask, unsigned mask2, int best)
+{
+    static char buf[100];
+    int i;
+    *buf = '\0';
+
+    if (mask & MII_BMCR_SPEED1000) {
+	if (mask2 & MII_BMCR2_1000HALF) {
+	    strcat(buf, " ");
+	    strcat(buf, "1000baseT-HD");
+	    if (best) goto out;
+	}
+	if (mask2 & MII_BMCR2_1000FULL) {
+	    strcat(buf, " ");
+	    strcat(buf, "1000baseT-FD");
+	    if (best) goto out;
+	}
+    }
+    mask >>= 5;
+    for (i = 4; i >= 0; i--) {
+	if (mask & (1<<i)) {
+	    strcat(buf, " ");
+	    strcat(buf, media[i].name);
+	    if (best) break;
+	}
+    }
+ out:
+    if (mask & (1<<5))
+	strcat(buf, " flow-control");
+    return buf;
+}
+
+int show_basic_mii(int sock, int phy_id)
+{
+    char buf[100];
+    int i, mii_val[32];
+    unsigned bmcr, bmsr, advert, lkpar, bmcr2, lpa2;
+
+    /* Some bits in the BMSR are latched, but we can't rely on being
+       the only reader, so only the current values are meaningful */
+    mdio_read(sock, MII_BMSR);
+    for (i = 0; i < ((verbose > 1) ? 32 : MII_BASIC_MAX); i++)
+	mii_val[i] = mdio_read(sock, i);
+
+    if (mii_val[MII_BMCR] == 0xffff) {
+	fprintf(stderr, "  No MII transceiver present!.\n");
+	return -1;
+    }
+
+    /* Descriptive rename. */
+    bmcr = mii_val[MII_BMCR]; bmsr = mii_val[MII_BMSR];
+    advert = mii_val[MII_ANAR]; lkpar = mii_val[MII_ANLPAR];
+    bmcr2 = mii_val[MII_CTRL1000]; lpa2 = mii_val[MII_STAT1000];
+
+    sprintf(buf, "%s: ", ifr.ifr_name);
+    if (bmcr & MII_BMCR_AN_ENA) {
+	if (bmsr & MII_BMSR_AN_COMPLETE) {
+	    if (advert & lkpar) {
+		strcat(buf, (lkpar & MII_AN_ACK) ?
+		       "negotiated" : "no autonegotiation,");
+		strcat(buf, media_list(advert & lkpar, bmcr2 & lpa2>>2, 1));
+		strcat(buf, ", ");
+	    } else {
+		strcat(buf, "autonegotiation failed, ");
+	    }
+	} else if (bmcr & MII_BMCR_RESTART) {
+	    strcat(buf, "autonegotiation restarted, ");
+	}
+    } else {
+	sprintf(buf+strlen(buf), "%s Mbit, %s duplex, ",
+		((bmcr2 & (MII_BMCR2_1000HALF | MII_BMCR2_1000FULL)) & lpa2 >> 2)
+		? "1000"
+		: (bmcr & MII_BMCR_100MBIT) ? "100" : "10",
+		(bmcr & MII_BMCR_DUPLEX) ? "full" : "half");
+    }
+    strcat(buf, (bmsr & MII_BMSR_LINK_VALID) ? "link ok" : "no link");
+
+    if (opt_watch) {
+	if (opt_log) {
+	    syslog(LOG_INFO, buf);
+	} else {
+	    char s[20];
+	    time_t t = time(NULL);
+	    strftime(s, sizeof(s), "%T", localtime(&t));
+	    printf("%s %s\n", s, buf);
+	}
+    } else {
+	printf("%s\n", buf);
+    }
+
+    if (verbose > 1) {
+	printf("  registers for MII PHY %d: ", phy_id);
+	for (i = 0; i < 32; i++)
+	    printf("%s %4.4x", ((i % 8) ? "" : "\n   "), mii_val[i]);
+	printf("\n");
+    }
+
+    if (verbose) {
+	printf("  product info: ");
+	for (i = 0; i < NMII; i++)
+	    if ((mii_id[i].id1 == mii_val[2]) &&
+		(mii_id[i].id2 == (mii_val[3] & 0xfff0)))
+		break;
+	if (i < NMII)
+	    printf("%s rev %d\n", mii_id[i].name, mii_val[3]&0x0f);
+	else
+	    printf("vendor %02x:%02x:%02x, model %d rev %d\n",
+		   mii_val[2]>>10, (mii_val[2]>>2)&0xff,
+		   ((mii_val[2]<<6)|(mii_val[3]>>10))&0xff,
+		   (mii_val[3]>>4)&0x3f, mii_val[3]&0x0f);
+	printf("  basic mode:   ");
+	if (bmcr & MII_BMCR_RESET)
+	    printf("software reset, ");
+	if (bmcr & MII_BMCR_LOOPBACK)
+	    printf("loopback, ");
+	if (bmcr & MII_BMCR_ISOLATE)
+	    printf("isolate, ");
+	if (bmcr & MII_BMCR_COLTEST)
+	    printf("collision test, ");
+	if (bmcr & MII_BMCR_AN_ENA) {
+	    printf("autonegotiation enabled\n");
+	} else {
+	    printf("%s Mbit, %s duplex\n",
+		   (bmcr & MII_BMCR_100MBIT) ? "100" : "10",
+		   (bmcr & MII_BMCR_DUPLEX) ? "full" : "half");
+	}
+	printf("  basic status: ");
+	if (bmsr & MII_BMSR_AN_COMPLETE)
+	    printf("autonegotiation complete, ");
+	else if (bmcr & MII_BMCR_RESTART)
+	    printf("autonegotiation restarted, ");
+	if (bmsr & MII_BMSR_REMOTE_FAULT)
+	    printf("remote fault, ");
+	printf((bmsr & MII_BMSR_LINK_VALID) ? "link ok" : "no link");
+	printf("\n  capabilities:%s", media_list(bmsr >> 6, bmcr2, 0));
+	printf("\n  advertising: %s", media_list(advert, lpa2 >> 2, 0));
+	if (lkpar & MII_AN_ABILITY_MASK)
+	    printf("\n  link partner:%s", media_list(lkpar, bmcr2, 0));
+	printf("\n");
+    }
+    return 0;
+}
+
+/*--------------------------------------------------------------------*/
+
+static int do_one_xcvr(int skfd, char *ifname, int maybe)
+{
+    struct mii_data *mii = (struct mii_data *)&ifr.ifr_data;
+
+    /* Get the vitals from the interface. */
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    if (ioctl(skfd, SIOCGMIIPHY, &ifr) < 0) {
+	if (!maybe || (errno != ENODEV))
+	    fprintf(stderr, "SIOCGMIIPHY on '%s' failed: %s\n",
+		    ifname, strerror(errno));
+	return 1;
+    }
+
+    if (override_phy >= 0) {
+	printf("using the specified MII index %d.\n", override_phy);
+	mii->phy_id = override_phy;
+    }
+
+    if (opt_reset) {
+	printf("resetting the transceiver...\n");
+	mdio_write(skfd, MII_BMCR, MII_BMCR_RESET);
+    }
+    if (nway_advertise) {
+	mdio_write(skfd, MII_ANAR, nway_advertise | 1);
+	opt_restart = 1;
+    }
+    if (opt_restart) {
+	printf("restarting autonegotiation...\n");
+	mdio_write(skfd, MII_BMCR, 0x0000);
+	mdio_write(skfd, MII_BMCR, MII_BMCR_AN_ENA|MII_BMCR_RESTART);
+    }
+    if (fixed_speed) {
+	int bmcr = 0;
+	if (fixed_speed & (MII_AN_100BASETX_FD|MII_AN_100BASETX_HD))
+	    bmcr |= MII_BMCR_100MBIT;
+	if (fixed_speed & (MII_AN_100BASETX_FD|MII_AN_10BASET_FD))
+	    bmcr |= MII_BMCR_DUPLEX;
+	mdio_write(skfd, MII_BMCR, bmcr);
+    }
+
+    if (!opt_restart && !opt_reset && !fixed_speed && !nway_advertise)
+	show_basic_mii(skfd, mii->phy_id);
+
+    return 0;
+}
+
+/*--------------------------------------------------------------------*/
+
+static void watch_one_xcvr(int skfd, char *ifname, int index)
+{
+    struct mii_data *mii = (struct mii_data *)&ifr.ifr_data;
+    static int status[MAX_ETH] = { 0, /* ... */ };
+    int now;
+
+    /* Get the vitals from the interface. */
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    if (ioctl(skfd, SIOCGMIIPHY, &ifr) < 0) {
+	if (errno != ENODEV)
+	    fprintf(stderr, "SIOCGMIIPHY on '%s' failed: %s\n",
+		    ifname, strerror(errno));
+	return;
+    }
+    now = (mdio_read(skfd, MII_BMCR) |
+	   (mdio_read(skfd, MII_BMSR) << 16));
+    if (status[index] && (status[index] != now))
+	show_basic_mii(skfd, mii->phy_id);
+    status[index] = now;
+}
+
+/*--------------------------------------------------------------------*/
+
+const char *usage =
+"usage: %s [-VvRrwl] [-A media,... | -F media] [interface ...]\n"
+"       -V, --version               display version information\n"
+"       -v, --verbose               more verbose output\n"
+"       -R, --reset                 reset MII to poweron state\n"
+"       -r, --restart               restart autonegotiation\n"
+"       -w, --watch                 monitor for link status changes\n"
+"       -l, --log                   with -w, write events to syslog\n"
+"       -A, --advertise=media,...   advertise only specified media\n"
+"       -F, --force=media           force specified media technology\n"
+"media: 100baseT4, 100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD,\n"
+"       (to advertise both HD and FD) 100baseTx, 10baseT\n";
+
+int main(int argc, char **argv)
+{
+    int i, c, ret, errflag = 0;
+    char s[6];
+    unsigned ctrl1000 = 0;
+    
+    while ((c = getopt_long(argc, argv, "A:F:p:lrRvVw?", longopts, 0)) != EOF)
+	switch (c) {
+	case 'A': nway_advertise = parse_media(optarg, &ctrl1000); break;
+	case 'F': fixed_speed = parse_media(optarg, &ctrl1000); break;
+	case 'p': override_phy = atoi(optarg); break;
+	case 'r': opt_restart++;	break;
+	case 'R': opt_reset++;		break;
+	case 'v': verbose++;		break;
+	case 'V': opt_version++;	break;
+	case 'w': opt_watch++;		break;
+	case 'l': opt_log++;		break;
+	case '?': errflag++;
+	}
+    /* Check for a few inappropriate option combinations */
+    if (opt_watch) verbose = 0;
+    if (errflag || (fixed_speed & (fixed_speed-1)) ||
+	(fixed_speed && (opt_restart || nway_advertise))) {
+	fprintf(stderr, usage, argv[0]);
+	return 2;
+    }
+
+    if (opt_version)
+	printf(version);
+
+    /* Open a basic socket. */
+    if ((skfd = socket(AF_INET, SOCK_DGRAM,0)) < 0) {
+	perror("socket");
+	exit(-1);
+    }
+
+    /* No remaining args means show all interfaces. */
+    if (optind == argc) {
+	ret = 1;
+	for (i = 0; i < MAX_ETH; i++) {
+	    sprintf(s, "eth%d", i);
+	    ret &= do_one_xcvr(skfd, s, 1);
+	}
+	if (ret)
+	    fprintf(stderr, "no MII interfaces found\n");
+    } else {
+	ret = 0;
+	for (i = optind; i < argc; i++) {
+	    ret |= do_one_xcvr(skfd, argv[i], 0);
+	}
+    }
+
+    if (opt_watch && (ret == 0)) {
+	while (1) {
+	    sleep(1);
+	    if (optind == argc) {
+		for (i = 0; i < MAX_ETH; i++) {
+		    sprintf(s, "eth%d", i);
+		    watch_one_xcvr(skfd, s, i);
+		}
+	    } else {
+		for (i = optind; i < argc; i++)
+		    watch_one_xcvr(skfd, argv[i], i-optind);
+	    }
+	}
+    }
+
+    close(skfd);
+    return ret;
+}
diff -BurN router/utils/robocfg.c gateway/utils/robocfg.c
--- router/utils/robocfg.c	1970-01-01 03:00:00.000000000 +0300
+++ gateway/utils/robocfg.c	2008-03-19 20:07:26.000000000 +0300
@@ -0,0 +1,619 @@
+/*
+ * Broadcom BCM5325E/536x switch configuration utility
+ *
+ * Copyright (C) 2005 Oleg I. Vdovikin
+ * Copyright (C) 2005 Dmitry 'dimss' Ivanov of "Telecentrs" (Riga, Latvia)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
+ * 02110-1301, USA.
+ */
+ 
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+
+/* linux stuff */
+typedef u_int64_t u64;
+typedef u_int32_t u32;
+typedef u_int16_t u16;
+typedef u_int8_t u8;
+
+#include <linux/if.h>
+#include <linux/sockios.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+
+#include "etc53xx.h"
+#define ROBO_PHY_ADDR	0x1E	/* robo switch phy address */
+
+/* MII registers */
+#define REG_MII_PAGE	0x10	/* MII Page register */
+#define REG_MII_ADDR	0x11	/* MII Address register */
+#define REG_MII_DATA0	0x18	/* MII Data register 0 */
+
+#define REG_MII_PAGE_ENABLE	1
+#define REG_MII_ADDR_WRITE	1
+#define REG_MII_ADDR_READ	2
+
+/* Private et.o ioctls */
+#define SIOCGETCPHYRD           (SIOCDEVPRIVATE + 9)
+#define SIOCSETCPHYWR           (SIOCDEVPRIVATE + 10)
+
+typedef struct {
+	struct ifreq ifr;
+	int fd;
+	int et;			/* use private ioctls */
+} robo_t;
+
+static u16 mdio_read(robo_t *robo, u16 phy_id, u8 reg)
+{
+	if (robo->et) {
+		int args[2] = { reg };
+		
+		if (phy_id != ROBO_PHY_ADDR) {
+			fprintf(stderr,
+				"Access to real 'phy' registers unavaliable.\n"
+				"Upgrade kernel driver.\n");
+
+			return 0xffff;
+		}
+	
+		robo->ifr.ifr_data = (caddr_t) args;
+		if (ioctl(robo->fd, SIOCGETCPHYRD, (caddr_t)&robo->ifr) < 0) {
+			perror("SIOCGETCPHYRD");
+			exit(1);
+		}
+	
+		return args[1];
+	} else {
+		struct mii_ioctl_data *mii = (struct mii_ioctl_data *)&robo->ifr.ifr_data;
+		mii->phy_id = phy_id;
+		mii->reg_num = reg;
+		if (ioctl(robo->fd, SIOCGMIIREG, &robo->ifr) < 0) {
+			perror("SIOCGMIIREG");
+			exit(1);
+		}
+		return mii->val_out;
+	}
+}
+
+static void mdio_write(robo_t *robo, u16 phy_id, u8 reg, u16 val)
+{
+	if (robo->et) {
+		int args[2] = { reg, val };
+
+		if (phy_id != ROBO_PHY_ADDR) {
+			fprintf(stderr,
+				"Access to real 'phy' registers unavaliable.\n"
+				"Upgrade kernel driver.\n");
+			return;
+		}
+		
+		robo->ifr.ifr_data = (caddr_t) args;
+		if (ioctl(robo->fd, SIOCSETCPHYWR, (caddr_t)&robo->ifr) < 0) {
+			perror("SIOCGETCPHYWR");
+			exit(1);
+		}
+	} else {
+		struct mii_ioctl_data *mii = (struct mii_ioctl_data *)&robo->ifr.ifr_data;
+		mii->phy_id = phy_id;
+		mii->reg_num = reg;
+		mii->val_in = val;
+		if (ioctl(robo->fd, SIOCSMIIREG, &robo->ifr) < 0) {
+			perror("SIOCSMIIREG");
+			exit(1);
+		}
+	}
+}
+
+static int _robo_reg(robo_t *robo, u8 page, u8 reg, u8 op)
+{
+	int i = 3;
+	
+	/* set page number */
+	mdio_write(robo, ROBO_PHY_ADDR, REG_MII_PAGE, 
+		(page << 8) | REG_MII_PAGE_ENABLE);
+	
+	/* set register address */
+	mdio_write(robo, ROBO_PHY_ADDR, REG_MII_ADDR, 
+		(reg << 8) | op);
+
+	/* check if operation completed */
+	while (i--) {
+		if ((mdio_read(robo, ROBO_PHY_ADDR, REG_MII_ADDR) & 3) == 0)
+			return 0;
+	}
+
+	return -1;
+}
+
+static int robo_reg(robo_t *robo, u8 page, u8 reg, u8 op)
+{
+	if (_robo_reg(robo, page, reg, op))
+	{
+		fprintf(stderr, "robo_reg: timeout\n");
+		exit(1);
+	}
+
+	return 0;
+}
+
+static void robo_read(robo_t *robo, u8 page, u8 reg, u16 *val, int count)
+{
+	int i;
+	
+	robo_reg(robo, page, reg, REG_MII_ADDR_READ);
+	
+	for (i = 0; i < count; i++)
+		val[i] = mdio_read(robo, ROBO_PHY_ADDR, REG_MII_DATA0 + i);
+}
+
+static u16 robo_read16(robo_t *robo, u8 page, u8 reg)
+{
+	robo_reg(robo, page, reg, REG_MII_ADDR_READ);
+	
+	return mdio_read(robo, ROBO_PHY_ADDR, REG_MII_DATA0);
+}
+
+static u32 robo_read32(robo_t *robo, u8 page, u8 reg)
+{
+	robo_reg(robo, page, reg, REG_MII_ADDR_READ);
+	
+	return mdio_read(robo, ROBO_PHY_ADDR, REG_MII_DATA0) +
+		(mdio_read(robo, ROBO_PHY_ADDR, REG_MII_DATA0 + 1) << 16);
+}
+
+static void robo_write16(robo_t *robo, u8 page, u8 reg, u16 val16)
+{
+	/* write data */
+	mdio_write(robo, ROBO_PHY_ADDR, REG_MII_DATA0, val16);
+
+	robo_reg(robo, page, reg, REG_MII_ADDR_WRITE);
+}
+
+static void robo_write32(robo_t *robo, u8 page, u8 reg, u32 val32)
+{
+	/* write data */
+	mdio_write(robo, ROBO_PHY_ADDR, REG_MII_DATA0, val32 & 65535);
+	mdio_write(robo, ROBO_PHY_ADDR, REG_MII_DATA0 + 1, val32 >> 16);
+	
+	robo_reg(robo, page, reg, REG_MII_ADDR_WRITE);
+}
+
+/* checks that attached switch is 5325E/535x */
+static int robo_vlan5350(robo_t *robo)
+{
+	/* set vlan access id to 15 and read it back */
+	u16 val16 = 15;
+	robo_write16(robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS_5350, val16);
+	
+	/* 5365 will refuse this as it does not have this reg */
+	return (robo_read16(robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS_5350) == val16);
+}
+
+u8 port[6] = { 0, 1, 2, 3, 4, 8 };
+char ports[] = "01234???5???????";
+char *rxtx[4] = { "enabled", "rx_disabled", "tx_disabled", "disabled" };
+char *stp[8] = { "none", "disable", "block", "listen", "learn", "forward", "6", "7" };
+
+struct {
+	char *name;
+	u16 bmcr;
+} media[5] = { { "auto", BMCR_ANENABLE | BMCR_ANRESTART }, 
+	{ "10HD", 0 }, { "10FD", BMCR_FULLDPLX },
+	{ "100HD", BMCR_SPEED100 }, { "100FD", BMCR_SPEED100 | BMCR_FULLDPLX } };
+
+struct {
+	char *name;
+	u16 value;
+} mdix[3] = { { "auto", 0x0000 }, { "on", 0x1800 }, { "off", 0x0800 } };
+
+void usage()
+{
+	fprintf(stderr, "Broadcom BCM5325E/536x switch configuration utility\n"
+		"Copyright (C) 2005-2008 Oleg I. Vdovikin (oleg@cs.msu.su)\n"
+		"Copyright (C) 2005 Dmitry 'dimss' Ivanov of \"Telecentrs\" (Riga, Latvia)\n\n"
+		"This program is distributed in the hope that it will be useful,\n"
+		"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+		"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n"
+		"GNU General Public License for more details.\n\n");
+
+	fprintf(stderr, "Usage: robocfg <op> ... <op>\n"
+			"Operations are as below:\n"
+			"\tshow -- show current config\n"
+			"\tshowmacs -- show known MAC addresses\n"
+			"\tswitch <enable|disable>\n"
+			"\tport <port_number> [state <%s|%s|%s|%s>]\n\t\t[stp %s|%s|%s|%s|%s|%s] [tag <vlan_tag>]\n"
+			"\t\t[media %s|%s|%s|%s|%s] [mdi-x %s|%s|%s]\n"
+			"\tvlan <vlan_number> [ports <ports_list>]\n"
+			"\tvlans <enable|disable|reset>\n\n"
+			"\tports_list should be one argument, space separated, quoted if needed,\n"
+			"\tport number could be followed by 't' to leave packet vlan tagged (CPU \n"
+			"\tport default) or by 'u' to untag packet (other ports default) before \n"
+			"\tbringing it to the port, '*' is ignored\n"
+			"\nSamples:\n"
+			"1) ASUS WL-500g Deluxe stock config (eth0 is WAN, eth0.1 is LAN):\n"
+			"robocfg switch disable vlans enable reset vlan 0 ports \"0 5u\" vlan 1 ports \"1 2 3 4 5t\""
+			" port 0 state enabled stp none switch enable\n"
+			"2) WRT54g, WL-500g Deluxe OpenWRT config (vlan0 is LAN, vlan1 is WAN):\n"
+			"robocfg switch disable vlans enable reset vlan 0 ports \"1 2 3 4 5t\" vlan 1 ports \"0 5t\""
+			" port 0 state enabled stp none switch enable\n",
+			rxtx[0], rxtx[1], rxtx[2], rxtx[3], stp[0], stp[1], stp[2], stp[3], stp[4], stp[5],
+			media[0].name, media[1].name, media[2].name, media[3].name, media[4].name,
+			mdix[0].name, mdix[1].name, mdix[2].name);
+}
+
+int
+main(int argc, char *argv[])
+{
+	u16 val16;
+	u16 mac[3];
+	int i = 0, j;
+	int robo5350 = 0;
+	u32 phyid;
+	
+	static robo_t robo;
+	struct ethtool_drvinfo info;
+	
+	if ((robo.fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+		perror("socket");
+		exit(1);
+	}
+
+	/* the only interface for now */
+	strcpy(robo.ifr.ifr_name, "eth0");
+
+	memset(&info, 0, sizeof(info));
+	info.cmd = ETHTOOL_GDRVINFO;
+	robo.ifr.ifr_data = (caddr_t)&info;
+	if (ioctl(robo.fd, SIOCETHTOOL, (caddr_t)&robo.ifr) < 0) {
+		perror("SIOCETHTOOL: your ethernet module is either unsupported or outdated");
+		exit(1);
+	} else
+	if (strcmp(info.driver, "et0") && strcmp(info.driver, "b44")) {
+		fprintf(stderr, "No suitable module found for %s (managed by %s)\n", 
+			robo.ifr.ifr_name, info.driver);
+		exit(1);
+	}
+	
+	/* try access using MII ioctls - get phy address */
+	if (ioctl(robo.fd, SIOCGMIIPHY, &robo.ifr) < 0) {
+		robo.et = 1;
+	} else {
+		/* got phy address check for robo address */
+		struct mii_ioctl_data *mii = (struct mii_ioctl_data *)&robo.ifr.ifr_data;
+		if (mii->phy_id != ROBO_PHY_ADDR) {
+			fprintf(stderr, "Invalid phy address (%d)\n", mii->phy_id);
+			exit(1);
+		}
+	}
+
+	phyid = mdio_read(&robo, ROBO_PHY_ADDR, 0x2) | 
+		(mdio_read(&robo, ROBO_PHY_ADDR, 0x3) << 16);
+	
+	if (phyid == 0xffffffff || phyid == 0x55210022) {
+		fprintf(stderr, "No Robo switch in managed mode found\n");
+		exit(1);
+	}
+	
+	robo5350 = robo_vlan5350(&robo);
+	
+	for (i = 1; i < argc;) {
+		if (strcasecmp(argv[i], "showmacs") == 0)
+		{
+			/* show MAC table of switch */
+			u16 buf[5];
+			int idx, base_vlan;
+
+			base_vlan = 0; /*get_vid_by_idx(&robo, 0);*/
+
+			printf(
+				"--------------------------------------\n"
+				"VLAN  MAC                Type     Port\n"
+				"--------------------------------------\n");
+			robo_write16(&robo, ROBO_ARLIO_PAGE, ROBO_ARL_RW_CTRL, 0x81);
+			robo_write16(&robo, ROBO_ARLIO_PAGE, ROBO_ARL_SEARCH_CTRL, 0x80);
+			for( idx = 0; idx < (robo5350 ? 
+				NUM_ARL_TABLE_ENTRIES_5350 : NUM_ARL_TABLE_ENTRIES); idx++)
+			{
+				robo_read(&robo, ROBO_ARLIO_PAGE, ROBO_ARL_SEARCH_RESULT, 
+					buf, robo5350 ? 4 : 5);
+				if (buf[3] & 0x8000 /* valid */)
+				{
+					printf("%04i  %02x:%02x:%02x:%02x:%02x:%02x  %7s  %c\n",
+						(base_vlan | ((buf[3] >> 5) & 0x0F) | 
+							(robo5350 ? 0 : ((buf[4] & 0x0f) << 4))),
+						buf[2] >> 8, buf[2] & 255, 
+						buf[1] >> 8, buf[1] & 255,
+						buf[0] >> 8, buf[0] & 255,
+						((buf[3] & 0x4000) ? "STATIC" : "DYNAMIC"),
+						ports[buf[3] & 0x0F]
+					);
+				}
+			}
+			i++;
+		} else
+		if (strcasecmp(argv[i], "port") == 0 && (i + 1) < argc)
+		{
+			int index = atoi(argv[++i]);
+			/* read port specs */
+			while (++i < argc) {
+				if (strcasecmp(argv[i], "state") == 0 && ++i < argc) {
+					for (j = 0; j < 4 && strcasecmp(argv[i], rxtx[j]); j++);
+					if (j < 4) {
+						/* change state */
+						robo_write16(&robo,ROBO_CTRL_PAGE, port[index],
+							(robo_read16(&robo, ROBO_CTRL_PAGE, port[index]) & ~(3 << 0)) | (j << 0));
+					} else {
+						fprintf(stderr, "Invalid state '%s'.\n", argv[i]);
+						exit(1);
+					}
+				} else
+				if (strcasecmp(argv[i], "stp") == 0 && ++i < argc) {
+					for (j = 0; j < 8 && strcasecmp(argv[i], stp[j]); j++);
+					if (j < 8) {
+						/* change stp */
+						robo_write16(&robo,ROBO_CTRL_PAGE, port[index],
+							(robo_read16(&robo, ROBO_CTRL_PAGE, port[index]) & ~(7 << 5)) | (j << 5));
+					} else {
+						fprintf(stderr, "Invalid stp '%s'.\n", argv[i]);
+						exit(1);
+					}
+				} else
+				if (strcasecmp(argv[i], "media") == 0 && ++i < argc) {
+					for (j = 0; j < 5 && strcasecmp(argv[i], media[j].name); j++);
+					if (j < 5) {
+                                    		mdio_write(&robo, port[index], MII_BMCR, media[j].bmcr);
+					} else {
+						fprintf(stderr, "Invalid media '%s'.\n", argv[i]);
+						exit(1);
+					}
+				} else
+				if (strcasecmp(argv[i], "mdi-x") == 0 && ++i < argc) {
+					for (j = 0; j < 3 && strcasecmp(argv[i], mdix[j].name); j++);
+					if (j < 3) {
+                                    		mdio_write(&robo, port[index], 0x1c, mdix[j].value |
+						    (mdio_read(&robo, port[index], 0x1c) & ~0x1800));
+					} else {
+						fprintf(stderr, "Invalid mdi-x '%s'.\n", argv[i]);
+						exit(1);
+					}
+				} else
+				if (strcasecmp(argv[i], "tag") == 0 && ++i < argc) {
+					j = atoi(argv[i]);
+					/* change vlan tag */
+					robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_PORT0_DEF_TAG + (index << 1), j);
+				} else break;
+			}
+		} else
+		if (strcasecmp(argv[i], "vlan") == 0 && (i + 1) < argc)
+		{
+			int vid = atoi(argv[++i]);
+			while (++i < argc) {
+				if (strcasecmp(argv[i], "ports") == 0 && ++i < argc) {
+					char *ports = argv[i];
+					int untag = 0;
+					int member = 0;
+					
+					while (*ports >= '0' && *ports <= '9') {
+						j = *ports++ - '0';
+						member |= 1 << j;
+						
+						/* untag if needed, CPU port requires special handling */
+						if (*ports == 'u' || (j != 5 && (*ports == ' ' || *ports == 0))) 
+						{
+							untag |= 1 << j;
+							if (*ports) ports++;
+							/* change default vlan tag */
+							robo_write16(&robo, ROBO_VLAN_PAGE, 
+								ROBO_VLAN_PORT0_DEF_TAG + (j << 1), vid);
+						} else 
+						if (*ports == '*' || *ports == 't' || *ports == ' ') ports++;
+						else break;
+						
+						while (*ports == ' ') ports++;
+					}
+					
+					if (*ports) {
+						fprintf(stderr, "Invalid ports '%s'.\n", argv[i]);
+						exit(1);
+					} else {
+						/* write config now */
+						val16 = (vid) /* vlan */ | (1 << 12) /* write */ | (1 << 13) /* enable */;
+						if (robo5350) {
+							robo_write32(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_WRITE_5350,
+								(1 << 20) /* valid */ | (untag << 6) | member | ((vid >> 4) << 12));
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS_5350, val16);
+						} else {
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_WRITE,
+								(1 << 14)  /* valid */ | (untag << 7) | member);
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS, val16);
+						}
+					}
+				} else break;
+			}
+		} else
+		if (strcasecmp(argv[i], "switch") == 0 && (i + 1) < argc)
+		{
+			/* enable/disable switching */
+			robo_write16(&robo, ROBO_CTRL_PAGE, ROBO_SWITCH_MODE,
+				(robo_read16(&robo, ROBO_CTRL_PAGE, ROBO_SWITCH_MODE) & ~2) |
+				(*argv[++i] == 'e' ? 2 : 0));
+			i++;
+		} else
+		if (strcasecmp(argv[i], "vlans") == 0 && (i + 1) < argc)
+		{
+			while (++i < argc) {
+				if (strcasecmp(argv[i], "reset") == 0) {
+					/* reset vlan validity bit */
+					for (j = 0; j <= (robo5350 ? VLAN_ID_MAX5350 : VLAN_ID_MAX); j++) 
+					{
+						/* write config now */
+						val16 = (j) /* vlan */ | (1 << 12) /* write */ | (1 << 13) /* enable */;
+						if (robo5350) {
+							robo_write32(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_WRITE_5350, 0);
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS_5350, val16);
+						} else {
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_WRITE, 0);
+							robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS, val16);
+						}
+					}
+				} else 
+				if (strcasecmp(argv[i], "enable") == 0 || strcasecmp(argv[i], "disable") == 0) 
+				{
+					int disable = (*argv[i] == 'd') || (*argv[i] == 'D');
+					/* enable/disable vlans */
+					robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_CTRL0, disable ? 0 :
+						(1 << 7) /* 802.1Q VLAN */ | (3 << 5) /* mac check and hash */);
+
+					robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_CTRL1, disable ? 0 :
+						(1 << 1) | (1 << 2) | (1 << 3) /* RSV multicast */);
+
+					robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_CTRL4, disable ? 0 :
+						(1 << 6) /* drop invalid VID frames */);
+
+					robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_CTRL5, disable ? 0 :
+						(1 << 3) /* drop miss V table frames */);
+
+				} else break;
+			}
+		} else
+		if (strcasecmp(argv[i], "show") == 0)
+		{
+			break;
+		} else
+		if (strcasecmp(argv[i], "robowr") == 0 && (i + 2) < argc)
+		{
+			long pagereg = strtol(argv[i + 1], NULL, 0);
+
+			robo_write16(&robo, pagereg >> 8, 
+				pagereg & 255, strtol(argv[i + 2], NULL, 0));
+
+			printf("Page 0x%02x, Reg 0x%02x: %04x\n",
+				pagereg >> 8, pagereg & 255,
+				robo_read16(&robo, pagereg >> 8, pagereg & 255));
+
+			i += 3;
+		} else
+		if (strcasecmp(argv[i], "robord") == 0 && (i + 1) < argc)
+		{
+			long pagereg = strtol(argv[i + 1], NULL, 0);
+
+			printf("Page 0x%02x, Reg 0x%02x: %04x\n",
+				pagereg >> 8, pagereg & 255,
+				robo_read16(&robo, pagereg >> 8, pagereg & 255));
+
+			i += 2;
+		} else
+		if (strcasecmp(argv[i], "dump") == 0)
+		{
+			for (i = 0; i < 256; i++)
+			{
+				if (_robo_reg(&robo, i, 0, REG_MII_ADDR_READ))
+					continue;
+
+				printf("Page %02x\n", i);
+
+				for (j = 0; j < 64; j++) {
+					printf(" %04x%s",
+						robo_read16(&robo, i, j), (j % 16) == 15 ? "\n" : "");
+				}
+			}
+
+			i++;
+		} else {
+			fprintf(stderr, "Invalid option %s\n", argv[i]);
+			usage();
+			exit(1);
+		}
+	}
+
+	if (i == argc) {
+		if (argc == 1) usage();
+		return 0;
+	}
+	
+	/* show config */
+		
+	printf("Switch: %sabled\n", robo_read16(&robo, ROBO_CTRL_PAGE, ROBO_SWITCH_MODE) & 2 ? "en" : "dis");
+
+	for (i = 0; i < 6; i++) {
+		printf(robo_read16(&robo, ROBO_STAT_PAGE, ROBO_LINK_STAT_SUMMARY) & (1 << port[i]) ?
+			"Port %d: %s%s " : "Port %d:  DOWN ", i,
+			robo_read16(&robo, ROBO_STAT_PAGE, ROBO_SPEED_STAT_SUMMARY) & (1 << port[i]) ? "100" : " 10",
+			robo_read16(&robo, ROBO_STAT_PAGE, ROBO_DUPLEX_STAT_SUMMARY) & (1 << port[i]) ? "FD" : "HD");
+		
+		val16 = robo_read16(&robo, ROBO_CTRL_PAGE, port[i]);
+		
+		printf("%s stp: %s vlan: %d ", rxtx[val16 & 3], stp[(val16 >> 5) & 7],
+			robo_read16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_PORT0_DEF_TAG + (i << 1)));
+			
+		robo_read(&robo, ROBO_STAT_PAGE, ROBO_LSA_PORT0 + port[i] * 6, mac, 3);
+		
+		printf("mac: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			mac[2] >> 8, mac[2] & 255, mac[1] >> 8, mac[1] & 255, mac[0] >> 8, mac[0] & 255);
+	}
+	
+	val16 = robo_read16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_CTRL0);
+	
+	printf("VLANs: %s %sabled%s%s\n", 
+		robo5350 ? "BCM5325/535x" : "BCM536x",
+		(val16 & (1 << 7)) ? "en" : "dis", 
+		(val16 & (1 << 6)) ? " mac_check" : "", 
+		(val16 & (1 << 5)) ? " mac_hash" : "");
+	
+	/* scan VLANs */
+	for (i = 0; i <= (robo5350 ? VLAN_ID_MAX5350 : VLAN_ID_MAX); i++) {
+		/* issue read */
+		val16 = (i) /* vlan */ | (0 << 12) /* read */ | (1 << 13) /* enable */;
+		
+		if (robo5350) {
+			u32 val32;
+			robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS_5350, val16);
+			/* actual read */
+			val32 = robo_read32(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_READ);
+			if ((val32 & (1 << 20)) /* valid */) {
+				printf("%2d: vlan%d:", 
+					i, (((val32 & 0xff000) >> 12) << 4) | i);
+				for (j = 0; j < 6; j++) {
+					if (val32 & (1 << j)) {
+						printf(" %d%s", j, (val32 & (1 << (j + 6))) ? 
+							(j == 5 ? "u" : "") : "t");
+					}
+				}
+				printf("\n");
+			}
+		} else {
+			robo_write16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_TABLE_ACCESS, val16);
+			/* actual read */
+			val16 = robo_read16(&robo, ROBO_VLAN_PAGE, ROBO_VLAN_READ);
+			if ((val16 & (1 << 14)) /* valid */) {
+				printf("%3d: vlan%d:", i, i);
+				for (j = 0; j < 6; j++) {
+					if (val16 & (1 << j)) {
+						printf(" %d%s", j, (val16 & (1 << (j + 7))) ? 
+							(j == 5 ? "u" : "") : "t");
+					}
+				}
+				printf("\n");
+			}
+		}
+	}
+	
+	return (0);
+}
