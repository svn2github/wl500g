diff -BurN router/others/dropbearstart.sh gateway/others/dropbearstart.sh
--- router/others/dropbearstart.sh	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/dropbearstart.sh	2009-02-18 13:49:38.000000000 +0300
@@ -0,0 +1,59 @@
+#! /bin/sh
+#
+# Copyright (C) 2009 by Alexander I. Buzin <al37919@gmail.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+
+# This script is intended to be run automatically during boot up.
+# It ensures that dropbear keys are in the right place either by
+# extracting them from flashfs if it is disabled or by by generating
+# them and saving in flashfs if they are absent at all.
+# IMPORTANT: This script does not change the state of flashfs!
+
+#check if the key files are in the right place
+if ! [ -s /tmp/local/etc/dropbear/dropbear_rsa_host_key -a \
+       -s /tmp/local/etc/dropbear/dropbear_dss_host_key ]; then
+	mkdir -p /tmp/local/etc/dropbear
+	#check if the key files are stored in flashfs
+	if [ -n "$(/bin/tar -tzf /dev/mtdblock/4 2> /dev/null | \
+	     grep tmp/local/etc/dropbear/dropbear_[rd]s[as]_host_key)" ]; then
+		/bin/tar -C / -xzf /dev/mtdblock/4 tmp/local/etc/dropbear tmp/local/etc/ssh.*
+	else
+		#generate new key files
+		dropbearkey -t rsa -f /tmp/local/etc/dropbear/dropbear_rsa_host_key \
+		  | grep "ssh-rsa" > /tmp/local/etc/dropbear/dropbear_rsa_host_key.pub
+		dropbearkey -t dss -f /tmp/local/etc/dropbear/dropbear_dss_host_key \
+		  | grep "ssh-dss" > /tmp/local/etc/dropbear/dropbear_dss_host_key.pub
+
+		#store generated keys in the flashfs for future use
+		mkdir -p /tmp/_tmp/tmp/local/etc
+		/bin/tar -C /tmp/_tmp/ -xzf /dev/mtdblock/4 2> /dev/null
+		cp -r /tmp/local/etc/dropbear /tmp/_tmp/tmp/local/etc
+		/bin/tar -C /tmp/_tmp/ -czf /tmp/_flash.tar.gz etc tmp
+
+		/sbin/flash /tmp/_flash.tar.gz /dev/mtd/4
+		rm -r /tmp/_tmp /tmp/_flash.tar.gz
+	fi
+fi
+
+port="$(nvram get ssh_port)"
+if [ "${port}" -ne "22" ]; then
+	args="-p ${port}"
+fi
+
+dropbear ${args}
+
+exit 0
diff -BurN router/others/flashfs.sh gateway/others/flashfs.sh
--- router/others/flashfs.sh	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/flashfs.sh	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,75 @@
+#!/bin/sh
+#
+# Copyright (C) 2004 by Oleg I. Vdovikin <oleg@cs.msu.su>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+VERSION="$(cat /.version)"
+
+case "$1" in
+	status)
+		if [ "$(nvram get boot_local)" = "$VERSION" ] ||
+		   [ "$(nvram get boot_local)" = "enabled" ]; then
+			echo "boot_local enabled"
+		else 
+			echo "boot_local disabled"
+		fi
+		;;
+	start)
+		if [ "$(nvram get boot_local)" = "$VERSION" ] ||
+		   [ "$(nvram get boot_local)" = "enabled" ]; then
+			/bin/tar -C / -xzf /dev/mtdblock/4
+		fi
+		;;
+	enable)
+		if [ "$(nvram get boot_local)" != "enabled" ]; then
+			nvram set boot_local="$VERSION"
+			nvram commit
+		fi
+		;;
+	enabled)
+		if [ "$(nvram get boot_local)" != "enabled" ]; then
+			nvram set boot_local=enabled
+			nvram commit
+		fi
+		;;
+	disable)
+		nvram set boot_local
+		nvram commit
+		;;
+	clear)
+		/sbin/erase /dev/mtd/4
+		;;
+	load)
+		/bin/tar -C / -xzvf /dev/mtdblock/4
+		;;
+	list)
+		/bin/tar -C / -tzf /dev/mtdblock/4
+		;;
+	save)
+		[ -f /usr/local/.files ] && FILES=$(grep -v ^# /usr/local/.files)
+		/bin/tar -C / -czvf /tmp/flash.tar.gz /tmp/local $FILES && 
+		ls -l /tmp/flash.tar.gz &&
+		echo "Check saved image and type \"$0 commit\" to commit changes"
+		;;
+	commit)
+		/sbin/flash /tmp/flash.tar.gz /dev/mtd/4 &&
+		echo "Committed."
+		;;
+	*)
+		echo "Usage: $0 status|start|enable|enabled|disable|clear|load|list|save|commit"
+		;;
+esac
diff -BurN router/others/ipkg.conf gateway/others/ipkg.conf
--- router/others/ipkg.conf	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/ipkg.conf	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,3 @@
+src wl500g http://wl500g.dyndns.org/ipkg
+src optware http://ipkg.nslu2-linux.org/feeds/optware/oleg/cross/stable
+dest root /
diff -BurN router/others/ipkg.sh gateway/others/ipkg.sh
--- router/others/ipkg.sh	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/ipkg.sh	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,1185 @@
+#!/bin/sh
+# ipkg - the itsy package management system
+#
+# Copyright (C) 2001 Carl D. Worth
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+set -e
+
+# By default do not do globbing. Any command wanting globbing should
+# explicitly enable it first and disable it afterwards.
+set -o noglob
+
+ipkg_is_upgrade () {
+  local A B a b
+  A=$(echo $1 | sed "s/[0-9]*/ & /g")
+  B=$(echo $2 | sed "s/[0-9]*/ & /g")
+  while [ \! -z "$A" ] && [ \! -z "$B" ]; do {
+    set $A; a=$1; shift; A=$*
+    set $B; b=$1; shift; B=$*
+    { [ "$a" -gt "$b" ] 2>&- || [ "$a" ">" "$b" ]; } && { return 0; }
+  }; done
+  return 1;
+}
+
+ipkg_srcs() {
+	local srcre="$1"
+	sed -ne "s/^src[[:space:]]\+$srcre[[:space:]]\+//p" < $IPKG_CONF
+}
+
+ipkg_src_names() {
+	sed -ne "s/^src[[:space:]]\+\([^[:space:]]\+\).*/\1/p" < $IPKG_CONF
+}
+
+ipkg_src_byname() {
+	local src="$1"
+	ipkg_srcs $src | head -1
+}
+
+ipkg_dests() {
+	local destre="`echo $1 | ipkg_protect_slashes`"
+	sed -ne "/^dest[[:space:]]\+$destre/{
+s/^dest[[:space:]]\+[^[:space:]]\+[[:space:]]\+//
+s/^/`echo $IPKG_OFFLINE_ROOT | ipkg_protect_slashes`/
+p
+}" < $IPKG_CONF
+}
+
+ipkg_dest_names() {
+	sed -ne "s/^dest[[:space:]]\+\([^[:space:]]\+\).*/\1/p" < $IPKG_CONF
+}
+
+ipkg_dests_all() {
+	ipkg_dests '.*'
+}
+
+ipkg_state_dirs() {
+	ipkg_dests_all | sed "s|\$|/$IPKG_DIR_PREFIX|"
+}
+
+ipkg_dest_default() {
+	ipkg_dests_all | head -1
+}
+
+ipkg_dest_default_name() {
+	ipkg_dest_names | head -1
+}
+
+ipkg_dest_byname() {
+	local dest="$1"
+	ipkg_dests $dest | head -1
+}
+
+ipkg_option() {
+	local option="$1"
+	sed -ne "s/^option[[:space:]]\+$option[[:space:]]\+//p" < $IPKG_CONF
+}
+
+ipkg_load_configuration() {
+	if [ -z "$IPKG_CONF_DIR" ]; then
+		IPKG_CONF_DIR=/etc
+	fi
+
+	IPKG_CONF="$IPKG_CONF_DIR/ipkg.conf"
+
+	if [ -z "$IPKG_OFFLINE_ROOT" ]; then
+	    IPKG_OFFLINE_ROOT="`ipkg_option offline_root`"
+	fi
+	# Export IPKG_OFFLINE_ROOT for use by update-alternatives
+	export IPKG_OFFLINE_ROOT
+	if [ -n "$DEST_NAME" ]; then
+		IPKG_ROOT="`ipkg_dest_byname $DEST_NAME`"
+		if [ -z "$IPKG_ROOT" ]; then
+			if [ -d "$IPKG_OFFLINE_ROOT$DEST_NAME" ]; then
+				IPKG_ROOT="$IPKG_OFFLINE_ROOT$DEST_NAME";
+			else
+				echo "ipkg: invalid destination specification: $DEST_NAME
+Valid destinations are directories or one of the dest names from $IPKG_CONF:" >&2
+				ipkg_dest_names >&2
+				return 1
+			fi
+		fi
+	else
+		IPKG_ROOT="`ipkg_dest_default`"
+	fi
+
+	# Global ipkg state directories
+	IPKG_DIR_PREFIX=opt/lib/ipkg
+	IPKG_LISTS_DIR=$IPKG_OFFLINE_ROOT/$IPKG_DIR_PREFIX/lists
+	IPKG_PENDING_DIR=$IPKG_OFFLINE_ROOT/$IPKG_DIR_PREFIX/pending
+	IPKG_TMP=$IPKG_ROOT/opt/tmp/ipkg
+
+	# Destination specific ipkg meta-data directory
+	IPKG_STATE_DIR=$IPKG_ROOT/$IPKG_DIR_PREFIX
+
+	# Proxy Support
+	IPKG_PROXY_USERNAME="`ipkg_option proxy_username`"
+	IPKG_PROXY_PASSWORD="`ipkg_option proxy_password`"
+	IPKG_HTTP_PROXY="`ipkg_option http_proxy`"
+	IPKG_FTP_PROXY="`ipkg_option ftp_proxy`"
+	IPKG_NO_PROXY="`ipkg_option no_proxy`"
+	if [ -n "$IPKG_HTTP_PROXY" ]; then 
+		export http_proxy="$IPKG_HTTP_PROXY"
+	fi
+
+	if [ -n "$IPKG_FTP_PROXY" ]; then 
+		export ftp_proxy="$IPKG_FTP_PROXY"
+	fi
+
+	if [ -n "$IPKG_NO_PROXY" ]; then 
+		export no_proxy="$IPKG_NO_PROXY"
+	fi
+
+	IPKG_STATUS_FIELDS='\(Package\|Status\|Essential\|Version\|Conffiles\|Root\)'
+}
+
+ipkg_usage() {
+	[ $# -gt 0 ] && echo "ipkg: $*"
+	echo "
+usage: ipkg [options...] sub-command [arguments...]
+where sub-command is one of:
+
+Package Manipulation:
+	update  		Update list of available packages
+	upgrade			Upgrade all installed packages to latest version
+	install <pkg>		Download and install <pkg> (and dependencies)
+	install <file.ipk>	Install package <file.ipk>
+	install <file.deb>	Install package <file.deb>
+	remove <pkg>		Remove package <pkg>
+
+Informational Commands:
+	list    		List available packages and descriptions
+	files <pkg>		List all files belonging to <pkg>
+	search <file>		Search for a packaging providing <file>
+	info [pkg [<field>]]	Display all/some info fields for <pkg> or all
+	status [pkg [<field>]]	Display all/some status fields for <pkg> or all
+	depends <pkg>		Print uninstalled package dependencies for <pkg>
+
+Options:
+	-d <dest_name>          Use <dest_name> as the the root directory for
+	-dest <dest_name>	package installation, removal, upgrading.
+				<dest_name> should be a defined dest name from the
+				configuration file, (but can also be a directory
+				name in a pinch).
+        -o <offline_root>       Use <offline_root> as the root for offline installation.
+        -offline <offline_root> 				
+
+Force Options (use when ipkg is too smart for its own good):
+	-force-depends          Make dependency checks warnings instead of errors
+	-force-defaults         Use default options for questions asked by ipkg.
+                                (no prompts). Note that this will not prevent
+                                package installation scripts from prompting.
+" >&2
+	exit 1
+}
+
+ipkg_dir_part() {
+	local dir="`echo $1 | sed -ne 's/\(.*\/\).*/\1/p'`"
+	if [ -z "$dir" ]; then
+		dir="./"
+	fi
+	echo $dir
+}
+
+ipkg_file_part() {
+	echo $1 | sed 's/.*\///'
+}
+
+ipkg_protect_slashes() {
+	sed -e 's/\//\\\//g'
+}
+
+ipkg_download() {
+	local src="$1"
+	local dest="$2"
+
+	local src_file="`ipkg_file_part $src`"
+	local dest_dir="`ipkg_dir_part $dest`"
+	if [ -z "$dest_dir" ]; then
+		dest_dir="$IPKG_TMP"
+	fi
+
+	local dest_file="`ipkg_file_part $dest`"
+	if [ -z "$dest_file" ]; then
+		dest_file="$src_file"
+	fi
+
+	# Proxy support
+	local proxyuser=""
+	local proxypassword=""
+	local proxyoption=""
+		
+	if [ -n "$IPKG_PROXY_USERNAME" ]; then
+		proxyuser="--proxy-user=\"$IPKG_PROXY_USERNAME\""
+		proxypassword="--proxy-passwd=\"$IPKG_PROXY_PASSWORD\""
+	fi
+
+	if [ -n "$IPKG_PROXY_HTTP" -o -n "$IPKG_PROXY_FTP" ]; then
+		proxyoption="--proxy=on"
+	fi
+
+	echo "Downloading $src ..."
+	rm -f $IPKG_TMP/$src_file
+	case "$src" in
+	http://* | ftp://*)
+		if ! wget --passive-ftp $proxyoption $proxyuser $proxypassword -P $IPKG_TMP $src; then
+			echo "ipkg_download: ERROR: Failed to retrieve $src, returning $err"
+			return 1
+		fi
+		mv $IPKG_TMP/$src_file $dest_dir/$dest_file 2>/dev/null
+		;;
+	file:/* )
+		ln -s `echo $src | sed 's/^file://'` $dest_dir/$dest_file 2>/dev/null
+		;;
+	*)
+	echo "DEBUG: $src"
+		;;
+	esac
+
+	echo "Done."
+	return 0
+}
+
+ipkg_update() {
+	if [ ! -e "$IPKG_LISTS_DIR" ]; then
+		mkdir -p $IPKG_LISTS_DIR
+	fi
+
+	local err=
+	for src_name in `ipkg_src_names`; do
+		local src="`ipkg_src_byname $src_name`"
+		if ! ipkg_download $src/Packages $IPKG_LISTS_DIR/$src_name; then
+			echo "ipkg_update: Error downloading $src/Packages to $IPKG_LISTS_DIR/$src_name" >&2
+			err=t
+		else
+			echo "Updated list of available packages in $IPKG_LISTS_DIR/$src_name"
+		fi
+	done
+
+	[ -n "$err" ] && return 1
+
+	return 0
+}
+
+ipkg_list() {
+	for src in `ipkg_src_names`; do
+		if ipkg_require_list $src; then 
+# black magic...
+sed -ne "
+/^Package:/{
+s/^Package:[[:space:]]*\<\([a-z0-9.+-]*$1[a-z0-9.+-]*\).*/\1/
+h
+}
+/^Description:/{
+s/^Description:[[:space:]]*\(.*\)/\1/
+H
+g
+s/\\
+/ - /
+p
+}
+" $IPKG_LISTS_DIR/$src
+		fi
+	done
+}
+
+ipkg_extract_paragraph() {
+	local pkg="$1"
+	sed -ne "/Package:[[:space:]]*$pkg[[:space:]]*\$/,/^\$/p"
+}
+
+ipkg_extract_field() {
+	local field="$1"
+# blacker magic...
+	sed -ne "
+: TOP
+/^$field:/{
+p
+n
+b FIELD
+}
+d
+: FIELD
+/^$/b TOP
+/^[^[:space:]]/b TOP
+p
+n
+b FIELD
+"
+}
+
+ipkg_extract_value() {
+	sed -e "s/^[^:]*:[[:space:]]*//"
+}
+
+ipkg_require_list() {
+	[ $# -lt 1 ] && return 1
+	local src="$1"
+	if [ ! -f "$IPKG_LISTS_DIR/$src" ]; then
+		echo "ERROR: File not found: $IPKG_LISTS_DIR/$src" >&2
+		echo "       You probably want to run \`ipkg update'" >&2
+		return 1
+	fi
+	return 0
+}
+
+ipkg_info() {
+	for src in `ipkg_src_names`; do
+		if ipkg_require_list $src; then
+			case $# in
+			0)
+				cat $IPKG_LISTS_DIR/$src
+				;;	
+			1)
+				ipkg_extract_paragraph $1 < $IPKG_LISTS_DIR/$src
+				;;
+			*)
+				ipkg_extract_paragraph $1 < $IPKG_LISTS_DIR/$src | ipkg_extract_field $2
+				;;
+			esac
+		fi
+	done
+}
+
+ipkg_status_sd() {
+	[ $# -lt 1 ] && return 0
+	sd="$1"
+	shift
+	if [ -f $sd/status ]; then
+		case $# in
+		0)
+			cat $sd/status
+			;;
+		1)
+			ipkg_extract_paragraph $1 < $sd/status
+			;;
+		*)
+			ipkg_extract_paragraph $1 < $sd/status | ipkg_extract_field $2
+			;;
+		esac
+	fi
+	return 0
+}
+
+ipkg_status_all() {
+	for sd in `ipkg_state_dirs`; do
+		ipkg_status_sd $sd $*
+	done
+}
+
+ipkg_status() {
+	if [ -n "$DEST_NAME" ]; then
+		ipkg_status_sd $IPKG_STATE_DIR $*
+	else
+		ipkg_status_all $*
+	fi
+}
+
+ipkg_status_matching_sd() {
+	local sd="$1"
+	local re="$2"
+	if [ -f $sd/status ]; then
+		sed -ne "
+: TOP
+/^Package:/{
+s/^Package:[[:space:]]*//
+s/[[:space:]]*$//
+h
+}
+/$re/{
+g
+p
+b NEXT
+}
+d
+: NEXT
+/^$/b TOP
+n
+b NEXT
+" < $sd/status
+	fi
+	return 0
+}
+
+ipkg_status_matching_all() {
+	for sd in `ipkg_state_dirs`; do
+		ipkg_status_matching_sd $sd $*
+	done
+}
+
+ipkg_status_matching() {
+	if [ -n "$DEST_NAME" ]; then
+		ipkg_status_matching_sd $IPKG_STATE_DIR $*
+	else
+		ipkg_status_matching_all $*
+	fi
+}
+
+ipkg_status_installed_sd() {
+	local sd="$1"
+	local pkg="$2"
+	ipkg_status_sd $sd $pkg Status | grep -q "Status: install ok installed"
+}
+
+ipkg_status_installed_all() {
+	local ret=1
+	for sd in `ipkg_state_dirs`; do
+		if `ipkg_status_installed_sd $sd $*`; then
+			ret=0
+		fi
+	done
+	return $ret
+}
+
+ipkg_status_mentioned_sd() {
+	local sd="$1"
+	local pkg="$2"
+	[ -n "`ipkg_status_sd $sd $pkg Status`" ]
+}
+
+ipkg_files() {
+	local pkg="$1"
+	if [ -n "$DEST_NAME" ]; then
+		dests=$IPKG_ROOT
+	else
+		dests="`ipkg_dests_all`"
+	fi
+	for dest in $dests; do
+		if [ -f $dest/$IPKG_DIR_PREFIX/info/$pkg.list ]; then
+			dest_sed="`echo $dest | ipkg_protect_slashes`"
+			sed -e "s/^/$dest_sed/" < $dest/$IPKG_DIR_PREFIX/info/$pkg.list
+		fi
+	done
+}
+
+ipkg_search() {
+	local pattern="$1"
+
+	for dest_name in `ipkg_dest_names`; do
+		dest="`ipkg_dest_byname $dest_name`"
+		dest_sed="`echo $dest | ipkg_protect_slashes`"
+
+		set +o noglob
+		local list_files="`ls -1 $dest/$IPKG_DIR_PREFIX/info/*.list 2>/dev/null`"
+		set -o noglob
+		for file in $list_files; do
+			if sed "s/^/$dest_sed/" $file | grep -q $pattern; then
+				local pkg="`echo $file | sed "s/^.*\/\(.*\)\.list/\1/"`"
+				[ "$dest_name" != `ipkg_dest_default_name` ] && pkg="$pkg ($dest_name)"
+				sed "s/^/$dest_sed/" $file | grep $pattern | sed "s/^/$pkg: /"
+			fi
+		done
+	done
+}
+
+ipkg_status_remove_sd() {
+	local sd="$1"
+	local pkg="$2"
+
+	if [ ! -f $sd/status ]; then
+		mkdir -p $sd
+		touch $sd/status
+	fi
+	sed -ne "/Package:[[:space:]]*$pkg[[:space:]]*\$/,/^\$/!p" < $sd/status > $sd/status.new
+	mv $sd/status.new $sd/status
+}
+
+ipkg_status_remove_all() {
+	for sd in `ipkg_state_dirs`; do
+		ipkg_status_remove_sd $sd $*
+	done
+}
+
+ipkg_status_remove() {
+	if [ -n "$DEST_NAME" ]; then
+		ipkg_status_remove_sd $IPKG_STATE_DIR $*
+	else
+		ipkg_status_remove_all $*
+	fi
+}
+
+ipkg_status_update_sd() {
+	local sd="$1"
+	local pkg="$2"
+
+	ipkg_status_remove_sd $sd $pkg
+	ipkg_extract_field "$IPKG_STATUS_FIELDS" >> $sd/status
+	echo "" >> $sd/status
+}
+
+ipkg_status_update() {
+	ipkg_status_update_sd $IPKG_STATE_DIR $*
+}
+
+ipkg_unsatisfied_dependences() {
+    local pkg=$1
+    local deps="`ipkg_get_depends $pkg`"
+    local remaining_deps=
+    for dep in $deps; do
+	local installed="`ipkg_get_installed $dep`"
+	if [ "$installed" != "installed" ] ; then
+	    remaining_deps="$remaining_deps $dep"
+	fi
+    done
+    ## echo "ipkg_unsatisfied_dependences pkg=$pkg $remaining_deps" > /dev/console
+    echo $remaining_deps
+}
+
+ipkg_safe_pkg_name() {
+	local pkg=$1
+	local spkg="`echo pkg_$pkg | sed -e y/-+./___/`"
+	echo $spkg
+}
+
+ipkg_set_depends() {
+	local pkg=$1; shift 
+	local new_deps="$*"
+	pkg="`ipkg_safe_pkg_name $pkg`"
+	## setvar ${pkg}_depends "$new_deps"
+	echo $new_deps > /tmp/ipkg/${pkg}.depends
+}
+
+ipkg_get_depends() {
+	local pkg=$1
+	pkg="`ipkg_safe_pkg_name $pkg`"
+	cat /tmp/ipkg/${pkg}.depends
+	## eval "echo \$${pkg}_depends"
+}
+
+ipkg_set_installed() {
+	local pkg=$1
+	pkg="`ipkg_safe_pkg_name $pkg`"
+	echo installed > /tmp/ipkg/${pkg}.installed
+	## setvar ${pkg}_installed "installed"
+}
+
+ipkg_set_uninstalled() {
+	local pkg=$1
+	pkg="`ipkg_safe_pkg_name $pkg`"
+	### echo ipkg_set_uninstalled $pkg > /dev/console
+	echo uninstalled > /tmp/ipkg/${pkg}.installed
+	## setvar ${pkg}_installed "uninstalled"
+}
+
+ipkg_get_installed() {
+	local pkg=$1
+	pkg="`ipkg_safe_pkg_name $pkg`"
+	if [ -f /tmp/ipkg/${pkg}.installed ]; then
+		cat /tmp/ipkg/${pkg}.installed
+	fi
+	## eval "echo \$${pkg}_installed"
+}
+
+ipkg_depends() {
+	local new_pkgs="$*"
+	local all_deps=
+	local installed_pkgs="`ipkg_status_matching_all 'Status:.*[[:space:]]installed'`"
+	for pkg in $installed_pkgs; do
+	    ipkg_set_installed $pkg
+	done
+	while [ -n "$new_pkgs" ]; do
+		all_deps="$all_deps $new_pkgs"
+		local new_deps=
+		for pkg in $new_pkgs; do
+			if echo $pkg | grep -q '[^a-z0-9.+-]'; then
+				echo "ipkg_depends: ERROR: Package name $pkg contains illegal characters (should be [a-z0-9.+-])" >&2
+				return 1
+			fi
+			# TODO: Fix this. For now I am ignoring versions and alternations in dependencies.
+			new_deps="$new_deps "`ipkg_info $pkg '\(Pre-\)\?Depends' | ipkg_extract_value | sed -e 's/([^)]*)//g
+s/\(|[[:space:]]*[a-z0-9.+-]\+[[:space:]]*\)\+//g
+s/,/ /g
+s/ \+/ /g'`
+			ipkg_set_depends $pkg $new_deps
+		done
+
+		new_deps=`echo $new_deps | sed -e 's/[[:space:]]\+/\\
+/g' | sort | uniq`
+
+		local maybe_new_pkgs=
+		for pkg in $new_deps; do
+			if ! echo $installed_pkgs | grep -q "\<$pkg\>"; then
+				maybe_new_pkgs="$maybe_new_pkgs $pkg"
+			fi
+		done
+
+		new_pkgs=
+		for pkg in $maybe_new_pkgs; do
+			if ! echo $all_deps | grep -q "\<$pkg\>"; then
+				if [ -z "`ipkg_info $pkg`" ]; then
+					echo "ipkg_depends: Warning: $pkg mentioned in dependency but no package found in $IPKG_LISTS_DIR" >&2
+					ipkg_set_installed $pkg
+				else
+					new_pkgs="$new_pkgs $pkg"
+					ipkg_set_uninstalled $pkg
+				fi
+			else
+				ipkg_set_uninstalled $pkg
+			fi
+		done
+	done
+
+	echo $all_deps
+}
+
+ipkg_get_install_dest() {
+	local dest="$1"
+	shift
+	local sd=$dest/$IPKG_DIR_PREFIX
+	local info_dir=$sd/info
+
+        local requested_pkgs="$*"
+	local pkgs="`ipkg_depends $*`"
+
+	mkdir -p $info_dir
+	for pkg in $pkgs; do
+		if ! ipkg_status_mentioned_sd $sd $pkg; then
+			echo "Package: $pkg
+Status: install ok not-installed" | ipkg_status_update_sd $sd $pkg
+		fi
+	done
+        ## mark the packages that we were directly requested to install as uninstalled
+        for pkg in $requested_pkgs; do ipkg_set_uninstalled $pkg; done
+
+	local new_pkgs=
+	local pkgs_installed=0
+	while [ -n "pkgs" ]; do
+		curcheck=0
+		## echo "pkgs to install: {$pkgs}" > /dev/console
+		for pkg in $pkgs; do
+			curcheck="`expr $curcheck + 1`"
+			local is_installed="`ipkg_get_installed $pkg`"
+			if [ "$is_installed" = "installed" ]; then
+				echo "$pkg is installed" > /dev/console
+				continue
+			fi
+
+			local remaining_deps="`ipkg_unsatisfied_dependences $pkg`"
+			if [ -n "$remaining_deps" ]; then
+				new_pkgs="$new_pkgs $pkg"
+				### echo "Dependences not satisfied for $pkg: $remaining_deps"
+				if [ $curcheck -ne `echo  $pkgs|wc -w` ]; then
+			        	continue
+				fi
+			fi
+
+			local filename=
+			for src in `ipkg_src_names`; do
+				if ipkg_require_list $src; then
+					filename="`ipkg_extract_paragraph $pkg < $IPKG_LISTS_DIR/$src | ipkg_extract_field Filename | ipkg_extract_value`"
+					[ -n "$filename" ] && break
+				fi
+			done
+
+			if [ -z "$filename" ]; then
+				echo "ipkg_get_install: ERROR: Cannot find package $pkg in $IPKG_LISTS_DIR"
+				echo "ipkg_get_install:        Check the spelling and maybe run \`ipkg update'."
+				ipkg_status_remove_sd $sd $pkg
+				return 1;
+			fi
+
+			[ -e "$IPKG_TMP" ] || mkdir -p $IPKG_TMP
+
+			echo ""
+			local tmp_pkg_file="$IPKG_TMP/"`ipkg_file_part $filename`
+			if ! ipkg_download `ipkg_src_byname $src`/$filename $tmp_pkg_file; then
+				echo "ipkg_get_install: Perhaps you need to run \`ipkg update'?"
+				return 1
+			fi
+
+			if ! ipkg_install_file_dest $dest $tmp_pkg_file; then
+				echo "ipkg_get_install: ERROR: Failed to install $tmp_pkg_file"
+				echo "ipkg_get_install: I'll leave it there for you to try a manual installation"
+				return 1
+			fi
+
+			ipkg_set_installed $pkg
+			pkgs_installed="`expr $pkgs_installed + 1`"
+			rm $tmp_pkg_file
+		done
+		### echo "Installed $pkgs_installed package(s) this round"
+		if [ $pkgs_installed -eq 0 ]; then
+			if [ -z "$new_pkgs" ]; then
+			    break
+			fi
+		fi
+		pkgs_installed=0
+		pkgs="$new_pkgs"
+		new_pkgs=
+		curcheck=0
+        done
+}
+
+ipkg_get_install() {
+	ipkg_get_install_dest $IPKG_ROOT $*
+}
+
+ipkg_install_file_dest() {
+	local dest="$1"
+	local filename="$2"
+	local sd=$dest/$IPKG_DIR_PREFIX
+	local info_dir=$sd/info
+
+	if [ ! -f "$filename" ]; then
+		echo "ipkg_install_file: ERROR: File $filename not found"
+		return 1
+	fi
+
+	local pkg="`ipkg_file_part $filename | sed 's/\([a-z0-9.+-]\+\)_.*/\1/'`"
+	local ext="`echo $filename | sed 's/.*\.//'`"
+	local pkg_extract_stdout
+	if [ "$ext" = "ipk" ]; then
+		pkg_extract_stdout="tar -xzOf"
+	elif [ "$ext" = "deb" ]; then
+		pkg_extract_stdout="ar p"
+	else
+		echo "ipkg_install_file: ERROR: File $filename has unknown extension $ext (not .ipk or .deb)"
+		return 1
+	fi
+
+	# Check dependencies
+	local depends="`ipkg_depends $pkg | sed -e "s/\<$pkg\>//"`"
+
+	# Don't worry about deps that are scheduled for installation
+	local missing_deps=
+	for dep in $depends; do
+		if ! ipkg_status_all $dep | grep -q 'Status:[[:space:]]install'; then
+			missing_deps="$missing_deps $dep"
+		fi
+	done
+
+	if [ ! -z "$missing_deps" ]; then
+		if [ -n "$FORCE_DEPENDS" ]; then
+			echo "ipkg_install_file: Warning: $pkg depends on the following uninstalled programs: $missing_deps"
+		else
+			echo "ipkg_install_file: ERROR: $pkg depends on the following uninstalled programs:
+	$missing_deps"
+			echo "ipkg_install_file: You may want to use \`ipkg install' to install these."
+			return 1
+		fi
+	fi
+
+	mkdir -p $IPKG_TMP/$pkg/control
+	mkdir -p $IPKG_TMP/$pkg/data
+	mkdir -p $info_dir
+
+	if ! $pkg_extract_stdout $filename ./control.tar.gz | (cd $IPKG_TMP/$pkg/control; tar -xzf - ) ; then
+		echo "ipkg_install_file: ERROR unpacking control.tar.gz from $filename"
+		return 1
+	fi
+
+	if [ -n "$IPKG_OFFLINE_ROOT" ]; then
+		if grep -q '^InstallsOffline:[[:space:]]*no' $IPKG_TMP/$pkg/control/control; then
+			echo "*** Warning: Package $pkg may not be installed in offline mode"
+			echo "*** Warning: Scheduling $filename for pending installation (installing into $IPKG_PENDING_DIR)"
+			echo "Package: $pkg
+Status: install ok pending" | ipkg_status_update_sd $sd $pkg
+			mkdir -p $IPKG_PENDING_DIR
+			cp $filename $IPKG_PENDING_DIR
+			rm -r $IPKG_TMP/$pkg/control
+			rm -r $IPKG_TMP/$pkg/data
+			rmdir $IPKG_TMP/$pkg
+			return 0
+		fi
+	fi
+
+
+	echo -n "Unpacking $pkg..."
+	set +o noglob
+	for file in $IPKG_TMP/$pkg/control/*; do
+		local base_file="`ipkg_file_part $file`"
+		mv $file $info_dir/$pkg.$base_file
+	done
+	set -o noglob
+	rm -r $IPKG_TMP/$pkg/control
+
+	if ! $pkg_extract_stdout $filename ./data.tar.gz | (cd $IPKG_TMP/$pkg/data; tar -xzf - ) ; then
+		echo "ipkg_install_file: ERROR unpacking data.tar.gz from $filename"
+		return 1
+	fi
+	echo "Done."
+
+	echo -n "Configuring $pkg..."
+	export PKG_ROOT=$dest
+	if [ -x "$info_dir/$pkg.preinst" ]; then
+		if ! $info_dir/$pkg.preinst install; then
+			echo "$info_dir/$pkg.preinst failed. Aborting installation of $pkg"
+			rm -rf $IPKG_TMP/$pkg/data
+			rmdir $IPKG_TMP/$pkg
+			return 1
+		fi
+	fi
+
+	local old_conffiles="`ipkg_status_sd $sd $pkg Conffiles | ipkg_extract_value`"
+	local new_conffiles=
+	if [ -f "$info_dir/$pkg.conffiles" ]; then
+		for conffile in `cat $info_dir/$pkg.conffiles`; do
+			if [ -f "$dest/$conffile" ] && ! echo " $old_conffiles " | grep -q " $conffile "`md5sum $dest/$conffile | sed 's/ .*//'`; then
+				local use_maintainers_conffile=
+				if [ -z "$FORCE_DEFAULTS" ]; then
+					while true; do
+						echo -n "Configuration file \`$conffile'
+ ==> File on system created by you or by a script.
+ ==> File also in package provided by package maintainer.
+   What would you like to do about it ?  Your options are:
+    Y or I  : install the package maintainer's version
+    N or O  : keep your currently-installed version
+      D     : show the differences between the versions (if diff is installed)
+ The default action is to keep your current version.
+*** `ipkg_file_part $conffile` (Y/I/N/O/D) [default=N] ? "
+						read response
+						case "$response" in
+						[YyIi] | [Yy][Ee][Ss])
+							use_maintainers_conffile=t
+							break
+						;;
+						[Dd])
+							echo "
+diff -u $dest/$conffile $IPKG_TMP/$pkg/data/$conffile"
+							diff -u $dest/$conffile $IPKG_TMP/$pkg/data/$conffile || true
+							echo "[Press ENTER to continue]"
+							read junk
+						;;
+						*)
+							break
+						;;
+						esac
+					done
+				fi
+				if [ -n "$use_maintainers_conffile" ]; then
+					local md5sum="`md5sum $IPKG_TMP/$pkg/data/$conffile | sed 's/ .*//'`"
+					new_conffiles="$new_conffiles $conffile $md5sum"
+				else
+					new_conffiles="$new_conffiles $conffile <custom>"
+					rm $IPKG_TMP/$pkg/data/$conffile
+				fi
+			else
+				md5sum="`md5sum $IPKG_TMP/$pkg/data/$conffile | sed 's/ .*//'`"
+				new_conffiles="$new_conffiles $conffile $md5sum"
+			fi
+		done
+	fi
+
+	local owd="`pwd`"
+	(cd $IPKG_TMP/$pkg/data/; tar cf - . | (cd $owd; cd $dest; tar xf -))
+	rm -rf $IPKG_TMP/$pkg/data
+	rmdir $IPKG_TMP/$pkg
+	$pkg_extract_stdout $filename ./data.tar.gz | tar tzf - | sed -e 's/^\.//' > $info_dir/$pkg.list
+
+	if [ -x "$info_dir/$pkg.postinst" ]; then
+		$info_dir/$pkg.postinst configure
+	fi
+
+	if [ -n "$new_conffiles" ]; then
+		new_conffiles='Conffiles: '`echo $new_conffiles | ipkg_protect_slashes`
+	fi
+	local sed_safe_root="`echo $dest | sed -e "s/^${IPKG_OFFLINE_ROOT}//" | ipkg_protect_slashes`"
+	sed -e "s/\(Package:.*\)/\1\\
+Status: install ok installed\\
+Root: ${sed_safe_root}\\
+${new_conffiles}/" $info_dir/$pkg.control | ipkg_status_update_sd $sd $pkg
+
+	rm -f $info_dir/$pkg.control
+	rm -f $info_dir/$pkg.conffiles
+	rm -f $info_dir/$pkg.preinst
+	rm -f $info_dir/$pkg.postinst
+
+	echo "Done."
+}
+
+ipkg_install_file() {
+	ipkg_install_file_dest $IPKG_ROOT $*
+}
+
+ipkg_install() {
+
+	while [ $# -gt 0 ]; do
+		local pkg="$1"
+		shift
+	
+		case "$pkg" in
+		http://* | ftp://*)
+			local tmp_pkg_file="$IPKG_TMP/"`ipkg_file_part $pkg`
+			if ipkg_download $pkg $tmp_pkg_file; then
+				ipkg_install_file $tmp_pkg_file
+				rm $tmp_pkg_file
+			fi
+			;;
+		file:/*.ipk  | file://*.deb)
+				local ipkg_filename="`echo $pkg|sed 's/^file://'`"
+				ipkg_install_file $ipkg_filename
+			;;
+		*.ipk  | *.deb)
+			if [ -f "$pkg" ]; then
+				ipkg_install_file $pkg
+			else
+				echo "File not found $pkg" >&2
+			fi
+			;;
+		*)
+			ipkg_get_install $pkg || true
+			;;
+		esac
+	done
+}
+
+ipkg_install_pending() {
+	[ -n "$IPKG_OFFLINE_ROOT" ] && return 0
+
+	if [ -d "$IPKG_PENDING_DIR" ]; then
+		set +o noglob
+		local pending="`ls -1d $IPKG_PENDING_DIR/*.ipk 2> /dev/null`" || true
+		set -o noglob
+		if [ -n "$pending" ]; then
+			echo "The following packages in $IPKG_PENDING_DIR will now be installed:"
+			echo $pending
+			for filename in $pending; do
+				if ipkg_install_file $filename; then
+					rm $filename
+				fi
+			done
+		fi
+	fi
+	return 0
+}
+
+ipkg_install_wanted() {
+	local wanted="`ipkg_status_matching 'Status:[[:space:]]*install.*not-installed'`"
+
+	if [ -n "$wanted" ]; then
+		echo "The following package were previously requested but have not been installed:"
+		echo $wanted
+
+		if [ -n "$FORCE_DEFAULTS" ]; then
+			echo "Installing them now."
+		else
+			echo -n "Install them now [Y/n] ? "
+			read response
+			case "$response" in
+			[Nn] | [Nn][Oo])
+				return 0
+				;;
+			esac
+		fi
+
+		ipkg_install $wanted
+	fi
+
+	return 0
+}
+
+ipkg_upgrade_pkg() {
+	local pkg="$1"
+	local avail_ver="`ipkg_info $pkg Version | ipkg_extract_value | head -1`"
+
+	is_installed=
+	for dest_name in `ipkg_dest_names`; do
+		local dest="`ipkg_dest_byname $dest_name`"
+		local sd=$dest/$IPKG_DIR_PREFIX
+		local inst_ver="`ipkg_status_sd $sd $pkg Version | ipkg_extract_value`"
+		if [ -n "$inst_ver" ]; then
+			is_installed=t
+
+			if [ -z "$avail_ver" ]; then
+				echo "Assuming locally installed package $pkg ($inst_ver) is up to date"
+				return 0
+			fi
+
+			if [ "$avail_ver" = "$inst_ver" ]; then 
+				echo "Package $pkg ($inst_ver) installed in $dest_name is up to date"
+			elif ipkg_is_upgrade "$avail_ver" "$inst_ver"; then
+				echo "Upgrading $pkg ($dest_name) from $inst_ver to $avail_ver"
+				ipkg_get_install_dest $dest $pkg
+			else
+				echo "Not downgrading package $pkg from $inst_ver to $avail_ver"
+			fi
+		fi
+	done
+
+	if [ -z "$is_installed" ]; then
+		echo "Package $pkg does not appear to be installed"
+		return 0
+	fi
+
+}
+
+ipkg_upgrade() {
+	if [ $# -lt 1 ]; then
+		local pkgs="`ipkg_status_matching 'Status:.*[[:space:]]installed'`"
+	else
+		pkgs="$*"
+	fi
+	
+	for pkg in $pkgs; do
+		ipkg_upgrade_pkg $pkg
+	done
+}
+
+ipkg_remove_pkg_dest() {
+	local dest="$1"
+	local pkg="$2"
+	local sd=$dest/$IPKG_DIR_PREFIX
+	local info_dir=$sd/info
+
+	if ! ipkg_status_installed_sd $sd $pkg; then
+		echo "ipkg_remove: Package $pkg does not appear to be installed in $dest"
+		if ipkg_status_mentioned_sd $sd $pkg; then
+			echo "Purging mention of $pkg from the ipkg database"
+			ipkg_status_remove_sd $sd $pkg
+		fi
+		return 1
+	fi
+
+	echo "ipkg_remove: Removing $pkg... "
+
+	local files="`cat $info_dir/$pkg.list`"
+
+	export PKG_ROOT=$dest
+	if [ -x "$info_dir/$pkg.prerm" ]; then
+		$info_dir/$pkg.prerm remove
+	fi
+
+	local conffiles="`ipkg_status_sd $sd $pkg Conffiles | ipkg_extract_value`"
+
+	local dirs_to_remove=
+	for file in $files; do
+		if [ -d "$dest/$file" ]; then
+			dirs_to_remove="$dirs_to_remove $dest/$file"
+		else
+			if echo " $conffiles " | grep -q " $file "; then
+				if echo " $conffiles " | grep -q " $file "`md5sum $dest/$file | sed 's/ .*//'`; then
+					rm -f $dest/$file
+				fi
+			else
+				rm -f $dest/$file
+			fi
+		fi
+	done
+
+	local removed_a_dir=t
+	while [ -n "$removed_a_dir" ]; do
+		removed_a_dir=
+		local new_dirs_to_remove=
+		for dir in $dirs_to_remove; do
+			if rmdir $dir >/dev/null 2>&1; then
+				removed_a_dir=t
+			else
+				new_dirs_to_remove="$new_dirs_to_remove $dir"
+			fi
+		done
+		dirs_to_remove="$new_dirs_to_remove"
+	done
+
+	if [ -n "$dirs_to_remove" ]; then
+		echo "ipkg_remove: Warning: Not removing the following directories since they are not empty:" >&2
+		echo "$dirs_to_remove" | sed -e 's/\/[/]\+/\//g' >&2
+	fi
+
+	if [ -x "$info_dir/$pkg.postrm" ]; then
+		$info_dir/$pkg.postrm remove
+	fi
+
+	ipkg_status_remove_sd $sd $pkg
+	set +o noglob
+	rm -f $info_dir/$pkg.*
+	set -o noglob
+
+	echo "Done."
+}
+
+ipkg_remove_pkg() {
+	local pkg="$1"
+	for dest in `ipkg_dests_all`; do
+		local sd=$dest/$IPKG_DIR_PREFIX
+		if ipkg_status_mentioned_sd $sd $pkg; then
+			ipkg_remove_pkg_dest $dest $pkg
+		fi
+	done
+}
+
+ipkg_remove() {
+	while [ $# -gt 0 ]; do
+		local pkg="$1"
+		shift
+		if [ -n "$DEST_NAME" ]; then
+			ipkg_remove_pkg_dest $IPKG_ROOT $pkg
+		else
+			ipkg_remove_pkg $pkg
+		fi
+	done
+}
+
+###########
+# ipkg main
+###########
+
+# Parse options
+while [ $# -gt 0 ]; do
+	arg="$1"
+	case $arg in
+	-d | -dest)
+		[ $# -gt 1 ] || ipkg_usage "option $arg requires an argument"
+		DEST_NAME="$2"
+		shift
+		;;
+	-o | -offline)
+		[ $# -gt 1 ] || ipkg_usage "option $arg requires an argument"
+		IPKG_OFFLINE_ROOT="$2"
+		shift
+		;;
+	-force-depends)
+		FORCE_DEPENDS=t
+		;;
+	-force-defaults)
+		FORCE_DEFAULTS=t
+		;;
+	-*)
+		ipkg_usage "unknown option $arg"
+		;;
+	*)
+		break
+		;;
+	esac
+	shift
+done
+
+[ $# -lt 1 ] && ipkg_usage "ipkg must have one sub-command argument"
+cmd="$1"
+shift
+
+ipkg_load_configuration
+mkdir -p /tmp/ipkg && mkdir -p $IPKG_TMP
+
+case "$cmd" in
+update|upgrade|list|info|status|install_pending)
+	;;
+install|depends|remove|files|search)
+	[ $# -lt 1 ] && ipkg_usage "ERROR: the \`\`$cmd'' command requires an argument"
+	;;
+*)
+	echo "ERROR: unknown sub-command \`$cmd'"
+	ipkg_usage
+	;;
+esac
+
+# Only install pending if we have an interactive sub-command
+case "$cmd" in
+upgrade|install)
+	ipkg_install_pending
+	ipkg_install_wanted
+	;;
+esac
+
+ipkg_$cmd $*
+for a in `ls $IPKG_TMP`; do
+	rm -rf $IPKG_TMP/$a
+done
diff -BurN router/others/linuxrc.sh gateway/others/linuxrc.sh
--- router/others/linuxrc.sh	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/linuxrc.sh	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,81 @@
+#!/bin/sh
+#
+# Copyright (C) 2004, 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+# spin-up hdd
+/sbin/poweron
+
+# get the boot device
+boot_dev=$(nvram get boot_dev)
+
+# short-cut
+if [ -z "$boot_dev" ]; then
+	exec /sbin/init <dev/null >dev/null 2>&1
+fi
+
+# mount procfs
+mount -t proc none /proc
+
+# disable hotplug
+echo > /proc/sys/kernel/hotplug
+
+# insert ide modules first
+insmod ide-mod && insmod ide-probe-mod && insmod ide-disk
+
+# insert usb modules
+if [ ! -b "$boot_dev" ]; then
+	insmod usbcore
+	insmod usb-ohci
+	[ "$(nvram get usb20_disable_x)" -ne 1 ] && insmod ehci-hcd && insmod usb-uhci && sleep 2s
+	insmod scsi_mod && insmod sd_mod && insmod usb-storage
+	# wait for initialization to complete
+	sleep 2s
+fi
+
+# trying to mount new rootfs if it exists
+mount -t ext3 -o ro "$boot_dev" /mnt || mount -t ext2 -o ro "$boot_dev" /mnt
+
+# enable hotplug
+echo /sbin/hotplug > /proc/sys/kernel/hotplug
+
+if [ -d /mnt/mnt ]; then
+	cd /mnt
+	mount -t devfs none dev
+	pivot_root . mnt
+	exec chroot . sbin/init <dev/null >dev/null 2>&1
+fi
+
+# if something fails
+cd /
+
+# unmount everything
+umount /mnt
+
+mount -t devfs none dev
+
+# remove modules
+rmmod usb-storage && rmmod sd_mod && rmmod scsi_mod
+rmmod usb-uhci && rmmod ehci-hcd
+rmmod usb-ohci
+rmmod usbcore
+rmmod ide-disk && rmmod ide-probe-mod && rmmod ide-mod
+
+umount /proc
+
+# finally execute init
+exec /sbin/init <dev/null >dev/null 2>&1
diff -BurN router/others/Makefile gateway/others/Makefile
--- router/others/Makefile	2004-11-15 11:51:39.000000000 +0300
+++ gateway/others/Makefile	2008-08-25 12:46:06.000000000 +0400
@@ -3,34 +3,52 @@
 endif
 
 all :
+	rm -rf $(INSTALLDIR)
+ifneq ($(findstring PARPORT_SUPPORT, $(GLOBAL_OPTIONS)),)
+	make -C parport
+endif
 
 install: all
-	install -d $(INSTALLDIR)/etc
+	install -d $(INSTALLDIR)/usr/etc
 	install -d $(INSTALLDIR)/sbin
 	install -d $(INSTALLDIR)/usr/sbin
+	install -d $(INSTALLDIR)/usr/bin
+	install -d $(INSTALLDIR)/usr/share/empty
 	install -d $(INSTALLDIR)/lib
 	install -d $(INSTALLDIR)/www
-	install -d $(INSTALLDIR)/lib/modules/2.4.20/parport
 
-	install services $(INSTALLDIR)/etc
+	install -m 644 services $(INSTALLDIR)/usr/etc
+	install -m 644 protocols $(INSTALLDIR)/usr/etc
+	install -m 644 rpc $(INSTALLDIR)/usr/etc
+	install -m 644 profile $(INSTALLDIR)/usr/etc
+	install -m 644 ipkg.conf $(INSTALLDIR)/usr/etc
 	install netcam_mfc_activeX.cab $(INSTALLDIR)/www
-	install lp.o $(INSTALLDIR)/lib/modules/2.4.20/parport
-	install parport.o $(INSTALLDIR)/lib/modules/2.4.20/parport
-	install parport_splink.o $(INSTALLDIR)/lib/modules/2.4.20/parport
+ifneq ($(findstring PARPORT_SUPPORT, $(GLOBAL_OPTIONS)),)
+	install -d $(INSTALLDIR)/lib/modules/$(LINUX_KERNEL)/parport
+	install lp.o $(INSTALLDIR)/lib/modules/$(LINUX_KERNEL)/parport
+	install parport.o $(INSTALLDIR)/lib/modules/$(LINUX_KERNEL)/parport
+	install parport_splink.o $(INSTALLDIR)/lib/modules/$(LINUX_KERNEL)/parport
+endif
 	#install waveserver $(INSTALLDIR)/usr/sbin/waveserver
 	
-	ln -sf /tmp/resolv.conf $(INSTALLDIR)/etc/resolv.conf
-	ln -sf /tmp/hosts $(INSTALLDIR)/etc/hosts
-	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500g.Deluxe.CFG
-	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500g.CFG
-	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500b.CFG
-	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500bv2.CFG
-	ln -sf /tmp/settings $(INSTALLDIR)/www/WL300g.CFG
+	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500g.Premium.CFG
+	ln -sf /tmp/settings $(INSTALLDIR)/www/WL700g.CFG
+	ln -sf /tmp/settings $(INSTALLDIR)/www/WL500W.CFG
+	ln -sf /tmp/settings $(INSTALLDIR)/www/WL550gE.CFG
+	ln -sf /tmp/flash.tar.gz $(INSTALLDIR)/www/WL500g.Premium.tar.gz
+	ln -sf /tmp/flash.tar.gz $(INSTALLDIR)/www/WL500W.tar.gz
+	ln -sf /tmp/flash.tar.gz $(INSTALLDIR)/www/WL550gE.tar.gz
 	ln -sf /var/tmp/display.jpg $(INSTALLDIR)/www/display.jpg
 
 ifeq ($(SYSLOG_SUPPORT),1)
 	install -m 755 rotatelog.sh $(INSTALLDIR)/usr/sbin
 endif
 
+	install -m 755 linuxrc.sh $(INSTALLDIR)/linuxrc
+	install -m 755 flashfs.sh $(INSTALLDIR)/sbin/flashfs
+	install -m 755 wshaper.sh $(INSTALLDIR)/sbin/wshaper
+	install -m 755 ipkg.sh $(INSTALLDIR)/usr/bin/ipkg.sh
+	install -m 755 dropbearstart.sh $(INSTALLDIR)/usr/sbin/dropbearstart
+
 clean:
 
diff -BurN router/others/profile gateway/others/profile
--- router/others/profile	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/profile	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,7 @@
+# /etc/profile
+
+export PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+export PS1="[\u@\h \W]\$ "
+
+[ -x /usr/local/etc/profile ] && . /usr/local/etc/profile
+[ -x /opt/etc/profile ] && . /opt/etc/profile
diff -BurN router/others/protocols gateway/others/protocols
--- router/others/protocols	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/protocols	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,149 @@
+# /etc/protocols:
+# $Id: protocols,v 1.3 2001/07/07 07:07:15 nalin Exp $
+#
+# Internet (IP) protocols
+#
+#	from: @(#)protocols	5.1 (Berkeley) 4/17/89
+#
+# Updated for NetBSD based on RFC 1340, Assigned Numbers (July 1992).
+#
+# See also http://www.iana.org/assignments/protocol-numbers
+
+ip	0	IP		# internet protocol, pseudo protocol number
+#hopopt	0	HOPOPT		# hop-by-hop options for ipv6
+icmp	1	ICMP		# internet control message protocol
+igmp	2	IGMP		# internet group management protocol
+ggp	3	GGP		# gateway-gateway protocol
+ipencap	4	IP-ENCAP	# IP encapsulated in IP (officially ``IP'')
+st	5	ST		# ST datagram mode
+tcp	6	TCP		# transmission control protocol
+cbt	7	CBT		# CBT, Tony Ballardie <A.Ballardie@cs.ucl.ac.uk>
+egp	8	EGP		# exterior gateway protocol
+igp	9	IGP		# any private interior gateway (Cisco: for IGRP)
+bbn-rcc	10	BBN-RCC-MON	# BBN RCC Monitoring
+nvp	11	NVP-II		# Network Voice Protocol
+pup	12	PUP		# PARC universal packet protocol
+argus	13	ARGUS		# ARGUS
+emcon	14	EMCON		# EMCON
+xnet	15	XNET		# Cross Net Debugger
+chaos	16	CHAOS		# Chaos
+udp	17	UDP		# user datagram protocol
+mux	18	MUX		# Multiplexing protocol
+dcn	19	DCN-MEAS	# DCN Measurement Subsystems
+hmp	20	HMP		# host monitoring protocol
+prm	21	PRM		# packet radio measurement protocol
+xns-idp	22	XNS-IDP		# Xerox NS IDP
+trunk-1	23	TRUNK-1		# Trunk-1
+trunk-2	24	TRUNK-2		# Trunk-2
+leaf-1	25	LEAF-1		# Leaf-1
+leaf-2	26	LEAF-2		# Leaf-2
+rdp	27	RDP		# "reliable datagram" protocol
+irtp	28	IRTP		# Internet Reliable Transaction Protocol
+iso-tp4	29	ISO-TP4		# ISO Transport Protocol Class 4
+netblt	30	NETBLT		# Bulk Data Transfer Protocol
+mfe-nsp	31	MFE-NSP		# MFE Network Services Protocol
+merit-inp	32	MERIT-INP	# MERIT Internodal Protocol
+sep	33	SEP		# Sequential Exchange Protocol
+3pc	34	3PC		# Third Party Connect Protocol
+idpr	35	IDPR		# Inter-Domain Policy Routing Protocol
+xtp	36	XTP		# Xpress Tranfer Protocol
+ddp	37	DDP		# Datagram Delivery Protocol
+idpr-cmtp	38	IDPR-CMTP	# IDPR Control Message Transport Proto
+tp++	39	TP++		# TP++ Transport Protocol
+il	40	IL		# IL Transport Protocol
+ipv6	41	IPv6		# IPv6
+sdrp	42	SDRP		# Source Demand Routing Protocol
+ipv6-route	43	IPv6-Route 	# Routing Header for IPv6
+ipv6-frag	44	IPv6-Frag	# Fragment Header for IPv6
+idrp	45	IDRP		# Inter-Domain Routing Protocol
+rsvp	46	RSVP		# Resource ReSerVation Protocol
+gre	47	GRE		# Generic Routing Encapsulation
+mhrp	48	MHRP		# Mobile Host Routing Protocol
+bna	49	BNA		# BNA
+ipv6-crypt	50	IPv6-Crypt	# Encryption Header for IPv6
+ipv6-auth	51	IPv6-Auth	# Authentication Header for IPv6
+i-nlsp	52	I-NLSP		# Integrated Net Layer Security TUBA
+swipe	53	SWIPE		# IP with Encryption
+narp	54	NARP		# NBMA Address Resolution Protocol
+mobile	55	MOBILE		# IP Mobility
+tlsp	56	TLSP		# Transport Layer Security Protocol
+skip	57	SKIP		# SKIP
+ipv6-icmp	58	IPv6-ICMP	# ICMP for IPv6
+ipv6-nonxt	59	IPv6-NoNxt	# No Next Header for IPv6
+ipv6-opts	60	IPv6-Opts	# Destination Options for IPv6
+#	61			# any host internal protocol
+cftp	62	CFTP		# CFTP
+#	63			# any local network
+sat-expak	64	SAT-EXPAK	# SATNET and Backroom EXPAK
+kryptolan	65	KRYPTOLAN	# Kryptolan
+rvd	66	RVD		# MIT Remote Virtual Disk Protocol
+ippc	67	IPPC		# Internet Pluribus Packet Core
+#	68			# any distributed file system
+sat-mon	69	SAT-MON		# SATNET Monitoring
+visa	70	VISA		# VISA Protocol
+ipcv	71	IPCV		# Internet Packet Core Utility
+cpnx	72	CPNX		# Computer Protocol Network Executive
+cphb	73	CPHB		# Computer Protocol Heart Beat
+wsn	74	WSN		# Wang Span Network
+pvp	75	PVP		# Packet Video Protocol
+br-sat-mon	76	BR-SAT-MON	# Backroom SATNET Monitoring
+sun-nd	77	SUN-ND		# SUN ND PROTOCOL-Temporary
+wb-mon	78	WB-MON		# WIDEBAND Monitoring
+wb-expak	79	WB-EXPAK	# WIDEBAND EXPAK
+iso-ip	80	ISO-IP		# ISO Internet Protocol
+vmtp	81	VMTP		# Versatile Message Transport
+secure-vmtp	82	SECURE-VMTP	# SECURE-VMTP
+vines	83	VINES		# VINES
+ttp	84	TTP		# TTP
+nsfnet-igp	85	NSFNET-IGP	# NSFNET-IGP
+dgp	86	DGP		# Dissimilar Gateway Protocol
+tcf	87	TCF		# TCF
+eigrp	88	EIGRP		# Enhanced Interior Routing Protocol (Cisco)
+ospf	89	OSPFIGP		# Open Shortest Path First IGP
+sprite-rpc	90	Sprite-RPC	# Sprite RPC Protocol
+larp	91	LARP		# Locus Address Resolution Protocol
+mtp	92	MTP		# Multicast Transport Protocol
+ax.25	93	AX.25		# AX.25 Frames
+ipip	94	IPIP		# Yet Another IP encapsulation
+micp	95	MICP		# Mobile Internetworking Control Pro.
+scc-sp	96	SCC-SP		# Semaphore Communications Sec. Pro.
+etherip	97	ETHERIP		# Ethernet-within-IP Encapsulation
+encap	98	ENCAP		# Yet Another IP encapsulation
+#	99			# any private encryption scheme
+gmtp	100	GMTP		# GMTP
+ifmp	101	IFMP		# Ipsilon Flow Management Protocol
+pnni	102	PNNI		# PNNI over IP
+pim	103	PIM		# Protocol Independent Multicast
+aris	104	ARIS		# ARIS
+scps	105	SCPS		# SCPS
+qnx	106	QNX		# QNX
+a/n	107	A/N		# Active Networks
+ipcomp	108	IPComp		# IP Payload Compression Protocol
+snp	109	SNP		# Sitara Networks Protocol
+compaq-peer	110	Compaq-Peer	# Compaq Peer Protocol
+ipx-in-ip	111	IPX-in-IP	# IPX in IP
+vrrp	112	VRRP		# Virtual Router Redundancy Protocol
+pgm	113	PGM		# PGM Reliable Transport Protocol
+#	114			# any 0-hop protocol
+l2tp	115	L2TP		# Layer Two Tunneling Protocol
+ddx	116	DDX		# D-II Data Exchange
+iatp	117	IATP		# Interactive Agent Transfer Protocol
+stp	118	STP		# Schedule Transfer
+srp	119	SRP		# SpectraLink Radio Protocol
+uti	120	UTI		# UTI
+smp	121	SMP		# Simple Message Protocol
+sm	122	SM		# SM
+ptp	123	PTP		# Performance Transparency Protocol
+isis	124	ISIS		# ISIS over IPv4
+fire	125	FIRE
+crtp	126	CRTP		# Combat Radio Transport Protocol
+crdup	127	CRUDP		# Combat Radio User Datagram
+sscopmce	128	SSCOPMCE
+iplt	129	IPLT
+sps	130	SPS		# Secure Packet Shield
+pipe	131	PIPE		# Private IP Encapsulation within IP
+sctp	132	SCTP		# Stream Control Transmission Protocol
+fc	133	FC		# Fibre Channel
+# rsvp-e2e-ignore	134	RSVP-E2E-IGNORE
+#	134-254			# Unassigned
+#	255			# Reserved
diff -BurN router/others/rpc gateway/others/rpc
--- router/others/rpc	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/rpc	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,69 @@
+#ident	"@(#)rpc	1.11	95/07/14 SMI"	/* SVr4.0 1.2	*/
+#
+#	rpc
+#
+portmapper	100000	portmap sunrpc rpcbind
+rstatd		100001	rstat rup perfmeter rstat_svc
+rusersd		100002	rusers
+nfs		100003	nfsprog
+ypserv		100004	ypprog
+mountd		100005	mount showmount
+ypbind		100007
+walld		100008	rwall shutdown
+yppasswdd	100009	yppasswd
+etherstatd	100010	etherstat
+rquotad		100011	rquotaprog quota rquota
+sprayd		100012	spray
+3270_mapper	100013
+rje_mapper	100014
+selection_svc	100015	selnsvc
+database_svc	100016
+rexd		100017	rex
+alis		100018
+sched		100019
+llockmgr	100020
+nlockmgr	100021
+x25.inr		100022
+statmon		100023
+status		100024
+bootparam	100026
+ypupdated	100028	ypupdate
+keyserv		100029	keyserver
+sunlink_mapper	100033
+tfsd		100037
+nsed		100038
+nsemntd		100039
+showfhd		100043	showfh
+ioadmd		100055	rpc.ioadmd
+NETlicense	100062
+sunisamd	100065
+debug_svc 	100066  dbsrv
+ypxfrd		100069  rpc.ypxfrd
+bugtraqd	100071
+kerbd		100078
+event		100101	na.event	# SunNet Manager
+logger		100102	na.logger	# SunNet Manager
+sync		100104	na.sync
+hostperf	100107	na.hostperf
+activity	100109	na.activity	# SunNet Manager
+hostmem		100112	na.hostmem
+sample		100113	na.sample
+x25		100114	na.x25
+ping		100115	na.ping
+rpcnfs		100116	na.rpcnfs
+hostif		100117	na.hostif
+etherif		100118	na.etherif
+iproutes	100120	na.iproutes
+layers		100121	na.layers
+snmp		100122	na.snmp snmp-cmc snmp-synoptics snmp-unisys snmp-utk
+traffic		100123	na.traffic
+nfs_acl		100227
+sadmind		100232
+nisd		100300	rpc.nisd
+nispasswd	100303	rpc.nispasswdd
+ufsd		100233	ufsd
+pcnfsd		150001	pcnfs
+amd		300019  amq
+sgi_fam		391002	fam
+bwnfsd		545580417
+fypxfrd		600100069 freebsd-ypxfrd
diff -BurN router/others/wshaper.sh gateway/others/wshaper.sh
--- router/others/wshaper.sh	1970-01-01 03:00:00.000000000 +0300
+++ gateway/others/wshaper.sh	2008-01-06 14:27:07.000000000 +0300
@@ -0,0 +1,147 @@
+#!/bin/sh
+# Wonder Shaper
+# please read the README before filling out these values 
+#
+# Set the following values to somewhat less than your actual download
+# and uplink speed. In kilobits. Also set the device that is to be shaped.
+
+DOWNLINK=$3
+UPLINK=$4
+DEV=$2
+
+# low priority OUTGOING traffic - you can leave this blank if you want
+# low priority source netmasks
+NOPRIOHOSTSRC="$5"
+
+# low priority destination netmasks
+NOPRIOHOSTDST="$6"
+
+# low priority source ports
+NOPRIOPORTSRC="$7"
+
+# low priority destination ports
+NOPRIOPORTDST="$8"
+
+
+# Now remove the following two lines :-)
+
+#echo Please read the documentation in 'README' first
+#exit
+
+if [ "$1" = "status" ]
+then
+	tc -s qdisc ls dev $DEV
+	tc -s class ls dev $DEV
+	exit
+fi
+
+
+# clean existing down- and uplink qdiscs, hide errors
+tc qdisc del dev $DEV root    2> /dev/null > /dev/null
+tc qdisc del dev $DEV ingress 2> /dev/null > /dev/null
+
+if [ "$1" = "stop" ] 
+then 
+	exit
+fi
+
+
+###### uplink
+
+# install root HTB, point default traffic to 1:20:
+
+tc qdisc add dev $DEV root handle 1: htb default 20
+
+# shape everything at $UPLINK speed - this prevents huge queues in your
+# DSL modem which destroy latency:
+
+tc class add dev $DEV parent 1: classid 1:1 htb rate ${UPLINK}kbit burst 6k
+
+# high prio class 1:10:
+
+tc class add dev $DEV parent 1:1 classid 1:10 htb rate ${UPLINK}kbit \
+   burst 6k prio 1
+
+# bulk & default class 1:20 - gets slightly less traffic, 
+# and a lower priority:
+
+tc class add dev $DEV parent 1:1 classid 1:20 htb rate $((9*$UPLINK/10))kbit \
+   burst 6k prio 2
+
+tc class add dev $DEV parent 1:1 classid 1:30 htb rate $((8*$UPLINK/10))kbit \
+   burst 6k prio 2
+
+# all get Stochastic Fairness:
+tc qdisc add dev $DEV parent 1:10 handle 10: sfq perturb 10
+tc qdisc add dev $DEV parent 1:20 handle 20: sfq perturb 10
+tc qdisc add dev $DEV parent 1:30 handle 30: sfq perturb 10
+
+# TOS Minimum Delay (ssh, NOT scp) in 1:10:
+
+tc filter add dev $DEV parent 1:0 protocol ip prio 10 u32 \
+      match ip tos 0x10 0xff  flowid 1:10
+
+# ICMP (ip protocol 1) in the interactive class 1:10 so we 
+# can do measurements & impress our friends:
+tc filter add dev $DEV parent 1:0 protocol ip prio 10 u32 \
+        match ip protocol 1 0xff flowid 1:10
+
+# To speed up downloads while an upload is going on, put ACK packets in
+# the interactive class:
+
+tc filter add dev $DEV parent 1: protocol ip prio 10 u32 \
+   match ip protocol 6 0xff \
+   match u8 0x05 0x0f at 0 \
+   match u16 0x0000 0xffc0 at 2 \
+   match u8 0x10 0xff at 33 \
+   flowid 1:10
+
+# rest is 'non-interactive' ie 'bulk' and ends up in 1:20
+
+# some traffic however suffers a worse fate
+for a in $NOPRIOPORTDST
+do
+	tc filter add dev $DEV parent 1: protocol ip prio 14 u32 \
+	   match ip dport $a 0xffff flowid 1:30
+done
+
+for a in $NOPRIOPORTSRC
+do
+ 	tc filter add dev $DEV parent 1: protocol ip prio 15 u32 \
+	   match ip sport $a 0xffff flowid 1:30
+done
+
+for a in $NOPRIOHOSTSRC
+do
+ 	tc filter add dev $DEV parent 1: protocol ip prio 16 u32 \
+	   match ip src $a flowid 1:30
+done
+
+for a in $NOPRIOHOSTDST
+do
+ 	tc filter add dev $DEV parent 1: protocol ip prio 17 u32 \
+	   match ip dst $a flowid 1:30
+done
+
+# rest is 'non-interactive' ie 'bulk' and ends up in 1:20
+
+tc filter add dev $DEV parent 1: protocol ip prio 18 u32 \
+   match ip dst 0.0.0.0/0 flowid 1:20
+
+
+########## downlink #############
+# slow downloads down to somewhat less than the real speed  to prevent 
+# queuing at our ISP. Tune to see how high you can set it.
+# ISPs tend to have *huge* queues to make sure big downloads are fast
+#
+# attach ingress policer:
+
+tc qdisc add dev $DEV handle ffff: ingress
+
+# filter *everything* to it (0.0.0.0/0), drop everything that's
+# coming in too fast:
+
+tc filter add dev $DEV parent ffff: protocol ip prio 50 u32 match ip src \
+   0.0.0.0/0 police rate ${DOWNLINK}kbit burst 10k drop flowid :1
+
+
