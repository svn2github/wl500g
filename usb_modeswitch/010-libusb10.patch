Project: http://wl500g.googlecode.com
From: Roman Samarev ( samarev [  ] acm.org )
Date: 2010/08/24
Subject: usb_modeswitch for libusb1.0 patch
Details:

This patch allow to compile usb_modeswitch with libusb-1.0 if LIBUSB10 is defined.
And libusb0.1 or libusb-compat if LIBUSB10 is absent.


diff -uBp usb-modeswitch.orig/Makefile usb_modeswitch/Makefile
--- usb-modeswitch.orig/Makefile	2010-08-17 21:15:53.000000000 +0400
+++ usb_modeswitch/Makefile	2010-08-26 20:53:29.000000000 +0400
@@ -1,8 +1,8 @@
 PROG        = usb_modeswitch
 VERS        = 1.1.4
 CC          = gcc
-CFLAGS      += -Wall
-LIBS        = -l usb
+CFLAGS      += -Wall -DLIBUSB10
+LIBS        = -lusb-1.0
 RM          = /bin/rm -f
 OBJS        = usb_modeswitch.c
 PREFIX      = $(DESTDIR)/usr
diff -uBp usb-modeswitch.orig/usb_modeswitch.c usb_modeswitch/usb_modeswitch.c
--- usb-modeswitch.orig/usb_modeswitch.c	2010-11-29 02:03:32.000000000 +0300
+++ usb_modeswitch/usb_modeswitch.c	2010-12-01 16:13:05.000000000 +0300
@@ -53,7 +53,130 @@
 #include <getopt.h>
 #include <syslog.h>
 
-#include <usb.h>
+#ifndef LIBUSB10
+    #include <usb.h>
+
+    inline int get_devnum(struct usb_device * dev)
+    {
+	return dev->devnum;
+    }
+    inline int get_busnum(struct usb_device * dev)
+    {
+	return (int)strtol(dev->bus->dirname,NULL,10);
+    }
+#else
+    #include <libusb.h>
+    #include <unistd.h>
+
+    #define USB_ENDPOINT_IN		LIBUSB_ENDPOINT_IN
+    #define USB_ENDPOINT_OUT		LIBUSB_ENDPOINT_OUT
+    #define USB_ENDPOINT_TYPE_MASK	LIBUSB_ENDPOINT_ADDRESS_MASK
+    #define USB_ENDPOINT_DIR_MASK	LIBUSB_ENDPOINT_DIR_MASK
+    #define USB_ENDPOINT_TYPE_BULK	LIBUSB_TRANSFER_TYPE_BULK
+    #define USB_TYPE_STANDARD		LIBUSB_REQUEST_TYPE_STANDARD
+    #define USB_TYPE_VENDOR		LIBUSB_REQUEST_TYPE_VENDOR
+    #define USB_RECIP_DEVICE		LIBUSB_RECIPIENT_DEVICE
+    #define USB_REQ_SET_FEATURE		LIBUSB_REQUEST_SET_FEATURE
+    #define USB_REQ_GET_CONFIGURATION	LIBUSB_REQUEST_GET_CONFIGURATION
+
+    #define LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+    #define LIBUSB_HAS_GET_DRIVER_NP
+
+
+    #define usb_device		libusb_device
+    #define usb_dev_handle	libusb_device_handle
+    #define usb_endpoint_descriptor	libusb_endpoint_descriptor
+
+    #define usb_init()		libusb_init ( &ctx )
+    #define usb_set_debug(x)	libusb_set_debug( ctx, 3 )
+    #define usb_find_busses()	(0)
+    #define usb_find_devices()	(0)
+    #define usb_close		libusb_close
+    #define usb_get_string_simple	libusb_get_string_descriptor_ascii
+    #define usb_reset		libusb_reset_device
+    #define usb_claim_interface	libusb_claim_interface
+    #define usb_clear_halt	libusb_clear_halt
+    #define usb_release_interface	libusb_release_interface
+    #define usb_control_msg	libusb_control_transfer
+    #define usb_set_configuration	libusb_set_configuration
+    #define usb_detach_kernel_driver_np	libusb_detach_kernel_driver
+
+    libusb_device_handle * usb_open(libusb_device *dev){
+	libusb_device_handle * handle;
+	libusb_open(dev, &handle);
+	return handle;
+    }
+
+    int get_busnum(struct libusb_device * dev)
+    {
+	return libusb_get_bus_number(dev);
+    }
+
+    int get_devnum(struct libusb_device * dev)
+    {
+	return libusb_get_device_address(dev);
+    }
+
+    int usb_get_driver_np(struct libusb_device_handle *dev, int interface,
+	char *name, unsigned int namelen)
+    {
+	int r = libusb_kernel_driver_active(dev, interface);
+	if (r == 1) {
+		/* libusb-1.0 doesn't expose driver name, so fill in a dummy value */
+		snprintf(name, namelen, "dummy");
+		return 0;
+	} else return r;
+    }
+
+    int usb_bulk_io(struct libusb_device_handle *dev, int ep, char *bytes,
+	int size, int timeout)
+    {
+	int actual_length;
+	int r;
+	printf("endpoint %x size %d timeout %d", ep, size, timeout);
+	r = libusb_bulk_transfer(dev, ep & 0xff, bytes, size,
+		&actual_length, timeout);
+	
+	/* if we timed out but did transfer some data, report as successful short
+	 * read. FIXME: is this how libusb-0.1 works? */
+	if (r == 0 || (r == LIBUSB_ERROR_TIMEOUT && actual_length > 0))
+		return actual_length;
+
+	return r;
+    }
+
+    int usb_bulk_read(struct usb_dev_handle *dev, int ep, char *bytes,
+	int size, int timeout)
+    {
+	if (!(ep & LIBUSB_ENDPOINT_IN)) {
+		/* libusb-0.1 will strangely fix up a read request from endpoint
+		 * 0x01 to be from endpoint 0x81. do the same thing here, but
+		 * warn about this silly behaviour. */
+		puts("endpoint %x is missing IN direction bit, fixing");
+		ep |= LIBUSB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(dev, ep, bytes, size, timeout);
+    }
+
+    int usb_bulk_write(struct usb_dev_handle *dev, int ep, char *bytes,
+	int size, int timeout)
+    {
+	if (ep & LIBUSB_ENDPOINT_IN) {
+		/* libusb-0.1 on BSD strangely fix up a write request to endpoint
+		 * 0x81 to be to endpoint 0x01. do the same thing here, but
+		 * warn about this silly behaviour. */
+		puts("endpoint %x has excessive IN direction bit, fixing");
+		ep &= ~LIBUSB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(dev, ep, bytes, size, timeout);
+    }
+
+    static struct libusb_context *ctx = NULL;
+
+#endif
+
 #include "usb_modeswitch.h"
 
 #define LINE_DIM 1024
@@ -392,8 +515,8 @@ int main(int argc, char **argv)
 		exit(0);
 	}
 	if (dev != NULL) {
-		devnum = dev->devnum;
-		busnum = (int)strtol(dev->bus->dirname,NULL,10);
+		devnum = get_devnum(dev);
+		busnum = get_busnum(dev);
 		SHOW_PROGRESS("Accessing device %03d on bus %03d ...\n", devnum, busnum);
 		devh = usb_open(dev);
 	} else {
@@ -405,8 +528,18 @@ int main(int argc, char **argv)
 	currentConfig = get_current_configuration();
 
 	/* Get class of default device/interface */
+#ifndef LIBUSB10
 	defaultClass = dev->descriptor.bDeviceClass;
 	interfaceClass = get_interface0_class(dev, currentConfig);
+#else
+	struct libusb_device_descriptor descriptor;
+	libusb_get_device_descriptor(dev, &descriptor);
+	defaultClass = descriptor.bDeviceClass;
+	struct libusb_config_descriptor *config;
+	libusb_get_config_descriptor(dev, 0, &config);
+	interfaceClass = config->interface[0].altsetting[0].bInterfaceClass;
+	libusb_free_config_descriptor(config);
+#endif
 	if (interfaceClass == -1) {
 		fprintf(stderr, "Error: getting the interface class failed. Aborting.\n\n");
 		exit(1);
@@ -594,8 +727,21 @@ void deviceDescription ()
 	memset (iproduct, ' ', DESCR_MAX);
 	memset (iserial, ' ', DESCR_MAX);
 
-	if (dev->descriptor.iManufacturer) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iManufacturer, imanufact, DESCR_MAX);
+#ifndef LIBUSB10
+	int iManufacturer = dev->descriptor.iManufacturer;
+	int iProduct = dev->descriptor.iProduct;
+	int iSerialNumber = dev->descriptor.iSerialNumber;
+#else
+	struct libusb_device_descriptor descriptor;
+	libusb_get_device_descriptor(dev, &descriptor);
+
+	int iManufacturer = descriptor.iManufacturer;
+	int iProduct = descriptor.iProduct;
+	int iSerialNumber = descriptor.iSerialNumber;
+#endif
+
+	if (iManufacturer) {
+		ret = usb_get_string_simple(devh, iManufacturer, imanufact, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"manufacturer\"\n");
 	} else
@@ -604,8 +750,8 @@ void deviceDescription ()
 	if (c)
 		memset((void*)c, '\0', 1);
 
-	if (dev->descriptor.iProduct) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iProduct, iproduct, DESCR_MAX);
+	if (iProduct) {
+		ret = usb_get_string_simple(devh, iProduct, iproduct, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"product\"\n");
 	} else
@@ -614,8 +760,8 @@ void deviceDescription ()
 	if (c)
 		memset((void*)c, '\0', 1);
 
-	if (dev->descriptor.iSerialNumber) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iSerialNumber, iserial, DESCR_MAX);
+	if (iSerialNumber) {
+		ret = usb_get_string_simple(devh, iSerialNumber, iserial, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"serial number\"\n");
 	} else
@@ -838,7 +984,11 @@ int switchAltSetting ()
 
 	SHOW_PROGRESS("Changing to alt setting %i ...\n", AltSetting);
 	ret = usb_claim_interface(devh, Interface);
+#ifndef LIBUSB10
 	ret = usb_set_altinterface(devh, AltSetting);
+#else
+	ret = libusb_set_interface_alt_setting(devh, Interface, AltSetting);
+#endif
 	usb_release_interface(devh, Interface);
 	if (ret != 0) {
 		SHOW_PROGRESS(" Changing to alt setting returned error %d. Trying to continue\n", ret);
@@ -855,7 +1005,7 @@ void switchHuaweiMode ()
 	int ret;
 
 	SHOW_PROGRESS("Sending Huawei control message ...\n");
-	ret = usb_control_msg(devh, USB_TYPE_STANDARD + USB_RECIP_DEVICE, USB_REQ_SET_FEATURE, 00000001, 0, buffer, 0, 1000);
+	ret = usb_control_msg(devh, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_REQ_SET_FEATURE, 00000001, 0, buffer, 0, 1000);
 	if (ret != 0) {
 		fprintf(stderr, "Error: sending Huawei control message failed (error %d). Aborting.\n\n", ret);
 		exit(1);
@@ -1103,7 +1253,7 @@ int checkSuccess()
 				devh = 0;
 				if (verbose) {
 					printf("\nFound target device %03d on bus %03d\n", \
-					dev->devnum, (int)strtol(dev->bus->dirname,NULL,10));
+					get_devnum(dev), get_busnum(dev));
 					printf("\nTarget device description data\n");
 					printf("-------------------------\n");
 					printf("Manufacturer: %s\n", imanufact);
@@ -1203,8 +1353,10 @@ void release_usb_device(int dummy) {
 */
 struct usb_device* search_devices( int *numFound, int vendor, int product, char* productList, int targetClass, int mode)
 {
+#ifndef LIBUSB10
 	struct usb_bus *bus;
-	char *listcopy, *token, buffer[2];
+#endif
+	char *listcopy=NULL, *token, buffer[2];
 	int devClass;
 	struct usb_device* right_dev = NULL;
 
@@ -1222,12 +1374,33 @@ struct usb_device* search_devices( int *
 	if (productList != '\0')
 		listcopy = malloc(strlen(productList)+1);
 
+#ifndef LIBUSB10
 	for (bus = usb_get_busses(); bus; bus = bus->next) {
 		struct usb_device *dev;
 		for (dev = bus->devices; dev; dev = dev->next) {
+#else
+	struct libusb_device **devs;
+	int i=0;
+
+	if (libusb_get_device_list( ctx, &devs ) < 0){
+		perror ("failed to access USB");
+		return 0;
+	}
+
+	while ( (dev = devs[i++]) != NULL) {
+#endif
+#ifndef LIBUSB10
+			int idVendor = dev->descriptor.idVendor;
+			int idProduct = dev->descriptor.idProduct;
+#else
+			struct libusb_device_descriptor descriptor;
+			libusb_get_device_descriptor(dev, &descriptor);
+			int idVendor = descriptor.idVendor;
+			int idProduct = descriptor.idProduct;
+#endif
 			if (verbose)
-				printf ("  searching devices, found USB ID %04x:%04x\n", dev->descriptor.idVendor, dev->descriptor.idProduct);
-			if (dev->descriptor.idVendor != vendor)
+				printf ("  searching devices, found USB ID %04x:%04x\n", idVendor, idProduct);
+			if (idVendor != vendor)
 				continue;
 			if (verbose)
 				printf ("   found matching vendor ID\n");
@@ -1248,16 +1421,16 @@ struct usb_device* search_devices( int *
 					product += (unsigned char)buffer[0];
 					product <<= 8;
 					product += (unsigned char)buffer[1];
-					if (product == dev->descriptor.idProduct) {
+					if (product == idProduct) {
 						if (verbose)
 							printf ("   found matching product ID from list\n");
 						(*numFound)++;
 						if (busnum == -1)
 							right_dev = dev;
 						else
-							if (dev->devnum >= devnum && (int)strtol(dev->bus->dirname,NULL,10) == busnum) {
+							if (get_devnum(dev) >= devnum && get_busnum(dev) == busnum) {
 								right_dev = dev;
-								TargetProduct = dev->descriptor.idProduct;
+								TargetProduct = idProduct;
 								break;
 							}
 					}
@@ -1267,7 +1440,7 @@ struct usb_device* search_devices( int *
 				}
 			/* Product ID is given */
 			} else
-				if (product == dev->descriptor.idProduct) {
+				if (product == idProduct) {
 					if (verbose)
 						printf ("   found matching product ID\n");
 					if (targetClass == 0) {
@@ -1276,13 +1449,24 @@ struct usb_device* search_devices( int *
 						if (verbose)
 							printf ("   adding device\n");
 					} else {
+#ifndef LIBUSB10
 						devClass = dev->descriptor.bDeviceClass;
+						int ifaceClass=dev->config[0].interface[0].altsetting[0].bInterfaceClass;
+#else
+						struct libusb_device_descriptor descriptor;
+						libusb_get_device_descriptor(dev, &descriptor);
+						devClass = descriptor.bDeviceClass;
+						struct libusb_config_descriptor *config;
+						libusb_get_config_descriptor(dev, 0, &config);
+						int ifaceClass = config->interface[0].altsetting[0].bInterfaceClass;
+						libusb_free_config_descriptor(config);
+#endif
 						if (devClass == 0)
-							devClass = dev->config[0].interface[0].altsetting[0].bInterfaceClass;
+							devClass = ifaceClass;
 						else
 							/* Check for some quirky devices */
-							if (devClass != dev->config[0].interface[0].altsetting[0].bInterfaceClass)
-								devClass = dev->config[0].interface[0].altsetting[0].bInterfaceClass;
+							if (devClass != ifaceClass)
+								devClass = ifaceClass;
 						if (devClass == targetClass) {
 							if (verbose)
 								printf ("   target class %02x matching\n", targetClass);
@@ -1309,13 +1493,15 @@ struct usb_device* search_devices( int *
 					 * successCheck() and do probe for plausible new devnum/busnum
 					 */
 					if (busnum != -1)
-						if (dev->devnum < devnum || (int)strtol(dev->bus->dirname,NULL,10) != busnum) {
+						if (get_devnum(dev) < devnum || get_busnum(dev) != busnum) {
 							if (verbose)
 								printf ("   busnum/devnum indicates an unrelated device\n");
 							right_dev = NULL;
 						}
 				}
+#ifndef LIBUSB10
 		}
+#endif
 	}
 	if (productList != NULL)
 		free(listcopy);
@@ -1331,8 +1517,15 @@ struct usb_device* search_devices( int *
 int find_first_bulk_output_endpoint(struct usb_device *dev)
 {
 	int i;
+#ifndef LIBUSB10
 	struct usb_interface_descriptor *alt = &(dev->config[0].interface[0].altsetting[0]);
 	struct usb_endpoint_descriptor *ep;
+#else
+	struct libusb_config_descriptor *config;
+	libusb_get_config_descriptor(dev, 0, &config);
+	const struct libusb_interface_descriptor *alt = &(config[0].interface[0].altsetting[0]);
+	const struct usb_endpoint_descriptor *ep;
+#endif
 
 	for(i=0;i < alt->bNumEndpoints;i++) {
 		ep=&(alt->endpoint[i]);
@@ -1341,6 +1534,9 @@ int find_first_bulk_output_endpoint(stru
 			return ep->bEndpointAddress;
 		}
 	}
+#ifdef LIBUSB10
+	libusb_free_config_descriptor(config);
+#endif
 
 	return 0;
 }
@@ -1349,9 +1545,15 @@ int find_first_bulk_output_endpoint(stru
 int find_first_bulk_input_endpoint(struct usb_device *dev)
 {
 	int i;
+#ifndef LIBUSB10
 	struct usb_interface_descriptor *alt = &(dev->config[0].interface[0].altsetting[0]);
 	struct usb_endpoint_descriptor *ep;
-
+#else
+	struct libusb_config_descriptor *config;
+	libusb_get_config_descriptor(dev, 0, &config);
+	const struct libusb_interface_descriptor *alt = &(config[0].interface[0].altsetting[0]);
+	const struct usb_endpoint_descriptor *ep;
+#endif
 	for(i=0;i < alt->bNumEndpoints;i++) {
 		ep=&(alt->endpoint[i]);
 		if( ( (ep->bmAttributes & USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_BULK) &&
@@ -1359,6 +1561,9 @@ int find_first_bulk_input_endpoint(struc
 			return ep->bEndpointAddress;
 		}
 	}
+#ifdef LIBUSB10
+	libusb_free_config_descriptor(config);
+#endif
 
 	return 0;
 }
@@ -1379,6 +1584,7 @@ int get_current_configuration()
 }
 
 
+#ifndef LIBUSB10
 int get_interface0_class(struct usb_device *dev, int devconfig)
 {
 	int i;
@@ -1387,6 +1593,7 @@ int get_interface0_class(struct usb_devi
 			return dev->config[i].interface[0].altsetting[0].bInterfaceClass;
 	return -1;
 }
+#endif
 
 
 /* Parameter parsing */
@@ -1502,41 +1709,45 @@ int hexstr2bin(const char *hex, char *bu
 void printVersion()
 {
 	char* version = VERSION;
-	printf(" * usb_modeswitch: handle USB devices with multiple modes\n");
-	printf(" * Version %s (C) Josua Dietze 2010\n", version);
-	printf(" * Based on libusb0 (0.1.12 and above)\n\n");
-	printf(" ! PLEASE REPORT NEW CONFIGURATIONS !\n\n");
+	printf(	" * usb_modeswitch: handle USB devices with multiple modes\n"
+		" * Version %s (C) Josua Dietze 2010\n", version );
+#ifndef LIBUSB10
+	printf(	" * Based on libusb0 (0.1.12 and above)\n\n" );
+#else
+	printf(	" * Based on libusb10 (1.0.1 and above)\n\n" );
+#endif
+	printf(	" ! PLEASE REPORT NEW CONFIGURATIONS !\n\n");
 }
 
 void printHelp()
 {
-	printf ("Usage: usb_modeswitch [-hvpVPmMrdHn] [-c filename]\n\n");
-	printf (" -h, --help                    this help\n");
-	printf (" -e, --version                 print version information and exit\n");
-	printf (" -v, --default-vendor NUM      vendor ID of original mode (mandatory)\n");
-	printf (" -p, --default-product NUM     product ID of original mode (mandatory)\n");
-	printf (" -V, --target-vendor NUM       target mode vendor ID (optional)\n");
-	printf (" -P, --target-product NUM      target mode product ID (optional)\n");
-	printf (" -C, --target-class NUM        target mode device class (optional)\n");
-	printf (" -m, --message-endpoint NUM    direct the message transfer there (optional)\n");
-	printf (" -M, --message-content <msg>   message to send (hex number as string)\n");
-	printf (" -2 <msg>, -3 <msg>            additional messages to send (-n recommended)\n");
-	printf (" -n, --need-response           read response to the message transfer (CSW)\n");
-	printf (" -r, --response-endpoint NUM   read response from there (optional)\n");
-	printf (" -d, --detach-only             detach the active driver, no further action\n");
-	printf (" -H, --huawei-mode             apply a special procedure\n");
-	printf (" -S, --sierra-mode             apply a special procedure\n");
-	printf (" -O, --sony-mode               apply a special procedure\n");
-	printf (" -G, --gct-mode                apply a special procedure\n");
-	printf (" -T, --kobil-mode              apply a special procedure\n");
-	printf (" -R, --reset-usb               reset the device after all other actions\n");
-	printf (" -Q, --quiet                   don't show progress or error messages\n");
-	printf (" -W, --verbose                 print all settings and debug output\n");
-	printf (" -D, --sysmode                 specific result and syslog message\n");
-	printf (" -s, --success NUM             check switching result after NUM secs\n");
-	printf (" -I, --no-inquire              do not get SCSI attributes (default on)\n\n");
-	printf (" -c, --config-file <filename>  load configuration from file\n\n");
-	printf (" -i, --interface NUM           select initial USB interface (default 0)\n");
-	printf (" -u, --configuration NUM       select USB configuration\n");
-	printf (" -a, --altsetting NUM          select alternative USB interface setting\n\n");
+	printf ("Usage: usb_modeswitch [-hvpVPmMrdHn] [-c filename]\n\n"
+		" -h, --help                    this help\n"
+		" -e, --version                 print version information and exit\n"
+		" -v, --default-vendor NUM      vendor ID of original mode (mandatory)\n"
+		" -p, --default-product NUM     product ID of original mode (mandatory)\n"
+		" -V, --target-vendor NUM       target mode vendor ID (optional)\n"
+		" -P, --target-product NUM      target mode product ID (optional)\n"
+		" -C, --target-class NUM        target mode device class (optional)\n"
+		" -m, --message-endpoint NUM    direct the message transfer there (optional)\n"
+		" -M, --message-content <msg>   message to send (hex number as string)\n"
+		" -2 <msg>, -3 <msg>            additional messages to send (-n recommended)\n"
+		" -n, --need-response           read response to the message transfer (CSW)\n"
+		" -r, --response-endpoint NUM   read response from there (optional)\n"
+		" -d, --detach-only             detach the active driver, no further action\n"
+		" -H, --huawei-mode             apply a special procedure\n"
+		" -S, --sierra-mode             apply a special procedure\n"
+		" -O, --sony-mode               apply a special procedure\n"
+		" -G, --gct-mode                apply a special procedure\n"
+		" -T, --kobil-mode              apply a special procedure\n"
+		" -R, --reset-usb               reset the device after all other actions\n"
+		" -Q, --quiet                   don't show progress or error messages\n"
+		" -W, --verbose                 print all settings and debug output\n"
+		" -D, --sysmode                 specific result and syslog message\n"
+		" -s, --success NUM             check switching result after NUM secs\n"
+		" -I, --no-inquire              do not get SCSI attributes (default on)\n\n"
+		" -c, --config-file <filename>  load configuration from file\n\n"
+		" -i, --interface NUM           select initial USB interface (default 0)\n"
+		" -u, --configuration NUM       select USB configuration\n"
+		" -a, --altsetting NUM          select alternative USB interface setting\n\n");
 }
diff -uBp usb-modeswitch.orig/usb_modeswitch.h usb_modeswitch/usb_modeswitch.h
--- usb-modeswitch.orig/usb_modeswitch.h	2010-11-29 02:02:37.000000000 +0300
+++ usb_modeswitch/usb_modeswitch.h	2010-08-24 21:12:19.000000000 +0400
@@ -24,7 +24,11 @@
 
 
 #include <stdlib.h>
-#include <usb.h>
+#ifndef LIBUSB10
+    #include <usb.h>
+#else
+    #include <libusb.h>
+#endif
 
 void readConfigFile(const char *configFilename);
 void printConfig();
