diff -uBp usb-modeswitch-1.2.4/Makefile usb_modeswitch/Makefile
--- usb-modeswitch-1.2.4/Makefile	2012-08-12 19:21:10.000000000 +0400
+++ usb_modeswitch/Makefile	2012-08-13 21:22:34.000000000 +0400
@@ -2,7 +2,7 @@ PROG        = usb_modeswitch
 VERS        = 1.2.4
 CC          = gcc
 CFLAGS      += -Wall
-LIBS        = -l usb
+LIBS        = -lusb-1.0
 RM          = /bin/rm -f
 OBJS        = usb_modeswitch.c
 PREFIX      = $(DESTDIR)/usr
diff -uBp usb-modeswitch-1.2.4/usb_modeswitch.c usb_modeswitch/usb_modeswitch.c
--- usb-modeswitch-1.2.4/usb_modeswitch.c	2012-08-12 19:03:46.000000000 +0400
+++ usb_modeswitch/usb_modeswitch.c	2012-08-13 21:40:36.000000000 +0400
@@ -54,10 +54,138 @@
 #include <ctype.h>
 #include <getopt.h>
 #include <syslog.h>
+#include <unistd.h>
 
-#include <usb.h>
 #include "usb_modeswitch.h"
 
+#define LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+#define LIBUSB_HAS_GET_DRIVER_NP
+
+#define USB_ENDPOINT_IN		LIBUSB_ENDPOINT_IN
+#define USB_ENDPOINT_OUT		LIBUSB_ENDPOINT_OUT
+#define USB_ENDPOINT_TYPE_MASK	LIBUSB_ENDPOINT_ADDRESS_MASK
+#define USB_ENDPOINT_DIR_MASK	LIBUSB_ENDPOINT_DIR_MASK
+#define USB_ENDPOINT_TYPE_BULK	LIBUSB_TRANSFER_TYPE_BULK
+#define USB_TYPE_STANDARD		LIBUSB_REQUEST_TYPE_STANDARD
+#define USB_TYPE_CLASS		LIBUSB_REQUEST_TYPE_CLASS
+#define USB_TYPE_VENDOR		LIBUSB_REQUEST_TYPE_VENDOR
+#define USB_RECIP_DEVICE		LIBUSB_RECIPIENT_DEVICE
+#define USB_RECIP_INTERFACE		LIBUSB_RECIPIENT_INTERFACE
+#define USB_REQ_SET_FEATURE		LIBUSB_REQUEST_SET_FEATURE
+#define USB_REQ_GET_CONFIGURATION	LIBUSB_REQUEST_GET_CONFIGURATION
+
+#define usb_set_debug(x)	libusb_set_debug(ctx, 3)
+#define usb_close		libusb_close
+#define usb_get_string_simple	libusb_get_string_descriptor_ascii
+#define usb_reset		libusb_reset_device
+#define usb_claim_interface	libusb_claim_interface
+#define usb_clear_halt	libusb_clear_halt
+#define usb_release_interface	libusb_release_interface
+#define usb_control_msg	libusb_control_transfer
+#define usb_set_configuration	libusb_set_configuration
+#define usb_detach_kernel_driver_np	libusb_detach_kernel_driver
+
+/* libusb 1.0 wrappers */
+int usb_bulk_io(struct libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	int actual_length;
+	int r;
+//	usbi_dbg("endpoint %x size %d timeout %d", ep, size, timeout);
+	r = libusb_bulk_transfer(handle, ep & 0xff, bytes, size,
+		&actual_length, timeout);
+	
+	/* if we timed out but did transfer some data, report as successful short
+	 * read. FIXME: is this how libusb-0.1 works? */
+	if (r == 0 || (r == LIBUSB_ERROR_TIMEOUT && actual_length > 0))
+		return actual_length;
+
+	return r;
+}
+
+int usb_bulk_read(struct libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	if (!(ep & LIBUSB_ENDPOINT_IN)) {
+		/* libusb-0.1 will strangely fix up a read request from endpoint
+		 * 0x01 to be from endpoint 0x81. do the same thing here, but
+		 * warn about this silly behaviour. */
+		printf("endpoint %x is missing IN direction bit, fixing", ep);
+		ep |= LIBUSB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(handle, ep, bytes, size, timeout);
+}
+
+int usb_bulk_write(struct libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	if (ep & LIBUSB_ENDPOINT_IN) {
+		/* libusb-0.1 on BSD strangely fix up a write request to endpoint
+		 * 0x81 to be to endpoint 0x01. do the same thing here, but
+		 * warn about this silly behaviour. */
+		printf("endpoint %x has excessive IN direction bit, fixing", ep);
+		ep &= ~LIBUSB_ENDPOINT_IN;
+	}
+
+	return usb_bulk_io(handle, ep, bytes, size, timeout);
+}
+
+static int usb_interrupt_io(libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	int actual_length;
+	int r;
+//	usbi_dbg("endpoint %x size %d timeout %d", ep, size, timeout);
+	r = libusb_interrupt_transfer(handle, ep & 0xff, bytes, size,
+		&actual_length, timeout);
+	
+	/* if we timed out but did transfer some data, report as successful short
+	 * read. FIXME: is this how libusb-0.1 works? */
+	if (r == 0 || (r == LIBUSB_ERROR_TIMEOUT && actual_length > 0))
+		return actual_length;
+
+	return (r);
+}
+
+int usb_interrupt_read(libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	if (!(ep & USB_ENDPOINT_IN)) {
+		/* libusb-0.1 will strangely fix up a read request from endpoint
+		 * 0x01 to be from endpoint 0x81. do the same thing here, but
+		 * warn about this silly behaviour. */
+		printf("endpoint %x is missing IN direction bit, fixing", ep);
+		ep |= USB_ENDPOINT_IN;
+	}
+	return usb_interrupt_io(handle, ep, bytes, size, timeout);
+}
+
+int usb_interrupt_write(libusb_device_handle *handle, int ep, char *bytes,
+	int size, int timeout)
+{
+	if (ep & USB_ENDPOINT_IN) {
+		/* libusb-0.1 on BSD strangely fix up a write request to endpoint
+		 * 0x81 to be to endpoint 0x01. do the same thing here, but
+		 * warn about this silly behaviour. */
+		printf("endpoint %x has excessive IN direction bit, fixing", ep);
+		ep &= ~USB_ENDPOINT_IN;
+	}
+
+	return usb_interrupt_io(handle, ep, bytes, size, timeout);
+}
+
+int usb_get_driver_np(struct libusb_device_handle *dev, int interface,
+char *name, unsigned int namelen)
+{
+	int r = libusb_kernel_driver_active(dev, interface);
+	if (r == 1) {
+		/* libusb-1.0 doesn't expose driver name, so fill in a dummy value */
+		snprintf(name, namelen, "dummy");
+		return 0;
+	} else return r;
+}
+
 #define LINE_DIM 1024
 #define MAXLINES 50
 #define BUF_SIZE 4096
@@ -73,8 +201,9 @@
 
 char *TempPP=NULL;
 
-struct usb_device *dev;
-struct usb_dev_handle *devh;
+static struct libusb_context *ctx = NULL;
+static struct libusb_device *dev;
+static struct libusb_device_handle *devh;
 
 int DefaultVendor=0, DefaultProduct=0, TargetVendor=0, TargetProduct=-1, TargetClass=0;
 int MessageEndpoint=0, ResponseEndpoint=0, ReleaseDelay=0;
@@ -351,6 +480,8 @@ int main(int argc, char **argv)
 {
 	int numDefaults=0, specialMode=0, sonySuccess=0;
 	int currentConfig=0, defaultClass=0, interfaceClass=0;
+	struct libusb_device_descriptor descriptor;
+	struct libusb_config_descriptor *config;
 
 
 	/* Make sure we have empty strings even if not set by config */
@@ -413,14 +544,11 @@ int main(int argc, char **argv)
 			printf("Note: target parameter missing; success check limited\n");
 
 	/* libusb initialization */
-	usb_init();
+	libusb_init(&ctx);
 
 	if (verbose)
 		usb_set_debug(15);
 
-	usb_find_busses();
-	usb_find_devices();
-
 	/* Count existing target devices, remember for success check */
 	if ((TargetVendor || TargetClass) && searchMode != SEARCH_BUSDEV) {
 		SHOW_PROGRESS(output,"Looking for target devices ...\n");
@@ -445,11 +573,11 @@ int main(int argc, char **argv)
 		exit(0);
 	} else {
 		if (devnum == -1) {
-			devnum = dev->devnum;
-			busnum = (int)strtol(dev->bus->dirname,NULL,10);
+			devnum = libusb_get_device_address(dev);
+			busnum = libusb_get_bus_number(dev);
 			SHOW_PROGRESS(output,"Accessing device %03d on bus %03d ...\n", devnum, busnum);
 		}
-		devh = usb_open(dev);
+		libusb_open(dev, &devh);
 		if (devh == NULL) {
 			SHOW_PROGRESS(output,"Error opening the device. Aborting.\n\n");
 			exit(1);
@@ -471,13 +599,16 @@ int main(int argc, char **argv)
 		currentConfig = 0;
 	}
 
+	libusb_get_device_descriptor(dev, &descriptor);
+	defaultClass = descriptor.bDeviceClass;
+	libusb_get_config_descriptor(dev, 0, &config);
 	if (Interface == -1)
-		Interface = dev->config[0].interface[0].altsetting[0].bInterfaceNumber;
+		Interface = config->interface[0].altsetting[0].bInterfaceNumber;
 	SHOW_PROGRESS(output,"Using interface number %d\n", Interface);
 
 	/* Get class of default device/interface */
-	defaultClass = dev->descriptor.bDeviceClass;
-	interfaceClass = get_interface_class(dev, currentConfig, Interface);
+	interfaceClass = get_interface_class(config, Interface);
+	libusb_free_config_descriptor(config);
 	if (interfaceClass == -1) {
 		fprintf(stderr, "Error: getting the class of interface %d failed. Does it exist? Aborting.\n\n",Interface);
 		exit(1);
@@ -700,8 +831,15 @@ void deviceDescription ()
 	memset (iproduct, ' ', DESCR_MAX);
 	memset (iserial, ' ', DESCR_MAX);
 
-	if (dev->descriptor.iManufacturer) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iManufacturer, imanufact, DESCR_MAX);
+	struct libusb_device_descriptor descriptor;
+	libusb_get_device_descriptor(dev, &descriptor);
+
+	int iManufacturer = descriptor.iManufacturer;
+	int iProduct = descriptor.iProduct;
+	int iSerialNumber = descriptor.iSerialNumber;
+
+	if (iManufacturer) {
+		ret = usb_get_string_simple(devh, iManufacturer, imanufact, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"manufacturer\"\n");
 	} else
@@ -710,8 +848,8 @@ void deviceDescription ()
 	if (c)
 		memset((void*)c, '\0', 1);
 
-	if (dev->descriptor.iProduct) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iProduct, iproduct, DESCR_MAX);
+	if (iProduct) {
+		ret = usb_get_string_simple(devh, iProduct, iproduct, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"product\"\n");
 	} else
@@ -720,8 +858,8 @@ void deviceDescription ()
 	if (c)
 		memset((void*)c, '\0', 1);
 
-	if (dev->descriptor.iSerialNumber) {
-		ret = usb_get_string_simple(devh, dev->descriptor.iSerialNumber, iserial, DESCR_MAX);
+	if (iSerialNumber) {
+		ret = usb_get_string_simple(devh, iSerialNumber, iserial, DESCR_MAX);
 		if (ret < 0)
 			fprintf(stderr, "Error: could not get description string \"serial number\"\n");
 	} else
@@ -926,7 +1064,7 @@ int switchAltSetting ()
 
 	SHOW_PROGRESS(output,"Changing to alt setting %i ...\n", AltSetting);
 	ret = usb_claim_interface(devh, Interface);
-	ret = usb_set_altinterface(devh, AltSetting);
+	ret = libusb_set_interface_alt_setting(devh, Interface, AltSetting);
 	usb_release_interface(devh, Interface);
 	if (ret != 0) {
 		SHOW_PROGRESS(output," Changing to alt setting returned error %d. Trying to continue\n", ret);
@@ -943,7 +1081,7 @@ void switchHuaweiMode ()
 	int ret;
 
 	SHOW_PROGRESS(output,"Sending Huawei control message ...\n");
-	ret = usb_control_msg(devh, USB_TYPE_STANDARD + USB_RECIP_DEVICE, USB_REQ_SET_FEATURE, 00000001, 0, buffer, 0, 1000);
+	ret = usb_control_msg(devh, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_REQ_SET_FEATURE, 00000001, 0, buffer, 0, 1000);
 	if (ret != 0) {
 		fprintf(stderr, "Error: sending Huawei control message failed (error %d). Aborting.\n\n", ret);
 		exit(1);
@@ -1046,8 +1184,6 @@ int switchSonyMode ()
 	dev = 0;
 	while ( dev == 0 && i < 30 ) {
 		if ( i > 5 ) {
-			usb_find_busses();
-			usb_find_devices();
 			dev = search_devices(&found, DefaultVendor, DefaultProduct, "\0", TargetClass, 0, SEARCH_TARGET);
 		}
 		if ( dev != 0 )
@@ -1062,7 +1198,7 @@ int switchSonyMode ()
 	SHOW_PROGRESS(output,"\n After %d seconds:",i);
 	if ( dev ) {
 		SHOW_PROGRESS(output," device came back, proceeding\n");
-		devh = usb_open( dev );
+		libusb_open(dev, &devh);
 		if (devh == 0) {
 			fprintf(stderr, "Error: could not get handle on device\n");
 			return 0;
@@ -1223,7 +1359,7 @@ int detachDriver()
 #ifndef LIBUSB_HAS_GET_DRIVER_NP
 	printf(" Cant't do driver detection and detaching on this platform.\n");
 	return 2;
-#endif
+#else
 
 	SHOW_PROGRESS(output,"Looking for active driver ...\n");
 	ret = usb_get_driver_np(devh, Interface, buffer, BUF_SIZE);
@@ -1237,12 +1373,12 @@ int detachDriver()
 	} else {
 		SHOW_PROGRESS(output," OK, driver found (\"%s\")\n", buffer);
 	}
+#endif
 
 #ifndef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
 	SHOW_PROGRESS(output," Can't do driver detaching on this platform\n");
 	return 2;
-#endif
-
+#else
 
 	ret = usb_detach_kernel_driver_np(devh, Interface);
 	if (ret == 0) {
@@ -1250,6 +1386,7 @@ int detachDriver()
 	} else
 		SHOW_PROGRESS(output," Driver \"%s\" detach failed with error %d. Trying to continue\n", buffer, ret);
 	return 1;
+#endif
 }
 
 
@@ -1333,24 +1470,16 @@ int checkSuccess()
 		 */
 		for (i=i; i < CheckSuccess; i++) {
 			SHOW_PROGRESS(output," Searching for target devices ...\n");
-			ret = usb_find_busses();
-			if (ret >= 0)
-				ret = usb_find_devices();
-			if (ret < 0) {
-				SHOW_PROGRESS(output,"Error: libusb1 bug, no more searching, try to work around\n");
-				success = 3;
-				break;
-			}
 			dev = search_devices(&newTargetCount, TargetVendor, TargetProduct, TargetProductList, TargetClass, 0, SEARCH_TARGET);
 			if (dev && (newTargetCount > targetDeviceCount)) {
 				printf("\nFound target device, now opening\n");
-				devh = usb_open(dev);
+				libusb_open(dev, &devh);
 				deviceDescription();
 				usb_close(devh);
 				devh = 0;
 				if (verbose) {
 					printf("\nFound target device %03d on bus %03d\n", \
-					dev->devnum, (int)strtol(dev->bus->dirname,NULL,10));
+					libusb_get_device_address(dev), libusb_get_bus_number(dev));
 					printf("\nTarget device description data\n");
 					printf("-------------------------\n");
 					printf("Manufacturer: %s\n", imanufact);
@@ -1448,13 +1577,14 @@ void release_usb_device(int dummy) {
 /* Iterates over busses and devices, counts the ones which match the given
  * parameters and returns the last one of them
 */
-struct usb_device* search_devices( int *numFound, int vendor, int product, char* productList, int targetClass, int configuration, int mode)
+struct libusb_device* search_devices( int *numFound, int vendor, int product, char* productList, int targetClass, int configuration, int mode)
 {
-	struct usb_bus *bus;
 	char *listcopy=NULL, *token, buffer[2];
 	int devClass;
-	struct usb_device* right_dev = NULL;
-	struct usb_dev_handle *testdevh;
+	struct libusb_device* right_dev = NULL;
+	struct libusb_device_handle *testdevh;
+	struct libusb_device **devs;
+	int i=0;
 
 	/* only target class given, target vendor and product assumed unchanged */
 	if ( targetClass && !(vendor || product) ) {
@@ -1470,21 +1600,29 @@ struct usb_device* search_devices( int *
 	if (productList != '\0')
 		listcopy = malloc(strlen(productList)+1);
 
-	for (bus = usb_get_busses(); bus; bus = bus->next) {
-		if (mode == SEARCH_BUSDEV)
-			if (busnum != (int)strtol(bus->dirname,NULL,10))
+	if (libusb_get_device_list(ctx, &devs) < 0) {
+		perror("failed to access USB");
+		return 0;
+	}
+
+	while ((dev = devs[i++]) != NULL) {
+		struct libusb_device_descriptor descriptor;
+		libusb_get_device_descriptor(dev, &descriptor);
+		int idVendor = descriptor.idVendor;
+		int idProduct = descriptor.idProduct;
+
+		if (mode == SEARCH_BUSDEV) {
+			if ((libusb_get_bus_number(dev) != busnum) ||
+				(libusb_get_device_address(dev) != devnum))
 				continue;
-		struct usb_device *dev;
-		for (dev = bus->devices; dev; dev = dev->next) {
-			if (mode == SEARCH_BUSDEV) {
-				if (dev->devnum != devnum)
-					continue;
-				else
-					SHOW_PROGRESS(output," bus/device number matched\n");
-			}
+			else
+				SHOW_PROGRESS(output," bus/device number matched\n");
+		}
+
 			if (verbose)
-				fprintf (output,"  searching devices, found USB ID %04x:%04x\n", dev->descriptor.idVendor, dev->descriptor.idProduct);
-			if (dev->descriptor.idVendor != vendor)
+				fprintf (output,"  searching devices, found USB ID %04x:%04x\n",
+						idVendor, idProduct);
+			if (idVendor != vendor)
 				continue;
 			if (verbose)
 				fprintf (output,"   found matching vendor ID\n");
@@ -1505,16 +1643,16 @@ struct usb_device* search_devices( int *
 					product += (unsigned char)buffer[0];
 					product <<= 8;
 					product += (unsigned char)buffer[1];
-					if (product == dev->descriptor.idProduct) {
+					if (product == idProduct) {
 						if (verbose)
 							fprintf (output,"   found matching product ID from list\n");
 						(*numFound)++;
 						if (busnum == -1)
 							right_dev = dev;
 						else
-							if (dev->devnum >= devnum && (int)strtol(dev->bus->dirname,NULL,10) == busnum) {
+							if (libusb_get_device_address(dev) >= devnum && libusb_get_bus_number(dev) == busnum) {
 								right_dev = dev;
-								TargetProduct = dev->descriptor.idProduct;
+								TargetProduct = idProduct;
 								break;
 							}
 					}
@@ -1523,7 +1661,7 @@ struct usb_device* search_devices( int *
 				}
 			/* Product ID is given */
 			} else
-				if (product == dev->descriptor.idProduct) {
+				if (product == idProduct) {
 					SHOW_PROGRESS(output,"   found matching product ID\n");
 					if (targetClass == 0 && configuration < 1) {
 						(*numFound)++;
@@ -1531,13 +1669,20 @@ struct usb_device* search_devices( int *
 						right_dev = dev;
 					} else {
 						if (targetClass != 0) {
-							devClass = dev->descriptor.bDeviceClass;
+							struct libusb_device_descriptor descriptor;
+							libusb_get_device_descriptor(dev, &descriptor);
+							devClass = descriptor.bDeviceClass;
+							struct libusb_config_descriptor *config;
+							libusb_get_config_descriptor(dev, 0, &config);
+							int ifaceClass = config->interface[0].altsetting[0].bInterfaceClass;
+							libusb_free_config_descriptor(config);
+
 							if (devClass == 0)
-								devClass = dev->config[0].interface[0].altsetting[0].bInterfaceClass;
+								devClass = ifaceClass;
 							else
 								/* Check for some quirky devices */
-								if (devClass != dev->config[0].interface[0].altsetting[0].bInterfaceClass)
-									devClass = dev->config[0].interface[0].altsetting[0].bInterfaceClass;
+								if (devClass != ifaceClass)
+									devClass = ifaceClass;
 							if (devClass == targetClass) {
 								if (verbose)
 									fprintf (output,"   target class %02x matching\n", targetClass);
@@ -1561,7 +1706,7 @@ struct usb_device* search_devices( int *
 							}
 						} else {
 							// check configuration (only if no target class given)
-							testdevh = usb_open(dev);
+							libusb_open(dev, &testdevh);
 							int testconfig = get_current_configuration(testdevh);
 							if (testconfig != configuration) {
 								if (verbose)
@@ -1576,7 +1721,6 @@ struct usb_device* search_devices( int *
 						}
 					}
 				}
-		}
 	}
 	if (listcopy != NULL)
 		free(listcopy);
@@ -1589,11 +1733,13 @@ struct usb_device* search_devices( int *
 
 /* Autodetect bulk endpoints (ab) */
 
-int find_first_bulk_output_endpoint(struct usb_device *dev)
+int find_first_bulk_output_endpoint(struct libusb_device *dev)
 {
 	int i;
-	struct usb_interface_descriptor *alt = &(dev->config[0].interface[0].altsetting[0]);
-	struct usb_endpoint_descriptor *ep;
+	struct libusb_config_descriptor *config;
+	libusb_get_config_descriptor(dev, 0, &config);
+	const struct libusb_interface_descriptor *alt = &(config[0].interface[0].altsetting[0]);
+	const struct libusb_endpoint_descriptor *ep;
 
 	for(i=0;i < alt->bNumEndpoints;i++) {
 		ep=&(alt->endpoint[i]);
@@ -1602,17 +1748,19 @@ int find_first_bulk_output_endpoint(stru
 			return ep->bEndpointAddress;
 		}
 	}
+	libusb_free_config_descriptor(config);
 
 	return 0;
 }
 
 
-int find_first_bulk_input_endpoint(struct usb_device *dev)
+int find_first_bulk_input_endpoint(struct libusb_device *dev)
 {
 	int i;
-	struct usb_interface_descriptor *alt = &(dev->config[0].interface[0].altsetting[0]);
-	struct usb_endpoint_descriptor *ep;
-
+	struct libusb_config_descriptor *config;
+	libusb_get_config_descriptor(dev, 0, &config);
+	const struct libusb_interface_descriptor *alt = &(config[0].interface[0].altsetting[0]);
+	const struct libusb_endpoint_descriptor *ep;
 	for(i=0;i < alt->bNumEndpoints;i++) {
 		ep=&(alt->endpoint[i]);
 		if( ( (ep->bmAttributes & USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_BULK) &&
@@ -1620,11 +1768,12 @@ int find_first_bulk_input_endpoint(struc
 			return ep->bEndpointAddress;
 		}
 	}
+	libusb_free_config_descriptor(config);
 
 	return 0;
 }
 
-int get_current_configuration(struct usb_dev_handle* devh)
+int get_current_configuration(struct libusb_device_handle* devh)
 {
 	int ret;
 
@@ -1644,39 +1793,16 @@ int get_current_configuration(struct usb
 	}
 }
 
-
-int get_interface0_class(struct usb_device *dev, int devconfig)
+int get_interface_class(struct libusb_config_descriptor *cfg, int ifcNumber)
 {
-	/* Hack for quirky devices */
-	if (devconfig == 0)
-		return dev->config[0].interface[0].altsetting[0].bInterfaceClass;
-
 	int i;
-	for (i=0; i<dev->descriptor.bNumConfigurations; i++)
-		if (dev->config[i].bConfigurationValue == devconfig)
-			return dev->config[i].interface[0].altsetting[0].bInterfaceClass;
-	return -1;
-}
 
-int get_interface_class(struct usb_device *dev, int cfgNumber, int ifcNumber)
-{
-	int i;
-	int j;
-	// some single-configuration devices balk on iteration, treat them separately
-	if (cfgNumber == 0)
-		for (i=0; i<dev->config[0].bNumInterfaces; i++) {
-//			SHOW_PROGRESS(output,"Test: looking at ifc %d, class is %d\n",i,dev->config[0].interface[i].altsetting[0].bInterfaceClass);
-			if (dev->config[0].interface[i].altsetting[0].bInterfaceNumber == ifcNumber)
-				return dev->config[0].interface[i].altsetting[0].bInterfaceClass;
-		}
-	else
-		for (j=0; j<dev->descriptor.bNumConfigurations; j++)
-			if (dev->config[j].bConfigurationValue == cfgNumber)
-				for (i=0; i<dev->config[j].bNumInterfaces; i++) {
-//					SHOW_PROGRESS(output,"Test: looking at ifc %d, class is %d\n",i,dev->config[j].interface[i].altsetting[0].bInterfaceClass);
-					if (dev->config[j].interface[i].altsetting[0].bInterfaceNumber == ifcNumber)
-						return dev->config[j].interface[i].altsetting[0].bInterfaceClass;
-				}
+	for (i=0; i<cfg->bNumInterfaces; i++) {
+//		SHOW_PROGRESS(output,"Test: looking at ifc %d, class is %d\n",i,cfg->interface[i].altsetting[0].bInterfaceClass);
+		if (cfg->interface[i].altsetting[0].bInterfaceNumber == ifcNumber)
+			return cfg->interface[i].altsetting[0].bInterfaceClass;
+	}
+
 	return -1;
 }
 
diff -uBp usb-modeswitch-1.2.4/usb_modeswitch.h usb_modeswitch/usb_modeswitch.h
--- usb-modeswitch-1.2.4/usb_modeswitch.h	2012-08-12 19:47:07.000000000 +0400
+++ usb_modeswitch/usb_modeswitch.h	2012-08-13 21:37:21.000000000 +0400
@@ -24,7 +24,7 @@
 
 
 #include <stdlib.h>
-#include <usb.h>
+#include <libusb.h>
 
 void readConfigFile(const char *configFilename);
 void printConfig();
@@ -46,13 +46,12 @@ int sendMessage(char* message, int count
 int write_bulk(int endpoint, char *message, int length);
 int read_bulk(int endpoint, char *buffer, int length);
 void release_usb_device(int dummy);
-struct usb_device* search_devices( int *numFound, int vendor, int product, char* productList,
+struct libusb_device* search_devices( int *numFound, int vendor, int product, char* productList,
 	int targetClass, int configuration, int mode);
-int find_first_bulk_output_endpoint(struct usb_device *dev);
-int find_first_bulk_input_endpoint(struct usb_device *dev);
-int get_current_configuration(struct usb_dev_handle* devh);
-int get_interface0_class(struct usb_device *dev, int devconfig);
-int get_interface_class(struct usb_device *dev, int cfgNumber, int ifcNumber);
+int find_first_bulk_output_endpoint(struct libusb_device *dev);
+int find_first_bulk_input_endpoint(struct libusb_device *dev);
+int get_current_configuration(struct libusb_device_handle* devh);
+int get_interface_class(struct libusb_config_descriptor *cfg, int ifcNumber);
 char* ReadParseParam(const char* FileName, char *VariableName);
 int hex2num(char c);
 int hex2byte(const char *hex);
