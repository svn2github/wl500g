diff -urNBp iptables.orig/extensions/libip6t_ROUTE.c iptables/extensions/libip6t_ROUTE.c
--- iptables.orig/extensions/libip6t_ROUTE.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libip6t_ROUTE.c	2006-12-12 13:34:45.000000000 +0300
@@ -0,0 +1,240 @@
+/* Shared library add-on to iptables to add ROUTE v6 target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.1 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_ROUTE.h>
+
+/* compile IP6T_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IP6T_ROUTE_TEE
+#define IP6T_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute the packet through `ifname' network interface\n"
+"    --gw    \tip     \t\tRoute the packet via this gateway\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.1");
+}
+
+static struct option opts[] = {
+	{ "oif", 1, 0, '1' },
+	{ "iif", 1, 0, '2' },
+	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw[0] = 0;
+	route_info->gw[1] = 0;
+	route_info->gw[2] = 0;
+	route_info->gw[3] = 0;
+	route_info->flags = 0;
+}
+
+
+#define IP6T_ROUTE_OPT_OIF      0x01
+#define IP6T_ROUTE_OPT_IIF      0x02
+#define IP6T_ROUTE_OPT_GW       0x04
+#define IP6T_ROUTE_OPT_CONTINUE 0x08
+#define IP6T_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IP6T_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --oif");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IP6T_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		exit_error(PARAMETER_PROBLEM,
+			   "--iif option not implemented");
+		break;
+
+	case '3':
+		if (*flags & IP6T_ROUTE_OPT_GW)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
+		if (!inet_pton(AF_INET6, optarg, (struct in6_addr*)&route_info->gw)) {
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid IPv6 address %s",
+				   optarg);
+		}
+
+		*flags |= IP6T_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IP6T_ROUTE_CONTINUE;
+		*flags |= IP6T_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IP6T_ROUTE_TEE;
+		*flags |= IP6T_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif or gw option required");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_target *target,
+      int numeric)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	printf("ROUTE ");
+
+	if (route_info->oif[0])
+		printf("oif:%s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf("gw:%s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf("continue");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf("tee");
+
+}
+
+
+static void save(const struct ip6t_ip6 *ip, 
+		 const struct ip6t_entry_target *target)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf("--gw %s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf("--continue ");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf("--tee ");
+}
+
+
+static struct ip6tables_target route = { 
+	.name 		= "ROUTE",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	register_target6(&route);
+}
diff -urNBp iptables.orig/extensions/libip6t_ROUTE.man iptables/extensions/libip6t_ROUTE.man
--- iptables.orig/extensions/libip6t_ROUTE.man	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libip6t_ROUTE.man	2006-12-12 13:34:45.000000000 +0300
@@ -0,0 +1,15 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--gw " "IPv6_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules. Not valid in combination with `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--continue'
diff -urNBp iptables.orig/extensions/libipt_ROUTE.c iptables/extensions/libipt_ROUTE.c
--- iptables.orig/extensions/libipt_ROUTE.c	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_ROUTE.c	2006-12-12 13:34:45.000000000 +0300
@@ -0,0 +1,264 @@
+/* Shared library add-on to iptables to add ROUTE target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.11 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_ROUTE.h>
+
+/* compile IPT_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IPT_ROUTE_TEE
+#define IPT_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.11");
+}
+
+static struct option opts[] = {
+	{ "oif", 1, 0, '1' },
+	{ "iif", 1, 0, '2' },
+	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_route_target_info *route_info = 
+		(struct ipt_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw = 0;
+	route_info->flags = 0;
+}
+
+
+#define IPT_ROUTE_OPT_OIF      0x01
+#define IPT_ROUTE_OPT_IIF      0x02
+#define IPT_ROUTE_OPT_GW       0x04
+#define IPT_ROUTE_OPT_CONTINUE 0x08
+#define IPT_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_route_target_info *route_info = 
+		(struct ipt_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --oif and --iif together");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --oif");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IPT_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --iif twice");
+
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --iif and --oif together");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --iif");
+
+		if (strlen(optarg) > sizeof(route_info->iif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->iif) - 1);
+
+		strcpy(route_info->iif, optarg);
+		*flags |= IPT_ROUTE_OPT_IIF;
+		break;
+
+	case '3':
+		if (*flags & IPT_ROUTE_OPT_GW)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
+		if (!inet_aton(optarg, (struct in_addr*)&route_info->gw)) {
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid IP address %s",
+				   optarg);
+		}
+
+		*flags |= IPT_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IPT_ROUTE_CONTINUE;
+		*flags |= IPT_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IPT_ROUTE_TEE;
+		*flags |= IPT_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif, iif or gw option required");
+
+	if ((flags & (IPT_ROUTE_OPT_CONTINUE|IPT_ROUTE_OPT_TEE)) && (flags & IPT_ROUTE_OPT_IIF))
+		exit_error(PARAMETER_PROBLEM,
+			   "ROUTE target: can't continue traversing the rules with iif option");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	printf("ROUTE ");
+
+	if (route_info->oif[0])
+		printf("oif:%s ", route_info->oif);
+
+	if (route_info->iif[0])
+		printf("iif:%s ", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr ip = { route_info->gw };
+		printf("gw:%s ", inet_ntoa(ip));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf("continue");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf("tee");
+
+}
+
+
+static void save(const struct ipt_ip *ip, 
+		 const struct ipt_entry_target *target)
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->iif[0])
+		printf("--iif %s ", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr ip = { route_info->gw };
+		printf("--gw %s ", inet_ntoa(ip));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf("--continue ");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf("--tee ");
+}
+
+
+static struct iptables_target route = { 
+	.next		= NULL,
+	.name		= "ROUTE",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&route);
+}
diff -urNBp iptables.orig/extensions/libipt_ROUTE.man iptables/extensions/libipt_ROUTE.man
--- iptables.orig/extensions/libipt_ROUTE.man	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/libipt_ROUTE.man	2006-12-12 13:34:45.000000000 +0300
@@ -0,0 +1,18 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--iif " "ifname"
+Change the packet's incoming interface to `ifname'
+.TP
+.BI "--gw " "IP_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--continue'
diff -urNBp iptables.orig/extensions/.ROUTE-test iptables/extensions/.ROUTE-test
--- iptables.orig/extensions/.ROUTE-test	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/.ROUTE-test	2006-12-12 13:34:45.000000000 +0300
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_ROUTE.c ] && echo ROUTE
diff -urNBp iptables.orig/extensions/.ROUTE-test6 iptables/extensions/.ROUTE-test6
--- iptables.orig/extensions/.ROUTE-test6	1970-01-01 03:00:00.000000000 +0300
+++ iptables/extensions/.ROUTE-test6	2010-11-12 18:48:15.000000000 +0300
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv6/netfilter/ip6t_ROUTE.c ] && echo ROUTE
