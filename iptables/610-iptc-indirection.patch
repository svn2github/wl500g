libiptc: remove indirections

 Backport of upstream commits
  fd1873110f8e57be578df17fc9d03536b10f4f73 libiptc: remove typedef indirection
  1c9015b2cb483678f153121255e10ec0bbfde3e6 libiptc: remove indirections

diff -urBp iptables.old/include/ip6tables.h iptables/include/ip6tables.h
--- iptables.old/include/ip6tables.h	2007-03-22 03:04:35.000000000 +0300
+++ iptables/include/ip6tables.h	2011-03-02 12:50:41.000000000 +0300
@@ -154,7 +154,7 @@ extern void register_target6(struct ip6t
 extern int service_to_port(const char *name, const char *proto);
 extern u_int16_t parse_port(const char *port, const char *proto);
 extern int do_command6(int argc, char *argv[], char **table,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle **handle);
 /* Keeping track of external matches and targets: linked lists. */
 extern struct ip6tables_match *ip6tables_matches;
 extern struct ip6tables_target *ip6tables_targets;
@@ -171,9 +171,9 @@ extern struct ip6tables_match *find_matc
 
 extern void parse_interface(const char *arg, char *vianame, unsigned char *mask);
 
-extern int for_each_chain(int (*fn)(const ip6t_chainlabel, int, ip6tc_handle_t *), int verbose, int builtinstoo, ip6tc_handle_t *handle);
-extern int flush_entries(const ip6t_chainlabel chain, int verbose, ip6tc_handle_t *handle);
-extern int delete_chain(const ip6t_chainlabel chain, int verbose, ip6tc_handle_t *handle);
+extern int for_each_chain(int (*fn)(const ip6t_chainlabel, int, struct ip6tc_handle *), int verbose, int builtinstoo, struct ip6tc_handle *handle);
+extern int flush_entries(const ip6t_chainlabel chain, int verbose, struct ip6tc_handle *handle);
+extern int delete_chain(const ip6t_chainlabel chain, int verbose, struct ip6tc_handle *handle);
 extern int
 ip6tables_insmod(const char *modname, const char *modprobe, int quiet);
 extern int load_ip6tables_ko(const char *modprobe, int quiet);
diff -urBp iptables.old/include/iptables.h iptables/include/iptables.h
--- iptables.old/include/iptables.h	2007-01-23 15:49:52.000000000 +0300
+++ iptables/include/iptables.h	2011-03-02 12:51:35.000000000 +0300
@@ -168,7 +168,7 @@ extern u_int16_t parse_protocol(const ch
 extern void parse_interface(const char *arg, char *vianame, unsigned char *mask);
 
 extern int do_command(int argc, char *argv[], char **table,
-		      iptc_handle_t *handle);
+		      struct iptc_handle **handle);
 /* Keeping track of external matches and targets: linked lists.  */
 extern struct iptables_match *iptables_matches;
 extern struct iptables_target *iptables_targets;
@@ -184,11 +184,11 @@ extern struct iptables_target *find_targ
 extern struct iptables_match *find_match(const char *name, enum ipt_tryload, struct iptables_rule_match **match);
 
 extern int delete_chain(const ipt_chainlabel chain, int verbose,
-			iptc_handle_t *handle);
+			struct iptc_handle *handle);
 extern int flush_entries(const ipt_chainlabel chain, int verbose, 
-			iptc_handle_t *handle);
-extern int for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
-		int verbose, int builtinstoo, iptc_handle_t *handle);
+			struct iptc_handle *handle);
+extern int for_each_chain(int (*fn)(const ipt_chainlabel, int, struct iptc_handle *),
+		int verbose, int builtinstoo, struct iptc_handle *handle);
 
 /* kernel revision handling */
 extern int kernel_version;
diff -urBp iptables.old/include/libiptc/libip6tc.h iptables/include/libiptc/libip6tc.h
--- iptables.old/include/libiptc/libip6tc.h	2007-01-23 15:49:52.000000000 +0300
+++ iptables/include/libiptc/libip6tc.h	2011-03-02 12:53:17.000000000 +0300
@@ -10,6 +10,8 @@
 #endif
 #define IP6T_ALIGN(s) (((s) + (IP6T_MIN_ALIGN-1)) & ~(IP6T_MIN_ALIGN-1))
 
+struct ip6tc_handle;
+
 typedef char ip6t_chainlabel[32];
 
 #define IP6TC_LABEL_ACCEPT "ACCEPT"
@@ -17,41 +19,38 @@ typedef char ip6t_chainlabel[32];
 #define IP6TC_LABEL_QUEUE   "QUEUE"
 #define IP6TC_LABEL_RETURN "RETURN"
 
-/* Transparent handle type. */
-typedef struct ip6tc_handle *ip6tc_handle_t;
-
 /* Does this chain exist? */
-int ip6tc_is_chain(const char *chain, const ip6tc_handle_t handle);
+int ip6tc_is_chain(const char *chain, const struct ip6tc_handle *handle);
 
 /* Take a snapshot of the rules. Returns NULL on error. */
-ip6tc_handle_t ip6tc_init(const char *tablename);
+struct ip6tc_handle *ip6tc_init(const char *tablename);
 
 /* Cleanup after ip6tc_init(). */
-void ip6tc_free(ip6tc_handle_t *h);
+void ip6tc_free(struct ip6tc_handle *h);
 
 /* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *ip6tc_first_chain(ip6tc_handle_t *handle);
-const char *ip6tc_next_chain(ip6tc_handle_t *handle);
+const char *ip6tc_first_chain(struct ip6tc_handle *handle);
+const char *ip6tc_next_chain(struct ip6tc_handle *handle);
 
 /* Get first rule in the given chain: NULL for empty chain. */
 const struct ip6t_entry *ip6tc_first_rule(const char *chain,
-					  ip6tc_handle_t *handle);
+					  struct ip6tc_handle *handle);
 
 /* Returns NULL when rules run out. */
 const struct ip6t_entry *ip6tc_next_rule(const struct ip6t_entry *prev,
-					 ip6tc_handle_t *handle);
+					 struct ip6tc_handle *handle);
 
 /* Returns a pointer to the target name of this position. */
 const char *ip6tc_get_target(const struct ip6t_entry *e,
-			     ip6tc_handle_t *handle);
+			     struct ip6tc_handle *handle);
 
 /* Is this a built-in chain? */
-int ip6tc_builtin(const char *chain, const ip6tc_handle_t handle);
+int ip6tc_builtin(const char *chain, const struct ip6tc_handle *handle);
 
 /* Get the policy of a given built-in chain */
 const char *ip6tc_get_policy(const char *chain,
 			     struct ip6t_counters *counters,
-			     ip6tc_handle_t *handle);
+			     struct ip6tc_handle *handle);
 
 /* These functions return TRUE for OK or 0 and set errno. If errno ==
    0, it means there was a version error (ie. upgrade libiptc). */
@@ -61,86 +60,86 @@ const char *ip6tc_get_policy(const char 
 int ip6tc_insert_entry(const ip6t_chainlabel chain,
 		       const struct ip6t_entry *e,
 		       unsigned int rulenum,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Atomically replace rule `rulenum' in `chain' with `fw'. */
 int ip6tc_replace_entry(const ip6t_chainlabel chain,
 			const struct ip6t_entry *e,
 			unsigned int rulenum,
-			ip6tc_handle_t *handle);
+			struct ip6tc_handle *handle);
 
 /* Append entry `fw' to chain `chain'. Equivalent to insert with
    rulenum = length of chain. */
 int ip6tc_append_entry(const ip6t_chainlabel chain,
 		       const struct ip6t_entry *e,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Delete the first rule in `chain' which matches `fw'. */
 int ip6tc_delete_entry(const ip6t_chainlabel chain,
 		       const struct ip6t_entry *origfw,
 		       unsigned char *matchmask,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Delete the rule in position `rulenum' in `chain'. */
 int ip6tc_delete_num_entry(const ip6t_chainlabel chain,
 			   unsigned int rulenum,
-			   ip6tc_handle_t *handle);
+			   struct ip6tc_handle *handle);
 
 /* Check the packet `fw' on chain `chain'. Returns the verdict, or
    NULL and sets errno. */
 const char *ip6tc_check_packet(const ip6t_chainlabel chain,
 			       struct ip6t_entry *,
-			       ip6tc_handle_t *handle);
+			       struct ip6tc_handle *handle);
 
 /* Flushes the entries in the given chain (ie. empties chain). */
 int ip6tc_flush_entries(const ip6t_chainlabel chain,
-			ip6tc_handle_t *handle);
+			struct ip6tc_handle *handle);
 
 /* Zeroes the counters in a chain. */
 int ip6tc_zero_entries(const ip6t_chainlabel chain,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Creates a new chain. */
 int ip6tc_create_chain(const ip6t_chainlabel chain,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Deletes a chain. */
 int ip6tc_delete_chain(const ip6t_chainlabel chain,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Renames a chain. */
 int ip6tc_rename_chain(const ip6t_chainlabel oldname,
 		       const ip6t_chainlabel newname,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* Sets the policy on a built-in chain. */
 int ip6tc_set_policy(const ip6t_chainlabel chain,
 		     const ip6t_chainlabel policy,
 		     struct ip6t_counters *counters,
-		     ip6tc_handle_t *handle);
+		     struct ip6tc_handle *handle);
 
 /* Get the number of references to this chain */
 int ip6tc_get_references(unsigned int *ref, const ip6t_chainlabel chain,
-			 ip6tc_handle_t *handle);
+			 struct ip6tc_handle *handle);
 
 /* read packet and byte counters for a specific rule */
 struct ip6t_counters *ip6tc_read_counter(const ip6t_chainlabel chain,
 					unsigned int rulenum,
-					ip6tc_handle_t *handle);
+					struct ip6tc_handle *handle);
 
 /* zero packet and byte counters for a specific rule */
 int ip6tc_zero_counter(const ip6t_chainlabel chain,
 		       unsigned int rulenum,
-		       ip6tc_handle_t *handle);
+		       struct ip6tc_handle *handle);
 
 /* set packet and byte counters for a specific rule */
 int ip6tc_set_counter(const ip6t_chainlabel chain,
 		      unsigned int rulenum,
 		      struct ip6t_counters *counters,
-		      ip6tc_handle_t *handle);
+		      struct ip6tc_handle *handle);
 
 /* Makes the actual changes. */
-int ip6tc_commit(ip6tc_handle_t *handle);
+int ip6tc_commit(struct ip6tc_handle *handle);
 
 /* Get raw socket. */
 int ip6tc_get_raw_socket();
diff -urBp iptables.old/include/libiptc/libiptc.h iptables/include/libiptc/libiptc.h
--- iptables.old/include/libiptc/libiptc.h	2007-01-23 15:49:52.000000000 +0300
+++ iptables/include/libiptc/libiptc.h	2011-03-02 12:52:52.000000000 +0300
@@ -18,6 +18,8 @@ extern "C" {
 
 #define IPT_ALIGN(s) (((s) + ((IPT_MIN_ALIGN)-1)) & ~((IPT_MIN_ALIGN)-1))
 
+struct iptc_handle;
+
 typedef char ipt_chainlabel[32];
 
 #define IPTC_LABEL_ACCEPT  "ACCEPT"
@@ -25,41 +27,38 @@ typedef char ipt_chainlabel[32];
 #define IPTC_LABEL_QUEUE   "QUEUE"
 #define IPTC_LABEL_RETURN  "RETURN"
 
-/* Transparent handle type. */
-typedef struct iptc_handle *iptc_handle_t;
-
 /* Does this chain exist? */
-int iptc_is_chain(const char *chain, const iptc_handle_t handle);
+int iptc_is_chain(const char *chain, const struct iptc_handle *handle);
 
 /* Take a snapshot of the rules.  Returns NULL on error. */
-iptc_handle_t iptc_init(const char *tablename);
+struct iptc_handle *iptc_init(const char *tablename);
 
 /* Cleanup after iptc_init(). */
-void iptc_free(iptc_handle_t *h);
+void iptc_free(struct iptc_handle *h);
 
 /* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *iptc_first_chain(iptc_handle_t *handle);
-const char *iptc_next_chain(iptc_handle_t *handle);
+const char *iptc_first_chain(struct iptc_handle *handle);
+const char *iptc_next_chain(struct iptc_handle *handle);
 
 /* Get first rule in the given chain: NULL for empty chain. */
 const struct ipt_entry *iptc_first_rule(const char *chain,
-					iptc_handle_t *handle);
+					struct iptc_handle *handle);
 
 /* Returns NULL when rules run out. */
 const struct ipt_entry *iptc_next_rule(const struct ipt_entry *prev,
-				       iptc_handle_t *handle);
+				       struct iptc_handle *handle);
 
 /* Returns a pointer to the target name of this entry. */
 const char *iptc_get_target(const struct ipt_entry *e,
-			    iptc_handle_t *handle);
+			    struct iptc_handle *handle);
 
 /* Is this a built-in chain? */
-int iptc_builtin(const char *chain, const iptc_handle_t handle);
+int iptc_builtin(const char *chain, const struct iptc_handle *handle);
 
 /* Get the policy of a given built-in chain */
 const char *iptc_get_policy(const char *chain,
 			    struct ipt_counters *counter,
-			    iptc_handle_t *handle);
+			    struct iptc_handle *handle);
 
 /* These functions return TRUE for OK or 0 and set errno.  If errno ==
    0, it means there was a version error (ie. upgrade libiptc). */
@@ -69,88 +68,88 @@ const char *iptc_get_policy(const char *
 int iptc_insert_entry(const ipt_chainlabel chain,
 		      const struct ipt_entry *e,
 		      unsigned int rulenum,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Atomically replace rule `rulenum' in `chain' with `e'. */
 int iptc_replace_entry(const ipt_chainlabel chain,
 		       const struct ipt_entry *e,
 		       unsigned int rulenum,
-		       iptc_handle_t *handle);
+		       struct iptc_handle *handle);
 
 /* Append entry `e' to chain `chain'.  Equivalent to insert with
    rulenum = length of chain. */
 int iptc_append_entry(const ipt_chainlabel chain,
 		      const struct ipt_entry *e,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Delete the first rule in `chain' which matches `e', subject to
    matchmask (array of length == origfw) */
 int iptc_delete_entry(const ipt_chainlabel chain,
 		      const struct ipt_entry *origfw,
 		      unsigned char *matchmask,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Delete the rule in position `rulenum' in `chain'. */
 int iptc_delete_num_entry(const ipt_chainlabel chain,
 			  unsigned int rulenum,
-			  iptc_handle_t *handle);
+			  struct iptc_handle *handle);
 
 /* Check the packet `e' on chain `chain'.  Returns the verdict, or
    NULL and sets errno. */
 const char *iptc_check_packet(const ipt_chainlabel chain,
 			      struct ipt_entry *entry,
-			      iptc_handle_t *handle);
+			      struct iptc_handle *handle);
 
 /* Flushes the entries in the given chain (ie. empties chain). */
 int iptc_flush_entries(const ipt_chainlabel chain,
-		       iptc_handle_t *handle);
+		       struct iptc_handle *handle);
 
 /* Zeroes the counters in a chain. */
 int iptc_zero_entries(const ipt_chainlabel chain,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Creates a new chain. */
 int iptc_create_chain(const ipt_chainlabel chain,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Deletes a chain. */
 int iptc_delete_chain(const ipt_chainlabel chain,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Renames a chain. */
 int iptc_rename_chain(const ipt_chainlabel oldname,
 		      const ipt_chainlabel newname,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* Sets the policy on a built-in chain. */
 int iptc_set_policy(const ipt_chainlabel chain,
 		    const ipt_chainlabel policy,
 		    struct ipt_counters *counters,
-		    iptc_handle_t *handle);
+		    struct iptc_handle *handle);
 
 /* Get the number of references to this chain */
 int iptc_get_references(unsigned int *ref,
 			const ipt_chainlabel chain,
-			iptc_handle_t *handle);
+			struct iptc_handle *handle);
 
 /* read packet and byte counters for a specific rule */
 struct ipt_counters *iptc_read_counter(const ipt_chainlabel chain,
 				       unsigned int rulenum,
-				       iptc_handle_t *handle);
+				       struct iptc_handle *handle);
 
 /* zero packet and byte counters for a specific rule */
 int iptc_zero_counter(const ipt_chainlabel chain,
 		      unsigned int rulenum,
-		      iptc_handle_t *handle);
+		      struct iptc_handle *handle);
 
 /* set packet and byte counters for a specific rule */
 int iptc_set_counter(const ipt_chainlabel chain,
 		     unsigned int rulenum,
 		     struct ipt_counters *counters,
-		     iptc_handle_t *handle);
+		     struct iptc_handle *handle);
 
 /* Makes the actual changes. */
-int iptc_commit(iptc_handle_t *handle);
+int iptc_commit(struct iptc_handle *handle);
 
 /* Get raw socket. */
 int iptc_get_raw_socket();
diff -urBp iptables.old/ip6tables.c iptables/ip6tables.c
--- iptables.old/ip6tables.c	2010-11-30 03:00:00.000000000 +0300
+++ iptables/ip6tables.c	2011-03-02 13:58:33.000000000 +0300
@@ -200,7 +200,7 @@ struct ip6tables_match *ip6tables_matche
 struct ip6tables_target *ip6tables_targets = NULL;
 
 /* Extra debugging from libiptc */
-extern void dump_entries6(const ip6tc_handle_t handle);
+extern void dump_entries6(const struct ip6tc_handle *handle);
 
 /* A few hardcoded protocols for 'all' and in case the user has no
    /etc/protocols */
@@ -1263,7 +1263,7 @@ print_num(u_int64_t number, unsigned int
 
 
 static void
-print_header(unsigned int format, const char *chain, ip6tc_handle_t *handle)
+print_header(unsigned int format, const char *chain, struct ip6tc_handle *handle)
 {
 	struct ip6t_counters counters;
 	const char *pol = ip6tc_get_policy(chain, &counters, handle);
@@ -1338,7 +1338,7 @@ print_firewall(const struct ip6t_entry *
 	       const char *targname,
 	       unsigned int num,
 	       unsigned int format,
-	       const ip6tc_handle_t handle)
+	       const struct ip6tc_handle *handle)
 {
 	struct ip6tables_target *target = NULL;
 	const struct ip6t_entry_target *t;
@@ -1456,7 +1456,7 @@ print_firewall(const struct ip6t_entry *
 
 static void
 print_firewall_line(const struct ip6t_entry *fw,
-		    const ip6tc_handle_t h)
+		    const struct ip6tc_handle *h)
 {
 	struct ip6t_entry_target *t;
 
@@ -1472,7 +1472,7 @@ append_entry(const ip6t_chainlabel chain
 	     unsigned int ndaddrs,
 	     const struct in6_addr daddrs[],
 	     int verbose,
-	     ip6tc_handle_t *handle)
+	     struct ip6tc_handle *handle)
 {
 	unsigned int i, j;
 	int ret = 1;
@@ -1482,7 +1482,7 @@ append_entry(const ip6t_chainlabel chain
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ipv6.dst = daddrs[j];
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= ip6tc_append_entry(chain, fw, handle);
 		}
 	}
@@ -1497,13 +1497,13 @@ replace_entry(const ip6t_chainlabel chai
 	      const struct in6_addr *saddr,
 	      const struct in6_addr *daddr,
 	      int verbose,
-	      ip6tc_handle_t *handle)
+	      struct ip6tc_handle *handle)
 {
 	fw->ipv6.src = *saddr;
 	fw->ipv6.dst = *daddr;
 
 	if (verbose)
-		print_firewall_line(fw, *handle);
+		print_firewall_line(fw, handle);
 	return ip6tc_replace_entry(chain, fw, rulenum, handle);
 }
 
@@ -1516,7 +1516,7 @@ insert_entry(const ip6t_chainlabel chain
 	     unsigned int ndaddrs,
 	     const struct in6_addr daddrs[],
 	     int verbose,
-	     ip6tc_handle_t *handle)
+	     struct ip6tc_handle *handle)
 {
 	unsigned int i, j;
 	int ret = 1;
@@ -1526,7 +1526,7 @@ insert_entry(const ip6t_chainlabel chain
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ipv6.dst = daddrs[j];
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= ip6tc_insert_entry(chain, fw, rulenum, handle);
 		}
 	}
@@ -1575,7 +1575,7 @@ delete_entry(const ip6t_chainlabel chain
 	     unsigned int ndaddrs,
 	     const struct in6_addr daddrs[],
 	     int verbose,
-	     ip6tc_handle_t *handle,
+	     struct ip6tc_handle *handle,
 	     struct ip6tables_rule_match *matches)
 {
 	unsigned int i, j;
@@ -1588,7 +1588,7 @@ delete_entry(const ip6t_chainlabel chain
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ipv6.dst = daddrs[j];
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= ip6tc_delete_entry(chain, fw, mask, handle);
 		}
 	}
@@ -1598,8 +1598,8 @@ delete_entry(const ip6t_chainlabel chain
 }
 
 int
-for_each_chain(int (*fn)(const ip6t_chainlabel, int, ip6tc_handle_t *),
-	       int verbose, int builtinstoo, ip6tc_handle_t *handle)
+for_each_chain(int (*fn)(const ip6t_chainlabel, int, struct ip6tc_handle *),
+	       int verbose, int builtinstoo, struct ip6tc_handle *handle)
 {
         int ret = 1;
 	const char *chain;
@@ -1624,7 +1624,7 @@ for_each_chain(int (*fn)(const ip6t_chai
 	for (i = 0; i < chaincount; i++) {
 		if (!builtinstoo
 		    && ip6tc_builtin(chains + i*sizeof(ip6t_chainlabel),
-				    *handle) == 1)
+				    handle) == 1)
 			continue;
 	        ret &= fn(chains + i*sizeof(ip6t_chainlabel), verbose, handle);
 	}
@@ -1635,7 +1635,7 @@ for_each_chain(int (*fn)(const ip6t_chai
 
 int
 flush_entries(const ip6t_chainlabel chain, int verbose,
-	      ip6tc_handle_t *handle)
+	      struct ip6tc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(flush_entries, verbose, 1, handle);
@@ -1647,7 +1647,7 @@ flush_entries(const ip6t_chainlabel chai
 
 static int
 zero_entries(const ip6t_chainlabel chain, int verbose,
-	     ip6tc_handle_t *handle)
+	     struct ip6tc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(zero_entries, verbose, 1, handle);
@@ -1659,7 +1659,7 @@ zero_entries(const ip6t_chainlabel chain
 
 int
 delete_chain(const ip6t_chainlabel chain, int verbose,
-	     ip6tc_handle_t *handle)
+	     struct ip6tc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(delete_chain, verbose, 0, handle);
@@ -1671,7 +1671,7 @@ delete_chain(const ip6t_chainlabel chain
 
 static int
 list_entries(const ip6t_chainlabel chain, int verbose, int numeric,
-	     int expanded, int linenumbers, ip6tc_handle_t *handle)
+	     int expanded, int linenumbers, struct ip6tc_handle *handle)
 {
 	int found = 0;
 	unsigned int format;
@@ -1712,7 +1712,7 @@ list_entries(const ip6t_chainlabel chain
 				       ip6tc_get_target(i, handle),
 				       num++,
 				       format,
-				       *handle);
+				       handle);
 			i = ip6tc_next_rule(i, handle);
 		}
 		found = 1;
@@ -1862,7 +1862,7 @@ static void set_revision(char *name, u_i
 	name[IP6T_FUNCTION_MAXNAMELEN - 1] = revision;
 }
 
-int do_command6(int argc, char *argv[], char **table, ip6tc_handle_t *handle)
+int do_command6(int argc, char *argv[], char **table, struct ip6tc_handle **handle)
 {
 	struct ip6t_entry fw, *e = NULL;
 	int invert = 0;
@@ -2439,27 +2439,27 @@ int do_command6(int argc, char *argv[], 
 		ret = append_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   *handle);
 		break;
 	case CMD_DELETE:
 		ret = delete_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle, matches);
+				   *handle, matches);
 		break;
 	case CMD_DELETE_NUM:
-		ret = ip6tc_delete_num_entry(chain, rulenum - 1, handle);
+		ret = ip6tc_delete_num_entry(chain, rulenum - 1, *handle);
 		break;
 	case CMD_REPLACE:
 		ret = replace_entry(chain, e, rulenum - 1,
 				    saddrs, daddrs, options&OPT_VERBOSE,
-				    handle);
+				    *handle);
 		break;
 	case CMD_INSERT:
 		ret = insert_entry(chain, e, rulenum - 1,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   *handle);
 		break;
 	case CMD_LIST:
 		ret = list_entries(chain,
@@ -2467,13 +2467,13 @@ int do_command6(int argc, char *argv[], 
 				   options&OPT_NUMERIC,
 				   options&OPT_EXPANDED,
 				   options&OPT_LINENUMBERS,
-				   handle);
+				   *handle);
 		break;
 	case CMD_FLUSH:
-		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
+		ret = flush_entries(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_ZERO:
-		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
+		ret = zero_entries(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_LIST|CMD_ZERO:
 		ret = list_entries(chain,
@@ -2481,22 +2481,22 @@ int do_command6(int argc, char *argv[], 
 				   options&OPT_NUMERIC,
 				   options&OPT_EXPANDED,
 				   options&OPT_LINENUMBERS,
-				   handle);
+				   *handle);
 		if (ret)
 			ret = zero_entries(chain,
-					   options&OPT_VERBOSE, handle);
+					   options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_NEW_CHAIN:
-		ret = ip6tc_create_chain(chain, handle);
+		ret = ip6tc_create_chain(chain, *handle);
 		break;
 	case CMD_DELETE_CHAIN:
-		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
+		ret = delete_chain(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_RENAME_CHAIN:
-		ret = ip6tc_rename_chain(chain, newname,	handle);
+		ret = ip6tc_rename_chain(chain, newname, *handle);
 		break;
 	case CMD_SET_POLICY:
-		ret = ip6tc_set_policy(chain, policy, NULL, handle);
+		ret = ip6tc_set_policy(chain, policy, NULL, *handle);
 		break;
 	default:
 		/* We should never reach this... */
diff -urBp iptables.old/ip6tables-restore.c iptables/ip6tables-restore.c
--- iptables.old/ip6tables-restore.c	2009-11-14 13:03:46.000000000 +0300
+++ iptables/ip6tables-restore.c	2011-03-02 13:06:31.000000000 +0300
@@ -54,9 +54,9 @@ static void print_usage(const char *name
 	exit(1);
 }
 
-ip6tc_handle_t create_handle(const char *tablename, const char* modprobe)
+struct ip6tc_handle *create_handle(const char *tablename, const char* modprobe)
 {
-	ip6tc_handle_t handle;
+	struct ip6tc_handle *handle;
 
 	handle = ip6tc_init(tablename);
 
@@ -108,7 +108,7 @@ int ip6tables_restore_main(int argc, cha
 int main(int argc, char *argv[])
 #endif
 {
-	ip6tc_handle_t handle = NULL;
+	struct ip6tc_handle *handle = NULL;
 	char buffer[10240];
 	int c;
 	char curtable[IP6T_TABLE_MAXNAMELEN + 1];
@@ -183,7 +183,9 @@ int main(int argc, char *argv[])
 		} else if ((strcmp(buffer, "COMMIT\n") == 0) && (in_table)) {
 			if (!testing) {
 				DEBUGP("Calling commit\n");
-				ret = ip6tc_commit(&handle);
+				ret = ip6tc_commit(handle);
+				ip6tc_free(handle);
+				handle = NULL;
 			} else {
 				DEBUGP("Not calling commit, testing\n");
 				ret = 1;
@@ -205,19 +207,19 @@ int main(int argc, char *argv[])
 			curtable[IP6T_TABLE_MAXNAMELEN] = '\0';
 
 			if (handle)
-				ip6tc_free(&handle);
+				ip6tc_free(handle);
 
 			handle = create_handle(table, modprobe);
 			if (noflush == 0) {
 				DEBUGP("Cleaning all chains of table '%s'\n",
 					table);
 				for_each_chain(flush_entries, verbose, 1, 
-						&handle);
+						handle);
 	
 				DEBUGP("Deleting all user-defined chains "
 				       "of table '%s'\n", table);
 				for_each_chain(delete_chain, verbose, 0, 
-						&handle) ;
+						handle) ;
 			}
 
 			ret = 1;
@@ -239,14 +241,14 @@ int main(int argc, char *argv[])
 			if (ip6tc_builtin(chain, handle) <= 0) {
 				if (noflush && ip6tc_is_chain(chain, handle)) {
 					DEBUGP("Flushing existing user defined chain '%s'\n", chain);
-					if (!ip6tc_flush_entries(chain, &handle))
+					if (!ip6tc_flush_entries(chain, handle))
 						exit_error(PARAMETER_PROBLEM,
 							   "error flushing chain "
 							   "'%s':%s\n", chain,
 							   strerror(errno));
 				} else {
 					DEBUGP("Creating new chain '%s'\n", chain);
-					if (!ip6tc_create_chain(chain, &handle))
+					if (!ip6tc_create_chain(chain, handle))
 						exit_error(PARAMETER_PROBLEM,
 							   "error creating chain "
 							   "'%s':%s\n", chain,
@@ -284,7 +286,7 @@ int main(int argc, char *argv[])
 					chain, policy);
 
 				if (!ip6tc_set_policy(chain, policy, &count,
-						     &handle))
+						     handle))
 					exit_error(OTHER_PROBLEM,
 						"Can't set policy `%s'"
 						" on `%s' line %u: %s\n",
diff -urBp iptables.old/ip6tables-save.c iptables/ip6tables-save.c
--- iptables.old/ip6tables-save.c	2009-11-14 13:03:18.000000000 +0300
+++ iptables/ip6tables-save.c	2011-03-02 13:59:19.000000000 +0300
@@ -142,7 +142,7 @@ static void print_ip(char *prefix, const
 /* We want this to be readable, so only print out neccessary fields.
  * Because that's the kind of world I want to live in.  */
 static void print_rule(const struct ip6t_entry *e, 
-		ip6tc_handle_t *h, const char *chain, int counters)
+		struct ip6tc_handle *h, const char *chain, int counters)
 {
 	struct ip6t_entry_target *t;
 	const char *target_name;
@@ -248,7 +248,7 @@ static int for_each_table(int (*func)(co
 
 static int do_output(const char *tablename)
 {
-	ip6tc_handle_t h;
+	struct ip6tc_handle *h;
 	const char *chain = NULL;
 
 	if (!tablename)
@@ -268,15 +268,15 @@ static int do_output(const char *tablena
 
 		/* Dump out chain names first, 
 		 * thereby preventing dependency conflicts */
-		for (chain = ip6tc_first_chain(&h);
+		for (chain = ip6tc_first_chain(h);
 		     chain;
-		     chain = ip6tc_next_chain(&h)) {
+		     chain = ip6tc_next_chain(h)) {
 
 			printf(":%s ", chain);
 			if (ip6tc_builtin(chain, h)) {
 				struct ip6t_counters count;
 				printf("%s ",
-				       ip6tc_get_policy(chain, &count, &h));
+				       ip6tc_get_policy(chain, &count, h));
 				printf("[%llu:%llu]\n", (unsigned long long)count.pcnt, (unsigned long long)count.bcnt);
 			} else {
 				printf("- [0:0]\n");
@@ -284,16 +284,16 @@ static int do_output(const char *tablena
 		}
 
 
-		for (chain = ip6tc_first_chain(&h);
+		for (chain = ip6tc_first_chain(h);
 		     chain;
-		     chain = ip6tc_next_chain(&h)) {
+		     chain = ip6tc_next_chain(h)) {
 			const struct ip6t_entry *e;
 
 			/* Dump out rules */
-			e = ip6tc_first_rule(chain, &h);
+			e = ip6tc_first_rule(chain, h);
 			while(e) {
-				print_rule(e, &h, chain, counters);
-				e = ip6tc_next_rule(e, &h);
+				print_rule(e, h, chain, counters);
+				e = ip6tc_next_rule(e, h);
 			}
 		}
 
@@ -305,7 +305,7 @@ static int do_output(const char *tablena
 		exit_error(OTHER_PROBLEM, "Binary NYI\n");
 	}
 
-	ip6tc_free(&h);
+	ip6tc_free(h);
 
 	return 1;
 }
diff -urBp iptables.old/ip6tables-standalone.c iptables/ip6tables-standalone.c
--- iptables.old/ip6tables-standalone.c	2009-11-14 13:01:58.000000000 +0300
+++ iptables/ip6tables-standalone.c	2011-03-02 13:08:11.000000000 +0300
@@ -46,7 +46,7 @@ main(int argc, char *argv[])
 {
 	int ret;
 	char *table = "filter";
-	ip6tc_handle_t handle = NULL;
+	struct ip6tc_handle *handle = NULL;
 
 	program_name = "ip6tables";
 	program_version = IPTABLES_VERSION;
@@ -60,8 +60,10 @@ main(int argc, char *argv[])
 #endif
 
 	ret = do_command6(argc, argv, &table, &handle);
-	if (ret)
-		ret = ip6tc_commit(&handle);
+	if (ret) {
+		ret = ip6tc_commit(handle);
+		ip6tc_free(handle);
+	}
 
 	if (!ret)
 		fprintf(stderr, "ip6tables: %s\n",
diff -urBp iptables.old/iptables.c iptables/iptables.c
--- iptables.old/iptables.c	2010-11-30 03:00:00.000000000 +0300
+++ iptables/iptables.c	2011-03-02 13:47:37.000000000 +0300
@@ -204,7 +204,7 @@ struct iptables_match *iptables_matches 
 struct iptables_target *iptables_targets = NULL;
 
 /* Extra debugging from libiptc */
-extern void dump_entries(const iptc_handle_t handle);
+extern void dump_entries(const struct iptc_handle *handle);
 
 /* A few hardcoded protocols for 'all' and in case the user has no
    /etc/protocols */
@@ -1324,7 +1324,7 @@ print_num(u_int64_t number, unsigned int
 
 
 static void
-print_header(unsigned int format, const char *chain, iptc_handle_t *handle)
+print_header(unsigned int format, const char *chain, struct iptc_handle *handle)
 {
 	struct ipt_counters counters;
 	const char *pol = iptc_get_policy(chain, &counters, handle);
@@ -1399,7 +1399,7 @@ print_firewall(const struct ipt_entry *f
 	       const char *targname,
 	       unsigned int num,
 	       unsigned int format,
-	       const iptc_handle_t handle)
+	       const struct iptc_handle *handle)
 {
 	struct iptables_target *target = NULL;
 	const struct ipt_entry_target *t;
@@ -1520,7 +1520,7 @@ print_firewall(const struct ipt_entry *f
 
 static void
 print_firewall_line(const struct ipt_entry *fw,
-		    const iptc_handle_t h)
+		    const struct iptc_handle * h)
 {
 	struct ipt_entry_target *t;
 
@@ -1536,7 +1536,7 @@ append_entry(const ipt_chainlabel chain,
 	     unsigned int ndaddrs,
 	     const struct in_addr daddrs[],
 	     int verbose,
-	     iptc_handle_t *handle)
+	     struct iptc_handle *handle)
 {
 	unsigned int i, j;
 	int ret = 1;
@@ -1546,7 +1546,7 @@ append_entry(const ipt_chainlabel chain,
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ip.dst.s_addr = daddrs[j].s_addr;
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= iptc_append_entry(chain, fw, handle);
 		}
 	}
@@ -1561,13 +1561,13 @@ replace_entry(const ipt_chainlabel chain
 	      const struct in_addr *saddr,
 	      const struct in_addr *daddr,
 	      int verbose,
-	      iptc_handle_t *handle)
+	      struct iptc_handle *handle)
 {
 	fw->ip.src.s_addr = saddr->s_addr;
 	fw->ip.dst.s_addr = daddr->s_addr;
 
 	if (verbose)
-		print_firewall_line(fw, *handle);
+		print_firewall_line(fw, handle);
 	return iptc_replace_entry(chain, fw, rulenum, handle);
 }
 
@@ -1580,7 +1580,7 @@ insert_entry(const ipt_chainlabel chain,
 	     unsigned int ndaddrs,
 	     const struct in_addr daddrs[],
 	     int verbose,
-	     iptc_handle_t *handle)
+	     struct iptc_handle *handle)
 {
 	unsigned int i, j;
 	int ret = 1;
@@ -1590,7 +1590,7 @@ insert_entry(const ipt_chainlabel chain,
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ip.dst.s_addr = daddrs[j].s_addr;
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= iptc_insert_entry(chain, fw, rulenum, handle);
 		}
 	}
@@ -1639,7 +1639,7 @@ delete_entry(const ipt_chainlabel chain,
 	     unsigned int ndaddrs,
 	     const struct in_addr daddrs[],
 	     int verbose,
-	     iptc_handle_t *handle,
+	     struct iptc_handle *handle,
 	     struct iptables_rule_match *matches)
 {
 	unsigned int i, j;
@@ -1652,7 +1652,7 @@ delete_entry(const ipt_chainlabel chain,
 		for (j = 0; j < ndaddrs; j++) {
 			fw->ip.dst.s_addr = daddrs[j].s_addr;
 			if (verbose)
-				print_firewall_line(fw, *handle);
+				print_firewall_line(fw, handle);
 			ret &= iptc_delete_entry(chain, fw, mask, handle);
 		}
 	}
@@ -1662,8 +1662,8 @@ delete_entry(const ipt_chainlabel chain,
 }
 
 int
-for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
-	       int verbose, int builtinstoo, iptc_handle_t *handle)
+for_each_chain(int (*fn)(const ipt_chainlabel, int, struct iptc_handle *),
+	       int verbose, int builtinstoo, struct iptc_handle *handle)
 {
         int ret = 1;
 	const char *chain;
@@ -1688,7 +1688,7 @@ for_each_chain(int (*fn)(const ipt_chain
 	for (i = 0; i < chaincount; i++) {
 		if (!builtinstoo
 		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
-				    *handle) == 1)
+				    handle) == 1)
 			continue;
 	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
 	}
@@ -1699,7 +1699,7 @@ for_each_chain(int (*fn)(const ipt_chain
 
 int
 flush_entries(const ipt_chainlabel chain, int verbose,
-	      iptc_handle_t *handle)
+	      struct iptc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(flush_entries, verbose, 1, handle);
@@ -1711,7 +1711,7 @@ flush_entries(const ipt_chainlabel chain
 
 static int
 zero_entries(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
+	     struct iptc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(zero_entries, verbose, 1, handle);
@@ -1723,7 +1723,7 @@ zero_entries(const ipt_chainlabel chain,
 
 int
 delete_chain(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
+	     struct iptc_handle *handle)
 {
 	if (!chain)
 		return for_each_chain(delete_chain, verbose, 0, handle);
@@ -1735,7 +1735,7 @@ delete_chain(const ipt_chainlabel chain,
 
 static int
 list_entries(const ipt_chainlabel chain, int verbose, int numeric,
-	     int expanded, int linenumbers, iptc_handle_t *handle)
+	     int expanded, int linenumbers, struct iptc_handle *handle)
 {
 	int found = 0;
 	unsigned int format;
@@ -1776,7 +1776,7 @@ list_entries(const ipt_chainlabel chain,
 				       iptc_get_target(i, handle),
 				       num++,
 				       format,
-				       *handle);
+				       handle);
 			i = iptc_next_rule(i, handle);
 		}
 		found = 1;
@@ -1941,7 +1941,7 @@ get_kernel_version(void) {
 	kernel_version = LINUX_VERSION(x, y, z);
 }
 
-int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
+int do_command(int argc, char *argv[], char **table, struct iptc_handle **handle)
 {
 	struct ipt_entry fw, *e = NULL;
 	int invert = 0;
@@ -2535,27 +2535,27 @@ int do_command(int argc, char *argv[], c
 		ret = append_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   *handle);
 		break;
 	case CMD_DELETE:
 		ret = delete_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle, matches);
+				   *handle, matches);
 		break;
 	case CMD_DELETE_NUM:
-		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
+		ret = iptc_delete_num_entry(chain, rulenum - 1, *handle);
 		break;
 	case CMD_REPLACE:
 		ret = replace_entry(chain, e, rulenum - 1,
 				    saddrs, daddrs, options&OPT_VERBOSE,
-				    handle);
+				    *handle);
 		break;
 	case CMD_INSERT:
 		ret = insert_entry(chain, e, rulenum - 1,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   *handle);
 		break;
 	case CMD_LIST:
 		ret = list_entries(chain,
@@ -2563,13 +2563,13 @@ int do_command(int argc, char *argv[], c
 				   options&OPT_NUMERIC,
 				   options&OPT_EXPANDED,
 				   options&OPT_LINENUMBERS,
-				   handle);
+				   *handle);
 		break;
 	case CMD_FLUSH:
-		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
+		ret = flush_entries(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_ZERO:
-		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
+		ret = zero_entries(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_LIST|CMD_ZERO:
 		ret = list_entries(chain,
@@ -2577,22 +2577,22 @@ int do_command(int argc, char *argv[], c
 				   options&OPT_NUMERIC,
 				   options&OPT_EXPANDED,
 				   options&OPT_LINENUMBERS,
-				   handle);
+				   *handle);
 		if (ret)
 			ret = zero_entries(chain,
-					   options&OPT_VERBOSE, handle);
+					   options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_NEW_CHAIN:
-		ret = iptc_create_chain(chain, handle);
+		ret = iptc_create_chain(chain, *handle);
 		break;
 	case CMD_DELETE_CHAIN:
-		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
+		ret = delete_chain(chain, options&OPT_VERBOSE, *handle);
 		break;
 	case CMD_RENAME_CHAIN:
-		ret = iptc_rename_chain(chain, newname,	handle);
+		ret = iptc_rename_chain(chain, newname,	*handle);
 		break;
 	case CMD_SET_POLICY:
-		ret = iptc_set_policy(chain, policy, NULL, handle);
+		ret = iptc_set_policy(chain, policy, NULL, *handle);
 		break;
 	default:
 		/* We should never reach this... */
diff -urBp iptables.old/iptables-restore.c iptables/iptables-restore.c
--- iptables.old/iptables-restore.c	2007-05-22 21:11:40.000000000 +0400
+++ iptables/iptables-restore.c	2011-03-02 13:09:42.000000000 +0300
@@ -51,9 +51,9 @@ static void print_usage(const char *name
 	exit(1);
 }
 
-iptc_handle_t create_handle(const char *tablename, const char* modprobe )
+struct iptc_handle * create_handle(const char *tablename, const char* modprobe )
 {
-	iptc_handle_t handle;
+	struct iptc_handle *handle;
 
 	handle = iptc_init(tablename);
 
@@ -107,7 +107,7 @@ int
 main(int argc, char *argv[])
 #endif
 {
-	iptc_handle_t handle = NULL;
+	struct iptc_handle *handle = NULL;
 	char buffer[10240];
 	int c;
 	char curtable[IPT_TABLE_MAXNAMELEN + 1];
@@ -182,7 +182,9 @@ main(int argc, char *argv[])
 		} else if ((strcmp(buffer, "COMMIT\n") == 0) && (in_table)) {
 			if (!testing) {
 				DEBUGP("Calling commit\n");
-				ret = iptc_commit(&handle);
+				ret = iptc_commit(handle);
+				iptc_free(handle);
+				handle = NULL;
 			} else {
 				DEBUGP("Not calling commit, testing\n");
 				ret = 1;
@@ -204,19 +206,19 @@ main(int argc, char *argv[])
 			curtable[IPT_TABLE_MAXNAMELEN] = '\0';
 
 			if (handle)
-				iptc_free(&handle);
+				iptc_free(handle);
 
 			handle = create_handle(table, modprobe);
 			if (noflush == 0) {
 				DEBUGP("Cleaning all chains of table '%s'\n",
 					table);
 				for_each_chain(flush_entries, verbose, 1, 
-						&handle);
+						handle);
 	
 				DEBUGP("Deleting all user-defined chains "
 				       "of table '%s'\n", table);
 				for_each_chain(delete_chain, verbose, 0, 
-						&handle) ;
+						handle) ;
 			}
 
 			ret = 1;
@@ -238,14 +240,14 @@ main(int argc, char *argv[])
 			if (iptc_builtin(chain, handle) <= 0) {
 				if (noflush && iptc_is_chain(chain, handle)) {
 					DEBUGP("Flushing existing user defined chain '%s'\n", chain);
-					if (!iptc_flush_entries(chain, &handle))
+					if (!iptc_flush_entries(chain, handle))
 						exit_error(PARAMETER_PROBLEM,
 							   "error flushing chain "
 							   "'%s':%s\n", chain,
 							   strerror(errno));
 				} else {
 					DEBUGP("Creating new chain '%s'\n", chain);
-					if (!iptc_create_chain(chain, &handle))
+					if (!iptc_create_chain(chain, handle))
 						exit_error(PARAMETER_PROBLEM,
 							   "error creating chain "
 							   "'%s':%s\n", chain,
@@ -283,7 +285,7 @@ main(int argc, char *argv[])
 					chain, policy);
 
 				if (!iptc_set_policy(chain, policy, &count,
-						     &handle))
+						     handle))
 					exit_error(OTHER_PROBLEM,
 						"Can't set policy `%s'"
 						" on `%s' line %u: %s\n",
diff -urBp iptables.old/iptables-save.c iptables/iptables-save.c
--- iptables.old/iptables-save.c	2007-05-22 21:11:40.000000000 +0400
+++ iptables/iptables-save.c	2011-03-02 13:59:08.000000000 +0300
@@ -158,7 +158,7 @@ static void print_ip(char *prefix, u_int
 /* We want this to be readable, so only print out neccessary fields.
  * Because that's the kind of world I want to live in.  */
 static void print_rule(const struct ipt_entry *e, 
-		iptc_handle_t *h, const char *chain, int counters)
+		struct iptc_handle *h, const char *chain, int counters)
 {
 	struct ipt_entry_target *t;
 	const char *target_name;
@@ -259,7 +259,7 @@ static int for_each_table(int (*func)(co
 
 static int do_output(const char *tablename)
 {
-	iptc_handle_t h;
+	struct iptc_handle * h;
 	const char *chain = NULL;
 
 	if (!tablename)
@@ -279,15 +279,15 @@ static int do_output(const char *tablena
 
 		/* Dump out chain names first, 
 		 * thereby preventing dependency conflicts */
-		for (chain = iptc_first_chain(&h);
+		for (chain = iptc_first_chain(h);
 		     chain;
-		     chain = iptc_next_chain(&h)) {
+		     chain = iptc_next_chain(h)) {
 			
 			printf(":%s ", chain);
 			if (iptc_builtin(chain, h)) {
 				struct ipt_counters count;
 				printf("%s ",
-				       iptc_get_policy(chain, &count, &h));
+				       iptc_get_policy(chain, &count, h));
 				printf("[%llu:%llu]\n", (unsigned long long)count.pcnt, (unsigned long long)count.bcnt);
 			} else {
 				printf("- [0:0]\n");
@@ -295,16 +295,16 @@ static int do_output(const char *tablena
 		}
 				
 
-		for (chain = iptc_first_chain(&h);
+		for (chain = iptc_first_chain(h);
 		     chain;
-		     chain = iptc_next_chain(&h)) {
+		     chain = iptc_next_chain(h)) {
 			const struct ipt_entry *e;
 
 			/* Dump out rules */
-			e = iptc_first_rule(chain, &h);
+			e = iptc_first_rule(chain, h);
 			while(e) {
-				print_rule(e, &h, chain, counters);
-				e = iptc_next_rule(e, &h);
+				print_rule(e, h, chain, counters);
+				e = iptc_next_rule(e, h);
 			}
 		}
 
@@ -316,7 +316,7 @@ static int do_output(const char *tablena
 		exit_error(OTHER_PROBLEM, "Binary NYI\n");
 	}
 
-	iptc_free(&h);
+	iptc_free(h);
 
 	return 1;
 }
diff -urBp iptables.old/iptables-standalone.c iptables/iptables-standalone.c
--- iptables.old/iptables-standalone.c	2007-01-23 15:50:01.000000000 +0300
+++ iptables/iptables-standalone.c	2011-03-02 13:17:08.000000000 +0300
@@ -47,7 +47,7 @@ main(int argc, char *argv[])
 {
 	int ret;
 	char *table = "filter";
-	iptc_handle_t handle = NULL;
+	struct iptc_handle *handle = NULL;
 
 	program_name = "iptables";
 	program_version = IPTABLES_VERSION;
@@ -61,8 +61,10 @@ main(int argc, char *argv[])
 #endif
 
 	ret = do_command(argc, argv, &table, &handle);
-	if (ret)
-		ret = iptc_commit(&handle);
+	if (ret) {
+		ret = iptc_commit(handle);
+		iptc_free(handle);
+	}
 
 	if (!ret) {
 		fprintf(stderr, "iptables: %s\n",
diff -urBp iptables.old/libiptc/libip4tc.c iptables/libiptc/libip4tc.c
--- iptables.old/libiptc/libip4tc.c	2010-11-30 03:00:00.000000000 +0300
+++ iptables/libiptc/libip4tc.c	2011-03-02 12:47:42.000000000 +0300
@@ -51,7 +51,7 @@ typedef unsigned int socklen_t;
 #define STRUCT_REPLACE		struct ipt_replace
 
 #define STRUCT_TC_HANDLE	struct iptc_handle
-#define TC_HANDLE_T		iptc_handle_t
+#define xtc_handle		iptc_handle
 
 #define ENTRY_ITERATE		IPT_ENTRY_ITERATE
 #define TABLE_MAXNAMELEN	IPT_TABLE_MAXNAMELEN
@@ -126,7 +126,7 @@ typedef unsigned int socklen_t;
 #define IP_PARTS(n) IP_PARTS_NATIVE(ntohl(n))
 
 int
-dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle)
+dump_entry(STRUCT_ENTRY *e, struct iptc_handle *const handle)
 {
 	size_t i;
 	STRUCT_ENTRY_TARGET *t;
@@ -244,7 +244,7 @@ check_match(const STRUCT_ENTRY_MATCH *m,
 static inline int
 check_entry(const STRUCT_ENTRY *e, unsigned int *i, unsigned int *off,
 	    unsigned int user_offset, int *was_return,
-	    TC_HANDLE_T h)
+	    struct iptc_handle *h)
 {
 	unsigned int toff;
 	STRUCT_STANDARD_TARGET *t;
@@ -320,7 +320,7 @@ check_entry(const STRUCT_ENTRY *e, unsig
 #ifdef IPTC_DEBUG
 /* Do every conceivable sanity check on the handle */
 static void
-do_check(TC_HANDLE_T h, unsigned int line)
+do_check(struct iptc_handle *h, unsigned int line)
 {
 	unsigned int i, n;
 	unsigned int user_offset; /* Offset of first user chain */
diff -urBp iptables.old/libiptc/libip6tc.c iptables/libiptc/libip6tc.c
--- iptables.old/libiptc/libip6tc.c	2007-01-23 15:49:53.000000000 +0300
+++ iptables/libiptc/libip6tc.c	2011-03-02 12:47:42.000000000 +0300
@@ -46,7 +46,7 @@ typedef unsigned int socklen_t;
 #define STRUCT_REPLACE		struct ip6t_replace
 
 #define STRUCT_TC_HANDLE	struct ip6tc_handle
-#define TC_HANDLE_T		ip6tc_handle_t
+#define xtc_handle		ip6tc_handle
 
 #define ENTRY_ITERATE		IP6T_ENTRY_ITERATE
 #define TABLE_MAXNAMELEN	IP6T_TABLE_MAXNAMELEN
@@ -131,7 +131,7 @@ ipv6_prefix_length(const struct in6_addr
 }
 
 static int
-dump_entry(struct ip6t_entry *e, const ip6tc_handle_t handle)
+dump_entry(struct ip6t_entry *e, struct ip6tc_handle *const handle)
 {
 	size_t i;
 	char buf[40];
@@ -265,7 +265,7 @@ unconditional(const struct ip6t_ip6 *ipv
 #ifdef IPTC_DEBUG
 /* Do every conceivable sanity check on the handle */
 static void
-do_check(TC_HANDLE_T h, unsigned int line)
+do_check(struct xtc_handle *h, unsigned int line)
 {
 	unsigned int i, n;
 	unsigned int user_offset; /* Offset of first user chain */
diff -urBp iptables.old/libiptc/libiptc.c iptables/libiptc/libiptc.c
--- iptables.old/libiptc/libiptc.c	2007-01-23 15:49:53.000000000 +0300
+++ iptables/libiptc/libiptc.c	2011-03-02 13:51:20.000000000 +0300
@@ -166,14 +166,14 @@ static struct rule_head *iptcc_alloc_rul
 }
 
 /* notify us that the ruleset has been modified by the user */
-static void
-set_changed(TC_HANDLE_T h)
+static inline void
+set_changed(struct xtc_handle *h)
 {
 	h->changed = 1;
 }
 
 #ifdef IPTC_DEBUG
-static void do_check(TC_HANDLE_T h, unsigned int line);
+static void do_check(struct xtc_handle *h, unsigned int line);
 #define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
 #else
 #define CHECK(h)
@@ -210,13 +210,13 @@ iptcb_get_entry_n(STRUCT_ENTRY *i,
 }
 
 static inline STRUCT_ENTRY *
-iptcb_get_entry(TC_HANDLE_T h, unsigned int offset)
+iptcb_get_entry(struct xtc_handle *h, unsigned int offset)
 {
 	return (STRUCT_ENTRY *)((char *)h->entries->entrytable + offset);
 }
 
 static unsigned int
-iptcb_entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+iptcb_entry2index(struct xtc_handle *const h, const STRUCT_ENTRY *seek)
 {
 	unsigned int pos = 0;
 
@@ -230,27 +230,27 @@ iptcb_entry2index(const TC_HANDLE_T h, c
 }
 
 static inline STRUCT_ENTRY *
-iptcb_offset2entry(TC_HANDLE_T h, unsigned int offset)
+iptcb_offset2entry(struct xtc_handle *h, unsigned int offset)
 {
 	return (STRUCT_ENTRY *) ((void *)h->entries->entrytable+offset);
 }
 
 
 static inline unsigned long
-iptcb_entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+iptcb_entry2offset(struct xtc_handle *const h, const STRUCT_ENTRY *e)
 {
 	return (void *)e - (void *)h->entries->entrytable;
 }
 
 static inline unsigned int
-iptcb_offset2index(const TC_HANDLE_T h, unsigned int offset)
+iptcb_offset2index(struct xtc_handle *const h, unsigned int offset)
 {
 	return iptcb_entry2index(h, iptcb_offset2entry(h, offset));
 }
 
 /* Returns 0 if not hook entry, else hooknumber + 1 */
 static inline unsigned int
-iptcb_ent_is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+iptcb_ent_is_hook_entry(STRUCT_ENTRY *e, struct xtc_handle *h)
 {
 	unsigned int i;
 
@@ -305,7 +305,7 @@ static struct rule_head *iptcc_get_rule_
 
 /* Returns chain head if found, otherwise NULL. */
 static struct chain_head *
-iptcc_find_chain_by_offset(TC_HANDLE_T handle, unsigned int offset)
+iptcc_find_chain_by_offset(struct xtc_handle *handle, unsigned int offset)
 {
 	struct list_head *pos;
 
@@ -322,7 +322,7 @@ iptcc_find_chain_by_offset(TC_HANDLE_T h
 }
 /* Returns chain head if found, otherwise NULL. */
 static struct chain_head *
-iptcc_find_label(const char *name, TC_HANDLE_T handle)
+iptcc_find_label(const char *name, const struct xtc_handle *handle)
 {
 	struct list_head *pos;
 
@@ -360,7 +360,7 @@ static void iptcc_delete_rule(struct rul
  * chain policy rules.
  * WARNING: This function has ugly design and relies on a lot of context, only
  * to be called from specific places within the parser */
-static int __iptcc_p_del_policy(TC_HANDLE_T h, unsigned int num)
+static int __iptcc_p_del_policy(struct xtc_handle *h, unsigned int num)
 {
 	if (h->chain_iterator_cur) {
 		/* policy rule is last rule */
@@ -392,7 +392,7 @@ static int __iptcc_p_del_policy(TC_HANDL
 }
 
 /* alphabetically insert a chain into the list */
-static inline void iptc_insert_chain(TC_HANDLE_T h, struct chain_head *c)
+static inline void iptc_insert_chain(struct xtc_handle *h, struct chain_head *c)
 {
 	struct chain_head *tmp;
 
@@ -412,7 +412,7 @@ static inline void iptc_insert_chain(TC_
 
 /* Another ugly helper function split out of cache_add_entry to make it less
  * spaghetti code */
-static void __iptcc_p_add_chain(TC_HANDLE_T h, struct chain_head *c,
+static void __iptcc_p_add_chain(struct xtc_handle *h, struct chain_head *c,
 				unsigned int offset, unsigned int *num)
 {
 	__iptcc_p_del_policy(h, *num);
@@ -427,7 +427,7 @@ static void __iptcc_p_add_chain(TC_HANDL
 
 /* main parser function: add an entry from the blob to the cache */
 static int cache_add_entry(STRUCT_ENTRY *e, 
-			   TC_HANDLE_T h, 
+			   struct xtc_handle *h, 
 			   STRUCT_ENTRY **prev,
 			   unsigned int *num)
 {
@@ -536,7 +536,7 @@ out_inc:
 
 
 /* parse an iptables blob into it's pieces */
-static int parse_table(TC_HANDLE_T h)
+static int parse_table(struct xtc_handle *h)
 {
 	STRUCT_ENTRY *prev;
 	unsigned int num = 0;
@@ -600,7 +600,7 @@ struct iptcb_chain_error {
 
 
 /* compile rule from cache into blob */
-static inline int iptcc_compile_rule (TC_HANDLE_T h, STRUCT_REPLACE *repl, struct rule_head *r)
+static inline int iptcc_compile_rule (struct xtc_handle *h, STRUCT_REPLACE *repl, struct rule_head *r)
 {
 	/* handle jumps */
 	if (r->type == IPTCC_R_JUMP) {
@@ -625,7 +625,7 @@ static inline int iptcc_compile_rule (TC
 }
 
 /* compile chain from cache into blob */
-static int iptcc_compile_chain(TC_HANDLE_T h, STRUCT_REPLACE *repl, struct chain_head *c)
+static int iptcc_compile_chain(struct xtc_handle *h, STRUCT_REPLACE *repl, struct chain_head *c)
 {
 	int ret;
 	struct rule_head *r;
@@ -673,7 +673,7 @@ static int iptcc_compile_chain(TC_HANDLE
 }
 
 /* calculate offset and number for every rule in the cache */
-static int iptcc_compile_chain_offsets(TC_HANDLE_T h, struct chain_head *c,
+static int iptcc_compile_chain_offsets(struct xtc_handle *h, struct chain_head *c,
 				       unsigned int *offset, unsigned int *num)
 {
 	struct rule_head *r;
@@ -708,7 +708,7 @@ static int iptcc_compile_chain_offsets(T
 }
 
 /* put the pieces back together again */
-static int iptcc_compile_table_prep(TC_HANDLE_T h, unsigned int *size)
+static int iptcc_compile_table_prep(struct xtc_handle *h, unsigned int *size)
 {
 	struct chain_head *c;
 	unsigned int offset = 0, num = 0;
@@ -731,7 +731,7 @@ static int iptcc_compile_table_prep(TC_H
 	return num;
 }
 
-static int iptcc_compile_table(TC_HANDLE_T h, STRUCT_REPLACE *repl)
+static int iptcc_compile_table(struct xtc_handle *h, STRUCT_REPLACE *repl)
 {
 	struct chain_head *c;
 	struct iptcb_chain_error *error;
@@ -760,11 +760,11 @@ static int iptcc_compile_table(TC_HANDLE
  **********************************************************************/
 
 /* Allocate handle of given size */
-static TC_HANDLE_T
+static struct xtc_handle *
 alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
 {
 	size_t len;
-	TC_HANDLE_T h;
+	struct xtc_handle *h;
 
 	len = sizeof(STRUCT_TC_HANDLE) + size;
 
@@ -793,10 +793,10 @@ out_free_handle:
 }
 
 
-TC_HANDLE_T
+struct xtc_handle *
 TC_INIT(const char *tablename)
 {
-	TC_HANDLE_T h;
+	struct xtc_handle *h;
 	STRUCT_GETINFO info;
 	unsigned int tmp;
 	socklen_t s;
@@ -870,12 +870,12 @@ error:
 		close(sockfd);
 		sockfd = -1;
 	}
-	TC_FREE(&h);
+	TC_FREE(h);
 	return NULL;
 }
 
 void
-TC_FREE(TC_HANDLE_T *h)
+TC_FREE(struct xtc_handle *h)
 {
 	struct chain_head *c, *tmp;
 
@@ -885,7 +885,7 @@ TC_FREE(TC_HANDLE_T *h)
 		sockfd = -1;
 	}
 
-	list_for_each_entry_safe(c, tmp, &(*h)->chains, list) {
+	list_for_each_entry_safe(c, tmp, &h->chains, list) {
 		struct rule_head *r, *rtmp;
 
 		list_for_each_entry_safe(r, rtmp, &c->rules, list) {
@@ -895,10 +895,8 @@ TC_FREE(TC_HANDLE_T *h)
 		free(c);
 	}
 
-	free((*h)->entries);
-	free(*h);
-
-	*h = NULL;
+	free(h->entries);
+	free(h);
 }
 
 static inline int
@@ -908,10 +906,10 @@ print_match(const STRUCT_ENTRY_MATCH *m)
 	return 0;
 }
 
-static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
+static int dump_entry(STRUCT_ENTRY *e, struct xtc_handle *const handle);
  
 void
-TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
+TC_DUMP_ENTRIES(struct xtc_handle *const handle)
 {
 	iptc_fn = TC_DUMP_ENTRIES;
 	CHECK(handle);
@@ -938,13 +936,13 @@ TC_DUMP_ENTRIES(const TC_HANDLE_T handle
 }
 
 /* Does this chain exist? */
-int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
+int TC_IS_CHAIN(const char *chain, const struct xtc_handle *handle)
 {
 	iptc_fn = TC_IS_CHAIN;
 	return iptcc_find_label(chain, handle) != NULL;
 }
 
-static void iptcc_chain_iterator_advance(TC_HANDLE_T handle)
+static void iptcc_chain_iterator_advance(struct xtc_handle *handle)
 {
 	struct chain_head *c = handle->chain_iterator_cur;
 
@@ -957,21 +955,21 @@ static void iptcc_chain_iterator_advance
 
 /* Iterator functions to run through the chains. */
 const char *
-TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+TC_FIRST_CHAIN(struct xtc_handle *handle)
 {
-	struct chain_head *c = list_entry((*handle)->chains.next,
+	struct chain_head *c = list_entry(handle->chains.next,
 					  struct chain_head, list);
 
 	iptc_fn = TC_FIRST_CHAIN;
 
 
-	if (list_empty(&(*handle)->chains)) {
+	if (list_empty(&handle->chains)) {
 		DEBUGP(": no chains\n");
 		return NULL;
 	}
 
-	(*handle)->chain_iterator_cur = c;
-	iptcc_chain_iterator_advance(*handle);
+	handle->chain_iterator_cur = c;
+	iptcc_chain_iterator_advance(handle);
 
 	DEBUGP(": returning `%s'\n", c->name);
 	return c->name;
@@ -979,9 +977,9 @@ TC_FIRST_CHAIN(TC_HANDLE_T *handle)
 
 /* Iterator functions to run through the chains.  Returns NULL at end. */
 const char *
-TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+TC_NEXT_CHAIN(struct xtc_handle *handle)
 {
-	struct chain_head *c = (*handle)->chain_iterator_cur;
+	struct chain_head *c = handle->chain_iterator_cur;
 
 	iptc_fn = TC_NEXT_CHAIN;
 
@@ -990,7 +988,7 @@ TC_NEXT_CHAIN(TC_HANDLE_T *handle)
 		return NULL;
 	}
 
-	iptcc_chain_iterator_advance(*handle);
+	iptcc_chain_iterator_advance(handle);
 	
 	DEBUGP(": returning `%s'\n", c->name);
 	return c->name;
@@ -998,7 +996,7 @@ TC_NEXT_CHAIN(TC_HANDLE_T *handle)
 
 /* Get first rule in the given chain: NULL for empty chain. */
 const STRUCT_ENTRY *
-TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+TC_FIRST_RULE(const char *chain, struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
@@ -1007,7 +1005,7 @@ TC_FIRST_RULE(const char *chain, TC_HAND
 
 	DEBUGP("first rule(%s): ", chain);
 
-	c = iptcc_find_label(chain, *handle);
+	c = iptcc_find_label(chain, handle);
 	if (!c) {
 		errno = ENOENT;
 		return NULL;
@@ -1020,7 +1018,7 @@ TC_FIRST_RULE(const char *chain, TC_HAND
 	}
 
 	r = list_entry(c->rules.next, struct rule_head, list);
-	(*handle)->rule_iterator_cur = r;
+	handle->rule_iterator_cur = r;
 	DEBUGP_C("%p\n", r);
 
 	return r->entry;
@@ -1028,33 +1026,33 @@ TC_FIRST_RULE(const char *chain, TC_HAND
 
 /* Returns NULL when rules run out. */
 const STRUCT_ENTRY *
-TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+TC_NEXT_RULE(const STRUCT_ENTRY *prev, struct xtc_handle *handle)
 {
 	struct rule_head *r;
 
 	iptc_fn = TC_NEXT_RULE;
-	DEBUGP("rule_iterator_cur=%p...", (*handle)->rule_iterator_cur);
+	DEBUGP("rule_iterator_cur=%p...", handle->rule_iterator_cur);
 
-	if (!(*handle)->rule_iterator_cur) {
+	if (handle->rule_iterator_cur == NULL) {
 		DEBUGP_C("returning NULL\n");
 		return NULL;
 	}
 	
-	r = list_entry((*handle)->rule_iterator_cur->list.next, 
+	r = list_entry(handle->rule_iterator_cur->list.next, 
 			struct rule_head, list);
 
 	iptc_fn = TC_NEXT_RULE;
 
 	DEBUGP_C("next=%p, head=%p...", &r->list, 
-		&(*handle)->rule_iterator_cur->chain->rules);
+		&handle->rule_iterator_cur->chain->rules);
 
-	if (&r->list == &(*handle)->rule_iterator_cur->chain->rules) {
-		(*handle)->rule_iterator_cur = NULL;
+	if (&r->list == &handle->rule_iterator_cur->chain->rules) {
+		handle->rule_iterator_cur = NULL;
 		DEBUGP_C("finished, returning NULL\n");
 		return NULL;
 	}
 
-	(*handle)->rule_iterator_cur = r;
+	handle->rule_iterator_cur = r;
 
 	/* NOTE: prev is without any influence ! */
 	DEBUGP_C("returning rule %p\n", r);
@@ -1063,13 +1061,13 @@ TC_NEXT_RULE(const STRUCT_ENTRY *prev, T
 
 /* How many rules in this chain? */
 unsigned int
-TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
+TC_NUM_RULES(const char *chain, struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	iptc_fn = TC_NUM_RULES;
-	CHECK(*handle);
+	CHECK(handle);
 
-	c = iptcc_find_label(chain, *handle);
+	c = iptcc_find_label(chain, handle);
 	if (!c) {
 		errno = ENOENT;
 		return (unsigned int)-1;
@@ -1080,16 +1078,16 @@ TC_NUM_RULES(const char *chain, TC_HANDL
 
 const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
 				unsigned int n,
-				TC_HANDLE_T *handle)
+				struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 	
 	iptc_fn = TC_GET_RULE;
 
-	CHECK(*handle);
+	CHECK(handle);
 
-	c = iptcc_find_label(chain, *handle);
+	c = iptcc_find_label(chain, handle);
 	if (!c) {
 		errno = ENOENT;
 		return NULL;
@@ -1129,7 +1127,7 @@ const char *standard_target_map(int verd
 
 /* Returns a pointer to the target name of this position. */
 const char *TC_GET_TARGET(const STRUCT_ENTRY *ce,
-			  TC_HANDLE_T *handle)
+			  struct xtc_handle *handle)
 {
 	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
 	struct rule_head *r = container_of(e, struct rule_head, entry[0]);
@@ -1158,7 +1156,7 @@ const char *TC_GET_TARGET(const STRUCT_E
 }
 /* Is this a built-in chain?  Actually returns hook + 1. */
 int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+TC_BUILTIN(const char *chain, const struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	
@@ -1177,7 +1175,7 @@ TC_BUILTIN(const char *chain, const TC_H
 const char *
 TC_GET_POLICY(const char *chain,
 	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
+	      struct xtc_handle *handle)
 {
 	struct chain_head *c;
 
@@ -1185,7 +1183,7 @@ TC_GET_POLICY(const char *chain,
 
 	DEBUGP("called for chain %s\n", chain);
 
-	c = iptcc_find_label(chain, *handle);
+	c = iptcc_find_label(chain, handle);
 	if (!c) {
 		errno = ENOENT;
 		return NULL;
@@ -1223,7 +1221,7 @@ iptcc_standard_map(struct rule_head *r, 
 }
 
 static int
-iptcc_map_target(const TC_HANDLE_T handle,
+iptcc_map_target(struct xtc_handle *const handle,
 	   struct rule_head *r)
 {
 	STRUCT_ENTRY *e = r->entry;
@@ -1278,7 +1276,7 @@ int
 TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
 		const STRUCT_ENTRY *e,
 		unsigned int rulenum,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
@@ -1286,7 +1284,7 @@ TC_INSERT_ENTRY(const IPT_CHAINLABEL cha
 
 	iptc_fn = TC_INSERT_ENTRY;
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1319,7 +1317,7 @@ TC_INSERT_ENTRY(const IPT_CHAINLABEL cha
 	memcpy(r->entry, e, e->next_offset);
 	r->counter_map.maptype = COUNTER_MAP_SET;
 
-	if (!iptcc_map_target(*handle, r)) {
+	if (!iptcc_map_target(handle, r)) {
 		free(r);
 		return 0;
 	}
@@ -1327,7 +1325,7 @@ TC_INSERT_ENTRY(const IPT_CHAINLABEL cha
 	list_add_tail(&r->list, prev);
 	c->num_rules++;
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1337,14 +1335,14 @@ int
 TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
 		 const STRUCT_ENTRY *e,
 		 unsigned int rulenum,
-		 TC_HANDLE_T *handle)
+		 struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r, *old;
 
 	iptc_fn = TC_REPLACE_ENTRY;
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1369,7 +1367,7 @@ TC_REPLACE_ENTRY(const IPT_CHAINLABEL ch
 	memcpy(r->entry, e, e->next_offset);
 	r->counter_map.maptype = COUNTER_MAP_SET;
 
-	if (!iptcc_map_target(*handle, r)) {
+	if (!iptcc_map_target(handle, r)) {
 		free(r);
 		return 0;
 	}
@@ -1377,7 +1375,7 @@ TC_REPLACE_ENTRY(const IPT_CHAINLABEL ch
 	list_add(&r->list, &old->list);
 	iptcc_delete_rule(old);
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1387,13 +1385,13 @@ TC_REPLACE_ENTRY(const IPT_CHAINLABEL ch
 int
 TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
 		const STRUCT_ENTRY *e,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 
 	iptc_fn = TC_APPEND_ENTRY;
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		DEBUGP("unable to find chain `%s'\n", chain);
 		errno = ENOENT;
 		return 0;
@@ -1408,7 +1406,7 @@ TC_APPEND_ENTRY(const IPT_CHAINLABEL cha
 	memcpy(r->entry, e, e->next_offset);
 	r->counter_map.maptype = COUNTER_MAP_SET;
 
-	if (!iptcc_map_target(*handle, r)) {
+	if (!iptcc_map_target(handle, r)) {
 		DEBUGP("unable to map target of rule for chain `%s'\n", chain);
 		free(r);
 		return 0;
@@ -1417,7 +1415,7 @@ TC_APPEND_ENTRY(const IPT_CHAINLABEL cha
 	list_add_tail(&r->list, &c->rules);
 	c->num_rules++;
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1495,13 +1493,13 @@ int
 TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
 		const STRUCT_ENTRY *origfw,
 		unsigned char *matchmask,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r, *i;
 
 	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1515,7 +1513,7 @@ TC_DELETE_ENTRY(const IPT_CHAINLABEL cha
 
 	memcpy(r->entry, origfw, origfw->next_offset);
 	r->counter_map.maptype = COUNTER_MAP_NOMAP;
-	if (!iptcc_map_target(*handle, r)) {
+	if (!iptcc_map_target(handle, r)) {
 		DEBUGP("unable to map target of rule for chain `%s'\n", chain);
 		free(r);
 		return 0;
@@ -1542,16 +1540,16 @@ TC_DELETE_ENTRY(const IPT_CHAINLABEL cha
 		/* If we are about to delete the rule that is the
 		 * current iterator, move rule iterator back.  next
 		 * pointer will then point to real next node */
-		if (i == (*handle)->rule_iterator_cur) {
-			(*handle)->rule_iterator_cur = 
-				list_entry((*handle)->rule_iterator_cur->list.prev,
+		if (i == handle->rule_iterator_cur) {
+			handle->rule_iterator_cur = 
+				list_entry(handle->rule_iterator_cur->list.prev,
 					   struct rule_head, list);
 		}
 
 		c->num_rules--;
 		iptcc_delete_rule(i);
 
-		set_changed(*handle);
+		set_changed(handle);
 		free(r);
 		return 1;
 	}
@@ -1566,14 +1564,14 @@ TC_DELETE_ENTRY(const IPT_CHAINLABEL cha
 int
 TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
 		    unsigned int rulenum,
-		    TC_HANDLE_T *handle)
+		    struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 
 	iptc_fn = TC_DELETE_NUM_ENTRY;
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1593,16 +1591,16 @@ TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL
 	/* If we are about to delete the rule that is the current
 	 * iterator, move rule iterator back.  next pointer will then
 	 * point to real next node */
-	if (r == (*handle)->rule_iterator_cur) {
-		(*handle)->rule_iterator_cur = 
-			list_entry((*handle)->rule_iterator_cur->list.prev,
+	if (r == handle->rule_iterator_cur) {
+		handle->rule_iterator_cur = 
+			list_entry(handle->rule_iterator_cur->list.prev,
 				   struct rule_head, list);
 	}
 
 	c->num_rules--;
 	iptcc_delete_rule(r);
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1612,7 +1610,7 @@ TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL
 const char *
 TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
 		STRUCT_ENTRY *entry,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	iptc_fn = TC_CHECK_PACKET;
 	errno = ENOSYS;
@@ -1621,13 +1619,13 @@ TC_CHECK_PACKET(const IPT_CHAINLABEL cha
 
 /* Flushes the entries in the given chain (ie. empties chain). */
 int
-TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r, *tmp;
 
 	iptc_fn = TC_FLUSH_ENTRIES;
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1638,20 +1636,20 @@ TC_FLUSH_ENTRIES(const IPT_CHAINLABEL ch
 
 	c->num_rules = 0;
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
 
 /* Zeroes the counters in a chain. */
 int
-TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 
 	iptc_fn = TC_ZERO_ENTRIES;
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1664,7 +1662,7 @@ TC_ZERO_ENTRIES(const IPT_CHAINLABEL cha
 			r->counter_map.maptype = COUNTER_MAP_ZEROED;
 	}
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1672,7 +1670,7 @@ TC_ZERO_ENTRIES(const IPT_CHAINLABEL cha
 STRUCT_COUNTERS *
 TC_READ_COUNTER(const IPT_CHAINLABEL chain,
 		unsigned int rulenum,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
@@ -1680,7 +1678,7 @@ TC_READ_COUNTER(const IPT_CHAINLABEL cha
 	iptc_fn = TC_READ_COUNTER;
 	CHECK(*handle);
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return NULL;
 	}
@@ -1696,15 +1694,15 @@ TC_READ_COUNTER(const IPT_CHAINLABEL cha
 int
 TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
 		unsigned int rulenum,
-		TC_HANDLE_T *handle)
+		struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 	
 	iptc_fn = TC_ZERO_COUNTER;
-	CHECK(*handle);
+	CHECK(handle);
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1717,7 +1715,7 @@ TC_ZERO_COUNTER(const IPT_CHAINLABEL cha
 	if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
 		r->counter_map.maptype = COUNTER_MAP_ZEROED;
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1726,16 +1724,16 @@ int 
 TC_SET_COUNTER(const IPT_CHAINLABEL chain,
 	       unsigned int rulenum,
 	       STRUCT_COUNTERS *counters,
-	       TC_HANDLE_T *handle)
+	       struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	struct rule_head *r;
 	STRUCT_ENTRY *e;
 
 	iptc_fn = TC_SET_COUNTER;
-	CHECK(*handle);
+	CHECK(handle);
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1750,7 +1748,7 @@ TC_SET_COUNTER(const IPT_CHAINLABEL chai
 
 	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1759,7 +1757,7 @@ TC_SET_COUNTER(const IPT_CHAINLABEL chai
 /* To create a chain, create two rules: error node and unconditional
  * return. */
 int
-TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, struct xtc_handle *handle)
 {
 	static struct chain_head *c;
 
@@ -1767,7 +1765,7 @@ TC_CREATE_CHAIN(const IPT_CHAINLABEL cha
 
 	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
            QUEUE, RETURN. */
-	if (iptcc_find_label(chain, *handle)
+	if (iptcc_find_label(chain, handle)
 	    || strcmp(chain, LABEL_DROP) == 0
 	    || strcmp(chain, LABEL_ACCEPT) == 0
 	    || strcmp(chain, LABEL_QUEUE) == 0
@@ -1792,9 +1790,9 @@ TC_CREATE_CHAIN(const IPT_CHAINLABEL cha
 	}
 
 	DEBUGP("Creating chain `%s'\n", chain);
-	list_add_tail(&c->list, &(*handle)->chains);
+	list_add_tail(&c->list, &handle->chains);
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1802,12 +1800,12 @@ TC_CREATE_CHAIN(const IPT_CHAINLABEL cha
 /* Get the number of references to this chain. */
 int
 TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
-		  TC_HANDLE_T *handle)
+		  struct xtc_handle *handle)
 {
 	struct chain_head *c;
 
 	iptc_fn = TC_GET_REFERENCES;
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1819,20 +1817,20 @@ TC_GET_REFERENCES(unsigned int *ref, con
 
 /* Deletes a chain. */
 int
-TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, struct xtc_handle *handle)
 {
 	unsigned int references;
 	struct chain_head *c;
 
 	iptc_fn = TC_DELETE_CHAIN;
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		DEBUGP("cannot find chain `%s'\n", chain);
 		errno = ENOENT;
 		return 0;
 	}
 
-	if (TC_BUILTIN(chain, *handle)) {
+	if (TC_BUILTIN(chain, handle)) {
 		DEBUGP("cannot remove builtin chain `%s'\n", chain);
 		errno = EINVAL;
 		return 0;
@@ -1857,15 +1855,15 @@ TC_DELETE_CHAIN(const IPT_CHAINLABEL cha
 
 	/* If we are about to delete the chain that is the current
 	 * iterator, move chain iterator firward. */
-	if (c == (*handle)->chain_iterator_cur)
-		iptcc_chain_iterator_advance(*handle);
+	if (c == handle->chain_iterator_cur)
+		iptcc_chain_iterator_advance(handle);
 
 	list_del(&c->list);
 	free(c);
 
 	DEBUGP("chain `%s' deleted\n", chain);
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1873,14 +1871,14 @@ TC_DELETE_CHAIN(const IPT_CHAINLABEL cha
 /* Renames a chain. */
 int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
 		    const IPT_CHAINLABEL newname,
-		    TC_HANDLE_T *handle)
+		    struct xtc_handle *handle)
 {
 	struct chain_head *c;
 	iptc_fn = TC_RENAME_CHAIN;
 
 	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
            QUEUE, RETURN. */
-	if (iptcc_find_label(newname, *handle)
+	if (iptcc_find_label(newname, handle)
 	    || strcmp(newname, LABEL_DROP) == 0
 	    || strcmp(newname, LABEL_ACCEPT) == 0
 	    || strcmp(newname, LABEL_QUEUE) == 0
@@ -1889,8 +1887,8 @@ int TC_RENAME_CHAIN(const IPT_CHAINLABEL
 		return 0;
 	}
 
-	if (!(c = iptcc_find_label(oldname, *handle))
-	    || TC_BUILTIN(oldname, *handle)) {
+	if (!(c = iptcc_find_label(oldname, handle))
+	    || TC_BUILTIN(oldname, handle)) {
 		errno = ENOENT;
 		return 0;
 	}
@@ -1902,7 +1900,7 @@ int TC_RENAME_CHAIN(const IPT_CHAINLABEL
 
 	strncpy(c->name, newname, sizeof(IPT_CHAINLABEL));
 	
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -1912,13 +1910,13 @@ int
 TC_SET_POLICY(const IPT_CHAINLABEL chain,
 	      const IPT_CHAINLABEL policy,
 	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
+	      struct xtc_handle *handle)
 {
 	struct chain_head *c;
 
 	iptc_fn = TC_SET_POLICY;
 
-	if (!(c = iptcc_find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, handle))) {
 		DEBUGP("cannot find chain `%s'\n", chain);
 		errno = ENOENT;
 		return 0;
@@ -1947,7 +1945,7 @@ TC_SET_POLICY(const IPT_CHAINLABEL chain
 		c->counter_map.maptype = COUNTER_MAP_NOMAP;
 	}
 
-	set_changed(*handle);
+	set_changed(handle);
 
 	return 1;
 }
@@ -2024,7 +2022,7 @@ static void counters_map_set(STRUCT_COUN
 
 
 int
-TC_COMMIT(TC_HANDLE_T *handle)
+TC_COMMIT(struct xtc_handle *handle)
 {
 	/* Replace, then map back the counters. */
 	STRUCT_REPLACE *repl;
@@ -2039,10 +2037,10 @@ TC_COMMIT(TC_HANDLE_T *handle)
 	CHECK(*handle);
 
 	/* Don't commit if nothing changed. */
-	if (!(*handle)->changed)
+	if (!handle->changed)
 		goto finished;
 
-	new_number = iptcc_compile_table_prep(*handle, &new_size);
+	new_number = iptcc_compile_table_prep(handle, &new_size);
 	if (new_number < 0) {
 		errno = ENOMEM;
 		goto out_zero;
@@ -2064,7 +2062,7 @@ TC_COMMIT(TC_HANDLE_T *handle)
 
 	/* These are the old counters we will get from kernel */
 	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
-				* (*handle)->info.num_entries);
+				* handle->info.num_entries);
 	if (!repl->counters) {
 		errno = ENOMEM;
 		goto out_free_repl;
@@ -2077,17 +2075,17 @@ TC_COMMIT(TC_HANDLE_T *handle)
 	}
 	memset(newcounters, 0, counterlen);
 
-	strcpy(repl->name, (*handle)->info.name);
+	strcpy(repl->name, handle->info.name);
 	repl->num_entries = new_number;
 	repl->size = new_size;
 
-	repl->num_counters = (*handle)->info.num_entries;
-	repl->valid_hooks = (*handle)->info.valid_hooks;
+	repl->num_counters = handle->info.num_entries;
+	repl->valid_hooks  = handle->info.valid_hooks;
 
 	DEBUGP("num_entries=%u, size=%u, num_counters=%u\n",
 		repl->num_entries, repl->size, repl->num_counters);
 
-	ret = iptcc_compile_table(*handle, repl);
+	ret = iptcc_compile_table(handle, repl);
 	if (ret < 0) {
 		errno = ret;
 		goto out_free_newcounters;
@@ -2111,10 +2109,10 @@ TC_COMMIT(TC_HANDLE_T *handle)
 		goto out_free_newcounters;
 
 	/* Put counters back. */
-	strcpy(newcounters->name, (*handle)->info.name);
+	strcpy(newcounters->name, handle->info.name);
 	newcounters->num_counters = new_number;
 
-	list_for_each_entry(c, &(*handle)->chains, list) {
+	list_for_each_entry(c, &handle->chains, list) {
 		struct rule_head *r;
 
 		/* Builtin chains have their own counters */
@@ -2207,7 +2205,6 @@ TC_COMMIT(TC_HANDLE_T *handle)
 	free(newcounters);
 
 finished:
-	TC_FREE(handle);
 	return 1;
 
 out_free_newcounters:
