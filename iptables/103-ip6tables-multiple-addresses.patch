[PATCH] iptables: fix ip6tables so that writes rules for EACH of a hostname's addresses

From: Wes Campaigne <westacular>
Date: Thu, 17 Feb 2011 08:06:58 -0500

For ipv4/iptables, a rule is created for all resolved addresses. This seems
correct.

For ipv6, at the resolving step, the code only grabbed the first address,
instead of all of them, even though all the backend code for handling multiple
addresses is there. It's not clear why, but even current git of ip6tables still
has this odd limitation.

---
 ip6tables.c |   31 +++++++++++++------------------
 1 file changed, 13 insertions(+), 18 deletions(-)

diff --git a/ip6tables.c b/ip6tables.c
--- a/ip6tables.c
+++ b/ip6tables.c
@@ -546,15 +546,15 @@ host_to_addr(const char *name, unsigned 
 {
 	struct addrinfo hints;
         struct addrinfo *res;
-        static struct in6_addr *addr;
+	struct addrinfo *p;
+	struct in6_addr *addr;
 	int err;
+	unsigned int i;
 
 	memset(&hints, 0, sizeof(hints));
         hints.ai_flags=AI_CANONNAME;
         hints.ai_family=AF_INET6;
         hints.ai_socktype=SOCK_RAW;
-        hints.ai_protocol=41;
-        hints.ai_next=NULL;
 
 	*naddr = 0;
         if ( (err=getaddrinfo(name, NULL, &hints, &res)) != 0 ){
@@ -563,20 +563,19 @@ host_to_addr(const char *name, unsigned 
 #endif
                 return (struct in6_addr *) NULL;
         } else {
-		if (res->ai_family != AF_INET6 ||
-		    res->ai_addrlen != sizeof(struct sockaddr_in6))
-			return (struct in6_addr *) NULL;
-
+		/* Find length of address-chain */
+		for(p = res; p != NULL; p = p->ai_next)
+			(*naddr)++;
 #ifdef DEBUG
                 fprintf(stderr, "resolved: len=%d  %s ", res->ai_addrlen, 
                     addr_to_numeric(&(((struct sockaddr_in6 *)res->ai_addr)->sin6_addr)));
 #endif
-		/* Get the first element of the address-chain */
-		addr = fw_calloc(1, sizeof(struct in6_addr));
-		in6addrcpy(addr, (struct in6_addr *)
-			&((struct sockaddr_in6 *)res->ai_addr)->sin6_addr);
+		addr = fw_calloc(*naddr, sizeof(struct in6_addr));
+		i = 0;
+		for(p = res; p != NULL; p = p->ai_next)
+			in6addrcpy(&(addr[i++]), (struct in6_addr *)
+				&((struct sockaddr_in6 *)p->ai_addr)->sin6_addr);
 		freeaddrinfo(res);
-		*naddr = 1;
 		return addr;
 	}
 
@@ -2512,12 +2511,8 @@ int do_command6(int argc, char *argv[], 
 		e = NULL;
 	}
 
-	for (c = 0; c < nsaddrs; c++)
-		free(&saddrs[c]);
-
-	for (c = 0; c < ndaddrs; c++)
-		free(&daddrs[c]);
-
+	free(saddrs);
+	free(daddrs);
 	free_opts(1);
 
 	return ret;
-- 
