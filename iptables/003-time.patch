diff -BurN iptables-1.2.7a/extensions/libipt_time.c iptables/extensions/libipt_time.c
--- iptables-1.2.7a/extensions/libipt_time.c	2002-05-29 17:08:16.000000000 +0400
+++ iptables/extensions/libipt_time.c	2009-04-10 18:43:21.000000000 +0300
@@ -0,0 +1,280 @@
+/* Shared library add-on to iptables to add TIME matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <stddef.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <time.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TIME v%s options:\n"
+" --datestart YYYY[-MM[-DD]] --datestop YYYY[-MM[-DD]]\n"
+"				Only match during the given dates.\n"
+" --timestart hh:mm[:ss] --timestop hh:mm[:ss]\n"
+"				Only match during the given daytime.\n"
+" --days <listofdays>\n"
+"				A list of days to apply -> ie. Mon,Tue,Wed,Thu,Fri.\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "datestart", 1, 0, '1' },
+	{ "datestop",  1, 0, '2' },
+	{ "timestart", 1, 0, '3' },
+	{ "timestop",  1, 0, '4' },
+	{ "days",      1, 0, '5' },
+	{0}
+};
+
+#define MAX_TIME_T	((time_t)(~0UL>>1))
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(m)->data;
+
+	timeinfo->time_start = 0;
+	timeinfo->time_stop = 24*60*60 - 1;
+	timeinfo->date_start = 0;
+	timeinfo->date_stop = MAX_TIME_T;
+	timeinfo->days_match = 0x7F;
+
+	/* caching not yet implemented */
+        *nfcache |= NFC_UNKNOWN;
+}
+
+static time_t
+parse_date(const char *date)
+{
+	struct tm dt = { .tm_mon = 1, .tm_mday = 1, .tm_hour = 0, .tm_min = 0, .tm_sec = 0 };
+
+	if (sscanf(date, "%d-%d-%dT%d:%d:%d", &dt.tm_year, &dt.tm_mon, &dt.tm_mday,
+			 &dt.tm_hour, &dt.tm_min, &dt.tm_sec) >= 1) {
+		dt.tm_year -= 1900; dt.tm_mon -= 1;
+		return timelocal(&dt);
+	}
+
+	/* If we are here, there was a problem ..*/
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid date `%s' specified, should be YYYY-MM-DD format", date);
+}
+
+static int
+parse_time(const char *time)
+{
+	int hours, minutes, seconds = 0;
+
+	if (sscanf(time, "%d:%d:%d", &hours, &minutes, &seconds) >= 2)
+		return (hours * 60 * 60 + minutes * 60 + seconds);
+
+	/* If we are here, there was a problem ..*/
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid time `%s' specified, should be HH:MM:SS format", time);
+}
+
+static const char *days[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
+
+static int
+parse_days(const char *string)
+{
+	char *comma;
+	int i, mask = 0;
+
+	do {
+		for (i = 0; i < 7; i++)
+			if (!strncasecmp(string, days[i], 3))
+				mask |= 1 << i;
+		comma = strchr(string, ',');
+		string = comma + 1;
+	} while (comma);
+
+	return mask;
+}
+
+#define IPT_DATE_START 0x01
+#define IPT_DATE_STOP  0x02
+#define IPT_TIME_START 0x04
+#define IPT_TIME_STOP  0x08
+#define IPT_TIME_DAYS  0x10
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(*match)->data;
+
+	switch (c)
+	{
+		/* datestart */
+	case '1':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --%s", opts[0].name);
+		if (*flags & IPT_DATE_START)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --%s twice", opts[0].name);
+		timeinfo->date_start = parse_date(optarg);
+		*flags |= IPT_DATE_START;
+		break;
+		/* datestop */
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --%s", opts[1].name);
+		if (*flags & IPT_DATE_STOP)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --%s twice", opts[1].name);
+		timeinfo->date_stop = parse_date(optarg);
+		*flags |= IPT_DATE_STOP;
+		break;
+
+		/* timestart */
+	case '3':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --%s", opts[2].name);
+		if (*flags & IPT_TIME_START)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --%s twice", opts[2].name);
+		timeinfo->time_start = parse_time(optarg);
+		*flags |= IPT_TIME_START;
+		break;
+		/* timestop */
+	case '4':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --%s", opts[3].name);
+		if (*flags & IPT_TIME_STOP)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --%s twice", opts[3].name);
+		timeinfo->time_stop = parse_time(optarg);
+		*flags |= IPT_TIME_STOP;
+		break;
+
+		/* days */
+	case '5':
+		if (*flags & IPT_TIME_DAYS)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --%s twice", opts[4].name);
+		timeinfo->days_match = parse_days(optarg);
+		if (invert)
+			timeinfo->days_match = ~timeinfo->days_match;
+		*flags |= IPT_TIME_DAYS;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; must have specified --timestart --timestop --days. */
+static void
+final_check(unsigned int flags)
+{
+	if ((flags & (IPT_TIME_START | IPT_TIME_STOP | IPT_TIME_DAYS)) != (IPT_TIME_START | IPT_TIME_STOP | IPT_TIME_DAYS) &&
+		(flags & (IPT_DATE_START | IPT_DATE_STOP)) != (IPT_DATE_START | IPT_DATE_STOP))
+		exit_error(PARAMETER_PROBLEM,
+			   "TIME match: You must specify `--%s --%s and --%s' or `--%s --%s'",
+				opts[2].name,opts[3].name,opts[4].name, opts[0].name,opts[1].name);
+}
+
+static void
+print_date(const time_t *datetime)
+{
+	struct tm dt;
+
+	localtime_r(datetime, &dt);
+	printf("%04d-%02d-%02d ", dt.tm_year+1900, dt.tm_mon+1, dt.tm_mday);
+}
+
+static void
+print_time(const int tm)
+{
+	printf("%02d:%02d:%02d ", tm / (60 * 60), (tm / 60) % 60, tm % 60 );
+}
+
+static void
+print_days(const struct ipt_time_info *time)
+{
+	int i;
+	char *sep = "";
+
+	for (i = 0; i < 7; i++) {
+		if (time->days_match & (1 << i)) {
+			printf("%s%s", sep, days[i]);
+			sep = ",";
+		}
+	}
+	printf(" ");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+
+	printf("TIME from ");
+	if (time->date_start > 0 && time->date_start < MAX_TIME_T)
+		print_date(&time->date_start);
+	print_time(time->time_start);
+	printf("to ");
+	if (time->date_stop > 0 && time->date_stop < MAX_TIME_T)
+		print_date(&time->date_stop);
+	print_time(time->time_stop);
+	printf("on ");	print_days(time);
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+
+	if (time->date_start > 0 && time->date_start < MAX_TIME_T) {
+		printf("--datestart "); print_date(&time->date_start);
+	}
+	if (time->date_stop > 0 && time->date_stop < MAX_TIME_T) {
+		printf("--datestop ");  print_date(&time->date_stop);
+	}
+	printf("--timestart "); print_time(time->time_start);
+	printf("--timestop ");  print_time(time->time_stop);
+	printf("--days ");      print_days(time);
+}
+
+static
+struct iptables_match timestruct = {
+	.next		=    NULL,
+	.name		=    "time",
+	.version	=    IPTABLES_VERSION,
+	.size		=    IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.userspacesize	=    offsetof(struct ipt_time_info, kerneltime),
+	.help		=    &help,
+	.init		=    &init,
+	.parse		=    &parse,
+	.final_check	=    &final_check,
+	.print		=    &print,
+	.save		=    &save,
+	.extra_opts	=    opts
+};
+
+void _init(void)
+{
+	register_match(&timestruct);
+}
