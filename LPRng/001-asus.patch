diff -urNBp LPRng-3.8.22/CONFIG_JW LPRng/CONFIG_JW
--- LPRng-3.8.22/CONFIG_JW	1970-01-01 03:00:00.000000000 +0300
+++ LPRng/CONFIG_JW	2011-05-15 14:26:17.000000000 +0400
@@ -0,0 +1 @@
+./configure --includedir=/root/broadcom/src/linux/linux/include --host=mips CC=mipsel-linux-gcc --disable-werror --disable-kerberos --disable-ssl --disable-mit_kerberos4 --with-userid=root --with-groupid=root --disable-setuid --disable-nls --enable-static --enables-shared
diff -urNBp LPRng-3.8.22/Makefile.in LPRng/Makefile.in
--- LPRng-3.8.22/Makefile.in	2003-09-06 00:07:13.000000000 +0400
+++ LPRng/Makefile.in	2010-02-25 21:14:12.000000000 +0300
@@ -42,7 +42,7 @@ LPD_PERMS_PATH=\"@LPD_PERMS_PATH@\"
 LPD_CONF_PATH=\"@LPD_CONF_PATH@\"
 PRINTCAP_PATH=\"@PRINTCAP_PATH@\"
 LPD_PATH=\"@LPD_DIR@/lpd\"
-SHELL="@SHELL@"
+# SHELL="@SHELL@"
 LOCKFILE=\"@LOCKFILE@\"
 PSHOWALL="@PSHOWALL@"
 FILTER_DIR=@FILTER_DIR@
diff -urNBp LPRng-3.8.22/src/AUTHENTICATE/sclient.c LPRng/src/AUTHENTICATE/sclient.c
--- LPRng-3.8.22/src/AUTHENTICATE/sclient.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/AUTHENTICATE/sclient.c	2011-06-09 00:21:41.000000000 +0400
@@ -108,6 +108,13 @@ char *argv[];
 
     /* open a TCP socket */
     sock = socket(PF_INET, SOCK_STREAM, 0);
+#ifdef WINDOW_1
+int windowsize=1024;
+setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+//fprintf(aaaaaa, "sclient: main\n");
+//fclose(aaaaaa);
+#endif
 	Max_open(sock);
     if( sock < 0 ){
 		perror("socket");
diff -urNBp LPRng-3.8.22/src/AUTHENTICATE/sserver.c LPRng/src/AUTHENTICATE/sserver.c
--- LPRng-3.8.22/src/AUTHENTICATE/sserver.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/AUTHENTICATE/sserver.c	2011-06-09 00:21:35.000000000 +0400
@@ -104,6 +104,13 @@ main(int argc, char *argv[])
 		FPRINTF(STDOUT, "socket: %s\n", Errormsg(errno));
 		exit(3);
 	}
+#ifdef WINDOW_1
+int windowsize=1024;
+setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+//fprintf(aaaaaa, "sserver: main\n");
+//fclose(aaaaaa);
+#endif
 	Max_open(sock);
 	/* Let the socket be reused right away */
 	(void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&on,
diff -urNBp LPRng-3.8.22/src/common/checkpc.c LPRng/src/common/checkpc.c
--- LPRng-3.8.22/src/common/checkpc.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/checkpc.c	2011-06-09 00:24:23.000000000 +0400
@@ -217,7 +217,9 @@ int main( int argc, char *argv[], char *
     }
 	if(Verbose)MESSAGE("Checking printcap info");
 	if( User_specified_printer ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( DEBUGL1 ) Dump_line_list("checkpc: names", &PC_names_line_list );
+#endif
 		s = Find_str_value( &PC_names_line_list, User_specified_printer, Value_sep );
 		DEBUG1("checkpc: for SERVER %s is really %s", User_specified_printer, s );
 		if( s ){
@@ -225,7 +227,9 @@ int main( int argc, char *argv[], char *
 			Scan_printer(&spooldirs);
 		}
 	} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( DEBUGL1 ) Dump_line_list("checkpc: all", &All_line_list );
+#endif
 		for( i = 0; i < All_line_list.count; ++i ){
 			Set_DYN(&Printer_DYN,All_line_list.list[i]);
 			Scan_printer(&spooldirs);
@@ -378,8 +382,10 @@ void Scan_printer(struct line_list *spoo
 		return;
 	}
 	if( !(dir = opendir( Spool_dir_DYN )) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		WARNMSG( "  Printer_DYN '%s' spool dir '%s' cannot be scanned '%s'",
 			Printer_DYN, Spool_dir_DYN, Errormsg(errno) );
+#endif
 		return;
 	}
 	if( (Fix || Remove) && Lpq_status_file_DYN ){
@@ -397,8 +403,10 @@ void Scan_printer(struct line_list *spoo
 			continue;
 		}
 		if( stat(cf_name,&statb) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG( "  stat of file '%s' failed '%s'",
 				cf_name, Errormsg(errno) );
+#endif
 			continue;
 		}
 		/* do not touch symbolic links */
@@ -491,11 +499,15 @@ void Scan_printer(struct line_list *spoo
 			WARNMSG( "%s: lp device not absolute  pathname '%s'",
 				Printer_DYN, s );
 		} else if( stat(s,&statb) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG( "%s: cannot stat lp device '%s' - %s",
 				Printer_DYN, s, Errormsg(errno) );
+#endif
 		} else if( (fd = Checkwrite(s,&statb,0,0,1)) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG( "%s: cannot open lp device '%s' - %s",
 				Printer_DYN, s, Errormsg(errno) );
+#endif
 		}
 		if( fd >= 0 ) close(fd);
 	}
@@ -568,8 +580,10 @@ void Check_executable_filter( char *id,
 		}
 		if(Verbose)MESSAGE("    executable '%s'", s );
 		if( stat(s,&statb) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG("cannot stat '%s' filter '%s' - %s", id,
 			s, Errormsg(errno) );
+#endif
 		} else if(!S_ISREG(statb.st_mode)) {
 			WARNMSG("'%s' filter '%s' not a file", id, s);
 		} else {
@@ -609,14 +623,18 @@ void Make_write_file( char *file, char *
 	}
 
 	if( (fd = Checkwrite( s, &statb, O_RDWR, 1, 1 )) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		WARNMSG( " ** cannot open '%s' - '%s'", s, Errormsg(errno) );
+#endif
 		if( Fix ){
 			int euid = geteuid();
 			To_euid_root();
 			fd = open( s, O_RDWR|O_CREAT, Spool_file_perms_DYN  );
 			To_euid(euid);
 			if( fd < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				WARNMSG( " ** cannot create '%s' - '%s'", s, Errormsg(errno) );
+#endif
 			}
 			Fix_owner( s );
 		}
@@ -718,7 +736,9 @@ int Check_file( char  *path, int fix, in
 		path, fix, (long)Current_time, age );
 
 	if( stat( path, &statb ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(Verbose)MESSAGE( "cannot stat file '%s', %s", path, Errormsg(errno) );
+#endif
 		err = 1;
 		return( err );
 	}
@@ -753,8 +773,10 @@ int Check_file( char  *path, int fix, in
 			if( rmflag ){
 				FPRINTF( STDOUT, "removing '%s'\n", path );
 				if( unlink( path ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					WARNMSG( "cannot remove '%s', %s", path,
 						Errormsg(errno) );
+#endif
 				}
 			}
 		}
@@ -775,8 +797,10 @@ int Fix_create_dir( char  *path, struct
 				WARNMSG( "not regular file '%s'", path );
 				err = 1;
 			} else if( unlink( s ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				WARNMSG( "cannot unlink file '%s', %s",
 					path, Errormsg(errno) );
+#endif
 				err = 1;
 			}
 		}
@@ -786,7 +810,9 @@ int Fix_create_dir( char  *path, struct
 		int euid = geteuid();
 		To_euid_root();
 		if( mkdir( path, Spool_dir_perms_DYN ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG( "mkdir '%s' failed, %s", path, Errormsg(errno) );
+#endif
 			err = 1;
 		} else {
 			err = Fix_owner( path );
@@ -810,7 +836,9 @@ int Fix_owner( char *path )
 		status = chown( path, DaemonUID, DaemonGID );
 		err = errno;
 		if( status ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			WARNMSG( "chown '%s' failed, %s", path, Errormsg(err) );
+#endif
 		}
 		errno = err;
 	}
@@ -830,8 +858,10 @@ int Fix_perms( char *path, int perms )
 	To_euid( euid );
 
 	if( status ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		WARNMSG( "chmod '%s' to 0%o failed, %s", path, perms,
 			 Errormsg(err) );
+#endif
 	}
 	errno = err;
 	return( status != 0 );
@@ -879,19 +909,25 @@ int Check_spool_dir( char *path, int own
 		if( stat( pathname, &statb ) == 0 && S_ISDIR( statb.st_mode )
 			&& chdir( pathname ) == -1 ){
 			if( !Fix ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				WARNMSG( "cannot chdir to '%s' as UID %d, GRP %d - '%s'",
 					pathname, geteuid(), getegid(), Errormsg(errno) );
+#endif
 			} else {
 				Fix_perms( pathname, Spool_dir_perms_DYN );
 				if( chdir( pathname ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					WARNMSG( "Permission change FAILED: cannot chdir to '%s' as UID %d, GRP %d - '%s'",
 					pathname, geteuid(), getegid(), Errormsg(errno) );
+#endif
 					Fix_owner( pathname );
 					Fix_perms( pathname, Spool_dir_perms_DYN );
 				}
 				if( chdir( pathname ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					WARNMSG( "Owner and Permission change FAILED: cannot chdir to '%s' as UID %d, GRP %d - '%s'",
 					pathname, geteuid(), getegid(), Errormsg(errno) );
+#endif
 				}
 			}
 		}
@@ -912,7 +948,9 @@ int Check_spool_dir( char *path, int own
 		To_euid(euid);
 	}
 	if( stat( path, &statb ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		WARNMSG( "stat of '%s' failed - %s", path, Errormsg(errno) );
+#endif
 		err = 1;
 		return( err );
 	}
@@ -1033,7 +1071,9 @@ void Test_port(int ruid, int euid, char
 				serial_line );
 			goto test_stty;
 		} else if( fd < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			FPRINTF( STDERR, "Error opening line '%s'\n", Errormsg(err));
+#endif
 			goto test_stty;
 		} else if( !isatty( fd ) ){
 			FPRINTF( STDERR,
@@ -1051,9 +1091,11 @@ void Test_port(int ruid, int euid, char
 				FPRINTF( STDERR, "***** Read with Timeout successful\n" );
 			} else {
 				 if( i < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					FPRINTF( STDERR,
 					"***** Read with Timeout FAILED!! Error '%s'\n",
 						Errormsg( err ) );
+#endif
 				} else {
 					FPRINTF( STDERR,
 						"***** Read with Timeout FAILED!! read() returned %d\n",
@@ -1092,12 +1134,16 @@ void Test_port(int ruid, int euid, char
 		err = errno;
 		if( Alarm_timed_out || i < 0 ){
 			if( Alarm_timed_out ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				FPRINTF( STDERR, "LockDevice timed out - %s", Errormsg(err) );
+#endif
 			}
 			FPRINTF( STDERR,
 				"*******************************************************\n" );
+#ifdef ORIGINAL_DEBUG //JY@1020
 				FPRINTF( STDERR, "********* LockDevice failed -  %s\n",
 					Errormsg(err) );
+#endif
 				FPRINTF( STDERR, "********* Try an alternate lock routine\n" );
 			FPRINTF( STDERR,
 				"*******************************************************\n" );
@@ -1109,7 +1155,9 @@ void Test_port(int ruid, int euid, char
 		 * now we fork a child with tries to reopen the file and lock it
 		 */
 		if( (pid = fork()) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			FPRINTF( STDERR, "fork failed - %s", Errormsg(errno) );
+#endif
 		} else if( pid == 0 ){
 			close(fd);
 			fd = -1;
@@ -1128,8 +1176,10 @@ void Test_port(int ruid, int euid, char
 				FPRINTF( STDERR, "Timeout opening line '%s'\n",
 					serial_line );
 			} else if( fd < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				FPRINTF( STDERR, "Error opening line '%s' - %s\n",
 				serial_line, Errormsg(err));
+#endif
 			} else if( i > 0 ){
 				FPRINTF( STDERR, "Lock '%s' succeeded! wrong result\n",
 					serial_line);
@@ -1151,8 +1201,10 @@ void Test_port(int ruid, int euid, char
 			while(1){
 				result = plp_waitpid( -1, &status, 0 );
 				err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 				FPRINTF( STDERR, "waitpid result %d, status %d, errno '%s'\n",
 					(int)result, status, Errormsg(err) );
+#endif
 				if( result == pid ){
 					FPRINTF( STDERR, "Daughter exit status %d\n", status );
 					if( status != 0 ){
@@ -1181,7 +1233,9 @@ void Test_port(int ruid, int euid, char
 		FPRINTF( STDERR, "\n\n" );
 		FPRINTF( STDERR, "Checking stty functions, fd %d\n\n", fd );
 		if( (pid = fork()) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			FPRINTF( STDERR, "fork failed - %s", Errormsg(errno) );
+#endif
 		} else if( pid == 0 ){
 			/* default for status */
 			SNPRINTF( t1, sizeof(t1)) "/tmp/t1XXX%d", getpid() );
@@ -1207,7 +1261,9 @@ void Test_port(int ruid, int euid, char
 			if( fd != ttyfd ){
 				i = dup2(fd, ttyfd );
 				if( i != ttyfd ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					FPRINTF( STDERR, "dup2() failed - %s\n", Errormsg(errno) );
+#endif
 					exit(-1);
 				}
 				close( fd );
@@ -1220,6 +1276,7 @@ void Test_port(int ruid, int euid, char
 				cmd, fd, ttyfd );
 			i = system( cmd );
 			FPRINTF( STDERR, "\n\n" );
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Stty_command_DYN = "9600 -even odd echo";
 			FPRINTF( STDERR, "Trying 'stty %s'\n", Stty_command_DYN );
 			Do_stty( ttyfd );
@@ -1239,6 +1296,7 @@ void Test_port(int ruid, int euid, char
 			FPRINTF( STDERR, "Trying 'stty %s'\n", Stty_command_DYN );
 			Do_stty( ttyfd );
 			SNPRINTF( stty, sizeof(stty)) sttycmd, serial_line, t2 );
+#endif
 			FPRINTF( STDERR, "Doing '%s'\n", cmd );
 			i = system( cmd );
 			FPRINTF( STDERR, "\n\n" );
@@ -1285,9 +1343,11 @@ void Test_port(int ruid, int euid, char
 	FPRINTF( STDERR, "Checking Lockf '%s'\n", line );
 	if( (fd = Checkwrite(line, &statb, O_RDWR, 1, 0 )) < 0) {
 		err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		FPRINTF( STDERR,
 			"open '%s' failed: wrong result - '%s'\n",
 			line, Errormsg(errno)  );
+#endif
 		exit(1);
 	}
 	if( Do_lock( fd, 0 ) < 0 ) {
@@ -1304,9 +1364,11 @@ void Test_port(int ruid, int euid, char
 		close( fd );
 		if( (fd = Checkwrite(line, &statb, O_RDWR, 1, 0 )) < 0) {
 			err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			FPRINTF( STDERR,
 				"Daughter re-open '%s' failed: wrong result - '%s'\n",
 				line, Errormsg(errno)  );
+#endif
 			exit(1);
 		}
 		if( Do_lock( fd, 0 ) < 0 ) {
@@ -1346,9 +1408,11 @@ void Test_port(int ruid, int euid, char
 		close( fd );
 		if( (fd = Checkwrite(line, &statb, O_RDWR, 1, 0 )) < 0) {
 			err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			FPRINTF( STDERR,
 				"Daughter re-open '%s' failed: wrong result - '%s'\n",
 				line, Errormsg(errno)  );
+#endif
 			exit(1);
 		}
 		FPRINTF( STDERR, "Daughter blocking for lock\n" );
diff -urNBp LPRng-3.8.22/src/common/child.c LPRng/src/common/child.c
--- LPRng-3.8.22/src/common/child.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/child.c	2011-06-09 00:24:39.000000000 +0400
@@ -58,6 +58,7 @@ pid_t plp_waitpid (pid_t pid, plp_status
 	return report;
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Commentary:
  * When we fork a child, then we need to clean it up.
@@ -83,12 +84,15 @@ void Dump_pinfo( char *title, struct lin
 	}
 	LOGDEBUG("*** done ***");
 }
+#endif
 
 int Countpid(void)
 {
 	int i, j, pid;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_pinfo("Countpid - before",&Process_list);
+#endif
 	for( i = j = 0; i < Process_list.count; ++i ){
 		pid = Cast_ptr_to_int(Process_list.list[i]);
 		if( kill(pid, 0) == 0 ){
@@ -97,7 +101,9 @@ int Countpid(void)
 		}
 	}
 	Process_list.count = j;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_pinfo("Countpid - after", &Process_list);
+#endif
 	return( Process_list.count );
 }
 
@@ -121,7 +127,9 @@ void Killchildren( int sig )
 		}
 	}
 	Process_list.count = j;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2)Dump_pinfo("Killchildren - after",&Process_list);
+#endif
 }
 
 /*
diff -urNBp LPRng-3.8.22/src/common/debug.c LPRng/src/common/debug.c
--- LPRng-3.8.22/src/common/debug.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/debug.c	2011-06-09 00:26:23.000000000 +0400
@@ -84,6 +84,9 @@
 */
 
 void Parse_debug (char *dbgstr, int interactive )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #if !defined(NODEBUG)
 	char *key, *convert, *end;
@@ -176,3 +179,4 @@ void Parse_debug (char *dbgstr, int inte
 #endif
 	/* LOGDEBUG("Parse_debug: Debug %d, DbgFlag 0x%x", Debug, DbgFlag ); */
 }
+#endif
\ No newline at end of file
diff -urNBp LPRng-3.8.22/src/common/errormsg.c LPRng/src/common/errormsg.c
--- LPRng-3.8.22/src/common/errormsg.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/errormsg.c	2011-06-09 00:28:25.000000000 +0400
@@ -56,6 +56,9 @@
 #endif
 
 const char * Errormsg ( int err )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return NULL; }
+#else
 {
     const char *cp;
 
@@ -79,6 +82,7 @@ const char * Errormsg ( int err )
 	}
     return (cp);
 }
+#endif
 
  struct msgkind {
     int var;
@@ -96,6 +100,9 @@ const char * Errormsg ( int err )
 };
 
  static char * putlogmsg(int kind)
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return NULL; }
+#else
 {
     int i;
     static char b[32];
@@ -111,9 +118,12 @@ const char * Errormsg ( int err )
     (void) SNPRINTF (b, sizeof(b)) "<BAD LOG FLAG %d>", kind);
     return (b);
 }
-
+#endif
 
  static void use_syslog(int kind, char *msg)
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
     /* testing mode indicates that this is not being used
      * in the "real world", so don't get noisy. */
@@ -156,9 +166,12 @@ const char * Errormsg ( int err )
 # endif							/* HAVE_OPENLOG */
 #endif                          /* HAVE_SYSLOG_H */
 }
-
+#endif
 
  static void log_backend (int kind, char *log_buf)
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
     char stamp_buf[2*SMALLBUFFER];
 	int n;
@@ -224,18 +237,23 @@ const char * Errormsg ( int err )
     /* plp_unblock_all_signals ( &omask ); / **/
 	errno = err;
 }
+#endif
 
 /*****************************************************
  * Put the printer name at the start of the log buffer
  *****************************************************/
  
  static void prefix_printer( char *log_buf, int len )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 	log_buf[0] = 0;
     if( Printer_DYN ){
 		SNPRINTF( log_buf, len-4) "%s: ", Printer_DYN );
 	}
 }
+#endif
 
 /* VARARGS2 */
 #ifdef HAVE_STDARGS
@@ -243,6 +261,9 @@ const char * Errormsg ( int err )
 #else
  void logmsg(va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     int kind;
@@ -269,6 +290,7 @@ const char * Errormsg ( int err )
     VA_END;
 	errno = err;
 }
+#endif
 
 /* VARARGS2 */
 #ifdef HAVE_STDARGS
@@ -276,6 +298,9 @@ const char * Errormsg ( int err )
 #else
  void fatal (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     int kind;
@@ -302,6 +327,7 @@ const char * Errormsg ( int err )
     VA_END;
     cleanup(0);
 }
+#endif
 
 /* VARARGS2 */
 #ifdef HAVE_STDARGS
@@ -309,6 +335,9 @@ const char * Errormsg ( int err )
 #else
  void logerr (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     int kind;
@@ -337,6 +366,7 @@ const char * Errormsg ( int err )
     VA_END;
     errno = err;
 }
+#endif
 
 /* VARARGS2 */
 #ifdef HAVE_STDARGS
@@ -344,6 +374,9 @@ const char * Errormsg ( int err )
 #else
  void logerr_die (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     int kind;
@@ -373,6 +406,7 @@ const char * Errormsg ( int err )
     cleanup(0);
     VA_END;
 }
+#endif
 
 /***************************************************************************
  * Diemsg( char *m1, *m2, ...)
@@ -385,6 +419,9 @@ const char * Errormsg ( int err )
 #else
  void Diemsg (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     char *msg;
@@ -416,6 +453,7 @@ const char * Errormsg ( int err )
     cleanup(0);
     VA_END;
 }
+#endif
 
 /***************************************************************************
  * Warnmsg( char *m1, *m2, ...)
@@ -428,6 +466,9 @@ const char * Errormsg ( int err )
 #else
  void Warnmsg (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     char *msg;
@@ -456,7 +497,7 @@ const char * Errormsg ( int err )
 	errno = err;
     VA_END;
 }
-
+#endif
 
 /***************************************************************************
  * Message( char *m1, *m2, ...)
@@ -469,6 +510,9 @@ const char * Errormsg ( int err )
 #else
  void Message (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     char *msg;
@@ -495,6 +539,7 @@ const char * Errormsg ( int err )
 	errno = err;
     VA_END;
 }
+#endif
 
 /* VARARGS1 */
 #ifdef HAVE_STDARGS
@@ -502,6 +547,9 @@ const char * Errormsg ( int err )
 #else
  void logDebug (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     char *msg;
@@ -527,6 +575,7 @@ const char * Errormsg ( int err )
 	errno = err;
     VA_END;
 }
+#endif
 
 /***************************************************************************
  * char *Sigstr(n)
@@ -546,7 +595,7 @@ const char * Errormsg ( int err )
 # define PAIR(X) { __string(X) , X }
 #endif
 
- struct signame signals[] = {
+static struct signame signals[] = {
 { "NO SIGNAL", 0 },
 #ifdef SIGHUP
  PAIR(SIGHUP),
@@ -660,6 +709,9 @@ const char * Errormsg ( int err )
 
 
 const char *Sigstr (int n)
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return NULL; }
+#else
 {
     static char buf[40];
 	const char *s = 0;
@@ -692,6 +744,7 @@ const char *Sigstr (int n)
 	}
     return(s);
 }
+#endif
 
 /***************************************************************************
  * Decode_status (plp_status_t *status)
@@ -699,6 +752,9 @@ const char *Sigstr (int n)
  ***************************************************************************/
 
 const char *Decode_status (plp_status_t *status)
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return NULL; }
+#else
 {
     static char msg[LINEBUFFER];
 
@@ -722,6 +778,7 @@ const char *Decode_status (plp_status_t
     }
     return (msg);
 }
+#endif
 
 /***************************************************************************
  * char *Server_status( int d )
@@ -748,6 +805,9 @@ const char *Decode_status (plp_status_t
 	};
 
 char *Server_status( int d )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return NULL; }
+#else
 {
 	char *s;
 	int i;
@@ -761,6 +821,7 @@ char *Server_status( int d )
 	}
 	return(s);
 }
+#endif
 
 /*
  * Error status on STDERR
@@ -771,6 +832,9 @@ char *Server_status( int d )
 #else
  void setstatus (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     struct job *job;
@@ -809,7 +873,7 @@ char *Server_status( int d )
 	insetstatus = 0;
 	VA_END;
 }
-
+#endif
 
 /***************************************************************************
  * void setmessage (struct job *job,char *header, char *fmt,...)
@@ -822,6 +886,9 @@ char *Server_status( int d )
 #else
  void setmessage (va_alist) va_dcl
 #endif
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 #ifndef HAVE_STDARGS
     struct job *job;
@@ -848,7 +915,7 @@ char *Server_status( int d )
 	}
 	VA_END;
 }
-
+#endif
 
 /***************************************************************************
  * send_to_logger( struct job *job, char *msg )
@@ -857,6 +924,9 @@ char *Server_status( int d )
 
  void send_to_logger( int send_to_status_fd, int send_to_mail_fd,
 	struct job *job, const char *header, char *msg_b )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{}
+#else
 {
 	char *s, *t;
 	char *id, *tstr;
@@ -912,4 +982,4 @@ char *Server_status( int d )
 	}
 	Free_line_list(&l);
 }
-
+#endif
\ No newline at end of file
diff -urNBp LPRng-3.8.22/src/common/fileopen.c LPRng/src/common/fileopen.c
--- LPRng-3.8.22/src/common/fileopen.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/fileopen.c	2011-06-09 00:24:10.000000000 +0400
@@ -46,7 +46,9 @@ int Checkread( const char *file, struct
 		Max_open(fd);
 		status = -1;
 		err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3( "Checkread: cannot open '%s', %s", file, Errormsg(err) );
+#endif
 		memset( statb, 0, sizeof(struct stat) );
 	}
 
@@ -119,7 +121,9 @@ int Checkwrite( const char *file, struct
 	umask( oldumask );
 	if( fd < 0 ){
 		status = -1;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3( "Checkwrite: cannot open '%s', %s", file, Errormsg(err) );
+#endif
 	} else if( nodelay ){
 		/* turn off nonblocking */
 		mask = fcntl( fd, F_GETFL, 0 );
diff -urNBp LPRng-3.8.22/src/common/gethostinfo.c LPRng/src/common/gethostinfo.c
--- LPRng-3.8.22/src/common/gethostinfo.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/gethostinfo.c	2011-06-09 00:24:14.000000000 +0400
@@ -36,6 +36,7 @@
 #define MAXHOSTNAMELEN 256
 #endif
 
+#undef HAVE_INNETGR
 
 void Clear_host_information( struct host_information *info )
 {
@@ -218,7 +219,9 @@ char *Fixup_fqdn( const char *shorthost,
 		info->h_addr_list.list[ info->h_addr_list.count++ ] = s;
 		info->h_addr_list.list[ info->h_addr_list.count ] = 0;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_host_information( "Fixup_fqdn", info );
+#endif
 
 	DEBUG2("Fixup_fqdn '%s': returning '%s'", shorthost, fqdn );
 	return(fqdn);
@@ -298,11 +301,39 @@ void Get_local_host( void )
 	  * get the Host computer Name
 	  */
 	host[0] = 0;
+#if 0
 	if( gethostname (host, sizeof(host)) < 0 
 		|| host[0] == 0 ) {
 		FATAL(LOG_ERR) "Get_local_fqdn: no host name" );
 	}
 	fqdn = Find_fqdn( &Host_IP, host );
+#else
+Check_max(&(Host_IP.host_names), 2);
+Check_max(&(Host_IP.h_addr_list), 2);
+{
+char q0[16], q1[16], q2[16], q3[16], hsh[32], hfq[32];
+strcpy(q0, "127");
+strcpy(q1, "0");
+strcpy(q2, "0");
+strcpy(q3, "1");
+strcpy(hsh, "localhost");
+strcpy(hfq, "localhost.localdomain");
+Host_IP.shorthost=&hsh[0];
+Host_IP.fqdn=&hfq[0];
+*(Host_IP.host_names.list)=Host_IP.fqdn;
+Host_IP.host_names.count=2;
+Host_IP.host_names.max=102;
+Host_IP.h_addrtype=2;
+Host_IP.h_length=4;
+*(Host_IP.h_addr_list.list+0)=&q0[0];
+*(Host_IP.h_addr_list.list+1)=&q1[0];
+*(Host_IP.h_addr_list.list+2)=&q2[0];
+*(Host_IP.h_addr_list.list+3)=&q3[0];
+Host_IP.h_addr_list.count=1;
+Host_IP.h_addr_list.max=102;
+}
+#endif
+#if 0
 	DEBUG3("Get_local_host: fqdn=%s", fqdn);
 	if( fqdn == 0 ){
 		FATAL(LOG_ERR) "Get_local_host: hostname '%s' bad", host );
@@ -314,6 +345,22 @@ void Get_local_host( void )
     if( Find_fqdn( &Localhost_IP, LOCALHOST) == 0 ){
         FATAL(LOG_ERR) "Get_local_host: 'localhost' IP address not available!");
     }
+#else
+Localhost_IP=Host_IP;
+printf("Localhost_IP.shorthost=%s\n", Localhost_IP.shorthost);
+printf("Localhost_IP.fqdn=%s\n", Localhost_IP.fqdn);
+printf("Localhost_IP.host_names.list=%s\n", *(Localhost_IP.host_names.list));
+printf("Localhost_IP.host_names.count=%d\n", Localhost_IP.host_names.count);
+printf("Localhost_IP.host_names.max=%d\n", Localhost_IP.host_names.max);
+printf("Localhost_IP.h_addrtype=%d\n", Localhost_IP.h_addrtype);
+printf("Localhost_IP.h_length=%d\n", Localhost_IP.h_length);
+printf("Localhost_IP.h_addr_list.list1=%s\n", *(Localhost_IP.h_addr_list.list+0));
+printf("Localhost_IP.h_addr_list.list2=%s\n", *(Localhost_IP.h_addr_list.list+1));
+printf("Localhost_IP.h_addr_list.list3=%s\n", *(Localhost_IP.h_addr_list.list+2));
+printf("Localhost_IP.h_addr_list.list4=%s\n", *(Localhost_IP.h_addr_list.list+3));
+printf("Localhost_IP.h_addr_list.count=%d\n", Localhost_IP.h_addr_list.count);
+printf("Localhost_IP.h_addr_list.max=%d\n", Localhost_IP.h_addr_list.max);
+#endif
 }
 
 /***************************************************************************
@@ -379,7 +426,9 @@ char *Get_remote_hostbyaddr( struct host
 	DEBUG3("Get_remote_hostbyaddr: %s", fqdn );
 	Set_DYN( &FQDNRemote_FQDN, info->fqdn );
 	Set_DYN( &ShortRemote_FQDN, info->shorthost );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4) Dump_host_information( "Get_remote_hostbyaddr", info );
+#endif
 	return( fqdn );
 }
 
@@ -430,6 +479,7 @@ int Same_host( struct host_information *
 	return( result != 0 );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Dump_host_information( char *title, struct host_information *info )
  * Dump file information
@@ -463,7 +513,7 @@ void Dump_host_information( char *title,
 		}
 	}
 }
-
+#endif
 
 /***************************************************************************
  * void form_addr_and_mask( char *v, *addr, *mask, int addrlen, int family)
@@ -573,8 +623,10 @@ int Match_ipaddr_value( struct line_list
 	int result = 1, i, j, invert = 0;
 	char *str, *addr, *mask;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DDB1)("Match_ipaddr_value: host %s", host?host->fqdn:0 );
 	DEBUGFC(DDB1)Dump_host_information("Match_ipaddr_value - host ", host );
+#endif
 	if( host == 0 || host->fqdn == 0 ) return(result);
 	addr = malloc_or_die(host->h_length,__FILE__,__LINE__);
 	mask = malloc_or_die(host->h_length,__FILE__,__LINE__);
@@ -596,7 +648,9 @@ int Match_ipaddr_value( struct line_list
 			Init_line_list(&users);
 			Get_file_image_and_split(str+1,0,0,&users,Whitespace,
 				0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGFC(DDB3)Dump_line_list("Match_ipaddr_value- file contents'", &users );
+#endif
 			result = Match_ipaddr_value( &users,host);
 			Free_line_list(&users);
 		} else {
diff -urNBp LPRng-3.8.22/src/common/getprinter.c LPRng/src/common/getprinter.c
--- LPRng-3.8.22/src/common/getprinter.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/getprinter.c	2011-06-09 00:23:45.000000000 +0400
@@ -17,7 +17,7 @@
 #include "getqueue.h"
 #include "child.h"
 /**** ENDINCLUDE ****/
-
+#ifdef REMOVE
 /***************************************************************************
  Get_printer()
     determine the name of the printer - Printer_DYN variable
@@ -135,14 +135,18 @@ void Fix_Rm_Rp_info(char *report_conflic
 			}
 			Set_DYN(&Printer_DYN,s);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG2("Fix_Rm_Rp_info: from printcap found '%s'", Printer_DYN );
 			if(DEBUGL2)Dump_line_list("Fix_Rm_Rp_info - PC_alias_line_list",
 				&PC_alias_line_list );
 			if(DEBUGL2)Dump_line_list("Fix_Rm_Rp_info - PC_entry_line_list",
 				&PC_entry_line_list );
+#endif
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL2)Dump_line_list("Fix_Rm_Rp_info - final PC_entry_line_list",
 			&PC_entry_line_list );
+#endif
 		Find_default_tags( &PC_entry_line_list, Pc_var_list, "client." );
 		Find_tags( &PC_entry_line_list, &Config_line_list, "client." );
 		Find_tags( &PC_entry_line_list, &PC_entry_line_list, "client." );
@@ -228,10 +232,12 @@ void Fix_Rm_Rp_info(char *report_conflic
 		Set_DYN(&Printer_DYN,s);
 		DEBUG2("Fix_Rm_Rp_info: found '%s'", Printer_DYN );
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2)Dump_line_list("Fix_Rm_Rp_info - PC_alias_line_list",
 		&PC_alias_line_list );
 	if(DEBUGL2)Dump_line_list("Fix_Rm_Rp_info - PC_entry_line_list",
 		&PC_entry_line_list );
+#endif
 	/* now get the Server_xxx variables */
 	Find_default_tags( &PC_entry_line_list, Pc_var_list, "server." );
 	Find_tags( &PC_entry_line_list, &Config_line_list, "server." );
@@ -280,7 +286,9 @@ void Fix_Rm_Rp_info(char *report_conflic
 	DEBUG1("Fix_Rm_Rp_info: Printer '%s', Queue '%s', Lp '%s', Rp '%s', Rh '%s'",
 		Printer_DYN, Queue_name_DYN, Lp_device_DYN,
 		RemotePrinter_DYN, RemoteHost_DYN );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2)Dump_parms("Fix_Rm_Rp_info", Pc_var_list);
+#endif
 }
 
 /***************************************************************************
@@ -322,7 +330,9 @@ void Get_all_printcap_entries(void)
 			}
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("Get_all_printcap_entries- All_line_list", &All_line_list );
+#endif
 }
 
 void Show_formatted_info( void )
@@ -338,7 +348,9 @@ void Show_formatted_info( void )
 			"%s: '%s'",
 			Printer_DYN, error );
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("Aliases",&PC_alias_line_list);
+#endif
 	s = Join_line_list_with_sep(&PC_alias_line_list,"|");
 	if( Write_fd_str( 1, s ) < 0 ) cleanup(0);
 	if(s) free(s); s = 0;
@@ -384,3 +396,4 @@ void Show_all_printcap_entries( void )
 		Show_formatted_info();
 	}
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/getqueue.c LPRng/src/common/getqueue.c
--- LPRng-3.8.22/src/common/getqueue.c	2003-09-06 00:07:18.000000000 +0400
+++ LPRng/src/common/getqueue.c	2011-06-09 00:23:22.000000000 +0400
@@ -56,6 +56,7 @@
  *   and leave it to the checkpc code to clean them up.
  */
 
+#if defined(JY20031104Scan_queue)
 int Scan_queue( struct line_list *spool_control,
 	struct line_list *sort_order, int *pprintable, int *pheld, int *pmove,
 		int only_queue_process, int *perr, int *pdone,
@@ -118,7 +119,9 @@ int Scan_queue( struct line_list *spool_
 		/* read the hf file and get the information */
 		Get_file_image_and_split( hf_name, 0, 0,
 			&job.info, Line_ends, 1, Value_sep,1,1,1,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL5)Dump_line_list("Scan_queue: hf", &job.info );
+#endif
 		if( job.info.count == 0 ){
 			continue;
 		}
@@ -137,7 +140,9 @@ int Scan_queue( struct line_list *spool_
 			p, m, e, dn, only_queue_process );
 		if( sort_order ){
 			if( !only_queue_process || (p || m || e || dn) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if(DEBUGL4)Dump_job("Scan_queue - before Make_sort_key",&job);
+#endif
 				Make_sort_key( &job );
 				DEBUG5("Scan_queue: sort key '%s'",job.sort_key);
 				Set_str_value(sort_order,job.sort_key,hf_name);
@@ -149,10 +154,12 @@ int Scan_queue( struct line_list *spool_
 	Free_job(&job);
 	Free_line_list(&directory_files);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL5){
 		LOGDEBUG("Scan_queue: final values" );
 		Dump_line_list_sub(SORT_KEY,sort_order);
 	}
+#endif
 	if( pprintable ) *pprintable = printable;
 	if( pheld ) *pheld = held;
 	if( pmove ) *pmove = move;
@@ -162,6 +169,7 @@ int Scan_queue( struct line_list *spool_
 		printable, held, move, error, done );
 	return(0);
 }
+#endif
 
 /*
  * char *Get_fd_image( int fd, char *file )
@@ -194,10 +202,12 @@ char *Get_fd_image( int fd, off_t maxsiz
 		len += n;
 		s[len] = 0;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3){
 		SNPRINTF(buffer,32)"%s",s);
 		logDebug("Get_fd_image: len %d '%s'", s?safestrlen(s):0, buffer );
 	}
+#endif
 	return(s);
 }
 
@@ -308,6 +318,7 @@ void Check_for_hold( struct job *job, st
  *  read the control file and hold file.
  */
 
+#if defined(JY20031104Setup_job)
 void Setup_job( struct job *job, struct line_list *spool_control,
 	const char *cf_name, const char *hf_name, int check_for_existence )
 {
@@ -371,8 +382,11 @@ void Setup_job( struct job *job, struct
 	Make_identifier( job );
 	Check_for_hold( job, spool_control );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_job("Setup_job",job);
+#endif
 }
+#endif
 
 /* Get_hold_class( spool_control, job )
  *  check to see if the spool class and the job class are compatible
@@ -469,6 +483,7 @@ int Get_hold_class( struct line_list *in
  *
  */
 
+#if defined(JY20031104Append_Z_value)
 void Append_Z_value( struct job *job, char *s )
 {
 	char *t;
@@ -484,7 +499,9 @@ void Append_Z_value( struct job *job, ch
 		Set_str_value(&job->info,"Z",s);
 	}
 }
+#endif
 
+#if defined(JY20031104Setup_cf_info)
 int Setup_cf_info( struct job *job, int check_for_existence )
 {
 	char *s;
@@ -510,9 +527,11 @@ int Setup_cf_info( struct job *job, int
 		DEBUG3("Setup_cf_info: control file '%s', hpformat '%d'", s, hpformat );
 		if( Get_file_image_and_split(s,0,0, &cf_line_list, Line_ends,0,0,0,0,0,0)
 			 && check_for_existence ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG3("Setup_cf_info: missing or empty control file '%s'", s );
 			SNPRINTF(buffer,sizeof(buffer))
 				"no control file %s - %s", s, Errormsg(errno) );
+#endif
 			Set_str_value(&job->info,ERROR,buffer);
 			Set_nz_flag_value(&job->info,ERROR_TIME,time(0));
 			returnstatus = 1;
@@ -564,8 +583,10 @@ int Setup_cf_info( struct job *job, int
 					DEBUG4("Setup_cf_info: '%s' - size %0.0f", file_found, size );
 					Set_double_value(datafile,SIZE,size );
 				} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 					SNPRINTF(buffer,sizeof(buffer))
 						"missing data file %s - %s", file_found, Errormsg(errno) );
+#endif
 					Set_str_value(&job->info,ERROR,buffer);
 					Set_nz_flag_value(&job->info,ERROR_TIME,time(0));
 					returnstatus = 1;
@@ -644,9 +665,12 @@ int Setup_cf_info( struct job *job, int
 	if( datafile )	free(datafile); datafile=0;
 	if( names )	free(names); names=0;
 	Free_line_list( &cf_line_list );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Setup_cf_info - final",job);
+#endif
 	return(returnstatus);
 }
+#endif
 
 char *Make_hf_image( struct job *job )
 {
@@ -677,7 +701,9 @@ int Set_hold_file( struct job *job, stru
 	status = 0;
 	outstr = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Set_hold_file",job);
+#endif
 	Set_str_value(&job->info,UPDATE_TIME,Time_str(0,0));
 	if( !(hf_name = Find_str_value(&job->info,HF_NAME,Value_sep)) ){
 		Errorcode = JABORT;
@@ -724,7 +750,9 @@ int Set_hold_file( struct job *job, stru
 			if(u) free(u); u = 0;
 			if(t) free(t); t = 0;
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		send_to_logger(-1, -1, job,UPDATE,outstr);
+#endif
 	}
 	if( outstr ) free( outstr ); outstr = 0;
 	return( status );
@@ -762,7 +790,9 @@ void Get_spool_control( const char *file
 	DEBUG2("Get_spool_control:  file '%s'", file );
 	Get_file_image_and_split( file, 0, 0,
 			info,Line_ends,1,Value_sep,1,1,1,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Get_spool_control- info", info );
+#endif
 }
 
 /*
@@ -782,7 +812,9 @@ void Set_spool_control( struct line_list
 	fd = Make_temp_fd( &tempfile );
 	DEBUG2("Set_spool_control: file '%s', tempfile '%s'",
 		file, tempfile );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Set_spool_control- info", info );
+#endif
 	s = Join_line_list(info,"\n");
 	if( Write_fd_str(fd, s) < 0 ){
 		Errorcode = JFAIL;
@@ -818,7 +850,9 @@ void Set_spool_control( struct line_list
 		}
 		t = Join_line_list( &l, "\n");
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		send_to_logger(-1,-1,0,QUEUE,t);
+#endif
 	}
 
 	Free_line_list(&l);
@@ -921,6 +955,7 @@ void Make_sort_key( struct job *job )
 		intval(NUMBER,&job->info,job);
 	}
 }
+#ifdef REMOVE
 
 /*
  * Set up printer
@@ -933,6 +968,7 @@ void Make_sort_key( struct job *job )
  *     and RemoteHost_DYN.
  */
 
+#if defined(JY20031104Setup_printer)
 int Setup_printer( char *prname, char *error, int errlen, int subserver )
 {
 	char *s;
@@ -969,9 +1005,11 @@ int Setup_printer( char *prname, char *e
 	}
 
 	if( chdir( Spool_dir_DYN ) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error, errlen)
 			"printer '%s', chdir to '%s' failed '%s'",
 				name, Spool_dir_DYN, Errormsg( errno ) );
+#endif
 		status = 2;
 		goto error;
 	}
@@ -990,17 +1028,20 @@ int Setup_printer( char *prname, char *e
 			Printer_DYN );
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG1("Setup_printer: printer now '%s', spool dir '%s'",
 		Printer_DYN, Spool_dir_DYN );
 	if(DEBUGL3){
 		Dump_parms("Setup_printer - vars",Pc_var_list);
 		Dump_line_list("Setup_printer - spool control", &Spool_control );
 	}
+#endif
 
  error:
 	DEBUG3("Setup_printer: status '%d', error '%s'", status, error );
 	return( status );
 }
+#endif
 
 /**************************************************************************
  * Read_pid( int fd, char *str, int len )
@@ -1058,7 +1099,7 @@ int Write_pid( int fd, int pid, char *st
 	}
 	return 0;
 }
-
+#endif
 /***************************************************************************
  * int Patselect( struct line_list *tokens, struct line_list *cf );
  *    check to see that the token value matches one of the following
@@ -1077,8 +1118,10 @@ int Patselect( struct line_list *token,
 	int i, n, val;
 	char *key, *s, *end;
 	
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_line_list("Patselect- tokens", token );
 	if(DEBUGL3)Dump_line_list("Patselect- info", cf );
+#endif
 	for( i = starting; match && i < token->count; ++i ){
 		key = token->list[i];
 		DEBUG3("Patselect: key '%s'", key );
@@ -1140,6 +1183,7 @@ int Patselect( struct line_list *token,
  *  "dB", the 27th with "da", the 28th with "db", and so forth.
 
  ***************************************************************************/
+#if defined(JY20031104Check_format)
 int Check_format( int type, const char *name, struct job *job )
 {
 	int n, c, hpformat;
@@ -1271,6 +1315,7 @@ int Check_format( int type, const char *
 	}
 	return( msg[0] != 0 );
 }
+#endif
 
 char *Find_start(char *str, const char *key )
 {
@@ -1365,6 +1410,7 @@ char *Fix_job_number( struct job *job, i
  * 
  ************************************************************************/
 
+#if defined(JY20031104Make_identifier)
 char *Make_identifier( struct job *job )
 {
 	char *user, *host, *s, *id;
@@ -1389,25 +1435,34 @@ char *Make_identifier( struct job *job )
 	}
 	return(s);
 }
+#endif
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 void Dump_job( char *title, struct job *job )
 {
 	int i;
 	struct line_list *lp;
 	if( title ) LOGDEBUG( "*** Job %s *** - 0x%lx", title, Cast_ptr_to_long(job));
+#ifdef ORIGINAL_DEBUG //JY@1020
 	Dump_line_list_sub( "info",&job->info);
 	LOGDEBUG("  datafiles - count %d", job->datafiles.count );
+#endif
 	for( i = 0; i < job->datafiles.count; ++i ){
 		char buffer[SMALLBUFFER];
 		SNPRINTF(buffer,sizeof(buffer))"  datafile[%d]", i );
 		lp = (void *)job->datafiles.list[i];
+#ifdef ORIGINAL_DEBUG //JY@1020
 		Dump_line_list_sub(buffer,lp);
+#endif
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	Dump_line_list_sub( "destination",&job->destination);
+#endif
 	if( title ) LOGDEBUG( "*** end ***" );
 }
+#endif
 
-
+#if defined(JY20031104Job_printable)
 void Job_printable( struct job *job, struct line_list *spool_control,
 	int *pprintable, int *pheld, int *pmove, int *perr, int *pdone )
 {
@@ -1417,8 +1472,10 @@ void Job_printable( struct job *job, str
 	struct stat statb; 
 	int n, printable = 0, held = 0, move = 0, error = 0, done = 0,destination, destinations;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Job_printable - job info",job);
 	if(DEBUGL4)Dump_line_list("Job_printable - spool control",spool_control);
+#endif
 
 	buffer[0] = 0;
 	if( job->info.count == 0 ){
@@ -1471,7 +1528,9 @@ void Job_printable( struct job *job, str
 		printable = 0;
 		for( destination = 0; destination < destinations; ++destination ){
 			Get_destination(job,destination);
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL4)Dump_job("Job_destination_printable - job",job);
+#endif
 			destbuffer[0] = 0;
 			if( Find_flag_value(&job->destination,ERROR_TIME,Value_sep) ){
 				SNPRINTF(destbuffer,sizeof(destbuffer)) "error" );
@@ -1524,7 +1583,9 @@ void Job_printable( struct job *job, str
 	DEBUG3("Job_printable: printable %d, held %d, move '%d', error '%d', done '%d', status '%s'",
 		printable, held, move, error, done, buffer );
 }
+#endif
 
+#ifdef REMOVE
 int Server_active( char *file )
 {
 	struct stat statb;
@@ -1541,6 +1602,7 @@ int Server_active( char *file )
 	DEBUG3("Server_active: file %s, serverpid %d", file, serverpid );
 	return( serverpid );
 }
+#endif
 
 /*
  * Destination Information
@@ -1567,7 +1629,9 @@ void Update_destination( struct job *job
 	Set_str_value(&job->info,buffer,t);
 	free(s);
 	free(t);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Update_destination",job);
+#endif
 }
 
 /*
@@ -1712,6 +1776,7 @@ int Trim_status_file( int status_fd, cha
  static char BSD_order[] = "HPJCLIMWT1234" ;
  static char LPRng_order[] = "HPJCLIMWT1234*" ;
 
+#if defined(JY20031104Fix_datafile_info)
 char *Fix_datafile_info( struct job *job, char *number, char *suffix,
 	char *xlate_format )
 {
@@ -1723,7 +1788,9 @@ char *Fix_datafile_info( struct job *job
 	
 	Init_line_list(&outfiles);
 	transfername = dataline = Nline = jobline = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Fix_datafile_info - starting", job );
+#endif
 
 	/* now we find the number of different data files */
 
@@ -1758,7 +1825,9 @@ char *Fix_datafile_info( struct job *job
 	Free_line_list(&outfiles);
 	Set_decimal_value(&job->info,DATAFILE_COUNT,count);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_job("Fix_datafile_info - after finding duplicates", job );
+#endif
 
 	jobcopies = Find_flag_value(&job->info,COPIES,Value_sep);
 	if( !jobcopies ) jobcopies = 1;
@@ -1768,7 +1837,9 @@ char *Fix_datafile_info( struct job *job
 		for( linecount = 0; linecount < job->datafiles.count; ++linecount ){
 			jobline = 0;
 			lp = (void *)job->datafiles.list[linecount];
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL5)Dump_line_list("Fix_datafile_info - info", lp  );
+#endif
 			transfername = Find_str_value(lp,TRANSFERNAME,Value_sep);
 			Nline = Find_str_value(lp,"N",Value_sep);
 			fmt[0] = 'f';
@@ -1806,7 +1877,9 @@ char *Fix_datafile_info( struct job *job
 	for( linecount = 0; linecount < job->datafiles.count; ++linecount ){
 		jobline = 0;
 		lp = (void *)job->datafiles.list[linecount];
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Fix_datafile_info - info", lp );
+#endif
 		transfername = Find_str_value(lp,TRANSFERNAME,Value_sep);
 		if( !Find_casekey_str_value(&outfiles,transfername,Value_sep) ){
 			jobline = safeextend4(jobline,"U",transfername,"\n",__FILE__,__LINE__);
@@ -1823,6 +1896,7 @@ char *Fix_datafile_info( struct job *job
 	while( (s = safestrchr(s,'\n')) ) *s++ = '\001';
 	return(dataline);
 }
+#endif
 
 int ordercomp(  const void *left, const void *right, const void *orderp)
 {
@@ -1873,6 +1947,7 @@ int ordercomp(  const void *left, const
 	{0,0}
 	};
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 void Fix_control( struct job *job, char *filter, char *xlate_format )
 {
 	char *s, *file_hostname, *number, *priority,
@@ -1884,7 +1959,9 @@ void Fix_control( struct job *job, char
 
 	Init_line_list(&controlfile);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_job( "Fix_control: starting", job );
+#endif
 
 	/* we set the control file with the single letter values in the
 	   hold job file
@@ -1903,7 +1980,9 @@ void Fix_control( struct job *job, char
 		}
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_line_list( "Fix_control: control file", &controlfile );
+#endif
 
 	n = j = 0;
 	n = Find_decimal_value( &job->info,NUMBER,Value_sep);
@@ -1935,7 +2014,9 @@ void Fix_control( struct job *job, char
 		*s = 0;
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_job( "Fix_control: before fixing", job );
+#endif
 
 	/* fix control file name */
 
@@ -2021,7 +2102,9 @@ void Fix_control( struct job *job, char
 	 * see if allowed options in file first.
 	 */
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_line_list( "Fix_control: before sorting", &controlfile );
+#endif
 	n = Mergesort( controlfile.list,
 		controlfile.count, sizeof( char *), ordercomp, order );
 	if( n ){
@@ -2029,7 +2112,9 @@ void Fix_control( struct job *job, char
 		LOGERR_DIE(LOG_ERR) "Fix_control: Mergesort failed" );
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_job( "Fix_control: after sorting", job );
+#endif
 	for( i = 0; i < controlfile.count; ++i ){
 		s = controlfile.list[i];
 		memmove(s+1,s+2,safestrlen(s+2)+1);
@@ -2086,6 +2171,7 @@ void Fix_control( struct job *job, char
 		close( tempfd ); tempfd = -1;
 	}
 }
+#endif
 
 /************************************************************************
  * Create_control:
@@ -2094,6 +2180,7 @@ void Fix_control( struct job *job, char
  *
  ************************************************************************/
 
+#if defined(JY20031104Create_control)
 int Create_control( struct job *job, char *error, int errlen,
 	char *xlate_format )
 {
@@ -2101,7 +2188,9 @@ int Create_control( struct job *job, cha
 	int status = 0, fd, i;
 	struct stat statb;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3) Dump_job( "Create_control: before fixing", job );
+#endif
 
 	/* deal with authentication */
 
@@ -2144,9 +2233,13 @@ int Create_control( struct job *job, cha
 				Free_line_list(&l);
 				DEBUG1("Create_control: match, using users '%s'", t );
 				Split(&l,t,",",0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if(DEBUGL1)Dump_line_list("Create_control: before Fix_dollars", &l );
+#endif
 				Fix_dollars(&l,job,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if(DEBUGL1)Dump_line_list("Create_control: after Fix_dollars", &l );
+#endif
 				for( j = 0; j < l.count; ++j ){
 					if( !ISNULL(l.list[j]) ){
 						accounting_name = l.list[j];
@@ -2268,8 +2361,10 @@ int Create_control( struct job *job, cha
 		DEBUG4("Create_control: writing to '%s'", openname );
 		if( (fd = Checkwrite(openname,&statb,0,1,0)) < 0
 			|| ftruncate(fd,0) || Write_fd_str(fd,cf) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SNPRINTF(error,errlen)"Write_control: cannot write '%s' - '%s'",
 				openname, Errormsg(errno) );
+#endif
 			status = 1;
 		}
 		Max_open(fd);
@@ -2280,6 +2375,7 @@ int Create_control( struct job *job, cha
 
 	return( status );
 }
+#endif
 
 /*
  * Buffer management
diff -urNBp LPRng-3.8.22/src/common/initialize.c LPRng/src/common/initialize.c
--- LPRng-3.8.22/src/common/initialize.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/initialize.c	2011-06-09 00:22:52.000000000 +0400
@@ -224,7 +224,9 @@ void Setup_configuration()
 	DEBUG1("Setup_configuration: Host '%s', ShortHost '%s', user '%s'",
 		FQDNHost_FQDN, ShortHost_FQDN, Logname_DYN );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2) Dump_parms( "Setup_configuration - final values", Pc_var_list );
+#endif
 
 	if( Is_server ){
 		DEBUG2("Setup_configuration: Printcap_path '%s'", Printcap_path_DYN );
@@ -282,6 +284,7 @@ void Setup_configuration()
 		}
 		Free_line_list( &order );
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3){
 		Dump_line_list("Setup_configuration: PC names", &PC_names_line_list );
 		Dump_line_list("Setup_configuration: PC order", &PC_order_line_list );
@@ -294,6 +297,7 @@ void Setup_configuration()
 		Dump_line_list("Setup_configuration: Raw Perms", &RawPerm_line_list );
 		Dump_line_list("Setup_configuration: Perms", &Perm_line_list );
 	}
+#endif
 }
 
 /*
diff -urNBp LPRng-3.8.22/src/common/linelist.c LPRng/src/common/linelist.c
--- LPRng-3.8.22/src/common/linelist.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/linelist.c	2011-06-09 00:30:45.000000000 +0400
@@ -410,7 +410,9 @@ char *Add_line_list( struct line_list *l
 			l->list[mid] = str;
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL5)Dump_line_list("Add_line_list: result", l);
+#endif
 	return( str );
 }
 
@@ -668,6 +670,7 @@ char *Join_line_list_with_quotes( struct
 	return( str );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 void Dump_line_list( const char *title, struct line_list *l )
 {
 	int i;
@@ -677,7 +680,9 @@ void Dump_line_list( const char *title,
 		LOGDEBUG( "  [%2d] 0x%lx ='%s'", i, Cast_ptr_to_long(l->list[i]), l->list[i] );
 	}
 }
+#endif
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 void Dump_line_list_sub( const char *title, struct line_list *l )
 {
 	int i;
@@ -687,7 +692,7 @@ void Dump_line_list_sub( const char *tit
 		LOGDEBUG( "  [%2d] 0x%lx ='%s'", i, Cast_ptr_to_long(l->list[i]), l->list[i] );
 	}
 }
-
+#endif
 
 /*
  * Find_str_in_flat
@@ -1455,14 +1460,18 @@ void Read_file_list( int required, struc
 					n = end - start;
 					Check_max( model, n );
 					/* copy to end */
+#ifdef ORIGINAL_DEBUG //JY@1020
 					if(DEBUGL5)Dump_line_list("Read_file_list: include before",
 						model );
+#endif
 					memmove( &model->list[model->count], 
 						&model->list[start], n*sizeof(char *) );
 					memmove( &model->list[start], 
 						&model->list[end],(model->count-start)*sizeof(char *));
+#ifdef ORIGINAL_DEBUG //JY@1020
 					if(DEBUGL4)Dump_line_list("Read_file_list: include after",
 						model );
+#endif
 					end = model->count;
 					start = end - n;
 					DEBUG4("Read_file_list: start now '%s'",model->list[start]);
@@ -1486,7 +1495,9 @@ void Read_file_list( int required, struc
 		}
 	}
 	Free_line_list(&l);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL5)Dump_line_list("Read_file_list: result", model);
+#endif
 }
 
 void Read_fd_and_split( struct line_list *list, int fd,
@@ -1525,15 +1536,17 @@ void Read_file_and_split( struct line_li
 	DEBUG3("Read_file_and_split: '%s', trim %d, nocomment %d",
 		file, trim, nocomment );
 	if( (fd = Checkread( file, &statb )) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		LOGERR_DIE(LOG_INFO)
 		"Read_file_and_split: cannot open '%s' - '%s'",
 			file, Errormsg(errno) );
+#endif
 	}
 	Read_fd_and_split( list, fd, linesep, sort, keysep, uniq,
 		trim, nocomment );
 }
 
-
+#ifdef REMOVE
 /*
  * Printcap information
  */
@@ -1575,8 +1588,10 @@ int  Build_pc_names( struct line_list *n
 	}
 	Split(&l,str,"|",0,0,0,1,0,0);
 	if( s ) *s = c;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Build_pc_names- names", &l);
 	if(DEBUGL4)Dump_line_list("Build_pc_names- options", &opts);
+#endif
 	if( l.count == 0 ){
 		if(Warnings){
 			WARNMSG(
@@ -1622,9 +1637,11 @@ int  Build_pc_names( struct line_list *n
 				l.list[0], *s );
 			}
 		} else if( ok ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL4)Dump_line_list("Build_pc_names: adding ", &l);
 			if(DEBUGL4)Dump_line_list("Build_pc_names- before names", names );
 			if(DEBUGL4)Dump_line_list("Build_pc_names- before order", order );
+#endif
 			if( !Find_exists_value( names, l.list[0], Value_sep ) ){
 				Add_line_list(order,l.list[0],0,0,0);
 			}
@@ -1722,7 +1739,9 @@ void Build_printcap_info(
 		}
 		free(keyid); keyid = 0;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4) Dump_line_list( "Build_printcap_info- end", list );
+#endif
 	return;
 }
 
@@ -1757,19 +1776,23 @@ char *Select_pc_info( const char *id,
 		Errorcode = JABORT;
 		FATAL(LOG_ERR)"Select_pc_info: printcap tc recursion depth %d", depth );
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Select_pc_info- names", names );
 	if(DEBUGL4)Dump_line_list("Select_pc_info- order", order );
 	if(DEBUGL4)Dump_line_list("Select_pc_info- input", input );
+#endif
 	start = 0; end = 0;
 	found = Find_str_value( names, id, Value_sep );
 	if( !found && PC_filters_line_list.count ){
 		Filterprintcap( &l, &PC_filters_line_list, id);
 		Build_printcap_info( names, order, input, &l, &Host_IP );
 		Free_line_list( &l );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Select_pc_info- after filter aliases", aliases );
 		if(DEBUGL4)Dump_line_list("Select_pc_info- after filter info", info );
 		if(DEBUGL4)Dump_line_list("Select_pc_info- after filter names", names );
 		if(DEBUGL4)Dump_line_list("Select_pc_info- after filter input", input );
+#endif
 		found = Find_str_value( names, id, Value_sep );
 	}
 	/* do partial glob match  */
@@ -1810,8 +1833,10 @@ char *Select_pc_info( const char *id,
 		Find_pc_info( found, info, aliases, names, order, input, depth, 0 );
 	}
 	DEBUG1("Select_pc_info: returning '%s'", found );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Select_pc_info- returning aliases", aliases );
 	if(DEBUGL4)Dump_line_list("Select_pc_info- returning info", info );
+#endif
 	return( found );
 }
 
@@ -1846,7 +1871,9 @@ void Find_pc_info( char *name,
 			Add_line_list( &pc, u, 0, 0, 0 );
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Find_pc_info- entry lines", &l );
+#endif
 	for( start = 0; start < pc.count; ++ start ){
 		u = pc.list[start];
 		c = 0;
@@ -1865,7 +1892,9 @@ void Find_pc_info( char *name,
 			}
 		}
 		/* get the tc entries */
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Find_pc_info- pc entry", &l );
+#endif
 		if( !Find_first_key(&l,"tc",Value_sep,&start_tc)
 			&& !Find_last_key(&l,"tc",Value_sep,&end_tc) ){
 			for( ; start_tc <= end_tc; ++start_tc ){
@@ -1880,7 +1909,9 @@ void Find_pc_info( char *name,
 				}
 			}
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Find_pc_info- tc", &tc );
+#endif
 		for( j = 0; j < tc.count; ++j ){
 			s = tc.list[j];
 			DEBUG4("Find_pc_info: tc entry '%s'", s );
@@ -1890,7 +1921,9 @@ void Find_pc_info( char *name,
 			}
 		}
 		Free_line_list(&tc);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Find_pc_info - adding", &l );
+#endif
 		for( i = 0; i < l.count; ++i ){
 			if( (t = l.list[i]) ){
 				Add_line_list( info, t, Value_sep, 1, 1 );
@@ -1900,6 +1933,7 @@ void Find_pc_info( char *name,
 	}
 	Free_line_list(&pc);
 }
+#endif
 
 /*
  * variable lists and initialization
@@ -1930,7 +1964,9 @@ void Clear_var_list( struct keywords *v,
 			Config_value_conversion( vars, vars->default_value );
 		}
     }
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL5)Dump_parms("Clear_var_list: after",v );
+#endif
 }
 
 /***************************************************************************
@@ -1981,6 +2017,7 @@ int Check_str_keyword( const char *name,
  * void Config_value_conversion( struct keyword *key, char *value )
  *  set the value of the variable as required
  ***************************************************************************/
+#if defined(JYWENG20031104Config_value_conversion)
 void Config_value_conversion( struct keywords *key, const char *s )
 {
 	int i = 0, c = 0, value = 0;
@@ -2041,7 +2078,7 @@ void Config_value_conversion( struct key
 		break;
 	}
 }
-
+#endif
 
  static struct keywords Keyletter[] = {
 	{ "P", 0, STRING_K, &Printer_DYN, 0,0,0 },
@@ -2108,15 +2145,18 @@ void Expand_vars( void )
 	void *p;
 	struct keywords *var;
 
+#ifdef REMOVE
 	/* check to see if you need to expand */
 	for( var = Pc_var_list; var->keyword; ++var ){
 		if( var->type == STRING_K && (p = var->variable) ){
 			Expand_percent(p);
 		}
 	}
+#endif
 }
 
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Expand_hash_values:
  *  expand the values of a hash
@@ -2137,6 +2177,7 @@ void Expand_hash_values( struct line_lis
 		}
 	}
 }
+#endif
 
 /*
  * Set a _DYN variable
@@ -2159,16 +2200,19 @@ void Clear_config( void )
 {
 	struct line_list **l;
 
+#ifdef REMOVE
 	DEBUGF(DDB1)("Clear_config: freeing everything");
 	Remove_tempfiles();
 	Clear_tempfile_list();
     Clear_var_list( Pc_var_list, 1 );
     Clear_var_list( DYN_var_list, 1 );
 	for( l = Allocs; *l; ++l ) Free_line_list(*l);
+#endif
 }
 
 char *Find_default_var_value( void *v )
 {
+#ifdef REMOVE
 	struct keywords *k;
 	char *s;
 	for( k = Pc_var_list; (s = k->keyword); ++k ){
@@ -2180,6 +2224,7 @@ char *Find_default_var_value( void *v )
 			return( s );
 		}
 	}
+#endif
 	return(0);
 }
 
@@ -2190,6 +2235,7 @@ char *Find_default_var_value( void *v )
 
 void Get_config( int required, char *path )
 {
+#ifdef REMOVE
 	DEBUG1("Get_config: required '%d', '%s'", required, path );
 	/* void Read_file_list( int required, struct line_list *model, char *str,
 	 *  const char *linesep, int sort, const char *keysep, int uniq, int trim,
@@ -2204,6 +2250,7 @@ void Get_config( int required, char *pat
 	Set_var_list( Pc_var_list, &Config_line_list);
 	Get_local_host();
 	Expand_vars();
+#endif
 }
 
 /***************************************************************************
@@ -2213,12 +2260,14 @@ void Get_config( int required, char *pat
 
 void Reset_config( void )
 {
+#ifdef REMOVE
 	DEBUG1("Reset_config: starting");
 	Clear_var_list( Pc_var_list, 1 );
 	Free_line_list( &PC_entry_line_list );
 	Free_line_list( &PC_alias_line_list );
 	Set_var_list( Pc_var_list, &Config_line_list);
 	Expand_vars();
+#endif
 }
 
 void close_on_exec( int fd )
@@ -2235,15 +2284,42 @@ void Setup_env_for_process( struct line_
 	char *s, *t, *u, *name;
 	int i;
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 1\n");
+fclose(aaaaaa);
+#endif
 	Init_line_list(&env_names);
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 1.1\n");
+fclose(aaaaaa);
+#endif
+
+#if 1
+pw = malloc(sizeof(struct passwd));
+pw->pw_name="root";
+pw->pw_passwd="x";
+pw->pw_gecos="root";
+pw->pw_dir="/root";
+pw->pw_shell="/bin/sh";
+pw->pw_uid=0;
+pw->pw_gid=0;
+#else
 	if( (pw = getpwuid( getuid())) == 0 ){
 		LOGERR_DIE(LOG_INFO) "setup_envp: getpwuid(%d) failed", getuid());
 	}
+#endif
+
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 2\n");
+fclose(aaaaaa);
+#endif
 	Set_str_value(env,"PRINTER",Printer_DYN);
 	Set_str_value(env,"USER",pw->pw_name);
 	Set_str_value(env,"LOGNAME",pw->pw_name);
 	Set_str_value(env,"HOME",pw->pw_dir);
-	Set_str_value(env,"LOGDIR",pw->pw_dir);
 	Set_str_value(env,"PATH",Filter_path_DYN);
 	Set_str_value(env,"LD_LIBRARY_PATH",Filter_ld_path_DYN);
 	Set_str_value(env,"SHELL",Shell_DYN);
@@ -2261,6 +2337,11 @@ void Setup_env_for_process( struct line_
 		if(t) free(t); t = 0;
 		if(u) free(u); u = 0;
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 3\n");
+fclose(aaaaaa);
+#endif
 	if( job ){
 		if( !(s = Find_str_value(&job->info,CF_OUT_IMAGE,Value_sep)) ){
 			s = Find_str_value(&job->info,OPENNAME,Value_sep);
@@ -2273,6 +2354,11 @@ void Setup_env_for_process( struct line_
 		Set_str_value(env, "CONTROL", s );
 	}
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 4\n");
+fclose(aaaaaa);
+#endif
 	if( Pass_env_DYN ){
 		Free_line_list(&env_names);
 		Split(&env_names,Pass_env_DYN,File_sep,1,Value_sep,1,1,0,0);
@@ -2283,10 +2369,18 @@ void Setup_env_for_process( struct line_
 			}
 		}
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Setup_env_for_process: check point 5\n");
+fclose(aaaaaa);
+#endif
 	Free_line_list(&env_names);
 	Check_max(env,1);
 	env->list[env->count] = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("Setup_env_for_process", env );
+#endif
+	free(pw);
 }
 
 /***************************************************************************
@@ -2335,10 +2429,12 @@ void Getprintcap_pathlist( int required,
 	}
 	Free_line_list(&l);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4){
 		Dump_line_list( "Getprintcap_pathlist - filters", filters  );
 		Dump_line_list( "Getprintcap_pathlist - info", raw  );
 	}
+#endif
 }
 
 /***************************************************************************
@@ -2349,6 +2445,7 @@ void Getprintcap_pathlist( int required,
  *    - kill off the filter process
  ***************************************************************************/
 
+#if defined(JYWENG20031104Filterprintcap)
 void Filterprintcap( struct line_list *raw, struct line_list *filters,
 	const char *str )
 {
@@ -2388,8 +2485,9 @@ void Filterprintcap( struct line_list *r
 		close( outtempfd); outtempfd = -1;
 	}
 }
+#endif
 
-
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * int In_group( char* *group, char *user );
  *  returns 1 on failure, 0 on success
@@ -2482,6 +2580,7 @@ int Check_for_rg_group( char *user )
 	DEBUG3("Check_for_rg_group: result: %d", match );
 	return( match );
 }
+#endif
 
 
 /***************************************************************************
@@ -2621,7 +2720,9 @@ void Split_cmd_line( struct line_list *l
 			s = t;
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1){ Dump_line_list("Split_cmd_line", l ); }
+#endif
 }
 
 /***************************************************************************
@@ -2644,6 +2745,12 @@ int Make_passthrough( char *line, char *
 	char error[SMALLBUFFER];
 	char *s;
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 1\n");
+fclose(aaaaaa);
+#endif
+
 	DEBUG1("Make_passthrough: cmd '%s', flags '%s'", line, flags );
 	if( job ){
 		s = Find_str_value( &job->info,QUEUENAME, Value_sep );
@@ -2657,6 +2764,11 @@ int Make_passthrough( char *line, char *
 	}
 	Init_line_list(&cmd);
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 2\n");
+fclose(aaaaaa);
+#endif
 	while( isspace(cval(line)) ) ++line;
 	if( cval(line) == '|' ) ++line;
 	noopts = root = 0;
@@ -2675,7 +2787,13 @@ int Make_passthrough( char *line, char *
 		}
 	}
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 3\n");
+fclose(aaaaaa);
+#endif
 	c = cval(line);
+#if defined(JYWENG20031104Fix_dollars)
 	if( strpbrk(line, "<>|;") || c == '(' ){
 		Add_line_list( &cmd, Shell_DYN, 0, 0, 0 );
 		Add_line_list( &cmd, "-c", 0, 0, 0 );
@@ -2694,6 +2812,7 @@ int Make_passthrough( char *line, char *
 		}
 		Fix_dollars(&cmd, job, 0, flags);
 	}
+#endif
 
 	Check_max(&cmd,1);
 	cmd.list[cmd.count] = 0;
@@ -2699,32 +2818,87 @@ int Make_passthrough( char *line, char *
 	cmd.list[cmd.count] = 0;
 
 	Setup_env_for_process(&env, job);
+
 	if(DEBUGL1){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		Dump_line_list("Make_passthrough - cmd",&cmd );
 		LOGDEBUG("Make_passthrough: fd count %d, root %d", passfd->count, root );
+#endif
 		for( i = 0 ; i < passfd->count; ++i ){
 			fd = Cast_ptr_to_int(passfd->list[i]);
 			LOGDEBUG("  [%d]=%d",i,fd);
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		Dump_line_list("Make_passthrough - env",&env );
+#endif
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 4.5\n");
+fclose(aaaaaa);
+#endif
 
 	c = cmd.list[0][0];
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5\n");
+fclose(aaaaaa);
+#endif
 	if( c != '/' ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.1\n");
+fclose(aaaaaa);
+#endif
 		FATAL(LOG_ERR)"Make_passthrough: bad filter - not absolute path name'%s'",
 			cmd.list[0] );
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.2\n");
+fclose(aaaaaa);
+#endif
 	if( (pid = dofork(0)) == -1 ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.3\n");
+fclose(aaaaaa);
+#endif
 		LOGERR_DIE(LOG_ERR)"Make_passthrough: fork failed");
 	} else if( pid == 0 ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.4\n");
+fclose(aaaaaa);
+#endif
 		for( i = 0; i < passfd->count; ++i ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.5\n");
+fclose(aaaaaa);
+#endif
 			fd = Cast_ptr_to_int(passfd->list[i]);
 			if( fd < i  ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.6\n");
+fclose(aaaaaa);
+#endif
 				/* we have fd 3 -> 4, but 3 gets wiped out */
 				do{
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.7\n");
+fclose(aaaaaa);
+#endif
 					newfd = dup(fd);
 					Max_open(newfd);
 					if( newfd < 0 ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.8\n");
+fclose(aaaaaa);
+#endif
 						Errorcode = JABORT;
 						LOGERR_DIE(LOG_INFO)"Make_passthrough: dup failed");
 					}
@@ -2732,8 +2906,18 @@ int Make_passthrough( char *line, char *
 						i, fd, newfd );
 					passfd->list[i] = Cast_int_to_voidstar(newfd);
 				} while( newfd < i );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 5.9\n");
+fclose(aaaaaa);
+#endif
 			}
 		}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 6\n");
+fclose(aaaaaa);
+#endif
 		if(DEBUGL4){
 			LOGDEBUG("Make_passthrough: after fixing fd, count %d", passfd->count );
 			for( i = 0 ; i < passfd->count; ++i ){
@@ -2751,6 +2935,11 @@ int Make_passthrough( char *line, char *
 		} else {
 			Full_user_perms();
 		}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Make_passthrough: check point 7\n");
+fclose(aaaaaa);
+#endif
 		for( i = 0; i < passfd->count; ++i ){
 			fd = Cast_ptr_to_int(passfd->list[i]);
 			if( dup2(fd,i) == -1 ){
@@ -2762,9 +2951,11 @@ int Make_passthrough( char *line, char *
 		}
 		close_on_exec(passfd->count);
 		execve(cmd.list[0],cmd.list,env.list);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF(error,sizeof(error))
 			"Make_passthrough: pid %d, execve '%s' failed - '%s'\n", getpid(),
 			cmd.list[0], Errormsg(errno) );
+#endif
 		Write_fd_str(2,error);
 		exit(JABORT);
 	}
@@ -2851,13 +3042,17 @@ int Filter_file( int input_fd, int outpu
 		buffer[n+len] = 0;
 		while( (s = safestrchr(buffer,'\n')) ){
 			*s++ = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SETSTATUS(job)"%s: %s", error_header, buffer );
+#endif
 			memmove(buffer,s,safestrlen(s)+1);
 		}
 		len = safestrlen(buffer);
 	}
 	if( buffer[0] ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SETSTATUS(job)"%s: %s", error_header, buffer );
+#endif
 	}
 	if( (close(of_error[0]) == -1 ) ){
 		Errorcode = JFAIL;
@@ -2867,8 +3062,10 @@ int Filter_file( int input_fd, int outpu
 	of_error[0] = -1;
 	while( (n = plp_waitpid(pid,&status,0)) != pid ){
 		int err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG1("Filter_file: waitpid(%d) returned %d, err '%s'",
 			pid, n, Errormsg(err) );
+#endif
 		if( err == EINTR ) continue; 
 		Errorcode = JABORT;
 		LOGERR_DIE(LOG_ERR) "Filter_file: waitpid(%d) failed", pid);
@@ -2882,10 +3079,12 @@ int Filter_file( int input_fd, int outpu
 	}
 	n = WEXITSTATUS(status);
 	if( n > 0 && n < 32 ) n+=(JFAIL-1);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG1("Filter_file: final status '%s'", Server_status(n) );
 	if( verbose ){
 		SETSTATUS(job)"Filter_file: pgm '%s' exited with status '%s'", pgm, Server_status(n));
 	}
+#endif
 	return( n );
 }
 
@@ -2951,6 +3150,7 @@ void Clean_meta( char *t )
 	}
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /**********************************************************************
  * Dump_parms( char *title, struct keywords *k )
  * - dump the list of keywords and variable values given by the
@@ -2989,8 +3189,9 @@ void Dump_parms( char *title, struct key
 	}
 	if( title ) LOGDEBUG( "*** <END> ***");
 }
+#endif
 
-
+#ifdef ORIGINAL_DEBUG //JY@1020
 /**********************************************************************
  * Dump_parms( char *title, struct keywords *k )
  * - dump the list of keywords and variable values given by the
@@ -3041,7 +3242,7 @@ void Dump_default_parms( int fd, char *t
 	}
 	Write_fd_str(fd, "\n");
 }
-
+#endif
 
 /***************************************************************************
  *char *Fix_Z_opts( struct job *job )
@@ -3074,6 +3275,7 @@ void Remove_sequential_separators( char
 	}
 }
 
+#if defined(JYWENG20031104Fix_dollars)
 void Fix_Z_opts( struct job *job )
 {
 	char *str, *s, *pattern, *start, *end;
@@ -3188,8 +3390,9 @@ void Fix_Z_opts( struct job *job )
 	DEBUG4("Fix_Z_opts: final Z '%s'", str );
 	Free_line_list(&l);
 }
+#endif
 
-
+#if defined(JYWENG20031104Fix_dollars)
 /***************************************************************************
  * void Fix_dollars( struct line_list *l, struct job *job,
  *   int nosplit, char *flags )
@@ -3217,7 +3420,9 @@ void Fix_dollars( struct line_list *l, s
 	char *strv, *s, *t, *rest;
 	char buffer[SMALLBUFFER], tag[32];
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Fix_dollars- before", l );
+#endif
 	for( count = 0; count < l->count; ++count ){
 		position = 0;
 		for( strv = l->list[count]; (s = safestrpbrk(strv+position,"$\\")); ){
@@ -3405,8 +3610,11 @@ void Fix_dollars( struct line_list *l, s
 		if( s ) ++j;
 	}
 	l->count = j;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL4)Dump_line_list("Fix_dollars- after", l );
+#endif
 }
+#endif
 
 /*
  * char *Make_pathname( char *dir, char *file )
@@ -3670,6 +3878,7 @@ char *Fix_str( char *str )
 	return( dupstr );
 }
 
+#if defined(JYWENG20031104Shutdown_or_close)
 /***************************************************************************
  * int Shutdown_or_close( int fd )
  * - if the file descriptor is a socket, then do a shutdown (write), return fd;
@@ -3690,7 +3899,9 @@ int Shutdown_or_close( int fd )
 	}
 	return( fd );
 }
+#endif
 
+#ifdef REMOVE
 /*
  *  Support for non-copy on write fork as for NT
  *   1. Preparation for the fork is done by calling 'Setup_lpd_call'
@@ -3766,7 +3977,7 @@ int Make_lpd_call( char *name, struct li
 		return(pid);
 	}
 	Name = "LPD_CALL";
-
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2){
 		LOGDEBUG("Make_lpd_call: lpd path '%s'", Lpd_path_DYN );
 		LOGDEBUG("Make_lpd_call: passfd count %d", passfd->count );
@@ -3775,6 +3986,7 @@ int Make_lpd_call( char *name, struct li
 		}
 		Dump_line_list("Make_lpd_call - args", args );
 	}
+#endif
 	for( i = 0; i < passfd->count; ++i ){
 		fd = Cast_ptr_to_int(passfd->list[i]);
 		if( fd < i  ){
@@ -3792,6 +4004,7 @@ int Make_lpd_call( char *name, struct li
 			} while( newfd < i );
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2){
 		LOGDEBUG("Make_lpd_call: after fixing fd count %d", passfd->count);
 		for( i = 0 ; i < passfd->count; ++i ){
@@ -3799,6 +4012,7 @@ int Make_lpd_call( char *name, struct li
 			LOGDEBUG("  [%d]=%d",i,fd);
 		}
 	}
+#endif
 	for( i = 0; i < passfd->count; ++i ){
 		fd = Cast_ptr_to_int(passfd->list[i]);
 		DEBUG2("Make_lpd_call: fd %d -> %d",fd, i );
@@ -3815,6 +4029,11 @@ int Make_lpd_call( char *name, struct li
 	}
 	passfd->count = 0;
 	Free_line_list( passfd );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "linelist:Make_lpd_call: b4 Do_work\n");
+fclose(aaaaaa);
+#endif
 	Do_work( name, args );
 	return(0);
 }
@@ -3836,8 +4055,17 @@ void Do_work( char *name, struct line_li
 		_dmalloc_outfile_fd = Find_flag_value(args, DMALLOC_OUTFILE,Value_sep);
 	}
 #endif
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "linelist: Do_work: starting...name=%s\n", name);
+fclose(aaaaaa);
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if( !safestrcasecmp(name,"logger") ) proc = Logger;
 	else if( !safestrcasecmp(name,"all") ) proc = Service_all;
+#else
+	if( !safestrcasecmp(name,"all") ) proc = Service_all;
+#endif
 	else if( !safestrcasecmp(name,"server") ) proc = Service_connection;
 	else if( !safestrcasecmp(name,"queue") ) proc = Service_queue;
 	else if( !safestrcasecmp(name,"printer") ) proc = Service_worker;
@@ -3858,10 +4086,12 @@ int Start_worker( char *name, struct lin
 
 	Init_line_list(&passfd);
 	Init_line_list(&args);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1){
 		DEBUG1("Start_worker: fd %d", fd );
 		Dump_line_list("Start_worker - parms", parms );
 	}
+#endif
 	Setup_lpd_call( &passfd, &args );
 	Merge_line_list( &args, parms, Value_sep,1,1);
 	Free_line_list( parms );
@@ -3878,3 +4108,4 @@ int Start_worker( char *name, struct lin
 	DEBUG1("Start_worker: pid %d", pid );
 	return(pid);
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/linksupport.c LPRng/src/common/linksupport.c
--- LPRng-3.8.22/src/common/linksupport.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/linksupport.c	2011-06-09 00:46:13.000000000 +0400
@@ -143,11 +143,16 @@
  ***************************************************************************/
 
 #include "lp.h"
+#include "lp_asus.h"
 #include "linksupport.h"
 #include "gethostinfo.h"
 #include "errorcodes.h"
 /**** ENDINCLUDE ****/
 
+/*JY1110*/
+//extern char clientaddr[32];//JY1110
+/**/
+
 /***************************************************************************
  * int Link_open(char *host, int port,  int timeout );
  * 1. Set up an inet socket;  a socket has a local host/local port and
@@ -168,7 +173,7 @@
  * Thus,  all of these restrictions are somewhat bogus.  We use the
  * configuration file 'PORT' restrictions instead
  ***************************************************************************/
-
+//extern char printerstatus[32];//JY1106
 
 int Link_setreuse( int sock )
 {
@@ -294,6 +299,20 @@ int getconnection ( char *xhostname,
 		dest_un.sun_family = AF_UNIX;
 #endif
 		sock = socket(dest_un.sun_family, SOCK_STREAM, 0);
+#ifdef WINDOW_1
+{
+int windowsize=1024;
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize)) == -1 ) {	
+;
+//fprintf(aaaaaa, "linksupport: getconnection: opensocket FAILED!!!!!\n");
+} else {
+;
+//fprintf(aaaaaa, "linksupport: getconnection: opensocket ok!!!\n");
+}
+//fclose(aaaaaa);
+}
+#endif
 		err = errno;
 		if( UID_root ) (void)To_euid( euid );
 		plp_set_signal_mask( &oblock, 0 );
@@ -316,9 +335,11 @@ int getconnection ( char *xhostname,
 			(struct sockaddr *) &dest_un, sizeof(dest_un));
 		err = errno;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW2)(
 			"getconnection: connect sock %d, status %d, err '%s', timedout %d",
 			sock, status, Errormsg(err), Alarm_timed_out );
+#endif
 		if( status < 0 || Alarm_timed_out ){
 			(void) close (sock);
 			sock = LINK_OPEN_FAIL;
@@ -327,8 +348,10 @@ int getconnection ( char *xhostname,
 					use_host);
 				err = errno = ETIMEDOUT;
 			} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUGF(DNW1)("getconnection: connection to '%s' failed '%s'",
 					use_host, Errormsg(err) );
+#endif
 			}
 		}
 		errno = err;
@@ -438,6 +461,18 @@ int getconnection ( char *xhostname,
 	plp_block_all_signals( &oblock );
 	if( UID_root ) (void)To_euid_root();
 	sock = socket(AF_Protocol(), connection_type, 0);
+#ifdef WINDOW_1
+{
+int windowsize=1024;
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize)) == -1) {
+//fprintf(aaaaaa, "linksupport: getconnection: opensocket: again FAILED!!!!!!\n");
+} else{
+//fprintf(aaaaaa, "linksupport: getconnection: opensocket: again ok!!!!!!\n");
+}
+//fclose(aaaaaa);
+}
+#endif
 	err = errno;
 	if( UID_root ) (void)To_euid( euid );
 	plp_set_signal_mask( &oblock, 0 );
@@ -533,9 +568,11 @@ int getconnection ( char *xhostname,
 		(struct sockaddr *) &dest_sin, sizeof(dest_sin));
 	err = errno;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DNW2)(
 		"getconnection: connect sock %d, status %d, err '%s', timedout %d",
 		sock, status, Errormsg(err), Alarm_timed_out );
+#endif
 	if( status < 0 || Alarm_timed_out ){
 		(void) close (sock);
 		sock = LINK_OPEN_FAIL;
@@ -544,8 +581,10 @@ int getconnection ( char *xhostname,
 				use_host);
 			err = errno = ETIMEDOUT;
 		} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGF(DNW1)("getconnection: connection to '%s' failed '%s'",
 				use_host, Errormsg(err) );
+#endif
 		}
 		if( err == ECONNREFUSED ){
 			sock = LINK_ECONNREFUSED;
@@ -587,8 +626,10 @@ int getconnection ( char *xhostname,
 			Set_linger( sock, Socket_linger_DYN );
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DNW1)("getconnection: connection to '%s' socket %d, errormsg '%s'",
 		use_host, sock, Errormsg(err) );
+#endif
 	errno = err;
 	return (sock);
 }
@@ -606,7 +647,9 @@ void Set_linger( int sock, int n )
 
 	DEBUGF(DNW2) ("Set_linger: SO_LINGER socket %d, value %d", sock, n );
 	if( getsockopt( sock,SOL_SOCKET,SO_LINGER,(char *)&option, &len) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW2) ("Set_linger: getsockopt linger failed - '%s'", Errormsg(errno) );
+#endif
 		return;
 	}
 	DEBUGF(DNW4) ("Set_linger: SO_LINGER socket %d, onoff %d, linger %d",
@@ -620,7 +663,9 @@ void Set_linger( int sock, int n )
 	}
 	if( setsockopt( sock, SOL_SOCKET, SO_LINGER,
 			(char *)&option, sizeof(option) ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW2) ("Set_linger: setsockopt linger %d failed - '%s'", n, Errormsg(errno) );
+#endif
 	}
 #else
 	DEBUGF(DNW2) ("Set_linger: NO SO_LINGER, socket %d, value %d", sock, n);
@@ -695,11 +740,25 @@ int Link_listen( char *port_name )
 		|| Link_setreuse( sock ) < 0
 		|| (Keepalive_DYN && Link_setkeepalive( sock ) < 0)
 		|| bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) < 0;
+#ifdef WINDOW_1
+{
+int windowsize=1024;
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize)) == -1) {
+//fprintf(aaaaaa, "linksupport: Link_listen: opensocket FAILED!!!!!!\n");
+} else{
+//fprintf(aaaaaa, "linksupport: Link_listen: opensocket ok!!!!!!\n");
+}
+//fclose(aaaaaa);
+}
+#endif
 	err = errno;
 	if( UID_root ) (void)To_euid( euid );
 	if( status ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW4)("Link_listen: bind to lpd port %d failed '%s'",
 			port, Errormsg(err));
+#endif
 		if( sock >= 0 ){
 			(void)close( sock );
 			sock = -1;
@@ -722,6 +781,9 @@ int Link_listen( char *port_name )
 }
 
 int Unix_link_listen( char *unix_socket_path )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	int sock;                   /* socket */
 	int status;                 /* socket */
@@ -751,6 +813,16 @@ int Unix_link_listen( char *unix_socket_
 	if( UID_root ) (void)To_euid_root();
 	unlink( sunaddr.sun_path );
 	status = ((sock = socket (sunaddr.sun_family, SOCK_STREAM, 0)) < 0);
+#ifdef WINDOW_1
+int windowsize=1024;
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize)) == -1) {
+//fprintf(aaaaaa, "linksupport: Unix_link_listen: opensocket FAILED!!!!!!\n");
+}else{
+//fprintf(aaaaaa, "linksupport: Unix_link_listen: opensocket ok!!!!!\n");
+}
+//fclose(aaaaaa);
+#endif
 	err = errno;
 	if( UID_root ) (void)To_euid( euid );
 	Max_open(sock);
@@ -766,8 +838,10 @@ int Unix_link_listen( char *unix_socket_
 	if( UID_root ) (void)To_euid( euid );
 	umask(omask);
 	if( status ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW4)("Unix_link_listen: bind to unix port %s failed '%s'",
 			Unix_socket_path_DYN, Errormsg(err));
+#endif
 		if( sock >= 0 ){
 			(void)close( sock );
 			sock = -1;
@@ -790,6 +864,7 @@ int Unix_link_listen( char *unix_socket_
 	errno = err;
 	return (sock);
 }
+#endif
 
 int Link_open(char *host, int timeout, struct sockaddr *bindto,
 	char *unix_socket_path )
@@ -814,6 +889,7 @@ int Link_open_type(char *host, int timeo
 	return( sock );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 int Link_open_list( char *hostlist, char **result,
 	int timeout, struct sockaddr *bindto, char *unix_socket_path )
 {
@@ -845,6 +921,7 @@ int Link_open_list( char *hostlist, char
 	Free_line_list(&list);
 	return( sock );
 }
+#endif
 
 /***************************************************************************
  * void Link_close( int socket )
@@ -925,8 +1002,10 @@ int Link_send( char *host, int *sock, in
 			DEBUGF(DNW2)("Link_send: write to '%s' timed out", host);
 			status = LINK_TRANSFER_FAIL;
 		} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGF(DNW2)("Link_send: write to '%s' failed '%s'",
 				host, Errormsg(err) );
+#endif
 			status = LINK_TRANSFER_FAIL;
 		}
 	}
@@ -945,8 +1024,10 @@ int Link_send( char *host, int *sock, in
 				DEBUGF(DNW2)("Link_send: ack read from '%s' timed out", host);
 				status = LINK_TRANSFER_FAIL;
 			} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUGF(DNW2)("Link_send: ack read from '%s' failed - %s",
 					host, Errormsg(err) );
+#endif
 				status = LINK_TRANSFER_FAIL;
 			}
 		} else if( i == 0 ){
@@ -983,6 +1064,7 @@ int Link_send( char *host, int *sock, in
 	return (status);
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * int Link_copy( char *host, int *socket, int timeout,
  *  char *src, int fd, int count)
@@ -1025,9 +1107,11 @@ int Link_copy( char *host, int *sock, in
 		if( Alarm_timed_out || len <= 0 ){
 			/* EOF on input */
 			if( pcount && count > 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUGF(DNW4)(
 					"Link_copy: read from '%s' failed, %0.0f bytes left - %s",
 					src, count, Errormsg(err) );
+#endif
 				status = LINK_TRANSFER_FAIL;
 			} else {
 				DEBUGF(DNW4)("Link_copy: read status %d count %0.0f", len, count );
@@ -1044,8 +1128,10 @@ int Link_copy( char *host, int *sock, in
 				DEBUGF(DNW4)("Link_copy: write to '%s' timed out", host);
 				status = LINK_TRANSFER_FAIL;
 			} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUGF(DNW4)("Link_copy: write to '%s' failed - %s",
 					host, Errormsg(err) );
+#endif
 				status = LINK_TRANSFER_FAIL;
 			}
 		}
@@ -1073,6 +1159,7 @@ int Link_copy( char *host, int *sock, in
 	DEBUGF(DNW4)("Link_copy: status %d", status );
 	return( status );
 }
+#endif
 
 
 /***************************************************************************
@@ -1181,8 +1268,10 @@ int Link_line_read(char *host, int *sock
 			status = LINK_TRANSFER_FAIL;
 		}
 	} else if( i < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW4)("Link_line_read: read from '%s' failed - %s", host,
 			Errormsg(err) );
+#endif
 		status = LINK_TRANSFER_FAIL;
 	} else if( lf == 0 ){
 		DEBUGF(DNW4)("Link_line_read: no LF on line from '%s'", host );
@@ -1196,6 +1285,7 @@ int Link_line_read(char *host, int *sock
 }
 
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * int Link_line_peek(char *host, int *sock, int timeout,
  *	  char *str, int *count )
@@ -1246,8 +1336,10 @@ int Link_line_peek(char *host, int *sock
 	 * long line, timeout, error, or OK
 	 */
 	if( len <= 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW1)("Link_line_peek: read from '%s' failed - %s", host,
 			Errormsg(err) );
+#endif
 		status = LINK_TRANSFER_FAIL;
 	} else {
 		*count = len;
@@ -1258,7 +1350,7 @@ int Link_line_peek(char *host, int *sock
 	errno = err;
 	return( status );
 }
-
+#endif
 
 /***************************************************************************
  * int Link_read(char *host, int *sock, int timeout,
@@ -1315,14 +1407,17 @@ int Link_read(char *host, int *sock, int
 			len, host, i );
 		status = LINK_TRANSFER_FAIL;
 	} else if( i < 0 ) {
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DNW2)("Link_read: read %d from '%s' failed, returned %d - %s",
 			len, host, i, Errormsg(err) );
+#endif
 		status = LINK_TRANSFER_FAIL;
 	}
 
 	errno = err;
 	return( status );
 }
+#ifdef TEST_WRITE//JYWeng
 
 /***************************************************************************
  * int Link_file_read( char *host, int *sock, int readtimeout,
@@ -1339,7 +1434,7 @@ int Link_read(char *host, int *sock, int
  *
  ***************************************************************************/
 
-int Link_file_read(char *host, int *sock, int readtimeout, int writetimeout,
+int Link_file_read_test(char *host, int *sock, int readtimeout, int writetimeout,
 	  int fd, double *count, int *ack )
 {
 	char str[LARGEBUFFER];		/* input buffer pointer */
@@ -1349,6 +1444,7 @@ int Link_file_read(char *host, int *sock
 	double len;
 	double readcount;
 
+	currten_sock = sock;//JY1120
 	len = i = status = cnt = 0;	/* shut up GCC */
 	readcount = 0;
 	*ack = 0;
@@ -1365,6 +1461,10 @@ int Link_file_read(char *host, int *sock
 
 	/* do the read */
 	len = *count;
+/*1106test status*/
+//plp_signal_break(SIGUSR, );
+check_prn_status("Printing", clientaddr);
+/**/
 	while( status == 0 && (*count == 0 || len > 0) ){
 		DEBUGF(DNW2)("Link_file_read: doing data read" );
 		l = sizeof(str);
@@ -1378,21 +1478,46 @@ int Link_file_read(char *host, int *sock
 			DEBUGF(DNW2)("Link_file_read: len %0.0f, readlen %d, read %d", len, l, i );
 			if( *count ) len -= i;
 			readcount += i;
+#if 1 //JYWeng
+/*1106test status*/
+//strcpy(printerstatus, "Printing");
+/**/
+
+writetimeout = 600;//JY1110
+//JY1110			cnt = write(fd_print, str, i );
+			cnt = Write_fd_len_timeout(writetimeout, fd_print, str, i);
+
+#else
+aaaaaa=fopen("/tmp/a12345", "a");
+fprintf(aaaaaa, "Linksupport: write_fd_len_timeout\n");
+fclose(aaaaaa);
 			cnt = Write_fd_len_timeout(writetimeout, fd, str, i );
+sleep(10);
+#endif
 			err = errno;
 			if( Alarm_timed_out || cnt < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUGF(DNW2)( "Link_file_read: write %d to fd %d failed - %s",
 					i, fd, Errormsg(err) );
+#endif
 				status = LINK_TRANSFER_FAIL; 
 			}
 		} else if( *count ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGF(DNW2)("Link_file_read: read from '%s' failed - %s",
 				host, Errormsg(err) );
+#endif
 			status = LINK_TRANSFER_FAIL;
 		} else {
 			break;
 		}
 	}
+#if JYDEBUG //JYWeng
+aaaaaa=fopen("/tmp/a12345", "a");
+fprintf(aaaaaa, "Linksupport: loop end!\n");
+fclose(aaaaaa);
+//close(fd_print);
+#endif
 	if( *count ){
 		*count -= len;
 	} else {
@@ -1417,8 +1542,121 @@ int Link_file_read(char *host, int *sock
 		} else if( i == 0 ){
 			DEBUGF(DNW2)("Link_file_read: EOF and no end marker" );
 		} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGF(DNW2)("Link_file_read: end marker read from '%s' failed - %s",
 				host, Errormsg(err) );
+#endif
+			status = LINK_TRANSFER_FAIL;
+		}
+	}
+
+	DEBUGF(DNW2)("Link_file_read: status %d", status );
+	return( status );
+}
+#endif
+
+/***************************************************************************
+ * int Link_file_read( char *host, int *sock, int readtimeout,
+ *    int writetimeout, int fd, int *count, int *ack )
+ *    reads and copies '*count' characters from socket to fd
+ *    *count points to maximum number of bytes to read;
+ *      updated with actual value read
+ *    if ack then will read an additional ACK character
+ *       returns value in *ack
+ *    if read does not complete within timeout seconds,
+ *      terminate action with error.
+ *    if timeout == 0, wait indefinitely
+ *    returns 0 *count not read
+ *
+ ***************************************************************************/
+
+int Link_file_read(char *host, int *sock, int readtimeout, int writetimeout,
+	  int fd, double *count, int *ack )
+{
+	char str[LARGEBUFFER];		/* input buffer pointer */
+	int i, l, cnt;			/* number to read or write */
+	int status;				/* status of operation */
+	int err;					/* error */
+	double len;
+	double readcount;
+
+	len = i = status = cnt = 0;	/* shut up GCC */
+	readcount = 0;
+	*ack = 0;
+	DEBUGF(DNW1) ("Link_file_read: reading %0.0f from '%s' on %d",
+		*count, host, *sock );
+	/* check for valid socket */
+	if(*sock < 0) {
+		DEBUGF(DNW2)( "Link_file_read: bad socket" );
+		return (LINK_OPEN_FAIL);
+	}
+	/*
+	 * set up timeout and then do the transfer
+	 */
+
+	/* do the read */
+	len = *count;
+	while( status == 0 && (*count == 0 || len > 0) ){
+		DEBUGF(DNW2)("Link_file_read: doing data read" );
+		l = sizeof(str);
+		if( *count && l > len ) l = len;
+		i = Read_fd_len_timeout( readtimeout, *sock, str, l );
+		err = errno;
+		if( Alarm_timed_out ){
+			DEBUGF(DNW2)( "Link_file_read: read from '%s' timed out", host);
+			status = LINK_TRANSFER_FAIL;
+		} else if( i > 0 ){
+			DEBUGF(DNW2)("Link_file_read: len %0.0f, readlen %d, read %d", len, l, i );
+			if( *count ) len -= i;
+			readcount += i;
+//JY1111			cnt = Write_fd_len_timeout(writetimeout, fd, str, i );
+sleep(10);
+			err = errno;
+			if( Alarm_timed_out || cnt < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
+				DEBUGF(DNW2)( "Link_file_read: write %d to fd %d failed - %s",
+					i, fd, Errormsg(err) );
+#endif
+				status = LINK_TRANSFER_FAIL; 
+			}
+		} else if( *count ){
+#ifdef ORIGINAL_DEBUG //JY@1020
+			DEBUGF(DNW2)("Link_file_read: read from '%s' failed - %s",
+				host, Errormsg(err) );
+#endif
+			status = LINK_TRANSFER_FAIL;
+		} else {
+			break;
+		}
+	}
+	if( *count ){
+		*count -= len;
+	} else {
+		*count = readcount;
+	}
+
+	if( *count && status == 0 && ack ){
+		DEBUGF(DNW2)("Link_file_read: doing end marker byte read" );
+		i = Read_fd_len_timeout(readtimeout, *sock, str, 1 );
+		err = errno;
+
+		if( Alarm_timed_out ){
+			DEBUGF(DNW2)( "Link_file_read: end marker byte read from '%s' timed out", host);
+			status = LINK_TRANSFER_FAIL;
+		} else if( i > 0 ){
+			DEBUGF(DNW2)("Link_file_read: end marker read count %d value %d", i, *str );
+			*ack = *str;
+			if( *ack ){
+				DEBUGF(DNW2)( "Link_file_read: nonzero end marker '%d'", *ack );
+				status = LINK_ACK_FAIL;
+			}
+		} else if( i == 0 ){
+			DEBUGF(DNW2)("Link_file_read: EOF and no end marker" );
+		} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
+			DEBUGF(DNW2)("Link_file_read: end marker read from '%s' failed - %s",
+				host, Errormsg(err) );
+#endif
 			status = LINK_TRANSFER_FAIL;
 		}
 	}
diff -urNBp LPRng-3.8.22/src/common/lpd.c LPRng/src/common/lpd.c
--- LPRng-3.8.22/src/common/lpd.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd.c	2011-06-08 23:36:24.000000000 +0400
@@ -1,1009 +1,1280 @@
-/***************************************************************************
- * LPRng - An Extended Print Spooler System
- *
- * Copyright 1988-2003, Patrick Powell, San Diego, CA
- *     papowell@lprng.com
- * See LICENSE for conditions of use.
- *
- ***************************************************************************/
-
- static char *const _id =
-"$Id: lpd.c,v 1.57 2003/09/05 20:07:19 papowell Exp $";
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <linux/lp.h>
+#include <fcntl.h>
+#include "wlancom.h"
+#include "lp_asus.h"
+#include "syslog.h"
+
+/*Lisa*/
+#include	<stdlib.h>
+#include	<getopt.h>
+#include	<ctype.h>
+#include	<fcntl.h>
+#include	<netdb.h>
+#include	<syslog.h>
+#include	<sys/resource.h>
+#include	<sys/stat.h>
+#include 	<sys/ioctl.h>
+#define		BASEPORT	9100
+#ifdef 		DEBUG
+#define		PRINT(...)
+#else
+#define		PRINT	printf
+#endif
+/*#define 	Raw_Printing_with_ASUS*/
+#define 	LOGOPTS		(LOG_PERROR|LOG_PID|LOG_LPR|LOG_ERR)
 
+/* 2004/09/10, added by Joey 
+ * The printer server desing 
+ * Remote Port/LPR/Raw
+ * 1. fork() for one printing job at the same time.
+ * 2. the nack is processed in parent process.
+ * 3. busyflag is used globally in parent proces
+ * 4. lptstatus.busy is used between parent and child
+ */
 
+//JY
 #include "lp.h"
-#include "child.h"
-#include "fileopen.h"
-#include "errorcodes.h"
-#include "initialize.h"
-#include "linksupport.h"
-#include "lpd_logger.h"
-#include "getqueue.h"
-#include "getopt.h"
-#include "proctitle.h"
-#include "lockfile.h"
-
-/* force local definitions */
-#undef EXTERN
-#undef DEFINE
-#undef DEFS
-
-#define EXTERN
-#define DEFINE(X) X
-#define DEFS
-
-#include "lpd.h"
-
- char* Lpd_listen_port_arg;	/* command line listent port value */
- char* Lpd_port_arg;	/* command line port value */
- char* Lpd_socket_arg; /* command line unix socket value */
-
-#if HAVE_TCPD_H
-#include <tcpd.h>
- int allow_severity = LOG_INFO;
- int deny_severity = LOG_WARNING;
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))//JY1112
 #endif
 
 
-/**** ENDINCLUDE ****/
-
-/***************************************************************************
- * main()
- * - top level of LPD Lite.  This is a cannonical method of handling
- *   input.  Note that we assume that the LPD daemon will handle all
- *   of the dirty work associated with formatting, printing, etc.
- * 
- * 1. get the debug level from command line arguments
- * 2. set signal handlers for cleanup
- * 3. get the Host computer Name and user Name
- * 4. scan command line arguments
- * 5. check command line arguments for consistency
- *
- ****************************************************************************/
-
-
-int main(int argc, char *argv[], char *envp[])
-{
-	int sock = 0;		/* socket for listen */
-	int pid;			/* pid */
-	fd_set defreadfds, readfds;	/* for select() */
-	int max_socks;		/* maximum number of sockets */
-	int lockfd;	/* the lock file descriptor */
-	int err, newsock;
- 	time_t last_time;	/* time that last Start_all was done */
-	time_t server_started_time;	/* time servers were started */
-	plp_status_t status;
-	int max_servers;
-	int start_fd = 0, start_pid = 0;
-	int logger_process_pid = 0;
-	int request_pipe[2], status_pipe[2];
-	int last_fork_pid_value;
-	struct line_list args;
-	struct sockaddr sinaddr;
-	int first_scan = 1;
-	int unix_sock = 0;
-	int fd_available;
-
-	Init_line_list( &args );
-	Is_server = 1;	/* we are the LPD server */
-	Logger_fd = -1;
-
-#ifndef NODEBUG
-	Debug = 0;
-#endif
-	if(DEBUGL3){
-		int n;
-		LOGDEBUG("lpd: argc %d", argc );
-		for( n = 0; n < argc; ++n ){
-			LOGDEBUG(" [%d] '%s'", n, argv[n] );
-		}
-		LOGDEBUG("lpd: env" );
-		for( n = 0; envp[n]; ++n ){
-			LOGDEBUG(" [%d] '%s'", n, envp[n] );
-		}
-	}
-
-	/* set signal handlers */
-	(void) plp_signal(SIGHUP,  (plp_sigfunc_t)Reinit);
-	(void) plp_signal(SIGINT, cleanup_INT);
-	(void) plp_signal(SIGQUIT, cleanup_QUIT);
-	(void) plp_signal(SIGTERM, cleanup_TERM);
-	(void) signal(SIGUSR1, SIG_IGN);
-	(void) signal(SIGUSR2, SIG_IGN);
-	(void) signal(SIGCHLD, SIG_DFL);
-	(void) signal(SIGPIPE, SIG_IGN);
-
-	/*
-	the next bit of insanity is caused by the interaction of signal(2) and execve(2)
-	man signal(2):
+extern int          errno;
 
-	 When a process which has installed signal handlers forks, the child pro-
-	 cess inherits the signals.  All caught signals may be reset to their de-
-	 fault action by a call to the execve(2) function; ignored signals remain
-	 ignored.
 
+#ifdef LPR_with_ASUS//JY1112
+#define PNT_SVR_PORT_ASUS    3838
+#endif
+#define PNT_SVR_PORT_LPR 515
+#define PRINT printf
 
-	man execve(2):
-	 
-	 Signals set to be ignored in the calling process are set to be ignored in
-					   ^^^^^^^
-					   signal(SIGCHLD, SIG_IGN)  <- in the acroread code???
-	 
-	 the new process. Signals which are set to be caught in the calling pro-  
-	 cess image are set to default action in the new process image.  Blocked  
-	 signals remain blocked regardless of changes to the signal action.  The  
-	 signal stack is reset to be undefined (see sigaction(2) for more informa-
-	 tion).
+#define UCHAR unsigned char
 
+#define STATUS_FILE "/var/state/lpr_status"
 
-	^&*(*&^!!! &*())&*&*!!!  and again, I say, &*()(&*!!!
 
-	This means that if you fork/execve a child,  then you better make sure
-	that you set up its signal/mask stuff correctly.
+int processReq(int sockfd); //Process the request from the client side
+int closesocket(int sockfd); 
+void sig_child(int sig);    //signal handler to the dead of child process
+void sig_cleanup(int sig); 
+void sig_remove(int sig);//JY1110 
+//void checkstatus_usb_par();//JY1110
+int waitsock(int sockfd , int sec , int usec);  //wait to socket until timeout
+void reset_printer(int sec);
+DWORD RECV(int sockfd , PBYTE pRcvbuf , DWORD dwlen , DWORD timeout);
 
-    So if somebody blocks all signals and then starts up LPD,  it will not work
-	correctly.
+int  fdPRN=0; //File descriptor of the printer port
+char busy = FALSE; //Add by Lisa
 
-	*/
 
-	{ plp_block_mask oblock; plp_unblock_all_signals( &oblock ); }
+/*
+ * logmessage
+ *
+ */
+void logmessage(char *logheader, char *fmt, ...)
+{
+  va_list args;
+  char buf[512];
 
+  va_start(args, fmt);
 
-	Get_parms(argc, argv);      /* scan input args */
+  vsnprintf(buf, sizeof(buf), fmt, args);
+  openlog(logheader, 0, 0);
+  syslog(0, buf);
+  closelog();
+  va_end(args);
+}
 
-	Initialize(argc, argv, envp, 'D' );
-	DEBUG1("Get_parms: UID_root %d, OriginalRUID %d", UID_root, OriginalRUID);
 
-	if( UID_root && (OriginalRUID != ROOTUID) ){
-		FATAL(LOG_ERR) "lpd installed SETUID root and started by user %d! Possible hacker attack", OriginalRUID);
-	}
 
-	Setup_configuration();
+int main(int argc, char **argv)
+{
+    int                 sockfd , clisockfd;
+    unsigned int        clilen;
+    int                 childpid;
+    struct sockaddr_in  serv_addr,cli_addr;
+    int err_select;//JY1113
+
+#ifdef LPR_with_ASUS//JY1112
+    int 		LPRflag = 0;
+    fd_set		rfds, afds;
+    int			nfds;
+    int			sockfd_ASUS;
+    unsigned int        clilen_ASUS;
+    int                 childpid_ASUS;
+    struct sockaddr_in  serv_addr_ASUS,cli_addr_ASUS;
+#endif
+#ifdef Raw_Printing_with_ASUS  //Lisa
+	int		netfd, fd, clientlen, one = 1;
+	struct sockaddr_in	netaddr, client;
+#endif
 
-	/* get the maximum number of servers allowed */
-	max_servers = Get_max_servers();
-	if(DEBUGL1){
-		int max_file_descriptors = Get_max_fd();
-		DEBUG1( "lpd: maximum servers %d, maximum file descriptors %d ",
-			max_servers, max_file_descriptors );
-	}
+    //Initial the server the not busy
+    lptstatus.busy = FALSE; 
+ 
+    //Setup the signal handler
+    signal(SIGCLD, sig_child); 
+    signal(SIGINT, sig_cleanup); 
+    signal(SIGQUIT, sig_cleanup); 
+    signal(SIGKILL, sig_cleanup);
+    signal(SIGUSR2, sig_remove);//JY1110 
+    
+    if((sockfd = socket(AF_INET,SOCK_STREAM,0)) < 0 )
+    {
+        //perror("can't open stream socket:");
+        exit(0);
+    }
+    
+    bzero((char *)&serv_addr , sizeof(serv_addr));
+    serv_addr.sin_family        = AF_INET;
+    serv_addr.sin_addr.s_addr   = htonl(INADDR_ANY);
+    serv_addr.sin_port          = htons(PNT_SVR_PORT_LPR);
+
+    
+    if(bind(sockfd,(struct sockaddr *)&serv_addr , sizeof(serv_addr)) < 0 )
+    {
+        //perror("can't bind:");
+        exit(0);
+    }
+    /*JY1111*/
+    int windowsize=2920;
+    setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+
+#if 1
+    int currentpid=getpid();
+    FILE *pidfileread;
+
+    if((pidfileread=fopen("/var/run/lpdparent.pid", "r")) == NULL)
+    {
+		pidfileread=fopen("/var/run/lpdparent.pid", "w");
+		fprintf(pidfileread, "%d", currentpid);
+		fclose(pidfileread);
+    }
+    else{
+		//printf("another lpd daemon exists!!\n");
+		fclose(pidfileread);
+               	exit(0);
+    }
+#endif    
+    listen(sockfd , 15);
 
-	if( Lockfile_DYN == 0 ){
-		LOGERR_DIE(LOG_INFO) _("No LPD lockfile specified!") );
+#ifdef Raw_Printing_with_ASUS //Lisa
+	if ((netfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) < 0)
+	{
+//		syslog(LOGOPTS, "socket: %m\n");
+		exit(1);
 	}
-
-	/* chdir to the root directory */
-	if( chdir( "/" ) == -1 ){
-		Errorcode = JABORT;
-		LOGERR_DIE(LOG_ERR) "cannot chdir to /");
+	if (setsockopt(netfd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0)
+	{
+//		syslog(LOGOPTS, "setsocketopt: %m\n");
+		exit(1);
 	}
-	pid = Get_lpd_pid();
-#if defined(__CYGWIN__)
-	if( (pid > 0) && ( kill(pid,0) || (errno != ESRCH) )) {
-		DIEMSG( _("Another print spooler active, possibly lpd process '%d'"),
-  				pid );
+	netaddr.sin_port = htons(BASEPORT);
+	netaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	memset(netaddr.sin_zero, 0, sizeof(netaddr.sin_zero));
+	if (bind(netfd, (struct sockaddr*) &netaddr, sizeof(netaddr)) < 0)
+	{
+		//syslog(LOGOPTS, "bind: %m\n");
+		exit(1);
 	}
-	lockfd = Lock_lpd_pid();
-	if( lockfd < 0 ){
-		DIEMSG( _("cannot open or lock lockfile - %s"), Errormsg(errno) );
+	if (listen(netfd, 5) < 0)
+	{
+		//syslog(LOGOPTS, "listen: %m\n");
+		exit(1);
 	}
-	Set_lpd_pid( lockfd );
-	close( lockfd );
-	lockfd = -1;
-#else
-	lockfd = Lock_lpd_pid();
-	if( lockfd < 0 ){
-		DIEMSG( _("Another print spooler active, possibly lpd process '%d'"),
-  				pid );
-	}
-	Set_lpd_pid( lockfd );
+	//clientlen = sizeof(client);
+	//memset(&client, 0, sizeof(client));
 #endif
 
+#ifdef LPR_with_ASUS//JY1112
+	if((sockfd_ASUS = socket(AF_INET,SOCK_STREAM,0)) < 0 )
 	{
-		char *s;
-		s = Lpd_listen_port_arg;
-		if( ISNULL(s) ) s = Lpd_listen_port_DYN;
-		if( ISNULL(s) ) s = Lpd_port_DYN;
-		if( !ISNULL(s) && safestrcasecmp( s,"off") && strtol(s,0,0) ){
-			sock = Link_listen(s);
-			DEBUG1("lpd: listening socket fd %d",sock);
-			if( sock < 0 ){
-				Errorcode = 1;
-				DIEMSG("Cannot bind to lpd port '%s'", s);
-			}
-		}
-
-		s = Lpd_socket_arg;
-		if( ISNULL(s) ) s = Unix_socket_path_DYN;
-		if( !ISNULL(s) && safestrcasecmp( s,"off") ){
-			unix_sock = Unix_link_listen(s);
-			DEBUG1("lpd: unix listening socket fd %d, path '%s'",unix_sock, s);
-			if( unix_sock < 0 ){
-				Errorcode = 1;
-				DIEMSG("Cannot bind to UNIX socket '%s'", s );
-			}
-		}
+	        //perror("can't open stream socket:");
+	        exit(0);
 	}
-
-	/* setting nonblocking on the listening fd
-	 * will prevent a problem with terminations of connections
-	 * before ACCEPT has completed
-	 *  1. user connects, does the 3 Way Handshake
-	 *  2. before accept() is done,  a RST packet is sent
-	 *  3. a select() will succeed, but the accept() will hang
-	 *  4. if the non-blocking mode is used, then the select will
-	 *     succeed and the accept() will fail
-	 */
-	Set_nonblock_io(sock);
-
-	/*
-	 * At this point you are the server for the LPD port
-	 * you need to fork to allow the regular user to continue
-	 * you put the child in its separate process group as well
-	 */
-	if( (pid = dofork(1)) < 0 ){
-		LOGERR_DIE(LOG_ERR) _("lpd: main() dofork failed") );
-	} else if( pid ){
-		if( Foreground_LPD ){
-			while( (pid = plp_waitpid( pid, &status, 0)) > 0 ){
-				DEBUG1( "lpd: process %d, status '%s'",
-					pid, Decode_status(&status));
-			}
-		}
-		Errorcode = 0;
+    	bzero((char *)&serv_addr_ASUS , sizeof(serv_addr_ASUS));
+    	serv_addr_ASUS.sin_family        = AF_INET;
+    	serv_addr_ASUS.sin_addr.s_addr   = htonl(INADDR_ANY);
+    	serv_addr_ASUS.sin_port          = htons(PNT_SVR_PORT_ASUS);
+
+    	if(bind(sockfd_ASUS,(struct sockaddr *)&serv_addr_ASUS , sizeof(serv_addr_ASUS)) < 0 )
+    	{
+        	//perror("can't bind:");
 		exit(0);
-	}
+   	}
 
-	/* set up the log file and standard environment - do not
-	   fool around with anything but fd 0,1,2 which should be safe
-		as we made sure that the fd 0,1,2 existed.
-    */
-
-	Setup_log( Logfile_LPD );
-
-	Name = "Waiting";
-	setproctitle( "lpd %s", Name  );
-
-	/*
-	 * Write the PID into the lockfile
-	 */
-
-#if defined(__CYGWIN__)
-	lockfd = Lock_lpd_pid();
-	if( lockfd < 0 ) {
-	   DIEMSG( "Can't open lockfile for writing" );
-	}
-	Set_lpd_pid( lockfd );
-	close( lockfd );
-	lockfd = -1;
-#else
-	Set_lpd_pid( lockfd );
+    	setsockopt(sockfd_ASUS, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+
+    	listen(sockfd_ASUS , 15);
+    
+    	/*set the fds*/
+    	nfds=MAX(sockfd, sockfd_ASUS);
+    	FD_ZERO(&afds);
 #endif
+    
+    while(TRUE)
+    {
+	//if (busy) syslog(LOG_NOTICE, "busying %d %d\n", lptstatus.busy, busy);
+
+	if (lptstatus.busy==FALSE) 
+	{	
+		busy=FALSE;
+	}
 
+#ifdef Raw_Printing_with_ASUS //Lisa
+	FD_SET(netfd, &afds);
+#endif
+#ifdef LPR_with_ASUS//JY1112
+	FD_SET(sockfd, &afds);
+	FD_SET(sockfd_ASUS, &afds);
+	memcpy(&rfds, &afds, sizeof(rfds));
 
-	if( Drop_root_DYN ){
-		Full_daemon_perms();
+	if((err_select=select(nfds+1, &rfds, (fd_set *)0, (fd_set *)0, (struct timeval *)0 )) < 0) 
+	{
+//JY1120	printf("select error on sockfd: error=%d\n", errno);
+		/**/
+//		printf("sockfd_FD_ISSET=%d\n", FD_ISSET(sockfd, &rfds));
+//JY1120		printf("sockfd_ASUS FD_ISSET=%d\n", FD_ISSET(sockfd_ASUS, &rfds));
+		/**/
+//		if(errno != 4)//JY1113: delete
+		//syslog(LOG_NOTICE, "select error %d\n", err_select);
+		continue;
 	}
+#endif
+        clilen = sizeof(cli_addr);
 
-	/* establish the pipes for low level processes to use */
-	if( pipe( request_pipe ) == -1 ){
-		LOGERR_DIE(LOG_ERR) _("lpd: pipe call failed") );
+	if(FD_ISSET(sockfd_ASUS, &rfds))
+	{
+		LPRflag = 0;
+		clisockfd   = accept(sockfd_ASUS,(struct sockaddr *)&cli_addr, &clilen);
 	}
-	Max_open(request_pipe[0]); Max_open(request_pipe[1]);
-	DEBUG2( "lpd: fd request_pipe(%d,%d)",request_pipe[0],request_pipe[1]);
-	Lpd_request = request_pipe[1];
-	Set_nonblock_io( Lpd_request );
-
-	Logger_fd = -1;
-	logger_process_pid = -1;
-	if( Logger_destination_DYN ){
-		if( pipe( status_pipe ) == -1 ){
-			LOGERR_DIE(LOG_ERR) _("lpd: pipe call failed") );
-		}
-		Max_open(status_pipe[0]); Max_open(status_pipe[1]);
-		Logger_fd = status_pipe[1];
-		DEBUG2( "lpd: fd status_pipe(%d,%d)",status_pipe[0],status_pipe[1]);
-		logger_process_pid = Start_logger( status_pipe[0] );
-		if( logger_process_pid < 0 ){
-			LOGERR_DIE(LOG_ERR) _("lpd: cannot start initial logger process") );
-		}
+#ifdef LPR_with_ASUS//JY1112 
+	else if(FD_ISSET(sockfd, &rfds))
+	{
+		LPRflag = 1;
+		clisockfd   = accept(sockfd,(struct sockaddr *)&cli_addr, &clilen);
 	}
-
-	/* open a connection to logger */
-	setmessage(0,LPD,"Starting");
-
-	/*
-	 * set up the select parameters
-	 */
-
-	FD_ZERO( &defreadfds );
-	if( sock > 0 ) FD_SET( sock, &defreadfds );
-	if( unix_sock > 0 ) FD_SET( unix_sock, &defreadfds );
-	FD_SET( request_pipe[0], &defreadfds );
-
-	/*
-	 * start waiting for connections from processes
-	 */
-
-	last_time = time( (void *)0 );
- 	server_started_time = 0;
-
-	start_pid = last_fork_pid_value = Start_all(first_scan, &start_fd );
-	Fork_error( last_fork_pid_value );
-	if( start_pid > 0 ){
-		first_scan = 0;
+#endif
+#ifdef Raw_Printing_with_ASUS //Lisa
+	else if(FD_ISSET(netfd, &rfds) && busy==FALSE)
+	{
+		LPRflag = 2;
+		clisockfd = accept(netfd, (struct sockaddr*) &cli_addr, &clilen);
 	}
+#endif
+	else
+        {
+		//syslog(LOG_NOTICE, "No select\n");
+		sleep(2);
+		continue;
+	}
+
+	strcpy(clientaddr , inet_ntoa(cli_addr.sin_addr));
+	
+	if(clisockfd < 0)
+        {
+	     //syslog(LOG_NOTICE, "LPD error: No clisockfd %d\n", LPRflag);
+             continue;
+        }
 
-	do{
-		struct timeval timeval, *timeout;
-		time_t this_time = time( (void *)0 );
-		int elapsed_time;
-
-		/* set up the timeout values */
-
-		timeout = 0;
-		memset(&timeval, 0, sizeof(timeval));
+	/* 2004/09/10 by Joey, process nack in parent for LPR and Remote Prot */	if (busy!=FALSE)
+	{
+		//syslog(LOG_NOTICE, "Printing others 1 %d %d\n", LPRflag, clisockfd);
+		if (LPRflag==0) processReq(clisockfd);
+		else if (LPRflag==1) processReq_LPR(clisockfd);
+		//syslog(LOG_NOTICE, "Printing others %d %d\n", LPRflag, clisockfd);
+		close(clisockfd);
+		// For Raw printing, don't resonse to client while busy
+		sleep(5);
+		continue;
+	}
+	
+        
+        if( (childpid = fork() ) < 0)
+        {
+        }
+        else if(childpid == 0) 
+        {
+		//syslog(LOG_NOTICE, "Printing %d\n", LPRflag);
+
+		if(LPRflag==0) processReq(clisockfd); 
+#ifdef LPR_with_ASUS//JY1114 
+		else if(LPRflag==1) processReq_LPR(clisockfd);
+#endif
+#ifdef Raw_Printing_with_ASUS //Lisa
+		else if(LPRflag == 2) processReq_Raw(clisockfd);
+#endif
+		close(sockfd);
+		close(sockfd_ASUS);
+#ifdef Raw_Printing_with_ASUS //Lisa
+		close(netfd);
+#endif
+        	exit(0);
+        }
+              
+	//syslog(0, "Printing Process %d %d %d\n", busy, lptstatus.busy, childpid);
+
+        //parents process goes on here
+        //remark PRINT("fork -- childpid %d\n",childpid);
+        
+        if(lptstatus.busy == FALSE)
+        {
+            lptstatus.busy = TRUE;
+            busy = TRUE; 
+            strcpy(lptstatus.addr , inet_ntoa(cli_addr.sin_addr));
+            lptstatus.pid = childpid;
+        }
+        close(clisockfd);
+    }
 
-		DEBUG1("lpd: LOOP START");
-		if(DEBUGL3){ int fd; fd = dup(0); LOGDEBUG("lpd: next fd %d",fd); close(fd); };
+}
 
-		DEBUG2( "lpd: Poll_time %d, Force_poll %d, start_pid %d, start_fd %d, Started_server %d",
-			Poll_time_DYN, Force_poll_DYN, start_pid, start_fd, Started_server );
 
-		if(DEBUGL2)Dump_line_list("lpd - Servers_line_list",&Servers_line_list );
+int processReq(int sockfd)
+{
+    
+    char                recv_buf[4]; //buffer to receive header
+    static char         waittime = 1;
+    int                 iCount;
+    struct print_buffer pbuf;
+    char                chPortOpened = FALSE;
+    
+    /***************************************/
+    /**  We reset the printer only when   **/
+    /**  user wants to cancel a job or    **/
+    /**  error occurs                     **/
+    /***************************************/
+    
+    //Process the request from cleint 
+    //return when error or job complete
+    while(TRUE)
+    {
+        LPT_CMD_PKT_HDR     *pHdrCmd  = NULL;
+        LPT_DATA_PKT_HDR    *pHdrData = NULL;
+        LPT_RES_PKT_HDR     pktRes;
+        WORD                body[1];
+        int                 rcv; //records how many bytes being received
+        char                *para_buf = NULL; //buffer to store parameter
+        
+        memset(recv_buf,0,sizeof(recv_buf));
+        iCount = sizeof(recv_buf);
+
+        if(waittime < 5)
+        {
+            waittime ++;
+        }
+
+        //Receive the complete header here
+        while( iCount > 0 )
+        {
+            rcv = RECV(sockfd , recv_buf + (4 - iCount) , iCount , 60);
+
+            if( rcv < 1)
+            {
+                //receive error
+                //PRINT("1. rcv -> %d\n",rcv);
+
+                if(rcv < 0)
+                {
+                	//perror("ERR:");             
+                }
+                
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                
+                return 0;
+            }
+            
+            iCount = iCount - rcv;
+        }
+
+
+        //Check Service ID
+
+        switch(recv_buf[0])
+        {
+            case NET_SERVICE_ID_LPT_EMU:
+                //PRINT("Service ID -> NET_SERVICE_ID_LPT_EMU \n");
+                break;
+            
+            default:
+                //PRINT("Service ID -> Not Supported \n");
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                return(0);
+                break;
+        }
+
+
+        //Check Packet Type
+
+        switch(recv_buf[1])
+        {
+            case NET_PACKET_TYPE_CMD:
+                //PRINT(">>> TYPE_CMD ");
+                pHdrCmd = (LPT_CMD_PKT_HDR *)recv_buf;
+                break;
+            
+            case NET_PACKET_TYPE_RES:
+                //We should not recevice Response Packet in Server
+                //PRINT("Packet Type -> NET_PACKET_TYPE_RES Error!!! \n");
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                return(0);
+                break;
+            
+            case NET_PACKET_TYPE_DATA:
+                //PRINT("$$$ TYPE_DATA ");
+                pHdrData = (LPT_DATA_PKT_HDR *)recv_buf;
+                break;
+            
+            default:
+                //PRINT("Packet Type -> Not Supported \n");
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                return(0);
+                break;
+        
+        }
+
+        if( pHdrCmd != NULL) 
+        {
+            //We receive command
+            
+            para_buf = NULL;
+
+            iCount = pHdrCmd->ParaLength;
+
+	    if (iCount!=0)
+	    {
+             	para_buf = malloc(pHdrCmd->ParaLength);
+            }
+
+	    //PRINT("HdrCmd Length %d\n", iCount);
+
+	    // para_buf may be NULL but this command still work
+	    // 2004/06/07 by Joey
+            if(iCount!=0 && para_buf == NULL)
+            {
+                //perror("malloc error 1:");
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                return(0);
+            }
+
+            while( iCount > 0 )
+            {
+                rcv = RECV(sockfd , (para_buf + (pHdrCmd->ParaLength - iCount )) , iCount , 30);
+
+                if( rcv < 1)
+                {
+                    //receive error
+                    //perror("2. RECV ERR:");             
+                    closesocket(sockfd);
+                    free(para_buf);
+                    if(chPortOpened == TRUE)
+                    {
+                        reset_printer(10);
+                    }
+                    return 0;
+                }
+                
+                iCount = iCount - rcv;
+            }
+
+
+            switch(pHdrCmd->CommandID)
+            {
+                case NET_CMD_ID_OPEN:
+                    //remark PRINT("NET_CMD_ID_OPEN\n"); 
+                                                                                                
+                    /************************************/
+                    /************************************/
+                    /*** TODO: add code here to check ***/
+                    /*** the printer status           ***/
+                    /************************************/
+                    /************************************/
+
+                    pktRes.ServiceID = NET_SERVICE_ID_LPT_EMU;
+                    pktRes.PacketType = NET_PACKET_TYPE_RES;
+                    pktRes.CommandID = NET_CMD_ID_OPEN;
+                    pktRes.ResLength = 2;
+
+                    if(busy == FALSE)
+                    {
+                        int prnstatus=0;
+		        FILE *statusFp = NULL;
+                        
+                        
+                        //remark PRINT("--------lptstatus.busy == FALSE\n"); 
+                        
+                        /* add by James Yeh to support usb printer */
+                        /* 2002/12/25 							   */
+                        
+                        //Open printer port -modified by PaN
+                        fdPRN = open_printer();
+
+                        if(fdPRN == 0)
+                        {
+                            //Failed to open printer port
+                            //PRINT("Can not open lp0 errno -> %d \n",errno);
+                            //perror("ERR:");
+    
+                            //Send header
+                            send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
+                            //Send body
+                            body[0] = ERR_SERVER_LPT_FAIL;
+                            send(sockfd , body , sizeof(body) , 0);
+                            free(para_buf);
+                            return(0);
+                        }
+                        
+                        ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+                        
+                        if(prnstatus != 0)
+                        {
+                            //remark PRINT("prnstatus != 0\n"); 
+                            body[0] = ERR_SERVER_OCCUPIED;
+                            
+                            /*******************************************************************************/
+                            /* why we are using ERR_SERVER_OCCUPIED instead of ERR_SERVER_LPT_FAIL here ?? */
+                            /* Because ERR_SERVER_OCCUPIED will let user try again & again. Using          */
+                            /* ERR_SERVER_LPT_FAIL will fail the reques                                    */
+                            /*******************************************************************************/
+    
+                            //Send header
+                            send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
+                            //Send body 
+                            send(sockfd , body , sizeof(body) , 0);
+                            free(para_buf);
+                            return(0);
+                        }
+                        
+			            statusFp = fopen(STATUS_FILE , "w");
+            
+            			if(statusFp != NULL)
+            			{
+                			fprintf(statusFp,"PRN_CLIENT=\"%s\"\n",lptstatus.addr);
+                			fclose(statusFp);
+            			}
+            			else
+            			{
+                			//perror("Open status file failed: ");
+            			}
+
+                        chPortOpened = TRUE;
+                        
+                        body[0] = ERR_SUCCESS;
+                    }
+                    else
+                    {
+                        //PRINT("*********lptstatus.busy == TRUE\n");
+                        body[0] = ERR_SERVER_OCCUPIED;
+
+                        //Send header
+                        send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
+                        //Send body 
+                        send(sockfd , body , sizeof(body) , 0);
+                        free(para_buf);
+                        return(0);
+                    }
+
+                    //Send header
+                    send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
+                    //Send body 
+                    send(sockfd , body , sizeof(body) , 0);
+
+                    break;
+
+                case NET_CMD_ID_CLOSE:
+                {
+                    char bCancel = FALSE;
+                    
+                     
+                    //remark PRINT("NET_CMD_ID_CLOSE\n");
+
+                    /*****************************************************/
+                    /* Check if user normally or abnormally end this job */
+                    /*                                 James 2002/06/05  */
+                    /*****************************************************/
+                    
+                    if(pHdrCmd->ParaLength != 1) //Length should be 1 byte long
+                    {
+                        //remark PRINT("NET_CMD_ID_CLOSE length error -- %d\n",pHdrCmd->ParaLength);
+                        closesocket(sockfd);
+                        free(para_buf);
+                        if(chPortOpened == TRUE)
+                        {
+                            reset_printer(10);
+                        }
+                        return(0);
+                    }
+                    
+                    //remark PRINT("para_buf[0] - %02X\n",para_buf[0]); 
+                    
+                    if(para_buf[0] == 1)
+                    {
+                        bCancel = TRUE;
+                    }
+                    
+
+                    pktRes.ServiceID = NET_SERVICE_ID_LPT_EMU;
+                    pktRes.PacketType = NET_PACKET_TYPE_RES;
+                    pktRes.CommandID = NET_CMD_ID_CLOSE;
+                    pktRes.ResLength = 2;
+
+                
+                    //Send header
+                    send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
+
+                    //Send body 
+                    body[0] = ERR_SUCCESS;
+                    send(sockfd , body , sizeof(body) , 0);
+
+                    closesocket(sockfd);
+                    free(para_buf);
+                    
+                    //close printer port modified by PaN
+                    sleep(1);
+
+                    if(bCancel == TRUE)
+                    {
+                        //reset printer
+                        //PRINT("Reset Printer\n");
+                        reset_printer(10);
+                    }
+
+                    close(fdPRN); 
+
+                    return(0);                              
+                    break;
+                }//case NET_CMD_ID_CLOSE:
+                    
+                case NET_CMD_ID_READ:
+                {
+                    LPT_DATA_PKT_HDR    pktData;
+                    WORD                len;
+                    int                 res_fread = 0;
+                    PBYTE               pReadbuf;
+
+                    len = (para_buf[1] << 8) + para_buf[0];
+                    
+                    //remark PRINT("NET_CMD_ID_READ len -> %d\n",len);
+
+                    /************************************/
+                    /************************************/
+                    /*** TODO: add code here to read  ***/
+                    /*** the printer port             ***/
+                    /************************************/
+                    /************************************/
+                    
+                    pReadbuf = malloc(len + 1);
+                    
+                    if(pReadbuf == NULL)
+                    {
+                        //perror("malloc error 2:");
+                        closesocket(sockfd);
+                        free(para_buf);
+                        if(chPortOpened == TRUE)
+                        {
+                            reset_printer(10);
+                        }
+                        return(0);
+                    }
+                    
+                    pbuf.len = len;
+                    pbuf.buf = pReadbuf;
+                    //PRINT("Start Read\n");
+                    res_fread = ioctl(fdPRN,LPREADDATA,&pbuf);
+                    //PRINT("End Read\n");
+                    //PRINT("---- res_fread %d\n",res_fread);
+                    
+                    if(res_fread > 0)
+                    {
+                        len = res_fread;
+                        pReadbuf[res_fread]= 0;
+                        //PRINT("*** %s\n",pReadbuf);
+                    }
+                    else
+                    {
+                        len = 0;
+                    }
+
+                    pktData.ServiceID = NET_SERVICE_ID_LPT_EMU;
+                    pktData.PacketType = NET_PACKET_TYPE_DATA;
+                    pktData.DataLength = len; //can not exceed 0xFFFF
+
+                    /**********    Sending Header     **********/
+                    send(sockfd , (const char *)&pktData , sizeof(pktData) , 0);
+                
+                    if( len > 0)
+                    {
+                        /**********    Sending Body       **********/
+                        send(sockfd , (const char *)pReadbuf , len , 0);
+                    }
+                    free(pReadbuf);                     
+                    
+                    break;
+                }
+
+                free(para_buf);
+            }//switch(pHdrCmd->CommandID)
+        }//if( pHdrCmd != NULL) 
+
+
+        if( pHdrData != NULL) 
+        {
+            //We receive Data
+            int     res_fwrite;
+            int     res_total_fwrite;
+            int     write_len;
+            int     total_len;
+            PBYTE   write_buf;
+            int prnstatus=0;
+
+            iCount = pHdrData->DataLength;
+
+            if (iCount!=0)
+	    {
+            	para_buf = malloc(pHdrData->DataLength);
+            }
+            //remark 
+	    //PRINT("pHdrData->DataLength -- %d\n",pHdrData->DataLength);
+
+            if(iCount!=0 && para_buf == NULL)
+            {
+                //perror("malloc error 3:");
+                closesocket(sockfd);
+                if(chPortOpened == TRUE)
+                {
+                    reset_printer(10);
+                }
+                return(0);
+            }
+            
+            //PRINT("DATA HDR OK...\n");
+
+            while( iCount > 0 )
+            {
+                rcv = RECV(sockfd , (para_buf + (pHdrData->DataLength - iCount )) , iCount , 30);
+
+                if( rcv < 1)
+                {
+                    //receive error
+                    //perror("3. RECV ERR:");             
+                    closesocket(sockfd);
+                    free(para_buf);
+                    if(chPortOpened == TRUE)
+                    {
+                        reset_printer(10);
+                    }
+                    return 0;
+                }
+
+                iCount = iCount - rcv;
+            }
+
+
+            //PRINT("DATA BODY OK...\n");
+
+            pbuf.len = pHdrData->DataLength;
+            pbuf.buf = para_buf;
+            
+            write_len = 0;
+            total_len = pHdrData->DataLength;
+            write_buf = para_buf;
+            res_fwrite = 0;
+            res_total_fwrite = 0;
+            
+            //remark PRINT("total_len %d\n",total_len);
+            
+            while(total_len > 0)
+            {
+                if(total_len > 4096)
+                {
+                    pbuf.len = 4096;
+                    pbuf.buf = write_buf;
+                    res_fwrite = ioctl(fdPRN,LPWRITEDATA,&pbuf);
+
+                    if(res_fwrite != 4096)
+                    {
+                        DWORD retry = 0;
+                        
+                        ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+                        
+                        //remark PRINT("prnstatus %d\n",prnstatus);
+
+                        while( ((prnstatus == 0) || (prnstatus & LP_PBUSY)) && (res_fwrite != 4096) && (retry < 3))
+                        {
+                            //remark PRINT("}}}}}}}}}}}} res_fwrite %d\n",res_fwrite);
+                            pbuf.len = 4096 - res_fwrite;
+                            pbuf.buf = &(write_buf[res_fwrite]);
+                            //usleep(500); //why we don't use usleep here ?? becuse usleep will sleep longer then we expect in iBox
+                            sleep(1);
+                            res_fwrite = res_fwrite + ioctl(fdPRN,LPWRITEDATA,&pbuf);
+                            //remark PRINT("}}}}}}}}}}}} res_fwrite %d\n",res_fwrite);
+                            ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+
+                            //remark PRINT("retry %d\n",retry);
+                            retry ++;   
+                        }
+                        
+                    }
+                    
+                    res_total_fwrite = res_total_fwrite + res_fwrite;
+                    
+                    if(res_fwrite != 4096)
+                    {
+                        break;
+                    }
+                    else
+                    {
+                        total_len = total_len - 4096;
+                        if(total_len == 0)
+                        {
+                            //remark PRINT("total_len == 0 \n");
+                            break;
+                        }
+                        write_buf = &(write_buf[4096]);
+                    }
+
+                    //remark PRINT("res_total_fwrite %d -- res_fwrite %d \n",res_total_fwrite,res_fwrite);
+                    
+                }
+                else
+                {
+                    pbuf.len = total_len;
+                    pbuf.buf = write_buf;
+                    res_fwrite = ioctl(fdPRN,LPWRITEDATA,&pbuf);
+
+                    //remark PRINT("PPPPPPP res_fwrite %d\n",res_fwrite);
+                    if(res_fwrite != total_len)
+                    {
+                        DWORD retry = 0;
+
+                        ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+                        //remark PRINT("prnstatus %d\n",prnstatus);
+                        
+                        while( ((prnstatus == 0) || (prnstatus & LP_PBUSY))  && (res_fwrite != total_len) && (retry < 3))
+                        {
+                            pbuf.len = total_len - res_fwrite;
+                            pbuf.buf = &(write_buf[res_fwrite]);
+                            //usleep(500); //why we don't use usleep here ?? becuse usleep will sleep longer then we expect in iBox
+                            sleep(1);
+                            res_fwrite = res_fwrite + ioctl(fdPRN,LPWRITEDATA,&pbuf);
+                            //remark PRINT("}}}}}}}}}}}} res_fwrite %d\n",res_fwrite);
+                            ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+                            //remark PRINT("retry %d\n",retry);
+                            retry ++;   
+                        }
+                        
+                    }
+
+                    res_total_fwrite = res_total_fwrite + res_fwrite;
+                    //remark PRINT("res_total_fwrite %d -- res_fwrite %d \n",res_total_fwrite,res_fwrite);
+                    break;
+                }
+                
+            }
+                
+                
+            //remark PRINT("WritePrint %d - %d bytes\n",res_total_fwrite,pHdrData->DataLength);
+
+            if(res_total_fwrite != pHdrData->DataLength)
+            {
+                int tmp=0;
+                //remark PRINT("res_total_fwrite != pHdrData->DataLength \n");
+                ioctl(fdPRN,LPGETSTATUS,&prnstatus);
+                
+                //remark PRINT("prnstatus %08X \n",prnstatus);
+                
+                if((prnstatus & LP_PERRORP) == 1 ) //Printer off-line
+                {
+                    //remark PRINT("Printer off-line -- prnstatus %d\n",prnstatus);
+                    res_total_fwrite = res_total_fwrite|0x8000;
+                }
+                else
+                {
+                    //remark PRINT("Paper Empty -- prnstatus %d\n",prnstatus);
+                    res_total_fwrite = res_total_fwrite|0x4000;
+                }
+		check_prn_status("BUSY or ERROR", clientaddr);
+            }
+            else{//JY1113 add
+/*JY1113*/
+		check_prn_status("Printing", clientaddr);
+/**/
+            }
+            //remark PRINT("res_total_fwrite %08X\n",res_total_fwrite);
+
+            body[0] = res_total_fwrite;
+
+            pktRes.ServiceID = NET_SERVICE_ID_LPT_EMU;
+            pktRes.PacketType = NET_PACKET_TYPE_RES;
+            pktRes.CommandID = NET_CMD_ID_DATA_RES;
+            pktRes.ResLength = 2;
 
-		/*
-		 * collect zombies.  If one exits, you can set last_fork_pid_value
-		 * to 0, as you may now be able to start a process
-		 */
+            //Send header
+            send(sockfd , (const char *)&pktRes , sizeof(pktRes) , 0);
 
-		while( (pid = plp_waitpid( -1, &status, WNOHANG)) > 0 ){
-			DEBUG1( "lpd: process %d, status '%s'",
-				pid, Decode_status(&status));
-			if( pid == logger_process_pid ){
-				/* ARGH! the logger process died */
-				logger_process_pid = -1;
-			}
-			if( pid == start_pid ){
-				start_pid = -1;
-			}
-			last_fork_pid_value = 0;
-		}
+            //Send body 
+            send(sockfd , body , sizeof(body) , 0);
+ 
+            free(para_buf);
+        }//if( pHdrData != NULL) 
+    }
+    //remark PRINT("Thread Over\n");
 
-		/*
-		 * if the Logger process dies, then you have real problems,
-		 * so you need to start it up.
-		 */
-		if( last_fork_pid_value >= 0 && Logger_fd > 0 && logger_process_pid <= 0 ){
-			DEBUG1( "lpd: restarting logger process");
-			last_fork_pid_value = logger_process_pid = Start_logger( status_pipe[0] );
-			Fork_error( last_fork_pid_value );
-			DEBUG1("lpd: logger_process_pid %d", logger_process_pid );
-		}
+    return(0);                              
+    
+}
 
-		/* you really do not want to start up more proceses until you can
-		 */
-		if( last_fork_pid_value < 0 ){
-			goto waitloop;
-		}
 
-		/*
-		 * Check to see if you need to rescan the spool queues
-		 *  - you have done all of the work in the Servers_line_list
-		 *    started by the last scan
-		 *  - it is time to do a new scan
-		 */
-
-		elapsed_time = (this_time - last_time);
-		if( Poll_time_DYN > 0 && start_pid <= 0 ){
-			int doit, scanned_queue_count;
-			DEBUG1("lpd: checking for scan, start_pid %d, start_fd %d, Poll_time_DYN %d, elapsed_time %d, Started_server %d, Force_poll %d",
-				start_fd, start_pid, Poll_time_DYN, elapsed_time, Started_server, Force_poll_DYN );
-			if( elapsed_time >= Poll_time_DYN ){
-				for( scanned_queue_count = doit = 0;
-					scanned_queue_count == 0 && doit < Servers_line_list.count; ++doit ){
-					char *s = Servers_line_list.list[doit];
-					if( s && cval(s) == '.' ) ++scanned_queue_count;
-				}
-				DEBUG1( "lpd: timeout checking for scan,  scanned_queue_count %d", scanned_queue_count);
-				if( scanned_queue_count == 0
-					&& ( Started_server || Force_poll_DYN ) ){
-					last_fork_pid_value = start_pid = Start_all(first_scan, &start_fd );
-					Fork_error( last_fork_pid_value );
-					DEBUG1( "lpd: restarting poll, start_pid %d, start_fd %d", start_pid, start_fd);
-					if( start_fd > 0 ){
-						first_scan = 0;
-						Started_server = 0;
-						last_time = this_time;
-					} else {
-						/* argh! process exhaustion */
-						goto waitloop;
-					}
-				}
-			} else {
-				/* oops... need to wait longer */
-				timeout = &timeval;
-				timeval.tv_sec = Poll_time_DYN - elapsed_time;
-			}
-		}
+void sig_child(int sig)
+{
+    int childpid;
+    
+    childpid = waitpid(-1, NULL , WNOHANG);
+
+    while( childpid > 0)
+    {
+   
+	//syslog(LOG_NOTICE, "sig child: %d\n", childpid); 
+    	//remark PRINT("sig_child %d\n",childpid);
+    
+	    if( lptstatus.pid == childpid )
+    	{
+	        FILE *statusFp = NULL;
+
+        	statusFp = fopen(STATUS_FILE , "w");
+            
+        	if(statusFp != NULL)
+        	{
+            		fprintf(statusFp,"PRN_CLIENT=\"\"\n");
+            		fclose(statusFp);
+        	}
+        	else
+        	{
+            		//perror("Open status file failed: ");
+        	}
+
+
+    	    	/*** Wait 10 seconds here      ***/
+        	/*** Because some slow printer ***/
+        	/*** need some time to consume ***/
+        	/*** the data...               ***/
+        	sleep(10);
+        
+        	lptstatus.busy = FALSE;
+        	lptstatus.pid  = 0;
+		check_prn_status(ONLINE, "");
+           
+    	}
 
-		/*
-		 * check to see if there are any spool queues that require
-		 * service. This is the case when
-		 *  - time since last startup was non-zero
-		 *  - Servers_line_list has an entry
-		 *  OR you have had a forced startup request
-		 */
-		if( Servers_line_list.count ){
-			int number_of_servers = Countpid();
-			int server_processes_started = 0;
-			int doit;
-			char *server_to_start = 0;
-			int forced_start = 0;
-			elapsed_time = this_time - server_started_time;
-			/* find the first entry WITHOUT a '.' as first character */
-			for( forced_start = doit = 0; !forced_start && doit < Servers_line_list.count; ++doit ){
-				server_to_start = Servers_line_list.list[doit];
-				if( server_to_start && cval(server_to_start) != '.' ){
-					forced_start = 1;
-					break;
-				}
-				server_to_start = 0;
-			}
-			while( (elapsed_time > Poll_start_interval_DYN || forced_start )
-				&& Servers_line_list.count > 0 && server_processes_started < Poll_servers_started_DYN
-				&& number_of_servers + server_processes_started < max_servers-4 ){
-				DEBUG1("lpd: elapsed time %d, server_started_time %d, max_servers %d, number_of_servers %d, started %d",
-					elapsed_time, server_started_time, max_servers, number_of_servers, server_processes_started );
-
-				/* find the first entry WITHOUT a '.' as first character */
-				for( forced_start = doit = 0; doit < Servers_line_list.count; ++doit ){
-					server_to_start = Servers_line_list.list[doit];
-					if( server_to_start && cval(server_to_start) != '.' ){
-						forced_start = 1;
-						break;
-					}
-					server_to_start = 0;
-				}
-				/* Ok, then settle for the first entry */
-				if( !server_to_start ){
-					doit = 0;
-					server_to_start = Servers_line_list.list[doit];
-					if( cval(server_to_start) == '.' ) ++server_to_start;
-				}
-				if( !ISNULL(server_to_start) ){
-					server_started_time = this_time;
-					DEBUG1("lpd: starting server '%s'", server_to_start );
-					Free_line_list(&args);
-					Set_str_value(&args,PRINTER,server_to_start);
-					last_fork_pid_value = pid = Start_worker( "queue",&args, 0 );
-					Fork_error( last_fork_pid_value );
-					Free_line_list(&args);
-					if( pid > 0 ){
-						Remove_line_list( &Servers_line_list, doit );
-						Started_server = 1;
-						server_started_time = this_time;
-						if( forced_start ){
-							++number_of_servers;
-						} else {
-							++server_processes_started;
-						}
-					} else {
-						/* argh! process exhaustion */
-						goto waitloop;
-					}
-				} else {
-					/* empty line... */
-					Remove_line_list( &Servers_line_list, doit );
-				}
-			}
-		}
-		/* we see if we have any work to do
-		 * and then schedule a timeout if necessary to start a process
-		 * NOTE: if the Poll_start_interval value is 0,
-		 * then we will wait until a process exits
-		 */
-		if( Servers_line_list.count > 0 && Poll_start_interval_DYN ){
-			int time_left;
-			elapsed_time = this_time - server_started_time;
-			time_left = Poll_start_interval_DYN - elapsed_time;
-			if( time_left < 0 ) time_left = 0;
-			timeout = &timeval;
-			if( timeval.tv_sec == 0 || timeval.tv_sec > time_left  ){
-				timeval.tv_sec = time_left;
-			}
-		}
+    	childpid = waitpid(-1, NULL , WNOHANG);
+	}
 
- waitloop:
-		/*
-		 * the place where we actually do some waiting
-		 */
-
-
-		DEBUG1("lpd: Started_server %d, last_fork_pid_value %d, active servers %d, max %d",
-			Started_server, last_fork_pid_value, Countpid(), max_servers );
-		/* do not accept incoming call if no worker available */
-		readfds = defreadfds;
-		if( Countpid() >= max_servers || last_fork_pid_value < 0 ){
-			DEBUG1( "lpd: not accepting requests" );
-			if( sock > 0 ) FD_CLR( sock, &readfds );
-			if( unix_sock > 0 ) FD_CLR( unix_sock, &readfds );
-			timeval.tv_sec = 10;
-			timeout = &timeval;
-		}
+   	//remark PRINT("waitpid -- childpid%d\n",childpid); 
+    
+}
 
-		max_socks = sock+1;
-		if( request_pipe[0] >= max_socks ){
-			max_socks = request_pipe[0]+1;
-		}
-		if( start_fd > 0 ){
-			FD_SET( start_fd, &readfds );
-			if( start_fd >= max_socks ){
-				max_socks = start_fd+1;
-			}
-		}
+void sig_cleanup(int sig)
+{
+    //remark PRINT("sig_cleanup\n");
+    exit(0);
+}
 
-		DEBUG1( "lpd: starting select timeout '%s', %d sec, max_socks %d",
-		timeout?"yes":"no", (int)(timeout?timeout->tv_sec:0), max_socks );
-		if(DEBUGL2){
-			int i;
-			for(i=0; i < max_socks; ++i ){
-				if( FD_ISSET( i, &readfds ) ){
-					LOGDEBUG( "lpd: waiting for fd %d to be readable", i );
-				}
-			}
-		}
-		Setup_waitpid_break();
-		errno = 0;
-		fd_available = select( max_socks,
-			FD_SET_FIX((fd_set *))&readfds,
-			FD_SET_FIX((fd_set *))0,
-			FD_SET_FIX((fd_set *))0, timeout );
-		err = errno;
-		Setup_waitpid();
-		if(DEBUGL1){
-			int i;
-			LOGDEBUG( "lpd: select returned %d, error '%s'",
-				fd_available, Errormsg(err) );
-			for(i=0; i < max_socks; ++i ){
-				if( FD_ISSET( i, &readfds ) ){
-					LOGDEBUG( "lpd: fd %d readable", i );
-				}
-			}
-		}
-		/* if we got a SIGHUP then we reread configuration */
-		if( Reread_config || !Use_info_cache_DYN ){
-			DEBUG1( "lpd: rereading configuration" );
-			/* we need to force the LPD logger to use new printcap information */
-			if( Reread_config ){
-				if( logger_process_pid > 0 ) kill( logger_process_pid, SIGINT );
-				setmessage(0,LPD,"Restart");
-				Reread_config = 0;
-			}
-			Setup_configuration();
-		}
-		/* mark this as a timeout */
-		if( fd_available < 0 ){
-			if( err != EINTR ){
-				errno = err;
-				LOGERR_DIE(LOG_ERR) _("lpd: select error!"));
-				break;
-			}
-			continue;
-		} else if( fd_available == 0 ){
-			DEBUG1( "lpd: signal or time out, last_fork_pid_value %d", last_fork_pid_value );
-			/* we try to fork now */
-			if( last_fork_pid_value < 0 ) last_fork_pid_value = 1;
-			continue;
-		}
-		if( sock > 0 && FD_ISSET( sock, &readfds ) ){
-#if defined(HAVE_SOCKLEN_T)
-			socklen_t len;
-#else
-			int len;
-#endif
-			len = sizeof( sinaddr );
-			newsock = accept( sock, &sinaddr, &len );
-			err = errno;
-			DEBUG1("lpd: connection fd %d", newsock );
-			if( newsock > 0 ){
-#if defined(TCPWRAPPERS)
-/*
- * libwrap/tcp_wrappers:
- * draht@suse.de, Mon Jan 28 2002
- */
+//JY1110
+void sig_remove(int sig)
+{
+	if(lptstatus.pid != 0){
+		kill(lptstatus.pid, SIGKILL);
+	}
+	else
+		return;
+}
 
-			    struct request_info wrap_req;
 
-			    request_init(&wrap_req, RQ_DAEMON, "lpd" , RQ_FILE, newsock, NULL);
-			    fromhost(&wrap_req);
-			    openlog("lpd", LOG_PID, LOG_LPR); /* we syslog(3) initialized, no closelog(). */
-			    if (hosts_access(&wrap_req)) {
-				/* We accept. */
-				syslog(LOG_INFO, "connection from %s", eval_client(&wrap_req));
-#endif
-
-				pid = Start_worker( "server", &args, newsock );
-				if( pid < 0 ){
-					LOGERR(LOG_INFO) _("lpd: fork() failed") );
-					Write_fd_str( newsock, "\002Server load too high\n");
-				} else {
-					DEBUG1( "lpd: listener pid %d running", pid );
-				}
-#if defined(TCPWRAPPERS)
-			    } else { /* we do not accept the connection: */
-				syslog(LOG_WARNING, "connection refused from %s", eval_client(&wrap_req));
-			    }
-/* 
- * end libwrap
- */
-#endif
-				close( newsock );
-				Free_line_list(&args);
-			} else {
-				errno = err;
-				LOGERR(LOG_INFO) _("lpd: accept on listening socket failed") );
-			}
-		}
-		if( unix_sock > 0 && FD_ISSET( unix_sock, &readfds ) ){
-#if defined(HAVE_SOCKLEN_T)
-			socklen_t len;
-#else
-			int len;
-#endif
-			len = sizeof( sinaddr );
-			newsock = accept( unix_sock, &sinaddr, &len );
-			err = errno;
-			DEBUG1("lpd: unix socket connection fd %d", newsock );
-			if( newsock > 0 ){
-#if defined(TCPWRAPPERS)
-/*
- * libwrap/tcp_wrappers:
- * draht@suse.de, Mon Jan 28 2002
- */
+int closesocket(int sockfd)
+{
+    //shutdown(sockfd,SHUT_RDWR);
+    return close(sockfd);
+}
 
-			    struct request_info wrap_req;
+/************************************/
+/***  Receive the socket          ***/
+/***  with a timeout value        ***/
+/************************************/
+DWORD RECV(int sockfd , PBYTE pRcvbuf , DWORD dwlen , DWORD timeout)
+{
 
-			    request_init(&wrap_req, RQ_DAEMON, "lpd" , RQ_FILE, newsock, NULL);
-			    fromhost(&wrap_req);
-			    openlog("lpd", LOG_PID, LOG_LPR); /* we syslog(3) initialized, no closelog(). */
-			    if (hosts_access(&wrap_req)) {
-				/* We accept. */
-				syslog(LOG_INFO, "connection from %s", eval_client(&wrap_req));
-#endif
-
-				pid = Start_worker( "server", &args, newsock );
-				if( pid < 0 ){
-					LOGERR(LOG_INFO) _("lpd: fork() failed") );
-					Write_fd_str( newsock, "\002Server load too high\n");
-				} else {
-					DEBUG1( "lpd: listener pid %d running", pid );
-				}
-#if defined(TCPWRAPPERS)
-			    } else { /* we do not accept the connection: */
-				syslog(LOG_WARNING, "connection refused from %s", eval_client(&wrap_req));
-			    }
-/* 
- * end libwrap
- */
-#endif
+    if( waitsock(sockfd , timeout , 0) == 0)
+    {
+        //timeout
+        PRINT("RECV timeout %d\n",timeout);
+        return -1;
+    }
 
-				close( newsock );
-				Free_line_list(&args);
-			} else {
-				errno = err;
-				LOGERR(LOG_INFO) _("lpd: accept on listening socket failed") );
-			}
-		}
-		if( FD_ISSET( request_pipe[0], &readfds ) 
-			&& Read_server_status( request_pipe[0] ) == 0 ){
-			Errorcode = JABORT;
-			LOGERR_DIE(LOG_ERR) _("lpd: Lpd_request pipe EOF! cannot happen") );
-		}
-		if( start_fd > 0 && FD_ISSET( start_fd, &readfds ) ){
-			start_fd = Read_server_status( start_fd );
-		}
-	}while( 1 );
-	Free_line_list(&args);
-	cleanup(0);
-	return(0);
-}
-
-/***************************************************************************
- * Setup_log( char *logfile, int sock )
- * Purpose: to set up a standard error logging environment
- * saveme will prevent STDIN from being clobbered
- *   1.  dup 'sock' to fd 0, close sock
- *   2.  opens /dev/null on fd 1
- *   3.  If logfile is "-" or NULL, output file is alread opened
- *   4.  Open logfile; if unable to, then open /dev/null for output
- ***************************************************************************/
-void Setup_log(char *logfile )
-{
-	struct stat statb;
-
-	close(0); close(1);
-	if (open("/dev/null", O_RDONLY, 0) != 0) {
-	    LOGERR_DIE(LOG_ERR) _("Setup_log: open /dev/null failed"));
-	}
-	if (open("/dev/null", O_WRONLY, 0) != 1) {
-	    LOGERR_DIE(LOG_ERR) _("Setup_log: open /dev/null failed"));
-	}
-
-    /*
-     * open logfile; if it is "-", use STDERR; if Foreground is set, use stderr
-     */
-	if( fstat(2,&statb) == -1 && dup2(1,2) == -1 ){
-		LOGERR_DIE(LOG_ERR) _("Setup_log: dup2(%d,%d) failed"), 1, 2);
-	}
-    if( logfile == 0 ){
-		if( !Foreground_LPD && dup2(1,2) == -1 ){
-			LOGERR_DIE(LOG_ERR) _("Setup_log: dup2(%d,%d) failed"), 1, 2);
-		}
-	} else if( safestrcmp(logfile, "-") ){
-		close(2);
-		if( Checkwrite(logfile, &statb, O_WRONLY|O_APPEND, 0, 0) != 2) {
-			LOGERR_DIE(LOG_ERR) _("Setup_log: open %s failed"), logfile );
-		}
-	}
+    return recv(sockfd , pRcvbuf  , dwlen , 0 );
 }
 
-/***************************************************************************
- * Reinit()
- * Reinitialize the database/printcap/permissions information
- * 1. free any allocated memory
- ***************************************************************************/
 
-void Reinit(void)
+int waitsock(int sockfd , int sec , int usec)
 {
-	Reread_config = 1;
-	(void) plp_signal (SIGHUP,  (plp_sigfunc_t)Reinit);
+    struct timeval  tv;
+    fd_set          fdvar;
+    int             res;
+    
+    FD_ZERO(&fdvar);
+    FD_SET(sockfd, &fdvar);
+    
+    tv.tv_sec  = sec;
+    tv.tv_usec = usec; 
+    
+    res = select( sockfd + 1 , &fdvar , NULL , NULL , &tv);
+    
+    return res;
 }
 
+void reset_printer(int sec)
+{
+    sleep(sec);
+    ioctl(fdPRN,LPRESET);
+}
 
-/***************************************************************************
- * Get_lpd_pid() and Set_lpd_pid()
- * Get and set the LPD pid into the LPD status file
- ***************************************************************************/
 
-int Get_lpd_pid(void)
+/* to check use usb or parport printer */
+/* James Yeh 2002/12/25 02:13	       */
+static int check_par_usb_prn()//JY: 20031104 change to int from void
 {
-	int pid;
-	int lockfd;
-	char *path;
-	struct stat statb;
-
-	path = safestrdup3( Lockfile_DYN,".", Lpd_port_DYN, __FILE__, __LINE__ );
-	pid = -1;
-	lockfd = Checkread( path, &statb );
-	if( lockfd >= 0 ){
-		pid = Read_pid( lockfd, (char *)0, 0  ); 
-	}
-	if( path ) free(path); path = 0;
-	return(pid);
+	char    is_useUsb = TRUE;
+    char    buf[1024];
+    char    *token;
+    FILE    *fp;
+
+    fp=fopen("/proc/sys/dev/parport/parport0/devices/lp/deviceid","r");
+
+    if( fp != NULL)
+    {
+        while ( fgets(buf, sizeof(buf), fp) != NULL )  
+        {
+            if(buf[0] == '\n')
+            {
+                //PRINT("skip empty line\n");
+                continue;
+            }
+    
+            if(strncmp(buf , "status: " , strlen("status: "))   == 0)
+            {
+                token= buf + strlen("status: ");
+//printf("token=%s\n", token);//JY1104                
+                if(token[0] == '0')
+                {
+                    is_useUsb = TRUE;
+//printf("USB\n");//JY1112: delete               
+                }
+                else
+                {
+                    is_useUsb = FALSE;
+//printf("PARALLEL\n");//JY1112: delete               
+                }
+                break;
+            }
+            
+        }
+        
+        fclose(fp);
+    }
+    
+	return(is_useUsb);//JY: 1104
 }
 
-void Set_lpd_pid(int lockfd)
+/*1110test status
+void checkstatus_usb_par()
 {
-	/* we write our PID */
-	if( ftruncate( lockfd, 0 ) ){
-		LOGERR_DIE(LOG_ERR) _("lpd: Cannot truncate lock file") );
+	if(fd_print <= 0 || fd_print == NULL){
+		check_prn_status("Off-line", "");
+	}
+	else {
+		check_prn_status(ONLINE, "");
 	}
-	Server_pid = getpid();
-	DEBUG1( "lpd: writing lockfile fd %d with pid '%d'",lockfd,Server_pid );
-	Write_pid( lockfd, Server_pid, (char *)0 );
 }
+*/
 
-int Lock_lpd_pid(void)
+/*JY1114: check printer status*/
+void check_prn_status(char *status_prn, char *cliadd_prn)
 {
-	int lockfd;
-	char *path;
-	struct stat statb;
-	int euid = geteuid();
-
-	path = safestrdup3( Lockfile_DYN,".", Lpd_port_DYN, __FILE__, __LINE__ );
-	To_euid_root();
-	lockfd = Checkwrite( path, &statb, O_RDWR, 1, 0 );
-	if( lockfd < 0 ){
-		LOGERR_DIE(LOG_ERR) _("lpd: Cannot open lock file '%s'"), path );
+	STATUSFILE=fopen("/var/state/printstatus.txt", "w");
+	if(cliadd_prn == NULL)
+	{
+		fprintf(STATUSFILE, "PRINTER_USER=\"\"\n");
 	}
-#if !defined(__CYGWIN__)
-	fchown( lockfd, DaemonUID, DaemonGID );
-	fchmod( lockfd, (statb.st_mode & ~0777) | 0644 );
-#endif
-	To_euid(euid);
-	if( Do_lock( lockfd, 0 ) < 0 ){
-		close( lockfd );
-		lockfd = -1;
+	else
+	{
+		fprintf(STATUSFILE, "PRINTER_USER=\"%s\"\n", cliadd_prn);
 	}
-	return(lockfd);
+	fprintf(STATUSFILE, "PRINTER_STATUS=\"%s\"\n", status_prn);
+	fclose(STATUSFILE);
+	//strcpy(printerstatus, status_prn);
 }
-
-int Read_server_status( int fd )
+/*JY1114: get printer queue name for LPR*/
+int get_queue_name(char *input)
 {
-	int status, count, found, n;
-	char buffer[LINEBUFFER];
-	char *name;
-	fd_set readfds;	/* for select() */
-	struct timeval timeval;
-	struct line_list l;
-
-	buffer[0] = 0;
-	errno = 0;
-
-	DEBUG1( "Read_server_status: starting" );
+	char QueueName_got[32];
+	char *index1;
+	int rps_i=0, rps_j=0;
+	while((index1 = strrchr(input, ' ')))
+		index1[0] = 0;
+	rps_i = 0;
+	strcpy(QueueName_got, input);
+	//return(strcmp(QueueName_got, "LPRServer"));
+	//by pass queue Name Check
+	return 0;
+}
 
-	Init_line_list(&l);
-	while(1){
-		FD_ZERO( &readfds );
-		FD_SET( fd, &readfds );
-		memset(&timeval,0, sizeof(timeval));
-		status = select( fd+1,
-			FD_SET_FIX((fd_set *))&readfds,
-			FD_SET_FIX((fd_set *))0,
-			FD_SET_FIX((fd_set *))0, &timeval );
-		DEBUG1( "Read_server_status: select status %d", status);
-		if( status == 0 ){
-			break;
-		} else if( status < 0 ){
-			close(fd);
-			fd = 0;
-			break;
-		}
-		status = read(fd,buffer,sizeof(buffer)-1);
-		DEBUG1( "Read_server_status: read status %d", status );
-		if( status <= 0 ){
-			close(fd);
-			fd = -1;
-			break;
-		}
-		buffer[status] = 0;
-		/* we split up read line and record information */
-		Split(&l,buffer,Whitespace,0,0,0,0,0,0);
-		if(DEBUGL1)Dump_line_list("Read_server_status - input", &l );
-		for( count = 0; count < l.count; ++count ){ 
-			name = l.list[count];
-			found = 0;
-			for( n = 0;!found && n < Servers_line_list.count; ++n ){
-				found = !safestrcasecmp( Servers_line_list.list[n], name);
-			}
-			if( !found ){
-				Add_line_list(&Servers_line_list,name,0,0,0);
-			}
-			Started_server = 1;
-		}
-	}
-	if(DEBUGL2)Dump_line_list("Read_server_status - waiting for start",
-			&Servers_line_list );
-	return(fd);
-}
-
-/***************************************************************************
- * void Get_parms(int argc, char *argv[])
- * 1. Scan the argument list and get the flags
- * 2. Check for duplicate information
- ***************************************************************************/
-
- static char *msg[] = {
-	N_("usage: %s [-FV][-D dbg][-L log][-P path][-p port][-R remote LPD TCP/IP destination port]\n"),
-	N_(" Options\n"),
-	N_(" -D dbg      - set debug level and flags\n"),
-	N_(" -F          - run in foreground, log to STDERR\n"),
-	N_(" -L logfile  - append log information to logfile\n"),
-	N_(" -V          - show version info\n"),
-	N_(" -p port     - TCP/IP listen port, 'off' disables TCP/IP listening port (lpd_listen_port)\n"),
-	N_(" -P path     - UNIX socket path, 'off' disables UNIX listening socket (unix_socket_path)\n"),
-	N_(" -R port     - remote LPD server port (lpd_port)\n"),
-	0,
-};
-
-void usage(void)
-{
-	int i;
-	char *s;
-	for( i = 0; (s = msg[i]); ++i ){
-		if( i == 0 ){
-			FPRINTF( STDERR, _(s), Name);
-		} else {
-			FPRINTF( STDERR, "%s", _(s) );
-		}
-	}
-	Parse_debug("=",-1);
-	FPRINTF( STDERR, "%s\n", Version );
-	exit(1);
-}
-
- char LPD_optstr[] 	/* LPD options */
- = "D:FL:VX:p:P:" ;
-
-void Get_parms(int argc, char *argv[] )
-{
-	int option, verbose = 0;
-
-	while ((option = Getopt (argc, argv, LPD_optstr )) != EOF){
-		switch (option) {
-		case 'D': Parse_debug(Optarg, 1); break;
-		case 'F': Foreground_LPD = 1; break;
-		case 'L': Logfile_LPD = Optarg; break;
-		case 'V': ++verbose; break;
-        case 'X': Worker_LPD = Optarg; break;
-		case 'p': Lpd_listen_port_arg = Optarg; break;
-		case 'P': Lpd_socket_arg = Optarg; break;
-		default: usage(); break;
-		}
-	}
-	if( Optind != argc ){
-		usage();
-	}
-	if( verbose ) {
-		FPRINTF( STDERR, "%s\n", Version );
-		if( verbose > 1 ) Printlist( Copyright, 1 );
-		exit(0);
+/*JY1120: send ack*/
+void send_ack_packet(int *talk, int ack)
+{
+	char buffertosend[SMALLBUFFER];
+	buffertosend[0] = ack;
+	buffertosend[1] = 0;
+	//printf("send_ack_packet...\n");//JY1120: delete
+	if( write( *talk, buffertosend, strlen(buffertosend) ) < 0 ) 
+	{		
+		//printf("send_ack_packet: can not write socket...\n");
 	}
 }
 
-/*
- * returns the pid of the process doing the scanning
- */
- 
-int Start_all( int first_scan, int *start_fd )
+/*#######Lisa: Raw printing##########
+ * open printer()
+ * copy stream()
+ * ProcessReq_Raw()
+ ##################################*/
+int open_printer(void)  
 {
-	struct line_list args, passfd;
-	int pid, p[2];
-
-	Init_line_list(&passfd);
-	Init_line_list(&args);
+        int		f;
 
-	DEBUG1( "Start_all: first_scan %d", first_scan );
-	if( pipe(p) == -1 ){
-		LOGERR_DIE(LOG_INFO) _("Start_all: pipe failed!") );
+	if(check_par_usb_prn() == TRUE)
+	{		
+		if ((f=open(LP_DEV(0), O_RDWR)) < 0 ) 
+		{
+			//syslog(LOGOPTS, "%s: %m\n", device);
+		}
 	}
-	Max_open(p[0]); Max_open(p[1]);
-	DEBUG1( "Start_all: fd pipe(%d,%d)",p[0],p[1]);
-
-	Setup_lpd_call( &passfd, &args );
-	Set_str_value(&args,CALL,"all");
-
-	Check_max(&passfd,2);
-	Set_decimal_value(&args,INPUT,passfd.count);
-	passfd.list[passfd.count++] = Cast_int_to_voidstar(p[1]);
-	Set_decimal_value(&args,FIRST_SCAN,first_scan);
-
-	pid = Make_lpd_call( "all", &passfd, &args );
-
-	Free_line_list( &args );
-	passfd.count = 0;
-	Free_line_list(&passfd);
-	close(p[1]);
-	if( pid < 0 ){
-		close( p[0] );
-		p[0] = -1;
+	else
+	{
+		if ((f=open("/dev/lp0",O_RDWR)) < 0)
+		{
+//			syslog(LOGOPTS, "Open Parallel port error");
+		} 
 	}
-	DEBUG1("Start_all: pid %d, fd %d", pid, p[0] );
-	if( start_fd ) *start_fd = p[0];
-	return(pid);
+	return (f);
 }
 
-plp_signal_t sigchld_handler (int signo)
+int copy_stream(int fd,int f)
 {
-	signal( SIGCHLD, SIG_DFL );
-	write(Lpd_request,"\n", 1);
-}
+	int		nread,nwrite;
+	char		buffer[8192];
+	int 		timeout=20, wait;
+	int 		busyflag=0;
 
-void Setup_waitpid (void)
-{
-	signal( SIGCHLD, SIG_DFL );
+	//PRINT("copy_stream\n");
+	while ((nread = read(fd, buffer, sizeof(buffer))) > 0)
+	{
+		int index=0,countread;
+		
+		// nwrite=fwrite(buffer, sizeof(char), nread, f);    
+                /* Lisa:fwrite => write */
+ 		check_prn_status("Printing", clientaddr);  //Add by Lisa
+          
+		while	(index < nread )
+		{
+			countread=nread-index;
+			nwrite=write(f, &buffer[index],countread);
+
+			if (nwrite<0)
+			{					
+	     			logmessage("lpd", "write error : %d\n", errno);
+				check_prn_status("Busy or Error", clientaddr);
+				return(nread);
+			}
+#ifdef REMOVE
+			else if (nwrite==0)
+			{
+	     			syslog(LOG_NOTICE, "write error 4: %d\n", nwrite);
+				check_prn_status("Busy or Error",clientaddr);
+				busyflag=1;
+			}
+#endif
+			else if ((wait=waitsock(f,timeout,0))==0)
+			{
+	     			//logmessage("lpd", "write error %d\n", errno);
+				check_prn_status("Busy or Error",clientaddr);
+				busyflag=1;
+			}
+			else if(wait<0) 
+			{
+	     			logmessage("lpd", "can not write : %d\n", errno);
+				check_prn_status("Busy or Error",clientaddr);
+				return(nread);
+			}
+			else
+			{
+				index+=nwrite;
+
+				if (busyflag==1)
+				{
+					busyflag = 0;
+					check_prn_status("Printing",clientaddr);
+				}
+			}
+		}			                
+	}
+	//(void)fflush(f);
+        check_prn_status(ONLINE,""); //Add by Lisa
+	return (nread);
 }
 
-void Setup_waitpid_break (void)
+void processReq_Raw(int fd)
 {
-	(void) plp_signal_break(SIGCHLD, sigchld_handler);
-}
+	int f1;
 
-void Fork_error( int last_fork_pid_value )
-{
-	DEBUG1("Fork_error: %d", last_fork_pid_value );
-	if( last_fork_pid_value < 0 ){
-		LOGMSG(LOG_CRIT)"LPD: fork failed! LPD not accepting any requests");
+	if (busy == FALSE)
+	{
+		if ((f1 = open_printer()) >= 0)   //modify by Lisa
+		{
+			if (copy_stream(fd, f1) < 0)
+			{
+				//syslog(0, "copy stream err\n");
+			}
+			close(f1);
+		}		
 	}
+	close(fd);
 }
diff -urNBp LPRng-3.8.22/src/common/lpd_control.c LPRng/src/common/lpd_control.c
--- LPRng-3.8.22/src/common/lpd_control.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_control.c	2011-06-09 00:24:03.000000000 +0400
@@ -46,6 +46,7 @@
 
 int Job_control( int *sock, char *input )
 {
+#ifdef REMOVE
 	struct line_list tokens;
 	char error[LINEBUFFER];
 	int tokencount;
@@ -63,7 +64,9 @@ int Job_control( int *sock, char *input
 
 	/* check printername for characters, underscore, digits */
 	Split(&tokens,input,Whitespace,0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DCTRL2)Dump_line_list("Job_control - input", &tokens);
+#endif
 
 	tokencount = tokens.count;
 	if( tokencount < 3 ){
@@ -197,12 +200,14 @@ int Job_control( int *sock, char *input
 	Name = "Job_control";
 	DEBUGF(DCTRL3)( "Job_control: DONE" );
 	Free_line_list(&tokens);
+#endif
 	return(0);
 }
 
 void Do_printer_work( char *user, int action, int *sock,
 	struct line_list *tokens, char *error, int errorlen )
 {
+#ifdef REMOVE
 	int i;
 
 	DEBUGF(DCTRL3)("Do_printer_work: printer '%s', action '%s'",
@@ -226,6 +231,7 @@ void Do_printer_work( char *user, int ac
 			Name = "Do_printer_work";
 		}
 	}
+#endif
 }
 
 /***************************************************************************
@@ -240,6 +246,7 @@ void Do_printer_work( char *user, int ac
 void Do_queue_control( char *user, int action, int *sock,
 	struct line_list *tokens, char *error, int errorlen )
 {
+#ifdef REMOVE
 	char *start, *end;
 	pid_t serverpid;			/* server pid to kill off */
 	struct stat statb;			/* status of file */
@@ -443,7 +450,9 @@ void Do_queue_control( char *user, int a
 	}
 
 	Perm_check_to_list(&l, &Perm_check );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DCTRL2)Dump_line_list("Do_queue_control - perms", &l);
+#endif
 	if( Server_queue_name_DYN ){
 		Set_flag_value(&Spool_control,CHANGE,1);
 	}
@@ -496,7 +505,9 @@ void Do_queue_control( char *user, int a
 	case OP_FLUSH:		Action = _("flushed status"); break;
 	}
 	if( Action ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( 0, ACTION, "%s", Action );
+#endif
 		SNPRINTF( line, sizeof(line)) "%s@%s: %s\n",
 			Printer_DYN, FQDNHost_FQDN, Action );
 		if( Write_fd_str( *sock, line ) < 0 ) cleanup(0);
@@ -566,6 +577,7 @@ void Do_queue_control( char *user, int a
  done:
 	DEBUGF(DCTRL3)( "Do_queue_control: done" );
 	Free_line_list(&l);
+#endif
 	return;
 }
 
@@ -593,17 +605,23 @@ int Do_control_file( int action, int *so
 	Init_line_list(&l);
 	Init_job(&job);
 	Free_line_list(&Sort_order);
+#if defined(JYWENG20031104Scan_queue)
 	if( Scan_queue( &Spool_control, &Sort_order,
 			0,0,0,0,0,0,0,0) ){
 		err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF(error, errorlen)
 			"Do_control_file: cannot read '%s' - '%s'",
 			Spool_dir_DYN, Errormsg(err) );
+#endif
 			return(1);
 	}
+#endif
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DCTRL4)("Do_control_file: total files %d", Sort_order.count );
 	DEBUGFC(DCTRL2)Dump_line_list("Do_control_file - tokens", tokens);
+#endif
 
 	/* scan the files to see if there is one which matches */
 
@@ -614,7 +632,9 @@ int Do_control_file( int action, int *so
 		 */
 		Free_job(&job);
 		Get_hold_file( &job, Sort_order.list[i] );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DCTRL2)Dump_job("Do_control_file - getting info",&job);
+#endif
 		identifier = Find_str_value(&job.info,IDENTIFIER,Value_sep);
 		if( identifier == 0 ) identifier = Find_str_value(&job.info,TRANSFERNAME,Value_sep);
 		if( identifier == 0 ) continue;
@@ -669,7 +689,9 @@ int Do_control_file( int action, int *so
 			if( update_dest ){
 				Set_flag_value(&job.destination,HOLD_TIME,time((void *)0) );
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC held" );
+#endif
 			break;
 		case OP_TOPQ:
 			Set_flag_value(&job.info,HOLD_TIME,0 );
@@ -677,7 +699,9 @@ int Do_control_file( int action, int *so
 			if( update_dest ){
 				Set_flag_value(&job.destination,HOLD_TIME,0 );
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC topq");
+#endif
 			break;
 		case OP_MOVE:
 			Set_str_value(&job.info,MOVE,option);
@@ -685,7 +709,9 @@ int Do_control_file( int action, int *so
 			Set_flag_value(&job.info,PRIORITY_TIME,0 );
 			Set_flag_value(&job.info,DONE_TIME,0 );
 			Set_flag_value(&job.info,REMOVE_TIME,0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC move" );
+#endif
 			break;
 		case OP_RELEASE:
 			Set_flag_value(&job.info,HOLD_TIME,0 );
@@ -694,7 +720,9 @@ int Do_control_file( int action, int *so
 				Set_flag_value(&job.destination,HOLD_TIME,0 );
 				Set_flag_value(&job.destination,ATTEMPT,0 );
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC release" );
+#endif
 			break;
 		case OP_REDO:
 			Set_flag_value(&job.info,HOLD_TIME,0 );
@@ -707,7 +735,9 @@ int Do_control_file( int action, int *so
 				Set_flag_value(&job.destination,DONE_TIME,0 );
 				Set_flag_value(&job.destination,COPY_DONE,0 );
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC redo");
+#endif
 			break;
 		}
 		if( update_dest ){
@@ -721,7 +751,9 @@ int Do_control_file( int action, int *so
 		/* record the last update person */
 		Perm_check_to_list(&l, &Perm_check );
 		if( Set_hold_file(&job,&l,0) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, TRACE, "LPC failed" );
+#endif
 			SNPRINTF( msg, sizeof(msg))
 				_("%s: cannot set hold file '%s'\n"),
 				Printer_DYN, identifier );
@@ -748,6 +780,7 @@ int Do_control_file( int action, int *so
 int Do_control_lpq( char *user, int action,
 	struct line_list *tokens )
 {
+#ifdef REMOVE
 	char msg[LINEBUFFER];			/* message field */
 	int i = 0;
 
@@ -778,6 +811,7 @@ int Do_control_lpq( char *user, int acti
 	case OP_LPRM: Job_remove( sock,  msg ); break;
 	}
 	*/
+#endif
 	return(0);
 }
 
@@ -789,6 +823,7 @@ int Do_control_lpq( char *user, int acti
 int Do_control_status( int *sock,
 	char *error, int errorlen )
 {
+#ifdef REMOVE
 	char msg[SMALLBUFFER];			/* message field */
 	char pr[LINEBUFFER];
 	char pr_status[LINEBUFFER];
@@ -807,9 +842,11 @@ int Do_control_status( int *sock,
 	Get_spool_control( Queue_control_file_DYN, &Spool_control );
 	if( Scan_queue( &Spool_control, &Sort_order, &printable,
 			&held, &move,1,&err,&done,0,0) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error, errorlen)
 			"Do_control_status: cannot read '%s' - '%s'",
 			Spool_dir_DYN, Errormsg(errno) );
+#endif
 		return(1);
 	}
 	Free_line_list(&Sort_order);
@@ -870,6 +907,7 @@ int Do_control_status( int *sock,
 	trunc_str( msg );
 	safestrncat(msg,"\n");
 	if( Write_fd_str( *sock, msg ) < 0 ) cleanup(0);
+#endif
 	return( 0 );
 }
 
@@ -891,7 +929,9 @@ int Do_control_redirect( int *sock,
 	int n = 0;
 
 	/* get the spool entries */
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DCTRL2)Dump_line_list("Do_control_redirect - tokens",tokens);
+#endif
 	switch( tokens->count ){
 	case 3:
 	case 4:
@@ -1070,6 +1110,7 @@ int Do_control_printcap( int *sock )
 	return(0);
 }
 
+#ifdef REMOVE
 int Do_control_defaultq( int *sock )
 {
 	char msg [LINEBUFFER];
@@ -1082,3 +1123,4 @@ int Do_control_defaultq( int *sock )
 
 	return(0);
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/lpd_dispatch.c LPRng/src/common/lpd_dispatch.c
--- LPRng-3.8.22/src/common/lpd_dispatch.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_dispatch.c	2011-06-09 00:23:11.000000000 +0400
@@ -12,6 +12,7 @@
 
 
 #include "lp.h"
+#include "lp_asus.h"
 #include "errorcodes.h"
 #include "getqueue.h"
 #include "getprinter.h"
@@ -29,8 +30,12 @@
 #include "krb5_auth.h"
 #include "lpd_dispatch.h"
 
+extern char busy;
+
 void Dispatch_input(int *talk, char *input )
 {
+	//printf("Input: %x\n", input[0]);
+
 	switch( input[0] ){
 		default:
 			FATAL(LOG_INFO)
@@ -41,6 +46,26 @@ void Dispatch_input(int *talk, char *inp
 			Write_fd_len( *talk, "", 1 );
 			break;
 		case REQ_RECV:
+/*JYWENG20031106status and remove*/
+#if 1
+		//syslog(LOG_NOTICE, "LPR printing: %d\n", busy);
+
+		if(busy != FALSE)
+		{
+			send_ack_packet(talk, ACK_RETRY);//JY1120
+
+			//syslog(LOG_NOTICE, "LPR ACK_RETRY: %d\n", busy);
+
+			return;	
+		}
+/**/
+#endif
+			fd_print = open_printer();
+			if(fd_print < 0)
+			{
+				//printf("device open error\n");//JY1113
+				return;//JY1120: exit
+			}
 			Receive_job( talk, input );
 			break;
 		case REQ_DSHORT:
@@ -55,10 +80,14 @@ void Dispatch_input(int *talk, char *inp
 			Job_control( talk, input );
 			break;
 		case REQ_BLOCK:
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Receive_block_job( talk, input );
+#endif
 			break;
 		case REQ_SECURE:
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Receive_secure( talk, input );
+#endif
 			break;
 #if defined(KERBEROS) && defined(MIT_KERBEROS4)
 		case REQ_K4AUTH:
@@ -68,6 +97,7 @@ void Dispatch_input(int *talk, char *inp
 	}
 }
 
+#ifdef REMOVE
 void Service_all( struct line_list *args )
 {
 	int i, reportfd, fd, printable, held, move, printing_enabled,
@@ -160,6 +190,12 @@ void Service_connection( struct line_lis
 	int port = 0;
 	struct sockaddr sinaddr;
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "lpd_dispatch: Service_connetcion starting...\n");
+fclose(aaaaaa);
+#endif
+
 	memset( &sinaddr, 0, sizeof(sinaddr) );
 	Name = "SERVER";
 	setproctitle( "lpd %s", Name );
@@ -291,3 +327,168 @@ void Service_connection( struct line_lis
 	Dispatch_input(&talk,input);
 	cleanup(0);
 }
+#endif
+
+/***************************************************************************
+ * processReq_LPR(int sockfd)
+ * read input line and decide what to do
+ ***************************************************************************/
+
+void processReq_LPR(int talk)
+{
+	char input[SMALLBUFFER];
+	char buffer[LINEBUFFER];	/* for messages */
+	int len;
+	int status;		/* status of operation */
+	int permission;
+	int port = 0;
+	struct sockaddr sinaddr;
+
+	memset( &sinaddr, 0, sizeof(sinaddr) );
+
+#ifdef REMOVE
+	Name = "Connecting";	
+	setproctitle( "lpd %s", Name );
+	(void) plp_signal (SIGHUP, cleanup );
+
+	if( !(talk = Find_flag_value(args,INPUT,Value_sep)) ){
+		Errorcode = JABORT;
+		FATAL(LOG_ERR)"Service_connection: no talk fd"); 
+	}
+
+	DEBUG1("Service_connection: listening fd %d", talk );
+
+	Free_line_list(args);
+#endif
+
+	/* make sure you use blocking IO */
+	Set_block_io(talk);
+
+	{
+#if defined(HAVE_SOCKLEN_T)
+		socklen_t len;
+#else
+		int len;
+#endif
+		len = sizeof( sinaddr );
+		if( getpeername( talk, &sinaddr, &len ) )
+		{
+			//printf("getpeername failed\n");
+			//LOGERR_DIE(LOG_DEBUG) _("Service_connection: getpeername failed") );
+		}
+	}
+
+	DEBUG1("Service_connection: family %d, "
+#ifdef AF_LOCAL
+		"AF_LOCAL %d,"
+#endif
+#ifdef AF_UNIX
+		"AF_UNIX %d"
+#endif
+	"%s" , sinaddr.sa_family,
+#ifdef AF_LOCAL
+	AF_LOCAL,
+#endif
+#ifdef AF_UNIX
+	AF_UNIX,
+#endif
+	"");
+	if( sinaddr.sa_family == AF_INET ){
+		port = ((struct sockaddr_in *)&sinaddr)->sin_port;
+#if defined(IPV6)
+	} else if( sinaddr.sa_family == AF_INET6 ){
+		port = ((struct sockaddr_in6 * )&sinaddr)->sin6_port;
+#endif
+	} else if( sinaddr.sa_family == 0
+#if defined(AF_LOCAL)
+	 	|| sinaddr.sa_family == AF_LOCAL
+#endif
+#if defined(AF_UNIX)
+	 	|| sinaddr.sa_family == AF_UNIX
+#endif
+		){
+		/* force the localhost address */
+		int len;
+		void *s, *addr;
+		memset( &sinaddr, 0, sizeof(sinaddr) );
+		Perm_check.unix_socket = 1;
+	 	sinaddr.sa_family = Localhost_IP.h_addrtype;
+		len = Localhost_IP.h_length;
+		if( sinaddr.sa_family == AF_INET ){
+			addr = &(((struct sockaddr_in *)&sinaddr)->sin_addr);
+#if defined(IPV6)
+		} else if( sinaddr->sa_family == AF_INET6 ){
+			addr = &(((struct sockaddr_in6 *)&sinaddr)->sin6_addr);
+#endif
+		} else {
+			FATAL(LOG_INFO) _("Service_connection: BAD LocalHost_IP value"));
+			addr = 0;
+		}
+		s = Localhost_IP.h_addr_list.list[0];
+		memmove(addr,s,len);
+	} else {
+		FATAL(LOG_INFO) _("Service_connection: bad protocol family '%d'"), sinaddr.sa_family );
+	}
+
+
+	//printf("port ok\n");
+	DEBUG2("Service_connection: socket %d, ip '%s' port %d", talk,
+		inet_ntop_sockaddr( &sinaddr, buffer, sizeof(buffer) ), ntohs( port ) );
+
+	/* get the remote name and set up the various checks */
+
+	Get_remote_hostbyaddr( &RemoteHost_IP, &sinaddr, 0 );
+	Perm_check.remotehost  =  &RemoteHost_IP;
+	Perm_check.host = &RemoteHost_IP;
+	Perm_check.port =  ntohs(port);
+
+	len = sizeof( input ) - 1;
+	memset(input,0,sizeof(input));
+	//printf("Starting read on fd\n");
+	DEBUG1( "Service_connection: starting read on fd %d", talk );
+
+	status = Link_line_read(ShortRemote_FQDN,&talk,
+		Send_job_rw_timeout_DYN,input,&len);
+	if( len >= 0 ) input[len] = 0;
+	DEBUG1( "Service_connection: read status %d, len %d, '%s'",
+		status, len, input );
+	if( len == 0 ){
+		DEBUG3( "Service_connection: zero length read" );
+		cleanup(0);
+	}
+	if( status ){
+		LOGERR_DIE(LOG_DEBUG) _("Service_connection: cannot read request") );
+	}
+	if( len < 2 ){
+		FATAL(LOG_INFO) _("Service_connection: bad request line '%s', from '%s'"),
+			input, inet_ntop_sockaddr( &sinaddr, buffer, sizeof(buffer) ) );
+	}
+
+	/* read the permissions information */
+#ifdef REMOVE
+	if( Perm_filters_line_list.count ){
+		Free_line_list(&Perm_line_list);
+		Merge_line_list(&Perm_line_list,&RawPerm_line_list,0,0,0);
+		Filterprintcap( &Perm_line_list, &Perm_filters_line_list, "");
+	}
+   
+	Perm_check.service = 'X';
+
+	permission = Perms_check( &Perm_line_list, &Perm_check, 0, 0 );
+	if( permission == P_REJECT ){
+		DEBUG1("Service_connection: talk socket '%d' no connect perms", talk );
+		Write_fd_str( talk, _("\001no connect permissions\n") );
+		cleanup(0);
+	}
+#endif
+	//printf("Dispatch command\n");
+	Dispatch_input(&talk,input);
+/*JY1111*/
+//	check_prn_status(ONLINE, "");
+/**/
+	if (busy==FALSE) cleanup(0);
+}
+
+
+
+
diff -urNBp LPRng-3.8.22/src/common/lpd_jobs.c LPRng/src/common/lpd_jobs.c
--- LPRng-3.8.22/src/common/lpd_jobs.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_jobs.c	2011-06-09 00:23:35.000000000 +0400
@@ -45,6 +45,7 @@
 
 /**** ENDINCLUDE ****/
 
+#ifdef REMOVE
 /***************************************************************************
  * Commentary:
  * Patrick Powell Thu May 11 09:26:48 PDT 1995
@@ -193,10 +194,12 @@ int cmp_server( const void *left, const
 	r = ((struct line_list **)right)[0];
 	tl = Find_flag_value(l,DONE_TIME,Value_sep);
 	tr = Find_flag_value(r,DONE_TIME,Value_sep);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL5)Dump_line_list("cmp_server - l",l);
 	if(DEBUGL5)Dump_line_list("cmp_server - r",r);
 	DEBUG5("cmp_server: tl %d, tr %d, cmp %d, p %d",
 		tl, tr, tl - tr, (int)(p!=0) );
+#endif
 	return( tl - tr );
 }
 
@@ -242,6 +245,7 @@ void Get_subserver_pc( char *printer, st
 		Find_str_value(subserver_info,FORWARDING,Value_sep) );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Dump_subserver_info()
  *  dump the server information list
@@ -255,9 +259,12 @@ void Dump_subserver_info( char *title, s
 		title,	l->count );
 	for( i = 0; i < l->count; ++i ){
 		SNPRINTF(buffer,sizeof(buffer))"server %d",i);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		Dump_line_list_sub(buffer,(struct line_list *)l->list[i]);
+#endif
 	}
 }
+#endif
 
 /***************************************************************************
  * Get_subserver_info()
@@ -278,7 +285,9 @@ void Get_subserver_info( struct line_lis
 	DEBUG1("Get_subserver_info: old_order '%s', list '%s'",old_order, list);
 	Split(&server_order,old_order,File_sep,0,0,0,1,0,0);
 	Split(&server_order,     list,File_sep,0,0,0,1,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("Get_subserver_info - starting",&server_order);
+#endif
 
 	/* get the info of printers */
 	for( i = 0; i < server_order.count; ++i ){
@@ -299,7 +308,9 @@ void Get_subserver_info( struct line_lis
 	}
 	Free_line_list(&server_order);
 	Free_line_list(&server);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_subserver_info("Get_subserver_info - starting order",order);
+#endif
 }
 
 /***************************************************************************
@@ -321,8 +332,10 @@ char *Make_temp_copy( char *srcfile, cha
 	destfd = Make_temp_fd_in_dir(&path, destdir);
 	unlink(path);
 	if( link( srcfile, path ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Make_temp_copy: link '%s' to '%s' failed, '%s'",
 			srcfile, path, Errormsg(errno) );
+#endif
 		srcfd = Checkread(srcfile, &statb );
 		if( srcfd < 0 ){
 			LOGERR(LOG_INFO)"Make_temp_copy: open '%s' failed", srcfile );
@@ -556,7 +569,9 @@ int Do_queue_jobs( char *name, int subse
 	}
 
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_subserver_info("Do_queue_jobs - after setup",&servers);
+#endif
 
 	if(DEBUGL4){ int fdx; fdx = dup(0);
 		LOGDEBUG("Do_queue_jobs: after subservers next fd %d",fdx);close(fdx);};
@@ -578,7 +593,9 @@ int Do_queue_jobs( char *name, int subse
 		/* fix up the sort stuff */
 		Free_job(&job);
 		Get_hold_file(&job,Sort_order.list[i] );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL3)Dump_job("Do_queue_jobs - info", &job);
+#endif
 
 		/* debug output */
 		mod = 0;
@@ -652,8 +669,10 @@ int Do_queue_jobs( char *name, int subse
 				}
 				Set_flag_value(sp,CHANGE,0);
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL1) Dump_subserver_info( "Do_queue_jobs - rescan",
 				&servers );
+#endif
 
 			/* check for changes to spool control information */
 			plp_unblock_all_signals( &oblock);
@@ -668,8 +687,10 @@ int Do_queue_jobs( char *name, int subse
 			}
 		}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4) Dump_line_list("Do_queue_jobs - sort order printable",
 			&Sort_order );
+#endif
 
 		Remove_done_jobs();
 
@@ -684,8 +705,10 @@ int Do_queue_jobs( char *name, int subse
 		destination = use_subserver = job_to_do = -1;
 		working =  destinations = chooser_did_not_find_server = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL2) Dump_subserver_info("Do_queue_jobs- checking for server",
 			&servers );
+#endif
 		for( j = 0; j < servers.count; ++j ){
 			sp = (void *)servers.list[j];
 			pid = Find_flag_value(sp,SERVER,Value_sep);
@@ -709,7 +732,9 @@ int Do_queue_jobs( char *name, int subse
 				Sort_order.list[job_index] );
 			Get_hold_file( &job, Sort_order.list[job_index] );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL4)Dump_job("Do_queue_jobs: job ",&job);
+#endif
 			if( job.info.count == 0 ) continue;
 
 			/* check to see if active */
@@ -977,14 +1002,18 @@ int Do_queue_jobs( char *name, int subse
 			if( chooser_did_not_find_server ){
 				setstatus(0, "chooser did not find subserver, waiting %d sec",
 					Chooser_interval_DYN );
+#ifdef ORIGINAL_DEBUG //JY@1020
 				Wait_for_subserver( Chooser_interval_DYN, &servers );
+#endif
 			} else if( working ){
 				if( servers.count > 1 ){
 					setstatus(0, "waiting for server queue process to exit" );
 				} else {
 					setstatus(0, "waiting for subserver to exit" );
 				}
+#ifdef ORIGINAL_DEBUG //JY@1020
 				Wait_for_subserver( 0, &servers );
+#endif
 			}
 			continue;
 		}
@@ -1055,13 +1084,17 @@ int Do_queue_jobs( char *name, int subse
 			}
 			Set_str_value(&jcopy.info,OPENNAME,0);
 			Set_str_value(&jcopy.info,HF_NAME,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL2)Dump_job("Do_queue_jobs: subserver jcopy", &jcopy );
+#endif
 
 			fail = 0;
 			for( i = 0; i < jcopy.datafiles.count; ++i ){
 				datafile = (void *)jcopy.datafiles.list[i];
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if(DEBUGL3)Dump_line_list("Do_queue_jobs - copying datafiles",
 					datafile);
+#endif
 				from = Find_str_value(datafile,TRANSFERNAME,Value_sep);
 				path = Make_temp_copy( from, sd );
 				DEBUG3("Do_queue_jobs: sd '%s', from '%s', path '%s'",
@@ -1102,7 +1135,9 @@ int Do_queue_jobs( char *name, int subse
 				Free_job(&jcopy);
 				continue;
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL2)Dump_job("Do_queue_jobs: subserver jcopy new", &jcopy );
+#endif
 
 			/* set up the new context */
 			safestrncpy(savename,Printer_DYN);
@@ -1141,9 +1176,11 @@ int Do_queue_jobs( char *name, int subse
 			Update_status(&job, JSUCC);
 
 			Set_str_value(sp,IDENTIFIER,id);
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setstatus(&job, "transfer '%s' to subserver '%s' finished", id, pr );
 			setmessage(&job,STATE,"COPYTO %s",pr);
 			setstatus(&job, "starting subserver '%s'", pr );
+#endif
 			pid = Fork_subserver( &servers, use_subserver, 0 );
 			jobs_printed = 1;
 		} else {
@@ -1203,6 +1240,7 @@ int Do_queue_jobs( char *name, int subse
 	return(0);
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Remote_job()
  * Send a job to a remote server.  This code is actually trickier
@@ -1257,9 +1295,13 @@ int Remote_job( struct job *job, int lpd
 	Errorcode = status = 0;
 
 	Copy_job(&jcopy,job);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2)Dump_job("Remote_job - jcopy", &jcopy );
+#endif
 	if( lpd_bounce ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL2) Dump_job( "Remote_job - before filtering", &jcopy );
+#endif
 		tempfd = Make_temp_fd(&tempfile);
 
 		old_lp_value = safestrdup(Find_str_value( &PC_entry_line_list, "lp", Value_sep),
@@ -1327,15 +1369,19 @@ int Remote_job( struct job *job, int lpd
 				_("Remote_job: %d datafiles and only allowed %d"),
 					n, Max_datafiles_DYN );
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage(job,STATE,"SENDING OLDID=%s NEWID=%s DEST=%s@%s",
 		oldid, newid, RemotePrinter_DYN, RemoteHost_DYN );
 	if(DEBUGL3)Dump_job("Send_job - after Fix_control", &jcopy );
+#endif
 	status = Send_job( &jcopy, job, Connect_timeout_DYN, Connect_interval_DYN,
 		Max_connect_interval_DYN, Send_job_rw_timeout_DYN, 0 );
 	DEBUG1("Remote_job: %s, status '%s'", id, Link_err_str(status) );
 	buffer[0] = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2)Dump_job("Remote_job - final jcopy value", &jcopy );
+#endif
  done:
 	s = 0;
 	if( status ){
@@ -1397,6 +1443,7 @@ int Remote_job( struct job *job, int lpd
  exit:
 	return( status );
 }
+#endif
 
 /***************************************************************************
  * Local_job()
@@ -1412,7 +1459,9 @@ int Local_job( struct job *job, char *id
 	status_fd = fd = -1;
 
 	DEBUG1("Local_job: starting %s", id );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage(job,STATE,"PRINTING");
+#endif
 	Errorcode = status = 0;
 	Set_str_value(&job->info,PRSTATUS,0);
 	Set_str_value(&job->info,ERROR,0);
@@ -1424,10 +1473,12 @@ int Local_job( struct job *job, char *id
 
 	if( Accounting_file_DYN && Local_accounting_DYN ){
 		SETSTATUS(job)"accounting at start");
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( Accounting_start_DYN ){
 			status = Do_accounting( 0,
 				Accounting_start_DYN, job, Connect_interval_DYN );
 		}
+#endif
 
 		DEBUG1("Local_job: accounting status %s", Server_status(status) );
 		if( status ){
@@ -1496,10 +1547,12 @@ int Local_job( struct job *job, char *id
 	Set_str_value(&job->info,PRSTATUS,Server_status(status));
 	if( Accounting_file_DYN && Local_accounting_DYN ){
 		SETSTATUS(job)"accounting at end");
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( Accounting_end_DYN ){
 			Do_accounting( 1, Accounting_end_DYN, job,
 				Connect_interval_DYN );
 		}
+#endif
 	}
 	SETSTATUS(job)"finished '%s', status '%s'", id, Server_status(status));
 
@@ -1528,8 +1581,22 @@ int Fork_subserver( struct line_list *se
 	Set_flag_value(parms,SUBSERVER,use_subserver);
 	DEBUG1( "Fork_subserver: starting '%s'", pr );
 	if( use_subserver > 0 ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "+++++++++++++++++++++++++++++++++++++++++++++\n");
+fprintf(aaaaaa, "Fork_subserver: Start_worker(queue)\n");
+fprintf(aaaaaa, "+++++++++++++++++++++++++++++++++++++++++++++\n");
+fclose(aaaaaa);
+#endif
 		pid = Start_worker( "queue",parms, 0 );
 	} else {
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "+++++++++++++++++++++++++++++++++++++++++++++\n");
+fprintf(aaaaaa, "Fork_subserver: Start_worker(printer)\n");
+fprintf(aaaaaa, "+++++++++++++++++++++++++++++++++++++++++++++\n");
+fclose(aaaaaa);
+#endif
 		pid = Start_worker( "printer",parms, 0 );
 	}
 
@@ -1542,6 +1609,7 @@ int Fork_subserver( struct line_list *se
 	return( pid );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * struct server_info *Wait_for_subserver( struct line_list *servers,
  *     int block )
@@ -1610,7 +1678,9 @@ void Wait_for_subserver( int timeout, st
 				pid, Sigstr(sigval));
 			status = JABORT;
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4) Dump_subserver_info("Wait_for_subserver", servers );
+#endif
 
 		for( found = i = 0; !found && i < servers->count; ++i ){
 			sp = (void *)servers->list[i];
@@ -1651,8 +1721,10 @@ void Wait_for_subserver( int timeout, st
 			FATAL(LOG_ERR)
 				_("Wait_for_subserver: Mergesort failed") );
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4) Dump_subserver_info(
 			"Wait_for_subserver: after sorting", servers );
+#endif
 	}
 	if( !done ){
 		/* we need to unblock signals and wait for event */
@@ -1667,6 +1739,7 @@ void Wait_for_subserver( int timeout, st
 
 	Free_job(&job);
 }
+#endif
 
 /***************************************************************************
  * int Decode_transfer_failure( int attempt, struct job *job, int status )
@@ -1783,7 +1856,9 @@ void Update_status( struct job *job, int
 
 	id = Find_str_value(&job->info,IDENTIFIER,Value_sep);
 	if( !id ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL1)Dump_job("Update_status - no ID", job );
+#endif
 		return;
 	}
 
@@ -1796,13 +1871,17 @@ void Update_status( struct job *job, int
 			Set_decimal_value(destination,SERVER,0);
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage(job,STATE,"EXITSTATUS %s", Server_status(status));
+#endif
 
  again:
 	DEBUG1("Update_status: again - status '%s', id '%s', dest id '%s'",
 		Server_status(status), id, did );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage(job,STATE,"PROCESSSTATUS %s", Server_status(status));
+#endif
 	switch( status ){
 		/* hold the destination stuff */
 	case JHOLD:
@@ -1817,7 +1896,9 @@ void Update_status( struct job *job, int
 		break;
 
 	case JSUCC:	/* successful, remove job */
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL3)Dump_job("Update_status - JSUCC start", job );
+#endif
 		if( destination ){
 			done = 0;
 			copies = Find_flag_value(&job->info,SEQUENCE,Value_sep);
@@ -1878,7 +1959,9 @@ void Update_status( struct job *job, int
 				}
 				if( copy >= copies ){
 					Set_flag_value(&job->info,DONE_TIME,time((void *)0));
+#ifdef ORIGINAL_DEBUG //JY@1020
 					Sendmail_to_user( status, job );
+#endif
 					setstatus( job, "%s@%s: job '%s' printed",
 						Printer_DYN, FQDNHost_FQDN, id );
 				} else {
@@ -1892,7 +1975,9 @@ void Update_status( struct job *job, int
 			if( hf_name ){
 				Set_flag_value(&job->info,REMOVE_TIME,time((void *)0));
 				Set_hold_file( job, 0, 0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if(DEBUGL3)Dump_job("Update_status - done_job", job );
+#endif
 				if( (Save_when_done_DYN || Done_jobs_DYN || Done_jobs_max_age_DYN) ){
 					setstatus( job, _("job '%s' saved"), id );
 					++Done_count;
@@ -1999,7 +2084,9 @@ void Update_status( struct job *job, int
 			}
 			Set_nz_flag_value(&job->info,REMOVE_TIME, time( (void *)0) );
 			Set_hold_file( job, 0, 0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Sendmail_to_user( status, job );
+#endif
 			if( (Save_on_error_DYN || Done_jobs_DYN || Done_jobs_max_age_DYN) ){
 				setstatus( job, _("job '%s' saved"), id );
 				++Done_count;
@@ -2041,7 +2128,9 @@ void Update_status( struct job *job, int
 			setstatus( job, "job '%s' error '%s'",id, strv);
 			Set_nz_flag_value(&job->info,REMOVE_TIME, time( (void *)0) );
 			Set_hold_file( job, 0, 0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Sendmail_to_user( status, job );
+#endif
 			if( (Save_on_error_DYN || Done_jobs_DYN || Done_jobs_max_age_DYN) ){
 				setstatus( job, _("job '%s' saved"), id );
 				++Done_count;
@@ -2085,7 +2174,9 @@ void Update_status( struct job *job, int
 			}
 			Set_nz_flag_value(&job->info,REMOVE_TIME, time( (void *)0) );
 			Set_hold_file( job, 0, 0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 			Sendmail_to_user( status, job );
+#endif
 			if( (Save_on_error_DYN || Done_jobs_DYN || Done_jobs_max_age_DYN) ){
 				setstatus( job, _("job '%s' saved"), id );
 				++Done_count;
@@ -2101,7 +2192,9 @@ void Update_status( struct job *job, int
 		}
 		break;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_job("Update_status: exit result", job );
+#endif
 }
 
 /***************************************************************************
@@ -2319,6 +2412,7 @@ void Service_worker( struct line_list *a
 			plp_sleep(n);
 		}
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 
 	if( RemotePrinter_DYN ){
 		Name = "(Worker - Remote)";
@@ -2334,11 +2428,14 @@ void Service_worker( struct line_list *a
 			RemotePrinter_DYN, RemoteHost_DYN );
 		}
 	} else {
+#endif
 		Name = "(Worker - Print)";
 		DEBUG1( "Service_worker: printing '%s'", id );
 		setproctitle( "lpd %s '%s'", Name, Printer_DYN );
 		Errorcode = Local_job( &job, id );
+#ifdef ORIGINAL_DEBUG //JY@1020
 	}
+#endif
 	cleanup(0);
 }
 
@@ -2447,15 +2544,19 @@ int Printer_open( char *lp_device, int *
 					}
 					if( status < 0 ){
 						err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 						setstatus( job,
 							"lock '%s' failed - %s", lp_device, Errormsg(errno) );
+#endif
 						close( device_fd );
 						device_fd = -1;
 					}
 				}
+#ifdef ORIGINAL_DEBUG //JY@1020
 				if( isatty( device_fd ) ){
 					Do_stty( device_fd );
 				}
+#endif
 				*status_fd = device_fd;
 			}
 			break;
@@ -2475,21 +2576,27 @@ int Printer_open( char *lp_device, int *
 		}
 
 		if( device_fd < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG1( "Printer_open: open '%s' failed, max_attempts %d, attempt %d '%s'",
 				lp_device, max_attempts, attempt, Errormsg(err) );
+#endif
 			if( max_attempts && attempt <= max_attempts ){
 				n = 8;
 				if( attempt < n ) n = attempt;
 				n = interval*( 1 << n );
 				if( max_interval > 0 && n > max_interval ) n = max_interval;
+#ifdef ORIGINAL_DEBUG //JY@1020
 				setstatus( job, "cannot open '%s' - '%s', attempt %d, sleeping %d",
 						lp_device, Errormsg( err), attempt+1, n );
+#endif
 				if( n > 0 ){
 					plp_sleep(n);
 				}
 			} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 				setstatus( job, "cannot open '%s' - '%s', attempt %d",
 						lp_device, Errormsg( err), attempt+1 );
+#endif
 			}
 		}
 	}
@@ -2594,7 +2701,9 @@ void Add_banner_to_job( struct job *job
 		Set_str_value(lp,"N","BANNER");
 		Set_str_value(lp,FORMAT,"f");
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_job("Add_banner_to_job", job);
+#endif
 }
 
 /* change the format of the output of a filter
@@ -2661,7 +2770,9 @@ void Filter_files_in_job( struct job *jo
 	tempfd = -1;
 	for( count = 0; count < job->datafiles.count; ++count ){
 		datafile = (void *)job->datafiles.list[count];
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Filter_files_in_job - datafile", datafile );
+#endif
 
 		openname = Find_str_value(datafile,OPENNAME,Value_sep);
 		if( !openname ) openname = Find_str_value(datafile,TRANSFERNAME,Value_sep);
@@ -2851,7 +2962,9 @@ void Filter_files_in_job( struct job *jo
             }
         }
     }
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3)Dump_job("Filter_files_in_job", job);
+#endif
 }
 
 void Service_queue( struct line_list *args )
@@ -2895,7 +3008,9 @@ int Remove_done_jobs( void )
 		DEBUG3("Remove_done_jobs: done_jobs - job_index [%d] '%s'", job_index,
 			hold_file);
 		Get_hold_file( &job, hold_file );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_job("Remove_done_jobs: done_jobs - job ",&job);
+#endif
 		if( job.info.count == 0 ) continue;
 		/* get status from hold file */
 		id = Find_str_value(&job.info,IDENTIFIER,Value_sep);
@@ -2922,8 +3037,10 @@ int Remove_done_jobs( void )
 		}
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("Remove_done_jobs - removal candidates",&info);
 	DEBUG1( "Remove_done_jobs: checking for removal - remove_count %d", Done_jobs_DYN );
+#endif
 
 	for( info_index = 0; info_index < info.count - Done_jobs_DYN; ++info_index ){
 		char *hold_file = info.list[info_index];
@@ -2949,3 +3066,4 @@ int Remove_done_jobs( void )
 	}
 	return( removed );
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/lpd_rcvjob.c LPRng/src/common/lpd_rcvjob.c
--- LPRng-3.8.22/src/common/lpd_rcvjob.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_rcvjob.c	2011-06-09 00:26:33.000000000 +0400
@@ -12,6 +12,7 @@
 
 
 #include "lp.h"
+#include "lp_asus.h"
 
 #include "child.h"
 #include "errorcodes.h"
@@ -27,6 +28,9 @@
 #include "lpd_remove.h"
 #include "lpd_rcvjob.h"
 #include "lpd_jobs.h"
+#ifdef JYDEBUG//JYWeng
+FILE *aaaaaa;
+#endif
 /**** ENDINCLUDE ****/
 
 /***************************************************************************
@@ -120,6 +124,18 @@ int Receive_job( int *sock, char *input
 	struct job job;
 	struct stat statb;
 
+#ifdef REMOVE
+#ifdef WINDOW_1//JYWeng
+//aaaaaa=fopen("/tmp/pp", "a");
+//fprintf(aaaaaa, "lpd_rcvjobs.c\n");
+//fclose(aaaaaa);
+#endif
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Receive_job: check point 1\n");
+fclose(aaaaaa);
+#endif
+#endif
 	Init_line_list(&l);
 	Init_line_list(&files);
 	Init_line_list(&info);
@@ -131,7 +147,20 @@ int Receive_job( int *sock, char *input
 	Clean_meta(input);
 	Split(&info,input,Whitespace,0,0,0,0,0,0);
 
+//printf("Receive_job!\n");//JY1107
+/*JY1113: test QueueName*/
+	if(get_queue_name(input))
+	{
+		//printf("QueueName is not LPRServer\n");
+		send_ack_packet(sock, ACK_FAIL);//JY1120
+		return(0);
+	}
+	//else printf("QueueName is LPRServer\n");
+/**/
+
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DRECV1)Dump_line_list("Receive_job: input", &info );
+#endif
 	if( info.count != 1 ){
 		SNPRINTF( error, errlen) _("bad command line") );
 		goto error;
@@ -141,8 +170,14 @@ int Receive_job( int *sock, char *input
 		goto error;
 	}
 
+#ifdef REMOVE
 	setproctitle( "lpd RECV '%s'", info.list[0] );
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Receive_job: check point 2\n");
+fclose(aaaaaa);
+#endif
 	if( Setup_printer( info.list[0], error, errlen, 0 ) ){
 		if( error[0] == 0 ){
 			SNPRINTF( error, errlen) _("%s: cannot set up print queue"), Printer_DYN );
@@ -177,6 +212,11 @@ int Receive_job( int *sock, char *input
 		DbgFlag = j;
 	}
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Receive_job: check point 3\n");
+fclose(aaaaaa);
+#endif
 	DEBUGF(DRECV1)("Receive_job: spooling_disabled %d",
 		Sp_disabled(&Spool_control) );
 	if( Sp_disabled(&Spool_control) ){
@@ -185,17 +225,28 @@ int Receive_job( int *sock, char *input
 		ack = ACK_RETRY;	/* retry */
 		goto error;
 	}
+#endif
 
 	/* send an ACK */
 	DEBUGF(DRECV1)("Receive_job: sending 0 ACK for job transfer request" );
+	printf("Send ACK\n");
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Receive_job: check point 4\n");
+fclose(aaaaaa);
+#endif
 	status = Link_send( ShortRemote_FQDN, sock, Send_job_rw_timeout_DYN, "", 1, 0 );
-	if( status ){
+
+	if( status )
+	{
+		
 		SNPRINTF( error, errlen)
 			_("%s: Receive_job: sending ACK 0 failed"), Printer_DYN );
 		goto error;
 	}
 
+#ifdef REMOVE
 	/* fifo order enforcement */
 	if( Fifo_DYN ){
 		char * path = Make_pathname( Spool_dir_DYN, Fifo_lock_file_DYN );
@@ -215,11 +266,23 @@ int Receive_job( int *sock, char *input
 		if(path) free(path); path = 0;
 	}
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Receive_job: check point 5\n");
+fclose(aaaaaa);
+#endif
+#endif
+
 	while( status == 0 ){
 		DEBUGF(DRECV1)("Receive_job: from %s- getting file transfer line", FQDNRemote_FQDN );
 		rlen = sizeof(line)-1;
 		line[0] = 0;
 		status = Link_line_read( ShortRemote_FQDN, sock, Send_job_rw_timeout_DYN, line, &rlen );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/pp", "a");
+fprintf(aaaaaa, "Receive_job: line=%0x\n", &line[0]);
+fclose(aaaaaa);
+#endif
 
 		DEBUGF(DRECV1)( "Receive_job: read from %s- status %d read %d bytes '%s'",
 				FQDNRemote_FQDN, status, rlen, line );
@@ -316,8 +379,24 @@ int Receive_job( int *sock, char *input
 
 		DEBUGF(DRECV4)("Receive_job: receiving '%s' %d bytes ", filename, read_len );
 		len = read_len;
+#if TEST_WRITE//JYWeng
+	if(filetype != DATA_FILE){
+#if 1//JY1110
 		status = Link_file_read( ShortRemote_FQDN, sock,
 			Send_job_rw_timeout_DYN, 0, temp_fd, &read_len, &ack );
+#else
+		status = Link_file_read_test( ShortRemote_FQDN, sock,
+			Send_job_rw_timeout_DYN, 0, temp_fd, &read_len, &ack );
+#endif
+		}
+	else	{
+		status = Link_file_read_test( ShortRemote_FQDN, sock,
+			Send_job_rw_timeout_DYN, 0, temp_fd, &read_len, &ack );
+		}
+#else
+		status = Link_file_read( ShortRemote_FQDN, sock,
+			Send_job_rw_timeout_DYN, 0, temp_fd, &read_len, &ack );
+#endif
 
 		DEBUGF(DRECV4)("Receive_job: status %d, read_len %0.0f, file_len %0.0f",
 			status, read_len, file_len );
@@ -328,7 +407,9 @@ int Receive_job( int *sock, char *input
 
 		if( status 
 			|| (file_len == 0 && read_len == 0)
-			|| (file_len != 0 && file_len != read_len) ){
+			|| (file_len != 0 && file_len != read_len) )
+		{
+			printf("Why error %lf %lf %d\n", file_len, read_len, status);
 			SNPRINTF( error, errlen)
 				_("%s: transfer of '%s' from '%s' failed"), Printer_DYN,
 				filename, ShortRemote_FQDN );
@@ -339,7 +420,9 @@ int Receive_job( int *sock, char *input
 		/*
 		 * we process the control file and make sure we can print it
 		 */
+		printf(" Control file\n");
 
+#if defined(JYWENG20031104CONTROL)
 		if( filetype == CONTROL_FILE ){
 			DEBUGF(DRECV2)("Receive_job: receiving new control file, old job.info.count %d, old files.count %d",
 				job.info.count, files.count );
@@ -371,12 +454,15 @@ int Receive_job( int *sock, char *input
 		} else {
 			Set_casekey_str_value(&files,filename,tempfile);
 		}
+#endif
 		DEBUGF(DRECV2)("Receive_job: sending 0 ACK transfer done" );
 		status = Link_send( ShortRemote_FQDN, sock, Send_job_rw_timeout_DYN, "",1, 0 );
 	}
 
 	DEBUGF(DRECV2)("Receive_job: eof on transfer, job.info.count %d, files.count %d",
 		job.info.count, files.count );
+
+#if defined(JYWENG20031104Check_for_missing_files)
 	if( job.info.count ){
 		/* we receive another control file */
 		if( Check_for_missing_files(&job, &files, error, errlen, 0, &hold_fd) ){
@@ -387,9 +473,14 @@ int Receive_job( int *sock, char *input
 		jobsize = 0;
 		Free_job(&job);
 	}
+#endif
+
+/*JY1110*/
+
 
  error:
 
+#if 0//JY1111
 	if( temp_fd > 0 ) close(temp_fd); temp_fd = -1;
 	if( fifo_fd > 0 ){
 		Do_unlock( fifo_fd );
@@ -398,8 +489,10 @@ int Receive_job( int *sock, char *input
 
 	Remove_tempfiles();
 	if( error[0] ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGF(DRECV1)("Receive_job: error, removing job" );
 		DEBUGFC(DRECV4)Dump_job("Receive_job - error", &job );
+#endif
 		s = Find_str_value(&job.info,HF_NAME,Value_sep);
 		if( !ISNULL(s) ) unlink(s);
 		if( ack == 0 ) ack = ACK_FAIL;
@@ -444,9 +537,14 @@ int Receive_job( int *sock, char *input
 	Free_line_list(&l);
 
 	cleanup( 0 );
+#endif//JY1111
+
+/*JY1111*/
+	check_prn_status(ONLINE, "");
 	return(0);
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Block Job Transfer
  * \RCV_BLOCKprinter size
@@ -485,7 +583,9 @@ int Receive_block_job( int *sock, char *
 	if( *input ) ++input;
 	Clean_meta(input);
 	Split(&l,input,Whitespace,0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DRECV1)Dump_line_list("Receive_block_job: input", &l );
+#endif
 
 	if( l.count != 2 ){
 		SNPRINTF( error, errlen-4) _("bad command line") );
@@ -587,8 +687,10 @@ int Receive_block_job( int *sock, char *
 	/* extract jobs */
 
 	if( lseek( temp_fd, 0, SEEK_SET ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error, errlen-4)	
 			_("Receive_block_job: lseek failed '%s'"), Errormsg(errno) );
+#endif
 		ack = ACK_FAIL;
 		goto error;
 	}
@@ -641,8 +743,10 @@ int Receive_block_job( int *sock, char *
 	}
 	return( error[0] != 0 );
 }
+#endif
 
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Scan_block_file( int fd, struct control_file *cfp )
  *  we scan the block file, getting the various portions
@@ -696,8 +800,10 @@ int Scan_block_file( int fd, char *error
 		Free_line_list(&info);
 		startpos = lseek( fd, 0, SEEK_CUR );
 		if( startpos == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SNPRINTF( error, errlen)	
 				_("Scan_block_file: lseek failed '%s'"), Errormsg(errno) );
+#endif
 			status = 1;
 			goto error;
 		}
@@ -716,7 +822,9 @@ int Scan_block_file( int fd, char *error
 			status = 1;
 			goto error;
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DRECV2)Dump_line_list("Scan_block_file- input", &info );
+#endif
 		read_len = atoi( info.list[0] );
 		filename = info.list[1];
 		tempfd = Make_temp_fd( &tempfile );
@@ -728,8 +836,10 @@ int Scan_block_file( int fd, char *error
 			DEBUGF(DRECV2)("Scan_block_file: len %d, reading %d, got count %d",
 				len, n, count );
 			if( count < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				SNPRINTF( error, errlen)	
 					_("Scan_block_file: read failed '%s'"), Errormsg(errno) );
+#endif
 				status = 1;
 				goto error;
 			} else if( count == 0 ){
@@ -740,8 +850,10 @@ int Scan_block_file( int fd, char *error
 			}
 			n = write(tempfd,buffer,count);
 			if( n != count ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				SNPRINTF( error, errlen)	
 					_("Scan_block_file: lseek failed '%s'"), Errormsg(errno) );
+#endif
 				status = 1;
 				goto error;
 			}
@@ -753,6 +865,8 @@ int Scan_block_file( int fd, char *error
 			DEBUGF(DRECV2)("Scan_block_file: control file '%s'", filename );
 			DEBUGF(DRECV2)("Scan_block_file: received control file, job.info.count %d, files.count %d",
 				job.info.count, files.count );
+
+#if defined(JYWENG20031104Config_value_conversion)
 			if( job.info.count ){
 				if( Check_for_missing_files(&job, &files, error, errlen, 0, &hold_fd) ){
 					goto error;
@@ -761,10 +875,12 @@ int Scan_block_file( int fd, char *error
 				Free_line_list(&files);
 				Free_job(&job);
 			}
+#endif
 			Set_str_value(&job.info,OPENNAME,tempfile);
 			Set_str_value(&job.info,TRANSFERNAME,filename);
 			hold_fd = Set_up_temporary_hold_file( &job, error, errlen );
 			if( hold_fd < 0 ) goto error;
+#if defined(JYWENG20031104Config_value_conversion)
 			if( files.count ){
 				/* we have datafiles, FOLLOWED by a control file,
 					followed (possibly) by another control file */
@@ -776,11 +892,13 @@ int Scan_block_file( int fd, char *error
 				Free_line_list(&files);
 				Free_job(&job);
 			}
+#endif
 		} else {
 			Set_str_value(&files,filename,tempfile);
 		}
 	}
 
+#if defined(JYWENG20031104Config_value_conversion)
 	if( files.count ){
 		/* we receive another control file */
 		if( Check_for_missing_files(&job, &files, error, errlen, header_info, &hold_fd) ){
@@ -790,6 +908,7 @@ int Scan_block_file( int fd, char *error
 		Free_line_list(&files);
 		Free_job(&job);
 	}
+#endif
 
  error:
 	if( hold_fd >= 0 ){
@@ -803,6 +922,7 @@ int Scan_block_file( int fd, char *error
 	Free_job(&job);
 	return( status );
 }
+#endif
 
 /***************************************************************************
  * static int read_one_line(int fd, char *buffer, int maxlen );
@@ -832,20 +952,39 @@ int Check_space( double jobsize, int min
 	int ok;
 
 	jobsize = ((jobsize+1023)/1024);
+
 	ok = ((jobsize + min_space) < space);
+#ifdef RETURNOK 
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "PATH=%s\n", pathname);
+fprintf(aaaaaa, "*********************************************************\n");
+fprintf(aaaaaa, "min_space=%d\n", min_space);
+fprintf(aaaaaa, "jobsize=%f\n", jobsize);
+fprintf(aaaaaa, "availspace=%f\n", space);
+fprintf(aaaaaa, "ok=%d\n", ok);
+fprintf(aaaaaa, "*********************************************************\n");
+fclose(aaaaaa);
+#endif
 
 	DEBUGF(DRECV1)("Check_space: path '%s', space %0.0f, jobsize %0.0fK, ok %d",
 		pathname, space, jobsize, ok );
 
-	return( ok );
+#ifdef RETURNOK 
+	return( ok );//JYWeng
+#else
+	return( 1 );
+#endif
 }
 
+#if defined(JYWENG20031104Do_perm_check)
 int Do_perm_check( struct job *job, char *error, int errlen )
 {
 	int permission = 0;			/* permission */
 	char *s;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DRECV1)Dump_job("Do_perm_check", job );
+#endif
 	Perm_check.service = 'R';
 	Perm_check.printer = Printer_DYN;
 	s = Find_str_value(&job->info,LOGNAME,Value_sep);
@@ -876,6 +1015,7 @@ int Do_perm_check( struct job *job, char
 	DEBUGF(DRECV1)("Do_perm_check: permission '%s'", perm_str(permission) );
 	return( permission );
 }
+#endif
 
 /*
  * Process the list of control and data files, and make a job from them
@@ -892,6 +1032,7 @@ int Do_perm_check( struct job *job, char
  *          != 0 - error
  */
 
+#if defined(JYWENG20031104Check_for_missing_files)
 int Check_for_missing_files( struct job *job, struct line_list *files,
 	char *error, int errlen, struct line_list *header_info, int *holdfile_fd )
 {
@@ -908,13 +1049,14 @@ int Check_for_missing_files( struct job
 		Errorcode = JABORT;
 		LOGERR_DIE(LOG_INFO) "Check_for_missing_files: gettimeofday failed");
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG1("Check_for_missing_files: holdfile_fd %d, start time 0x%x usec 0x%x",
 		*holdfile_fd,
 		(int)start_time.tv_sec, (int)start_time.tv_usec );
 	if(DEBUGL1)Dump_job("Check_for_missing_files - start", job );
 	if(DEBUGL1)Dump_line_list("Check_for_missing_files- files", files );
 	if(DEBUGL1)Dump_line_list("Check_for_missing_files- header_info", header_info );
-
+#endif
 
 	Set_flag_value(&job->info,JOB_TIME,(int)start_time.tv_sec);
 	Set_flag_value(&job->info,JOB_TIME_USEC,(int)start_time.tv_usec);
@@ -955,7 +1097,9 @@ int Check_for_missing_files( struct job
 				Set_flag_value(lp,COPIES,1);
 				if( openname ) openname[-1] = '=';
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL1)Dump_job("RedHat Linux fix", job );
+#endif
 		}
 		for( count = 0; count < job->datafiles.count; ++count ){
 			lp = (void *)job->datafiles.list[count];
@@ -971,8 +1115,10 @@ int Check_for_missing_files( struct job
 				goto error;
 			}
 			if( (status = stat( openname, &statb )) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 					SNPRINTF( error, errlen) "stat() '%s' error - %s",
 					openname, Errormsg(errno) );
+#endif
 				goto error;
 			}
 			copies = Find_flag_value(lp,COPIES,Value_sep);
@@ -981,7 +1127,9 @@ int Check_for_missing_files( struct job
 		}
 		Set_double_value(&job->info,SIZE,jobsize);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL1)Dump_line_list("Check_for_missing_files- found", &datafiles );
+#endif
 		if( files->count != datafiles.count ){
 			SNPRINTF(error,errlen)"too many data files");
 			status = 1;
@@ -1006,12 +1154,13 @@ int Check_for_missing_files( struct job
 			DEBUG1("Check_for_missing_files: setting user to authuser '%s'", s );
 		}
 	}
-
+#if defined(JYWENG20031104Create_control)
 	if( Create_control( job, error, errlen, Xlate_incoming_format_DYN ) ){
 		DEBUG1("Check_for_missing_files: Create_control error '%s'", error );
 		status = 1;
 		goto error;
 	}
+#endif
 	Set_str_value(&job->info,HPFORMAT,0);
 	Set_str_value(&job->info,INCOMING_TIME,0);
 
@@ -1037,9 +1186,11 @@ int Check_for_missing_files( struct job
 		DEBUG1("Check_for_missing_files: renaming '%s' to '%s'",
 			openname, transfername );
 		if( (status = rename(openname,transfername)) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SNPRINTF( error,errlen)
 				"error renaming '%s' to '%s' - %s",
 				openname, transfername, Errormsg( errno ) );
+#endif
 		}
 	}
 	if( status ) goto error;
@@ -1052,18 +1203,24 @@ int Check_for_missing_files( struct job
 	DEBUG1("Check_for_missing_files: renaming '%s' to '%s'",
 		openname, transfername );
 	if( (status = rename(openname,transfername)) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error,errlen)
 			"error renaming '%s' to '%s' - %s",
 			openname, transfername, Errormsg( errno ) );
+#endif
 		goto error;
 	}
 	if( (status = Set_hold_file( job, 0, *holdfile_fd )) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error,errlen)
 			"error setting up hold file - %s",
 			Errormsg( errno ) );
+#endif
 		goto error;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_job("Check_for_missing_files - ending", job );
+#endif
 
  error:
 	transfername = Find_str_value(&job->info,TRANSFERNAME,Value_sep);
@@ -1087,14 +1244,18 @@ int Check_for_missing_files( struct job
 		/*
 		LOGMSG(LOG_INFO) "Check_for_missing_files: SUCCESS '%s'", transfername);
 		*/
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( job, "STATE", "CREATE" );
+#endif
 	}
 
 	if( *holdfile_fd >= 0 ) close(*holdfile_fd); *holdfile_fd = -1;
 	Free_line_list(&datafiles);
 	return( status );
 }
+#endif
 
+#if defined(JYWENG200301104Set_up_temporary_hold_file)
 /***************************************************************************
  * int Set_up_temporary_hold_file( struct job *job,
  *	char *error, int errlen )
@@ -1122,15 +1283,18 @@ int Set_up_temporary_hold_file( struct j
 	Set_flag_value(&job->info,INCOMING_TIME,time((void *)0) );
 	/* write status */
 	if( Set_hold_file( job, 0, fd ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF( error,errlen)
 			"error setting up hold file - %s",
 			Errormsg( errno ) );
+#endif
 		close(fd); fd = -1;
 		goto error;
 	}
  error:
 	return( fd );
 }
+#endif
 
 /***************************************************************************
  * int Find_non_colliding_job_number( struct job *job )
@@ -1178,6 +1342,9 @@ int Find_non_colliding_job_number( struc
 }
 
 int Get_route( struct job *job, char *error, int errlen )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	int i, fd, tempfd, count, c;
 	char *tempfile, *openname, *s, *t, *id;
@@ -1212,8 +1379,10 @@ int Get_route( struct job *job, char *er
 
 	openname = Find_str_value(&job->info,OPENNAME,Value_sep);
 	if( (fd = open(openname,O_RDONLY,0)) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		SNPRINTF(error,errlen)"Get_route: open '%s' failed '%s'",
 			openname, Errormsg(errno) );
+#endif
 		errorcode = 1;
 		goto error;
 	}
@@ -1241,21 +1410,27 @@ int Get_route( struct job *job, char *er
 		}
 		close(fd); close(tempfd); fd = -1; tempfd = -1;
 		if( rename( tempfile, openname ) == -1 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SNPRINTF(error,errlen)"Get_route: rename '%s' to '%s' failed - %s",
 				tempfile, openname, Errormsg(errno) );
+#endif
 			errorcode = 1;
 			goto error;
 		}
 		if( (fd = open(openname,O_RDONLY,0)) < 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			SNPRINTF(error,errlen)"Get_route: open '%s' failed '%s'",
 				openname, Errormsg(errno) );
+#endif
 			errorcode = 1;
 			goto error;
 		}
 		Max_open(fd);
 		if( Get_file_image_and_split(openname,0,0, &cf_line_list, Line_ends,0,0,0,0,0,0) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
             SNPRINTF(error,errlen)
                 "Get_route: open failed - modified control file  %s - %s", openname, Errormsg(errno) );
+#endif
 			goto error;
 		}
 		for( i = 'A'; i <= 'Z'; ++i ){
@@ -1351,7 +1526,9 @@ int Get_route( struct job *job, char *er
 	}
 	Free_line_list(&job->destination);
 	Set_flag_value(&job->info,DESTINATIONS,count);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_job("Get_route: final", job );
+#endif
 
  error:
 	Free_line_list(&info);
@@ -1360,3 +1537,4 @@ int Get_route( struct job *job, char *er
 	Free_line_list(&cf_line_list);
 	return( errorcode );
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/lpd_remove.c LPRng/src/common/lpd_remove.c
--- LPRng-3.8.22/src/common/lpd_remove.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_remove.c	2011-06-09 00:35:34.000000000 +0400
@@ -12,6 +12,7 @@
 
 
 #include "lp.h"
+#include "lp_asus.h"
 #include "lpd_remove.h"
 #include "getqueue.h"
 #include "getprinter.h"
@@ -50,6 +51,30 @@
 
 int Job_remove( int *sock, char *input )
 {
+printf("Job_remove\n");//JY
+#if !defined(JYWENG20031106remove)
+	if( input && *input ) ++input;//JY1114
+
+	if(get_queue_name(input))
+	{
+		printf("QueueName is not LPRServer\n");
+		send_ack_packet(sock, ACK_FAIL);//JY1120
+		return(0);
+	}
+	else
+	{
+		printf("QueueName is LPRServer\n");
+	}
+
+	if(lptstatus.pid != 0){
+		check_prn_status(ONLINE, "");
+		kill(lptstatus.pid, SIGKILL);
+	}
+	else
+		return(0);
+#endif
+
+#ifdef REMOVE
 	char error[LINEBUFFER];
 	int i;
 	char *name, *s, *user = 0;
@@ -63,7 +88,9 @@ int Job_remove( int *sock, char *input )
 	++input;
 	DEBUGF(DLPRM1)("Job_remove: input '%s'", input );
 	Split(&tokens,input,Whitespace,0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPRM2)Dump_line_list("Job_remove: input", &tokens );
+#endif
 
 	/* check printername for characters, underscore, digits */
 
@@ -97,11 +124,13 @@ int Job_remove( int *sock, char *input )
 		Set_DYN(&Printer_DYN, Printer_DYN );
 		Get_queue_remove( user, sock, &tokens, &done_list );
 	} else {
+/*1103
 		Get_all_printcap_entries();
 		for( i = 0; i < All_line_list.count; ++i ){
 			Set_DYN(&Printer_DYN, All_line_list.list[i]);
 			Get_queue_remove( user, sock, &tokens, &done_list );
 		}
+*/
 	}
 	goto done;
 
@@ -115,9 +144,11 @@ int Job_remove( int *sock, char *input )
 	if( user ) free(user); user = 0;
 	Free_line_list(&done_list);
 	Free_line_list(&tokens);
+#endif
 	return( 0 );
 }
 
+#ifdef REMOVE
 /***************************************************************************
  * void Get_queue_remove
  *  - find and remove the spool queue entries
@@ -140,9 +171,11 @@ void Get_queue_remove( char *user, int *
 
 	/* set printer name and printcap variables */
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPRM2)Dump_line_list("Get_queue_remove - tokens", tokens );
 	DEBUGF(DLPRM2)( "Get_queue_remove: user '%s', printer '%s'",
 		user, Printer_DYN );
+#endif
 
 	Errorcode = 0;
 
@@ -209,12 +242,16 @@ void Get_queue_remove( char *user, int *
 
 	/* scan the files to see if there is one which matches */
 	removed = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPRM3)Dump_line_list("Get_queue_remove - tokens", tokens );
+#endif
 	for( count = 0; count < Sort_order.count; ++count ){
 		Free_job(&job);
 		Get_hold_file(&job, Sort_order.list[count] );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPRM3)Dump_job("Get_queue_remove - info",&job);
+#endif
         if( tokens->count && Patselect( tokens, &job.info, 0) ){
 			continue;
         }
@@ -255,15 +292,21 @@ void Get_queue_remove( char *user, int *
 		SNPRINTF( msg, sizeof(msg)) _("  dequeued '%s'\n"), identifier );
 		Write_fd_str( *sock, msg );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( &job, "LPRM", "start" );
+#endif
 		if( Remove_job( &job ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			setmessage( &job, "LPRM", "fail" );
+#endif
 			SNPRINTF( msg, sizeof(msg))
 				_("error: could not remove '%s'"), identifier ); 
 			Write_fd_str( *sock, msg );
 			goto error;
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( &job, "LPRM", "success" );
+#endif
 		if( (pid = Find_flag_value(&job.info,SERVER,Value_sep)) ){
 			DEBUGF(DLPRM4)("Get_queue_remove: active_pid %d", pid );
 			if( kill( pid, 0 ) == 0 ){
@@ -294,10 +337,13 @@ void Get_queue_remove( char *user, int *
 		/* kill spooler process */
 		
 		pid = 0;
+#if 0//1103
 		if( (fd = Checkread( Queue_lock_file_DYN, &statb )) >= 0 ){
 			pid = Read_pid( fd, (char *)0, 0 );
 			close( fd );
 		}
+#else
+#endif
 		DEBUGF(DLPRM2)("Get_queue_status: checking server pid %d", pid );
 		/* kill active spooler */
 		if( pid > 0 ){
@@ -349,8 +395,10 @@ void Get_queue_remove( char *user, int *
 			tokens->list[0] = user;
 			++tokens->count;
 			tokens->list[tokens->count] = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			fd = Send_request( 'M', REQ_REMOVE, tokens->list, Connect_timeout_DYN,
 				Send_query_rw_timeout_DYN, *sock );
+#endif
 			if( fd >= 0 ){
 				shutdown( fd, 1 );
 				while( (c = read(fd,msg,sizeof(msg))) > 0 ){
@@ -395,7 +443,9 @@ void Get_local_or_remote_remove( char *u
 		Get_queue_remove( user, sock, tokens, done_list );
 		return;
 	}
+/*1103
 	Fix_Rm_Rp_info(0,0);
+*/
 	/* now we look at the remote host */
 	if( Find_fqdn( &LookupHost_IP, RemoteHost_DYN )
 		&& ( !Same_host(&LookupHost_IP,&Host_IP )
@@ -411,8 +461,10 @@ void Get_local_or_remote_remove( char *u
 	tokens->list[0] = user;
 	++tokens->count;
 	tokens->list[tokens->count] = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	fd = Send_request( 'M', REQ_REMOVE, tokens->list, Connect_timeout_DYN,
 		Send_query_rw_timeout_DYN, *sock );
+#endif
 	if( fd >= 0 ){
 		shutdown( fd, 1 );
 		while( (n = read(fd,msg,sizeof(msg))) > 0 ){
@@ -449,10 +501,16 @@ int Remove_job( struct job *job )
 	char *identifier, *openname;
 	struct line_list *datafile;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPRM1)Dump_job("Remove_job",job);
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage(job,STATE,"REMOVE");
+#endif
 	identifier = Find_str_value(&job->info,IDENTIFIER,Value_sep);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	setmessage( job, TRACE, "remove START" );
+#endif
 	if( !identifier ){
 		identifier = Find_str_value(&job->info,TRANSFERNAME,Value_sep);
 	}
@@ -474,12 +532,19 @@ int Remove_job( struct job *job )
 	fail |= Remove_file( openname );
 
 	if( fail == 0 ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( job, TRACE, "remove SUCCESS" );
+#endif
 	} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 		setmessage( job, TRACE, "remove FAILED" );
+#endif
 	}
 	if( Lpq_status_file_DYN ){
 		unlink(Lpq_status_file_DYN);
 	}
 	return( fail );
 }
+#endif
+
+
diff -urNBp LPRng-3.8.22/src/common/lpd_secure.c LPRng/src/common/lpd_secure.c
--- LPRng-3.8.22/src/common/lpd_secure.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_secure.c	2011-06-09 00:24:46.000000000 +0400
@@ -50,6 +50,7 @@
 /*************************************************************************
  * Receive_secure() - receive a secure transfer
  *************************************************************************/
+#ifdef ORIGINAL_DEBUG //JY@1020
 int Receive_secure( int *sock, char *input )
 {
 	char *printername;
@@ -252,7 +253,9 @@ int Receive_secure( int *sock, char *inp
 	cleanup(0);
 	return(0);
 }
+#endif
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 int Do_secure_work( char *jobsize, int from_server,
 	char *tempfile, struct line_list *header_info )
 {
@@ -373,7 +376,7 @@ int Do_secure_work( char *jobsize, int f
 	DEBUGF(DRECV1)("Do_secure_work: returning %d", status );
 	return( status );
 }
-
+#endif
 
 /***************************************************************************
  * void Fix_auth() - get the Use_auth_DYN value for the remote printer
diff -urNBp LPRng-3.8.22/src/common/lpd_status.c LPRng/src/common/lpd_status.c
--- LPRng-3.8.22/src/common/lpd_status.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpd_status.c	2011-06-09 00:36:28.000000000 +0400
@@ -12,6 +12,7 @@
 
 
 #include "lp.h"
+#include "lp_asus.h"
 #include "getopt.h"
 #include "gethostinfo.h"
 #include "proctitle.h"
@@ -28,6 +29,8 @@
 #include "lpd_jobs.h"
 #include "lpd_status.h"
 
+//extern char printerstatus[32];//JY1106
+
 /**** ENDINCLUDE ****/
 
 /***************************************************************************
@@ -85,7 +88,64 @@ int Job_status( int *sock, char *input )
 	struct line_list done_list;
 	char error[SMALLBUFFER], buffer[16];
 	int db, dbflag;
+	
+	FILE *READSTATUSFILE;//JY1120
+	char readbuffer[SMALLBUFFER];//JY1120
+	char *str_index;//JY1120
+
+#if !defined(JYWENG20031104status)
+	if( input && *input ) ++input;//JY1114
+	if(get_queue_name(input))
+	{
+		printf("QueueName is not LPRServer\n");
+		send_ack_packet(sock, ACK_FAIL);//JY1120
+		return(0);
+	}
+	else
+	{
+		printf("QueueName is LPRServer\n");
+	}
+
+	int prnstatus=1;
+	char buffertosend[LARGEBUFFER];
+	int fdPRNPARorUSB = open_printer(); /*JYWENG20031104*/
+
+	if(fdPRNPARorUSB == 0)
+	{
+		printf("file descriptor not created\n");
+		send_ack_packet(sock, ACK_FAIL);//JY1120
+		return(0);	
+	}
+//	ioctl(fdPRNPARorUSB, 0x060b, &prnstatus);
+//	if(prnstatus == 0)
+//JY1120
+	if((READSTATUSFILE=fopen("/var/state/printstatus.txt", "r")) == NULL)
+	{
+		printf("open /var/state/printstatus.txt failed!\n");
+		send_ack_packet(sock, ACK_FAIL);//JY1120
+		return(0);		
+	}
+	while( fgets(readbuffer, SMALLBUFFER, READSTATUSFILE) != NULL)
+	{
+		if((str_index = strstr(readbuffer, "PRINTER_STATUS=\"")))
+		{
+			str_index += 16;//moving to status
+			strncpy(printerstatus, str_index, strlen(str_index) - 2 );	
+		}
+	}
+//JY1120	
+
+	SNPRINTF(buffertosend, sizeof(buffertosend))"Status: %s\n", printerstatus);
+//	else
+//		SNPRINTF(buffertosend, sizeof(buffertosend))"Status: Off line\n");
+//	if( Write_fd_str( *sock, buffertosend ) < 0 ) cleanup(0);
+	if( write( *sock, buffertosend, strlen(buffertosend) ) < 0 ) cleanup(0);
+	exit(0);//JY1120
+	
+#endif
+
 
+#ifdef REMOVE
 	Init_line_list(&l);
 	Init_line_list(&listv);
 	Init_line_list(&done_list);
@@ -200,7 +260,9 @@ int Job_status( int *sock, char *input )
 		Free_line_list(&listv);
 		Split(&listv,s+1,Arg_sep,1,Value_sep,1,1,0,0);
 		Remove_line_list( &l, 0 );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ1)Dump_line_list( "Job_status: args", &listv );
+#endif
 		if( (n = Find_flag_value(&listv,"lines",Value_sep)) ) status_lines = n;
 		DEBUGF(DLPQ1)("Job_status: status_lines '%d'", status_lines );
 		Free_line_list(&listv);
@@ -242,9 +304,11 @@ int Job_status( int *sock, char *input )
 	Free_line_list( &done_list );
 	if( Write_fd_str( *sock, error ) < 0 ) cleanup(0);
 	DEBUGF(DLPQ3)("Job_status: done" );
+#endif
 	return(0);
 }
 
+#ifdef REMOVE
 /***************************************************************************
  * void Get_queue_status
  * sock - used to send information
@@ -281,8 +345,10 @@ void Get_queue_status( struct line_list
 
 	cache_index = -1;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG1("Get_queue_status: sock fd %d, checking '%s'", *sock, Printer_DYN );
 	if(DEBUGL1)Dump_line_list( "Get_queue_status: done_list", done_list );
+#endif
 
 	/* set printer name and printcap variables */
 
@@ -379,8 +445,10 @@ void Get_queue_status( struct line_list
 		DEBUGF(DLPQ1)("Get_queue_status: lock succeeded");
 		Free_line_list(&cache);
 		Get_fd_image_and_split(lockfd, 0,0,&cache,Line_ends,0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status- cache", &cache );
 		DEBUGF(DLPQ3)("Get_queue_status: cache hash_key '%s'", hash_key );
+#endif
 		file = 0;
 		nx = -1;
 		if( cache.count < Lpq_status_cached_DYN ){
@@ -409,7 +477,9 @@ void Get_queue_status( struct line_list
 			Split(&cache_info,file,Arg_sep,1,Value_sep,1,1,0,0);
 			file = Find_str_value(&cache_info,FILENAMES,Value_sep);
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status: cache_info", &cache_info );
+#endif
 		if( file && (fd = Checkread( file, &statb )) > 0 ){
 			modified = statb.st_mtime;
 			delta = now - modified;
@@ -516,8 +586,10 @@ void Get_queue_status( struct line_list
 		Scan_queue( &Spool_control, &Sort_order, &printable,&held,&move,0,0,0,0,0 );
 	}
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DLPQ3)("Get_queue_status: total files %d", Sort_order.count );
 	DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status- Sort_order", &Sort_order );
+#endif
 
 
 	/* set up the short format for folks */
@@ -543,7 +615,9 @@ void Get_queue_status( struct line_list
 		Job_printable(&job,&Spool_control, &printable,&held,&move,&jerror,&jdone);
 		DEBUGF(DLPQ3)("Get_queue_status: printable %d, held %d, move %d, error %d, done %d",
 			printable, held, move, jerror, jdone );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ4)Dump_job("Get_queue_status - info", &job );
+#endif
 		if( job.info.count == 0 ) continue;
 
 		if( tokens->count && Patselect( tokens, &job.info, 0) ){
@@ -702,8 +776,10 @@ void Get_queue_status( struct line_list
 			if( nodest == 0 && destinations ){
 				for( dcount = 0; dcount < destinations; ++dcount ){
 					if( Get_destination( &job, dcount ) ) continue;
+#ifdef ORIGINAL_DEBUG //JY@1020
 					DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status: destination",
 						&job.destination);
+#endif
 					d_error =
 						Find_str_value(&job.destination,ERROR,Value_sep);
 					d_dest =
@@ -791,11 +867,13 @@ void Get_queue_status( struct line_list
 	}
 	len = safestrlen( header );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPQ4)Dump_line_list("Get_queue_status: job status",&outbuf);
 
 	DEBUGF(DLPQ3)(
 		"Get_queue_status: RemoteHost_DYN '%s', RemotePrinter_DYN '%s', Lp '%s'",
 		RemoteHost_DYN, RemotePrinter_DYN, Lp_device_DYN );
+#endif
 
 	if( displayformat != REQ_DSHORT ){
 		s = 0;
@@ -1070,10 +1148,12 @@ void Get_queue_status( struct line_list
 			}
 		}
 		close(tempfd); tempfd = -1;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status- cache", &cache );
 		/* now we update the cached information */
 		DEBUGF(DLPQ3)("Get_queue_status: hash_key '%s', cache_index %d",
 			hash_key, cache_index );
+#endif
 		modified = 0;
 		nx = -1;
 		for( ix = 0; cache_index < 0 && ix < cache.count; ++ix ){
@@ -1129,7 +1209,9 @@ void Get_queue_status( struct line_list
 		cache.list[cache_index] = safestrdup3(hash_key,"=",s,__FILE__,__LINE__);
 		if( s ) free(s); s = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DLPQ3)Dump_line_list("Get_queue_status- new cache", &cache );
+#endif
 		if( rename( tempfile, buffer ) ){
 			err = errno;
 			unlink( Lpq_status_file_DYN );
@@ -1222,8 +1304,10 @@ void Get_queue_status( struct line_list
 				RemotePrinter_DYN, RemoteHost_DYN);
 			if( Remote_support_DYN ) uppercase( Remote_support_DYN );
 			if( safestrchr( Remote_support_DYN, 'Q' ) ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				fd = Send_request( 'Q', displayformat, tokens->list, Connect_timeout_DYN,
 					Send_query_rw_timeout_DYN, *sock );
+#endif
 				if( fd >= 0 ){
 					char *tempfile;
 					/* shutdown( fd, 1 ); */
@@ -1321,9 +1405,13 @@ void Print_different_last_status_lines(
 	char *s, *t;
 
 	Init_line_list(&l);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DLPQ1)("Print_different_last_status_lines: status lines %d", status_lines );
+#endif
 	Get_fd_image_and_split(fd,max_size,0,&l,Line_ends,0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DLPQ1)Dump_line_list( "Print_different_last_status_lines", &l );
+#endif
 
 	header[0] = 0;
 	last_printed = start = -1;
@@ -1394,8 +1482,10 @@ void Get_local_or_remote_status( struct
 	if( safestrchr( Remote_support_DYN, 'Q' ) ){
 		DEBUGF(DLPQ1)("Get_local_or_remote_status: doing remote %s@%s",
 			RemotePrinter_DYN, RemoteHost_DYN);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		fd = Send_request( 'Q', displayformat, tokens->list, Connect_timeout_DYN,
 			Send_query_rw_timeout_DYN, *sock );
+#endif
 		if( fd >= 0 ){
 			/* shutdown( fd, 1 ); */
 			tempfd = Make_temp_fd( 0 );
@@ -1408,3 +1498,4 @@ void Get_local_or_remote_status( struct
 		}
 	}
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/lpstat.c LPRng/src/common/lpstat.c
--- LPRng-3.8.22/src/common/lpstat.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/lpstat.c	2011-06-09 00:23:04.000000000 +0400
@@ -157,8 +157,10 @@ int main(int argc, char *argv[], char *e
 		o_flag = 1;
 		flag_count = 1;
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1)Dump_line_list("lpstat - printer request list", &request_list);
 	if(DEBUGL1)Dump_line_list("lpstat - options", &options);
+#endif
 
 	if( r_flag ){
 		Write_fd_str(1,"scheduler is running\n");
@@ -279,8 +281,10 @@ int Read_status_info( char *host, int so
 	DEBUG1("Read_status_info: status_line_count %d", status_line_count );
 	buffer[0] = 0;
 	do {
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG1("Read_status_info: look_for_pr %d, in buffer already '%s'", look_for_pr, buffer );
 		if( DEBUGL2 )Dump_line_list("Read_status_info - starting list", &l );
+#endif
 		count = safestrlen(buffer);
 		n = sizeof(buffer)-count-1;
 		status = 1;
@@ -303,7 +307,9 @@ int Read_status_info( char *host, int so
 			Split(&l,buffer,Line_ends,0,0,0,0,0,0);
 			memmove(buffer,s,safestrlen(s)+1);
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( DEBUGL2 )Dump_line_list("Read_status_info - status after splitting", &l );
+#endif
 		if( status ){
 			if( buffer[0] ){
 				Add_line_list(&l,buffer,0,0,0);
@@ -314,9 +320,11 @@ int Read_status_info( char *host, int so
 		}
 		index_list = 0;
  again:
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG2("Read_status_info: look_for_pr '%d'", look_for_pr );
 		if( DEBUGL2 )Dump_line_list("Read_status_info - starting, Printer_list",
 			&Printer_list);
+#endif
 		while( look_for_pr && index_list < l.count ){
 			s = l.list[index_list];
 			if( s == 0 || isspace(cval(s)) || !(t = strstr(s,"Printer:"))
@@ -568,6 +576,7 @@ void Get_parms(int argc, char *argv[] )
 		s = Printer_list.list[i];
 		All_printers = !safestrcasecmp(s,"all");
 	}
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL1){
 		LOGDEBUG("All_printers %d, D_flag %d, d_flag %d, r_flag %d, R_flag %d, s_flag %d, t_flag %d, l_flag %d, P_flag %d",
 			All_printers, D_flag,  d_flag, r_flag, R_flag, s_flag, t_flag, l_flag, P_flag );
@@ -581,6 +590,7 @@ void Get_parms(int argc, char *argv[] )
 		LOGDEBUG("v_flag %d, v_val '%s'", v_flag, v_val );
 		Dump_line_list("lpstat - Printer_list", &Printer_list);
 	}
+#endif
 }
 
  char *lpstat_msg =
diff -urNBp LPRng-3.8.22/src/common/monitor.c LPRng/src/common/monitor.c
--- LPRng-3.8.22/src/common/monitor.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/monitor.c	2011-06-09 00:21:16.000000000 +0400
@@ -399,6 +399,13 @@ int tcp_open( int port )
 	sinaddr.sin_port = htons( port );
 
 	fd = socket( AF_INET, SOCK_STREAM, 0 );
+#ifdef WINDOW_1
+int windowsize=1024;
+setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+//fprintf(aaaaaa, " monitor: tcp_send\n");
+//fclose(aaaaaa);
+#endif
 	Max_open(fd);
 	err = errno;
 	if( fd < 0 ){
diff -urNBp LPRng-3.8.22/src/common/permission.c LPRng/src/common/permission.c
--- LPRng-3.8.22/src/common/permission.c	2003-09-06 00:07:19.000000000 +0400
+++ LPRng/src/common/permission.c	2011-06-09 00:24:17.000000000 +0400
@@ -19,9 +19,10 @@
 #include "permission.h"
 #include "linksupport.h"
 
-/**** ENDINCLUDE ****/
+#undef HAVE_INNETGR
 
- struct keywords permwords[] = {
+/**** ENDINCLUDE ****/
+static struct keywords permwords[] = {
 
 {"ACCEPT", 0, P_ACCEPT,0,0,0,0},
 {"AUTH", 0, P_AUTH,0,0,0,0},
@@ -93,8 +94,10 @@ int Perms_check( struct line_list *perms
 	int last_default_perm;
 	char buffer[4];
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGFC(DDB1)Dump_perm_check( "Perms_check - checking", check );
 	DEBUGFC(DDB1)Dump_line_list( "Perms_check - permissions", perms );
+#endif
 	Init_line_list(&values);
 	Init_line_list(&args);
 	last_default_perm = perm_val( Default_permission_DYN );
@@ -447,7 +450,9 @@ int match( struct line_list *list, const
 			Init_line_list(&users);
 			Get_file_image_and_split(s+1,0,0,&users,Whitespace,
 				0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUGFC(DDB3)Dump_line_list("match- file contents'", &users );
+#endif
 			result = match( &users,str,0);
 			Free_line_list(&users);
 		} else {
@@ -551,8 +556,10 @@ int match_char( struct line_list *list,
 	int i;
 	char *s;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUGF(DDB3)("match_char: value '0x%x' '%c'", value, value );
 	DEBUGFC(DDB3)Dump_line_list("match_char - lines", list );
+#endif
 	for( i = 0; result && i < list->count; ++i ){
 		if( !(s = list->list[i]) ) continue;
 		result = (safestrchr( s, value ) == 0) && (safestrchr(s,'*') == 0) ;
@@ -627,7 +634,9 @@ int ingroup( char *group, const char *us
 		Init_line_list(&users);
 		Get_file_image_and_split(group+1,0,0,&users,Whitespace,
 			0,0,0,0,0,0);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUGFC(DDB3)Dump_line_list("match- file contents'", &users );
+#endif
 		result = match_group( &users,user,0);
 		Free_line_list(&users);
 	} else if( (grent = getgrnam( group )) ){
@@ -665,6 +674,7 @@ int ingroup( char *group, const char *us
 	return( result );
 }
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 /***************************************************************************
  * Dump_perm_check( char *title, struct perm_check *check )
  * Dump perm_check information
@@ -679,8 +689,10 @@ void Dump_perm_check( char *title,  stru
 		LOGDEBUG(
 		"  user '%s', rmtuser '%s', printer '%s', service '%c', lpc '%s'",
 		check->user, check->remoteuser, check->printer, check->service, check->lpc );
+#ifdef ORIGINAL_DEBUG //JY@1020
 		Dump_host_information( "  host", check->host );
 		Dump_host_information( "  remotehost", check->remotehost );
+#endif
 /*
 		LOGDEBUG( "  ip '%s' port %d, unix_socket %d",
 			inet_ntop_sockaddr( &check->addr, buffer, sizeof(buffer)),
@@ -692,6 +704,7 @@ void Dump_perm_check( char *title,  stru
 			check->authtype, check->authfrom, check->authuser, check->authca );
 	}
 }
+#endif
 
 /***************************************************************************
  * Perm_check_to_list( struct line_list *list, struct perm_check *check )
diff -urNBp LPRng-3.8.22/src/common/printjob.c LPRng/src/common/printjob.c
--- LPRng-3.8.22/src/common/printjob.c	2003-09-06 00:07:20.000000000 +0400
+++ LPRng/src/common/printjob.c	2011-06-09 00:37:58.000000000 +0400
@@ -110,6 +110,9 @@
 
 int Print_job( int output, int status_device, struct job *job,
 	int send_job_rw_timeout, int poll_for_status, char *user_filter )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	char *FF_str, *leader_str, *trailer_str, *filter;
 	int i, of_stdin, of_stderr, if_error[2],
@@ -124,6 +127,13 @@ int Print_job( int output, int status_de
 	struct line_list *datafile, files;
 	struct stat statb;
 
+return 0;//delete
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 1\n");
+fclose(aaaaaa);
+#endif
+
 	of_pid = -1;
 	msgbuffer[0] = 0;
 	filtermsgbuffer[0] = 0;
@@ -133,6 +143,7 @@ int Print_job( int output, int status_de
 	FF_str = leader_str = trailer_str = 0;
 	files_printed = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG2( "Print_job: output fd %d", output );
 	if(DEBUGL5){
 		LOGDEBUG("Print_job: at start open fd's");
@@ -142,11 +153,16 @@ int Print_job( int output, int status_de
 			}
 		}
 	}
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL2) Dump_job( "Print_job", job );
+#endif
 	id = Find_str_value(&job->info,IDENTIFIER,Value_sep);
 	if( id == 0 ) id = Find_str_value(&job->info,TRANSFERNAME,Value_sep);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG2("Print_job: OF_Filter_DYN '%s'", OF_Filter_DYN );
+#endif
 
 	/* clear output buffer */
 	Init_buf(&Outbuf, &Outmax, &Outlen );
@@ -166,6 +182,11 @@ int Print_job( int output, int status_de
 	 * if AlwaysBanner then get user name
 	 */
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2\n");
+fclose(aaaaaa);
+#endif
 
 	banner_name = Find_str_value(&job->info, BNRNAME, Value_sep );
 	if( Always_banner_DYN && banner_name == 0 ){
@@ -175,48 +196,114 @@ int Print_job( int output, int status_de
 		if( banner_name == 0 ) banner_name = "ANONYMOUS";
 		Set_str_value(&job->info,BNRNAME,banner_name);
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.1\n");
+fclose(aaaaaa);
+#endif
 	/* suppress header overrides everything */
 	do_banner = (!Suppress_header_DYN && banner_name);
 
 	/* now we have a banner, is it at start or end? */
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG2("Print_job: do_banner %d, :hl=%d, :bs=%s, :be=%s, banner_name '%s'",
 			do_banner, Banner_last_DYN, Banner_start_DYN, Banner_end_DYN, banner_name );
+#endif
 	if( do_banner && !Banner_last_DYN ){
 		Print_banner( banner_name, Banner_start_DYN, job );
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.2\n");
+fclose(aaaaaa);
+#endif
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG2("Print_job: setup %d bytes '%s'", Outlen, Outbuf ); 
+#endif
 
 	msgbuffer[0] = 0;
 	/* do we need an OF filter? */
 	Set_block_io( output );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.3\n");
+fclose(aaaaaa);
+#endif
 	if( OF_Filter_DYN ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.4\n");
+fclose(aaaaaa);
+#endif
 		if( Run_OF_filter( send_job_rw_timeout, &of_pid, &of_stdin, &of_stderr,
 			output, &Outbuf, &Outmax, &Outlen,
 			job, id, 0,
 			msgbuffer, sizeof(msgbuffer)-1 ) ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.5\n");
+fclose(aaaaaa);
+#endif
 			goto exit;
 		}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.6\n");
+fclose(aaaaaa);
+#endif
 	} else if( Outlen ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.7\n");
+fclose(aaaaaa);
+#endif
 		/* no filter - direct to device */
 		n = Write_outbuf_to_OF(job,"LP",output, Outbuf, Outlen,
 			status_device, msgbuffer, sizeof(msgbuffer)-1,
 			send_job_rw_timeout, poll_for_status, Status_file_DYN );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.8\n");
+fclose(aaaaaa);
+#endif
 		if( n ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.9\n");
+fclose(aaaaaa);
+#endif
 			Errorcode = JFAIL;
 			SETSTATUS(job)"LP device write error '%s'", Server_status(n));
 			goto exit;
 		}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.10\n");
+fclose(aaaaaa);
+#endif
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 2.11\n");
+fclose(aaaaaa);
+#endif
 	Init_buf(&Outbuf, &Outmax, &Outlen );
 
 	/* 
 	 *  print out the data files
 	 */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 3\n");
+fclose(aaaaaa);
+#endif
 
 	for( count = 0; count < job->datafiles.count; ++count ){
 		datafile = (void *)job->datafiles.list[count];
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if(DEBUGL4)Dump_line_list("Print_job - datafile", datafile );
+#endif
 
 		Set_block_io( output );
 		transfername = Find_str_value(datafile,TRANSFERNAME,Value_sep);
@@ -258,8 +345,15 @@ int Print_job( int output, int status_de
 				Value_sep);
 		}
 		if( filter == 0 ) filter = Filter_DYN;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Print_job: format '%s', filter '%s'", format, filter );
+#endif
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 4\n");
+fclose(aaaaaa);
+#endif
 		uppercase(filter_name);
 		if( filter ){
 			s = filter;
@@ -281,7 +375,9 @@ int Print_job( int output, int status_de
 		if( fd >= 0 ) close(fd); fd = -1;
 		if( !Is_server && openname == 0 ){
 			fd = 0;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG3("Print_job: taking file from STDIN" );
+#endif
 		} else if( (fd = Checkread( openname, &statb )) < 0 ){
 			Errorcode = JFAIL;
 			LOGMSG( LOG_ERR) "Print_job: job '%s', cannot open data file '%s'",
@@ -291,7 +387,9 @@ int Print_job( int output, int status_de
 		SETSTATUS(job)"processing '%s', size %0.0f, format '%s', %s",
 			transfername, (double)statb.st_size, format, filter_title );
 		if( cval(format) == 'p' ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG3("Print_job: using 'p' formatter '%s'", Pr_program_DYN );
+#endif
 			SETSTATUS(job)"format 'p' pretty printer '%s'", Pr_program_DYN);
 			if( Pr_program_DYN == 0 ){
 				SETSTATUS(job)"no 'p' format filter available" );
@@ -299,6 +397,11 @@ int Print_job( int output, int status_de
 				goto end_of_job;
 			}
 			tempfd = Make_temp_fd(0);
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 5\n");
+fclose(aaaaaa);
+#endif
 			n = Filter_file( fd, tempfd, "PR_PROGRAM",
 				Pr_program_DYN, 0, job, 0, 1 );
 			if( n ){
@@ -324,17 +427,24 @@ int Print_job( int output, int status_de
 			if( copies > 1 ){
 				SETSTATUS(job)"doing copy %d of %d", copy+1, copies );
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			if(DEBUGL5){
 				LOGDEBUG("Print_job: doing '%s' open fd's", openname);
 				for( i = 0; i < 20; ++i ) if( fstat(i,&statb) == 0 )
 					 LOGDEBUG("  fd %d (0%o)", i, statb.st_mode&S_IFMT);
 			}
+#endif
 			Init_buf(&Outbuf, &Outmax, &Outlen );
 			if( files_printed++ && (!No_FF_separator_DYN || FF_separator_DYN) && FF_str ){
 				/* FF separator -> of_fd; */
 				SETSTATUS(job)"printing '%s' FF separator ",id);
 				Put_buf_str( FF_str, &Outbuf, &Outmax, &Outlen );
 			}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 6\n");
+fclose(aaaaaa);
+#endif
 			/* do we have output for the OF device/filter ? */
 			if( Outlen > 0 ){
 				Set_block_io( output );
@@ -362,12 +472,19 @@ int Print_job( int output, int status_de
 				Init_buf(&Outbuf, &Outmax, &Outlen );
 			}
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 7\n");
+fclose(aaaaaa);
+#endif
 			Set_block_io( output );
 			if( filter ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUG3("Print_job: format '%s' starting filter '%s'",
 					format, filter );
 				DEBUG2("Print_job: filter_stderr_to_status_file %d, ps '%s'",
 					Filter_stderr_to_status_file_DYN, Status_file_DYN );
+#endif
 				if_error[0] = if_error[1] = -1;
 				if( Filter_stderr_to_status_file_DYN && Status_file_DYN && *Status_file_DYN ){
 					if_error[1] = Checkwrite( Status_file_DYN, &statb, O_WRONLY|O_APPEND, 0, 0 );
@@ -377,8 +494,10 @@ int Print_job( int output, int status_de
 					goto end_of_job;
 				}
 				Max_open(if_error[0]); Max_open(if_error[1]);
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUG3("Print_job: %s fd if_error[%d,%d]", filter_title,
 					 if_error[0], if_error[1] );
+#endif
 				s = 0;
 				if( Backwards_compatible_filter_DYN ) s = BK_filter_options_DYN;
 				if( s == 0 ) s = Filter_options_DYN;
@@ -451,8 +570,10 @@ int Print_job( int output, int status_de
 				}
 			} else {
 				/* we write to the output device, and then get status */
+#ifdef ORIGINAL_DEBUG //JY@1020
 				DEBUG3("Print_job: format '%s' no filter, reading from %d",
 					format, fd );
+#endif
 				Init_buf(&Outbuf, &Outmax, &Outlen );
 				while( (Outlen = read(fd,Outbuf,Outmax)) > 0 ){
 					Outbuf[Outlen] = 0;
@@ -472,9 +593,13 @@ int Print_job( int output, int status_de
 				}
 				Outlen = 0;
 			}
+#ifdef ORIGINAL_DEBUG //JY@1020
 			DEBUG3("Print_job: finished copy");
+#endif
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Print_job: finished file");
+#endif
 	}
 
 	/* 
@@ -482,7 +607,9 @@ int Print_job( int output, int status_de
 	 */
  end_of_job:
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG3("Print_job: end of job");
+#endif
 	Init_buf(&Outbuf, &Outmax, &Outlen );
 
 	/* check for the banner at the end */
@@ -499,6 +626,11 @@ int Print_job( int output, int status_de
 	/* 
 	 * Trailer_on_close_DYN -> of_fd;
 	 */ 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 8\n");
+fclose(aaaaaa);
+#endif
 	if( trailer_str ) Put_buf_str( trailer_str, &Outbuf, &Outmax, &Outlen );
 
 	/*
@@ -529,6 +661,11 @@ int Print_job( int output, int status_de
 		}
 	}
 	Init_buf(&Outbuf, &Outmax, &Outlen );
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "printjob: printjob check point 9\n");
+fclose(aaaaaa);
+#endif
 #ifdef HAVE_TCDRAIN
 	if( isatty( output ) && tcdrain( output ) == -1 ){
 		LOGERR_DIE(LOG_INFO)"Print_job: tcdrain failed");
@@ -546,6 +683,7 @@ int Print_job( int output, int status_de
 	if( of_stderr != -1 ) close(of_stderr); of_stderr = -1;
 	if( tempfd != -1 ) close(tempfd); tempfd = -1;
 	if( fd != -1 ) close(fd); fd = -1;
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3){
 		LOGDEBUG("Print_job: at end open fd's");
 		for( i = 0; i < 20; ++i ){
@@ -554,8 +692,10 @@ int Print_job( int output, int status_de
 			}
 		}
 	}
+#endif
 	return( Errorcode );
 }
+#endif
 
 /*
  * int Create_OF_filter( int *of_stdin, int *of_stderr )
@@ -572,6 +712,9 @@ int Run_OF_filter( int send_job_rw_timeo
 	int output, char **outbuf, int *outmax, int *outlen,
 	struct job *job, char *id, int terminate_of,
 	char *msgbuffer, int msglen )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	char msg[SMALLBUFFER];
 	char *s;
@@ -579,6 +722,12 @@ int Run_OF_filter( int send_job_rw_timeo
 	struct stat statb;
 	struct line_list files;
 
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 1\n");
+fclose(aaaaaa);
+#endif
+
 	if( *of_pid < 0 ){
 		Init_line_list(&files);
 		of_fd[0] = of_fd[1] = of_error[0] = of_error[1] = -1;
@@ -595,9 +744,16 @@ int Run_OF_filter( int send_job_rw_timeo
 			LOGERR(LOG_INFO)"Run_OF_filter: pipe() failed");
 			goto exit;
 		}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 2\n");
+fclose(aaaaaa);
+#endif
 		Max_open(of_fd[0]); Max_open(of_fd[1]);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG2("Run_OF_filter: errors_to_ps %d, ps '%s'", Filter_stderr_to_status_file_DYN,
 			Status_file_DYN );
+#endif
 		of_error[0] = of_error[1] = -1;
 		if( Filter_stderr_to_status_file_DYN && Status_file_DYN && *Status_file_DYN ){
 			of_error[1] = Checkwrite( Status_file_DYN, &statb, O_WRONLY|O_APPEND, 0, 0 );
@@ -607,31 +763,80 @@ int Run_OF_filter( int send_job_rw_timeo
 			goto exit;
 		}
 		Max_open(of_error[0]); Max_open(of_error[1]);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: fd of_fd[%d,%d], of_error[%d,%d]",
 			of_fd[0], of_fd[1], of_error[0], of_error[1] );
+#endif
 
 		/* set format */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.1\n");
+fclose(aaaaaa);
+#endif
 		Set_str_value(&job->info,FORMAT,"o");
 		/* set up file descriptors */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.2\n");
+fclose(aaaaaa);
+#endif
 
 		s = 0;
 		if( Backwards_compatible_filter_DYN ) s = BK_of_filter_options_DYN;
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.3\n");
+fclose(aaaaaa);
+#endif
 		if( s == 0 ) s = OF_filter_options_DYN;
 		if( s == 0 ) s = Filter_options_DYN;
 
 		Check_max(&files,10);
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.4\n");
+fclose(aaaaaa);
+#endif
 		files.list[files.count++] = Cast_int_to_voidstar(of_fd[0]);	/* stdin */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.5\n");
+fclose(aaaaaa);
+#endif
 		files.list[files.count++] = Cast_int_to_voidstar(output);	/* stdout */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.6\n");
+fclose(aaaaaa);
+#endif
 		files.list[files.count++] = Cast_int_to_voidstar(of_error[1]);	/* stderr */
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.7\n");
+fclose(aaaaaa);
+#endif
 		if( (*of_pid = Make_passthrough( OF_Filter_DYN, s,&files, job, 0 ))<0){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 3.8\n");
+fclose(aaaaaa);
+#endif
 			Errorcode = JFAIL;
 			LOGERR(LOG_INFO)"Run_OF_filter: could not create OF process");
 			goto exit;
 		}
 		files.count = 0;
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 4\n");
+fclose(aaaaaa);
+#endif
 		Free_line_list(&files);
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: OF pid %d", *of_pid );
+#endif
 		if( of_fd[0] > 0 &&  (close( of_fd[0] ) == -1 ) ){
 			Errorcode = JFAIL;
 			LOGERR(LOG_INFO)"Run_OF_filter: X0 close(%d) failed", of_fd[0]);
@@ -644,39 +849,77 @@ int Run_OF_filter( int send_job_rw_timeo
 			goto exit;
 		}
 		of_error[1] = -1;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: writing init to OF pid '%d', count %d", *of_pid, *outlen );
+#endif
 
 		*of_stderr = of_error[0];
 		*of_stdin = of_fd[1];
 	} else {
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: SIGCONT to to OF pid '%d'", *of_pid );
+#endif
 		kill( *of_pid, SIGCONT );
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5\n");
+fclose(aaaaaa);
+#endif
 	if( Suspend_OF_filter_DYN && !terminate_of ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.1\n");
+fclose(aaaaaa);
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: stopping OF pid '%d'", *of_pid );
+#endif
 		Put_buf_str( Filter_stop, outbuf, outmax, outlen );
 		n = Write_outbuf_to_OF(job,"OF",*of_stdin,
 			*outbuf, *outlen,
 			*of_stderr, msgbuffer, msglen,
 			send_job_rw_timeout, 0, Status_file_DYN );
 		if( n == 0 ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.2\n");
+fclose(aaaaaa);
+#endif
 			n = Get_status_from_OF(job,"OF",*of_pid,
 				*of_stderr, msgbuffer, msglen,
 				send_job_rw_timeout, 1, Filter_poll_interval_DYN, Status_file_DYN );
 		}
 		if( n != JSUSP ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.3\n");
+fclose(aaaaaa);
+#endif
 			Errorcode = n;
 			SETSTATUS(job)"OF filter problems, error '%s'", Server_status(n));
 			goto exit;
 		}
 		SETSTATUS(job)"OF filter suspended" );
 	} else {
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.4\n");
+fclose(aaaaaa);
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG3("Run_OF_filter: end OF pid '%d'", *of_pid );
+#endif
 		n = Write_outbuf_to_OF(job,"OF",*of_stdin,
 			*outbuf, *outlen,
 			*of_stderr, msgbuffer, msglen,
 			send_job_rw_timeout, 0, Status_file_DYN );
 		if( n ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.5\n");
+fclose(aaaaaa);
+#endif
 			Errorcode = n;
 			SETSTATUS(job)"OF filter problems, error '%s'", Server_status(n));
 			goto exit;
@@ -687,6 +930,11 @@ int Run_OF_filter( int send_job_rw_timeo
 			*of_stderr, msgbuffer, msglen,
 			send_job_rw_timeout, 0, 0, Status_file_DYN );
 		if( n ){
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 5.6\n");
+fclose(aaaaaa);
+#endif
 			Errorcode = n;
 			SETSTATUS(job)"OF filter problems, error '%s'", Server_status(n));
 			goto exit;
@@ -695,6 +943,11 @@ int Run_OF_filter( int send_job_rw_timeo
 		*of_stderr = -1;
 		/* now we get the exit status for the filter */
 		time_left = send_job_rw_timeout;
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 6\n");
+fclose(aaaaaa);
+#endif
 		while(1){
 			/* now we get the exit status for the filter */
 			n = Wait_for_pid( *of_pid, "OF", 0, time_left );
@@ -712,12 +965,22 @@ int Run_OF_filter( int send_job_rw_timeo
 							continue;
 						}
 					}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 7\n");
+fclose(aaaaaa);
+#endif
 				default:
 					Errorcode = n;
 					SETSTATUS(job)"%s filter exit status '%s'",
 						"OF", Server_status(n));
 					goto exit;
 			}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: check point 8\n");
+fclose(aaaaaa);
+#endif
 			SETSTATUS(job) "%s filter finished", "OF" );
 			break;
 		}
@@ -725,8 +988,14 @@ int Run_OF_filter( int send_job_rw_timeo
 	}
 	return( 0 );
  exit:
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "Run_OF_filter: EXIT!\n");
+fclose(aaaaaa);
+#endif
 	return( -1 );
 }
+#endif
 
 /*
  * Print a banner
@@ -734,7 +1003,12 @@ int Run_OF_filter( int send_job_rw_timeo
  */
 
 void Print_banner( char *name, char *pgm, struct job *job )
+#ifdef ORIGINAL_DEBUG //JY@1020
 {
+#else
+{}
+#endif
+#ifdef ORIGINAL_DEBUG //JY@1020
 	char buffer[LARGEBUFFER];
 	int len, n;
 	char *bl = 0;
@@ -743,6 +1017,7 @@ void Print_banner( char *name, char *pgm
 	/*
 	 * print the banner
 	 */
+#ifdef ORIGINAL_DEBUG //JY@1020
 	if(DEBUGL3){
 		struct stat statb; int i;
 		LOGDEBUG("Print_banner: at start open fd's");
@@ -752,10 +1027,13 @@ void Print_banner( char *name, char *pgm
 			}
 		}
 	}
+#endif
 	if( !pgm ) pgm = Banner_printer_DYN;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	DEBUG2( "Print_banner: name '%s', pgm '%s', sb=%d, Banner_line_DYN '%s'",
 		name, pgm, Short_banner_DYN, Banner_line_DYN );
+#endif
 
 	if( !pgm && !Short_banner_DYN ){
 		return;
@@ -788,7 +1066,9 @@ void Print_banner( char *name, char *pgm
 			LOGERR_DIE(LOG_INFO)"Print_banner: Xa close(%d) failed",
 				tempfd);
 		}
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG4("Print_banner: BANNER '%s'", Outbuf+len);
+#endif
 	} else {
 		struct line_list l;
 		Init_line_list(&l);
@@ -810,6 +1090,7 @@ void Print_banner( char *name, char *pgm
 		}
 	}
 }
+#endif
 
 /*
  * Write_outbuf_to_OF(
@@ -834,6 +1115,9 @@ int Write_outbuf_to_OF( struct job *job,
 	int of_fd, char *buffer, int outlen,
 	int of_error, char *msg, int msgmax,
 	int timeout, int poll_for_status, char *status_file )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	time_t start_time, current_time;
 	int msglen, return_status, count, elapsed, left;
@@ -920,10 +1204,12 @@ int Write_outbuf_to_OF( struct job *job,
 			of_fd, &buffer, &outlen, left );
 		DEBUG4("Write_outbuf_to_OF: return_status %d, count %d, '%s'",
 			return_status, count, msg);
+#ifdef ORIGINAL_DEBUG //JY@1020
 		if( DEBUGL4 ){
 			char smb[32]; SNPRINTF(smb,sizeof(smb))"%s",msg);
 			logDebug("Write_outbuf_to_OF: writing '%s...'", smb );
 		}
+#endif
 		if( count > 0 ){
 			msglen += count;
 			msg[msglen] = 0;
@@ -941,6 +1227,7 @@ int Write_outbuf_to_OF( struct job *job,
 	/* read and see if there is any status coming back */
 	return( return_status );
 }
+#endif
 
 /*
  * int Get_status_from_OF( struct job *job, char *title, int of_pid,
@@ -954,6 +1241,9 @@ int Write_outbuf_to_OF( struct job *job,
 int Get_status_from_OF( struct job *job, char *title, int of_pid,
 	int of_error, char *msg, int msgmax,
 	int timeout, int suspend, int max_wait, char *status_file )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	time_t start_time, current_time;
 	int m, msglen, return_status, count, elapsed, left, done;
@@ -1060,8 +1350,14 @@ int Get_status_from_OF( struct job *job,
 			}
 		} while( count > 0 );
 	}
+#ifdef JYDEBUG//JYWeng
+fopen("/tmp/qqqqq" ,"a");
+fprintf(aaaaaa, "Get_status_from_OF: status=%d\n", return_status);
+fclose(aaaaaa);
+#endif
 	return(return_status);
 }
+#endif
 
 /****************************************************************************
  * int Wait_for_pid( int of_pid, char *name, int suspend, int timeout )
@@ -1082,6 +1378,9 @@ int Get_status_from_OF( struct job *job,
  ****************************************************************************/
 
 int Wait_for_pid( int of_pid, char *name, int suspend, int timeout )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	int pid, err, return_code;
  	plp_status_t ps_status;
@@ -1140,3 +1439,4 @@ int Wait_for_pid( int of_pid, char *name
 	errno = err;
 	return( return_code );
 }
+#endif
diff -urNBp LPRng-3.8.22/src/common/sendjob.c LPRng/src/common/sendjob.c
--- LPRng-3.8.22/src/common/sendjob.c	2003-09-06 00:07:20.000000000 +0400
+++ LPRng/src/common/sendjob.c	2011-06-09 00:23:41.000000000 +0400
@@ -135,8 +135,10 @@ int Send_job( struct job *job, struct jo
 
 	errno = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	sock = Link_open_list( RemoteHost_DYN,
 		&real_host, connect_timeout_len, 0, Unix_socket_path_DYN );
+#endif
 
 	err = errno;
 	DEBUG4("Send_job: socket %d", sock );
diff -urNBp LPRng-3.8.22/src/common/sendreq.c LPRng/src/common/sendreq.c
--- LPRng-3.8.22/src/common/sendreq.c	2003-09-06 00:07:20.000000000 +0400
+++ LPRng/src/common/sendreq.c	2011-06-09 00:23:50.000000000 +0400
@@ -88,7 +88,9 @@ int Send_request(
 	DEBUG1("Send_request: connnect_timeout %d, transfer_timeout %d",
 			connnect_timeout, transfer_timeout );
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	security = Fix_send_auth(0,&info, 0, errormsg, sizeof(errormsg) );
+#endif
 
 	DEBUG1("Send_request: security %s", security?security->name:0 );
 	if( security ){
@@ -132,8 +134,10 @@ int Send_request(
 	cmd = safeextend2(cmd,"\n", __FILE__,__LINE__ );
 	errno = 0;
 
+#ifdef ORIGINAL_DEBUG //JY@1020
 	sock = Link_open_list( RemoteHost_DYN,
 		&real_host, connnect_timeout, 0, Unix_socket_path_DYN );
+#endif
 	err = errno;
 	if( sock < 0 ){
 		char *msg = "";
@@ -169,8 +173,10 @@ int Send_request(
 	}
 	/* now send the command line */
 	if( security && security->client_send ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 		status = Send_auth_transfer( &sock, transfer_timeout, 0, 0,
 			errormsg, sizeof(errormsg), cmd, security, &info );
+#endif
 	} else {
 		status = Link_send( RemoteHost_DYN, &sock, transfer_timeout,
 			cmd, safestrlen(cmd), 0 );
diff -urNBp LPRng-3.8.22/src/common/utilities.c LPRng/src/common/utilities.c
--- LPRng-3.8.22/src/common/utilities.c	2003-09-06 00:07:20.000000000 +0400
+++ LPRng/src/common/utilities.c	2011-06-09 00:26:14.000000000 +0400
@@ -11,6 +11,7 @@
 "$Id: utilities.c,v 1.57 2003/09/05 20:07:20 papowell Exp $";
 
 #include "lp.h"
+#include "lp_asus.h"
 
 #include "utilities.h"
 #include "getopt.h"
@@ -144,10 +145,22 @@ void Printlist( char **m, int fd )
 int Write_fd_len( int fd, const char *msg, int len )
 {
 	int i;
+	int busy_index = 0;//JY1110: add sock
 
 	i = len;
 	while( len > 0 && (i = write( fd, msg, len ) ) >= 0 ){
 		len -= i, msg += i;
+		if(i == 0)
+			busy_index++;//JY1110: add sock
+		else
+			busy_index=0;
+			
+		if(busy_index > 3){//JY1110: add sock
+			check_prn_status("BUSY or ERROR", clientaddr);
+		}
+		else{
+			check_prn_status("Printing", clientaddr);
+		}
 	}
 	return( (i < 0) ? -1 : 0 );
 }
@@ -444,8 +457,8 @@ int safestrcmp( const char *s1, const ch
 /* perform safe comparison, even with null pointers */
 int safestrlen( const char *s1 )
 {
-	if( s1 ) return(strlen(s1));
-	return(0);
+	if (s1 != NULL) return strlen(s1);
+	return 0;
 }
 
 
@@ -597,6 +610,9 @@ int Get_max_servers( void )
  ***************************************************************************/
 
 int Get_max_fd( void )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	int n = 0;	/* We need some sort of limit here */
 
@@ -632,6 +648,7 @@ int Get_max_fd( void )
 	DEBUG1("Get_max_fd: returning %d", n );
 	return( n );
 }
+#endif
 
 
 char *Brk_check_size( void )
@@ -743,6 +760,9 @@ int Set_block_io( int fd )
 int Read_write_timeout(
 	int readfd, char *inbuffer, int maxinlen, int *readlen,
 	int writefd, char **outbuffer, int *outlen, int timeout )
+#ifndef ORIGINAL_DEBUG //JY@1020
+{ return 0; }
+#else
 {
 	time_t start_t, current_t;
 	int elapsed, m, err, done, retval;
@@ -814,12 +834,16 @@ int Read_write_timeout(
             FD_SET_FIX((fd_set *))&writefds,
             FD_SET_FIX((fd_set *))0, tp );
 		err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 		DEBUG4("Read_write_timeout: select returned %d, errno '%s'",
 			m, Errormsg(err) );
+#endif
 		if( m < 0 ){
 			if( err != EINTR ){
+#ifdef ORIGINAL_DEBUG //JY@1020
 				LOGERR(LOG_INFO)"Read_write_timeout: select returned %d, errno '%s'",
 				m, Errormsg(err) );
+#endif
 				retval = JTIMEOUT;
 				done = 1;
 			}
@@ -864,6 +888,7 @@ int Read_write_timeout(
 	errno = err;
 	return( retval );
 }
+#endif
 
 /***************************************************************************
  * Set up alarms so LPRng doesn't hang forever during transfers.
@@ -890,6 +915,13 @@ int Read_write_timeout(
 	Alarm_timed_out = 1;
 	signal( SIGALRM, SIG_IGN );
 	errno = EINTR;
+#if 1//JY1110: timeout while writing
+/*JY1111*/
+	check_prn_status("BUSY or ERROR", clientaddr);
+	send_ack_packet(currten_sock, ACK_FAIL);//JY1120
+/**/
+exit(0);
+#endif
 #if defined(HAVE_SIGLONGJMP)
 	siglongjmp(Timeout_env,1);
 #else
@@ -1383,23 +1415,29 @@ int Set_full_group( int euid, int gid )
 			}
 			if( initgroups(user, pw->pw_gid ) == -1 ){
 				err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 				LOGERR_DIE(LOG_ERR) "Set_full_group: initgroups failed '%s'",
 					Errormsg( err ) );
+#endif
 			}
 		} else
 #endif
 #if defined(HAVE_SETGROUPS)
 			if( setgroups(0,0) == -1 ){
 				err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 				LOGERR_DIE(LOG_ERR) "Set_full_group: setgroups failed '%s'",
 					Errormsg( err ) );
+#endif
 			}
 #endif
 		status = setgid( gid );
 		if( status < 0 ){
 			err = errno;
+#ifdef ORIGINAL_DEBUG //JY@1020
 			LOGERR_DIE(LOG_ERR) "Set_full_group: setgid '%d' failed '%s'",
 				gid, Errormsg( err ) );
+#endif
 		}
 	}
 	return( 0 );
@@ -1490,6 +1528,9 @@ void Reset_daemonuid(void)
 #  define BLOCKS(f)    (double)f.f_bavail
 # endif
 
+#ifdef JYDEBUG1//JYWeng
+FILE *aaaaaa;
+#endif
 
 /***************************************************************************
  * Check_space() - check to see if there is enough space
@@ -1505,6 +1546,26 @@ double Space_avail( char *pathname )
 	} else {
 		space = BLOCKS(fsb) * (BLOCKSIZE(fsb)/1024.0);
 	}
+#ifdef JYDEBUG//JYWeng
+aaaaaa=fopen("/tmp/qqqqq", "a");
+fprintf(aaaaaa, "TYPE=%d\n", USE_STATFS_TYPE);
+fprintf(aaaaaa, "Space_avail: fsb_bsize=%d\n", fsb.f_bsize);
+fprintf(aaaaaa, "Space_avail: fsb_frsize=%d\n", fsb.f_frsize);
+fprintf(aaaaaa, "Space_avail: fsb_block=%d\n", fsb.f_blocks);
+fprintf(aaaaaa, "Space_avail: fsb_bfree=%d\n", fsb.f_bfree);
+fprintf(aaaaaa, "Space_avail: fsb_bavail=%d\n", fsb.f_bavail);
+fprintf(aaaaaa, "Space_avail: fsb_files=%d\n", fsb.f_files);
+fprintf(aaaaaa, "Space_avail: fsb_ffree=%d\n", fsb.f_ffree);
+fprintf(aaaaaa, "Space_avail: fsb_favail=%d\n", fsb.f_favail);
+fprintf(aaaaaa, "Space_avail: fsb_f_flag=%d\n", fsb.f_flag);
+fprintf(aaaaaa, "BLOCKS(fsb)=%f\n", BLOCKS(fsb));
+fprintf(aaaaaa, "BLOCKSIZE(fsb)=%f\n", BLOCKSIZE(fsb));
+fprintf(aaaaaa, "space=%f\n", space);
+fclose(aaaaaa);
+#endif
+#ifdef JYDEBUG//JYWeng
+space=3000.0;
+#endif
 	return(space);
 }
 
diff -urNBp LPRng-3.8.22/src/common/vars.c LPRng/src/common/vars.c
--- LPRng-3.8.22/src/common/vars.c	2003-09-06 00:07:20.000000000 +0400
+++ LPRng/src/common/vars.c	2004-11-11 10:29:17.000000000 +0300
@@ -25,7 +25,7 @@
 #include "permission.h"
 #include "printjob.h"
 /**** ENDINCLUDE ****/
-
+#ifdef REMOVE
 /***************************************************************************
 
 Commentary:
@@ -553,3 +553,4 @@ struct keywords DYN_var_list[] = {
 
 { (char *)0,0,0,0,0,0,0 }
 } ;
+#endif
diff -urNBp LPRng-3.8.22/src/freefs.c LPRng/src/freefs.c
--- LPRng-3.8.22/src/freefs.c	1970-01-01 03:00:00.000000000 +0300
+++ LPRng/src/freefs.c	2011-05-15 14:26:17.000000000 +0400
@@ -0,0 +1,75 @@
+#include "portable.h"
+/**** ENDINCLUDE ****/
+
+#ifdef HAVE_SYS_MOUNT_H
+# include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_STATVFS_H
+# include <sys/statvfs.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+# include <sys/statfs.h>
+#endif
+#if defined(HAVE_SYS_VFS_H) && !defined(SOLARIS)
+# include <sys/vfs.h>
+#endif
+
+#ifdef SUNOS
+extern int statfs(const char *, struct statfs *);
+#endif
+
+# if USE_STATFS_TYPE == STATVFS
+#  define plp_statfs(path,buf) statvfs(path,buf)
+#  define plp_struct_statfs struct statvfs
+#  define statfs(path, buf) statvfs(path, buf)
+#  define USING "STATVFS"
+#  define BLOCKSIZE(f) (unsigned long)(f.f_frsize?f.frsize:f.f_bsize)
+#  define BLOCKS(f)    (unsigned long)f.f_bavail
+# endif
+
+# if USE_STATFS_TYPE == ULTRIX_STATFS
+#  define plp_statfs(path,buf) statfs(path,buf)
+#  define plp_struct_statfs struct fs_data
+#  define USING "ULTRIX_STATFS"
+#  define BLOCKSIZE(f) (unsigned long)f.fd_bsize
+#  define BLOCKS(f)    (unsigned long)f.fd_bfree
+# endif
+
+# if USE_STATFS_TYPE ==  SVR3_STATFS
+#  define plp_struct_statfs struct statfs
+#  define plp_statfs(path,buf) statfs(path,buf,sizeof(struct statfs),0)
+#  define USING "SV3_STATFS"
+#  define BLOCKSIZE(f) (unsigned long)f.f_bsize
+#  define BLOCKS(f)    (unsigned long)f.f_bfree
+# endif
+
+# if USE_STATFS_TYPE == STATFS
+#  define plp_struct_statfs struct statfs
+#  define plp_statfs(path,buf) statfs(path,buf)
+#  define USING "STATFS"
+#  define BLOCKSIZE(f) (unsigned long)f.f_bsize
+#  define BLOCKS(f)    (unsigned long)f.f_bavail
+# endif
+
+/***************************************************************************
+ * Space_avail() - get the amount of free space avail in the spool directory
+ ***************************************************************************/
+
+int main( int argc, char *argv[], char *envp[] )
+{
+	char *pathname = argv[1];
+	plp_struct_statfs fsb;
+	unsigned long space = 0;
+
+	if( !pathname ){
+		pathname = ".";
+	}
+	if( plp_statfs( pathname, &fsb ) == -1 ){
+		fprintf(stderr, "Space_avail: cannot stat '%s'", pathname );
+		exit(1);
+	}
+	space = (1.0 * BLOCKS(fsb) * BLOCKSIZE(fsb))/1024;
+	printf("path '%s', Using '%s', %lu blocks, %lu blocksize, space %lu\n",
+	pathname, USING, BLOCKS(fsb), BLOCKSIZE(fsb), space );
+	return(0);
+}
diff -urNBp LPRng-3.8.22/src/include/linelist.h LPRng/src/include/linelist.h
--- LPRng-3.8.22/src/include/linelist.h	2003-09-06 00:07:21.000000000 +0400
+++ LPRng/src/include/linelist.h	2004-11-11 10:29:18.000000000 +0300
@@ -240,7 +240,11 @@ void Find_pc_info( char *name,
 void Clear_var_list( struct keywords *v, int setv );
 void Set_var_list( struct keywords *keys, struct line_list *values );
 int Check_str_keyword( const char *name, int *value );
+#if defined(JYWENG20031104Config_value_conversion)
 void Config_value_conversion( struct keywords *key, const char *s );
+#else
+#define Config_value_conversion(...) NULL
+#endif
 void Expand_percent( char **var );
 void Expand_vars( void );
 void Expand_hash_values( struct line_list *hash );
diff -urNBp LPRng-3.8.22/src/include/lp_asus.h LPRng/src/include/lp_asus.h
--- LPRng-3.8.22/src/include/lp_asus.h	1970-01-01 03:00:00.000000000 +0300
+++ LPRng/src/include/lp_asus.h	2011-06-09 00:46:28.000000000 +0400
@@ -0,0 +1,153 @@
+/* For ASUS Space-Link by Neo Shih */
+
+#ifndef _ASUS_LP_H
+#define _ASUS_LP_H 1
+
+#ifdef LINUX26
+ #define        LP_DEV(arg)            "/dev/lp"#arg
+#else
+ #define        LP_DEV(arg)            "/dev/usb/lp"#arg
+#endif
+
+/*
+ * usr/include/linux/lp.h c.1991-1992 James Wiegand
+ * many modifications copyright (C) 1992 Michael K. Johnson
+ * Interrupt support added 1993 Nigel Gamble
+ * Removed 8255 status defines from inside __KERNEL__ Marcelo Tosatti 
+ */
+
+/*
+ * Per POSIX guidelines, this module reserves the LP and lp prefixes
+ * These are the lp_table[minor].flags flags...
+ */
+#define LP_EXIST 0x0001
+#define LP_SELEC 0x0002
+#define LP_BUSY	 0x0004
+#define LP_BUSY_BIT_POS 2
+#define LP_OFFL	 0x0008
+#define LP_NOPA  0x0010
+#define LP_ERR   0x0020
+#define LP_ABORT 0x0040
+#define LP_CAREFUL 0x0080 /* obsoleted -arca */
+#define LP_ABORTOPEN 0x0100
+
+#define LP_TRUST_IRQ_  0x0200 /* obsolete */
+#define LP_NO_REVERSE  0x0400 /* No reverse mode available. */
+#define LP_DATA_AVAIL  0x0800 /* Data is available. */
+
+/* 
+ * bit defines for 8255 status port
+ * base + 1
+ * accessed with LP_S(minor), which gets the byte...
+ */
+#define LP_PBUSY	0x80  /* inverted input, active high */
+#define LP_PACK		0x40  /* unchanged input, active low */
+#define LP_POUTPA	0x20  /* unchanged input, active high */
+#define LP_PSELECD	0x10  /* unchanged input, active high */
+#define LP_PERRORP	0x08  /* unchanged input, active low */
+
+/* timeout for each character.  This is relative to bus cycles -- it
+ * is the count in a busy loop.  THIS IS THE VALUE TO CHANGE if you
+ * have extremely slow printing, or if the machine seems to slow down
+ * a lot when you print.  If you have slow printing, increase this
+ * number and recompile, and if your system gets bogged down, decrease
+ * this number.  This can be changed with the tunelp(8) command as well.
+ */
+
+#define LP_INIT_CHAR 1000
+
+/* The parallel port specs apparently say that there needs to be
+ * a .5usec wait before and after the strobe.
+ */
+
+#define LP_INIT_WAIT 1
+
+/* This is the amount of time that the driver waits for the printer to
+ * catch up when the printer's buffer appears to be filled.  If you
+ * want to tune this and have a fast printer (i.e. HPIIIP), decrease
+ * this number, and if you have a slow printer, increase this number.
+ * This is in hundredths of a second, the default 2 being .05 second.
+ * Or use the tunelp(8) command, which is especially nice if you want
+ * change back and forth between character and graphics printing, which
+ * are wildly different...
+ */
+
+#define LP_INIT_TIME 2
+
+/* IOCTL numbers */
+#define LPCHAR   0x0601  /* corresponds to LP_INIT_CHAR */
+#define LPTIME   0x0602  /* corresponds to LP_INIT_TIME */
+#define LPABORT  0x0604  /* call with TRUE arg to abort on error, */
+			 /*   FALSE to retry.  Default is retry.  */
+#define LPSETIRQ 0x0605  /* call with new IRQ number, */
+			 /*   or 0 for polling (no IRQ) */
+#define LPGETIRQ 0x0606  /* get the current IRQ number */
+#define LPWAIT   0x0608  /* corresponds to LP_INIT_WAIT */
+/* NOTE: LPCAREFUL is obsoleted and it' s always the default right now -arca */
+#define LPCAREFUL   0x0609  /* call with TRUE arg to require out-of-paper, off- */
+			    /* line, and error indicators good on all writes, */
+			    /* FALSE to ignore them.  Default is ignore. */
+#define LPABORTOPEN 0x060a  /* call with TRUE arg to abort open() on error, */
+			    /* FALSE to ignore error.  Default is ignore.  */
+#define LPGETSTATUS 0x060b  /* return LP_S(minor) */
+#define LPRESET     0x060c  /* reset printer */
+
+
+// Neo
+/*===========================================================================*/
+#define LPGETID		0x0610 	/* get printer's device ID */
+#define LPFINDMODE	0x0611	/* find all modes supported by printer */
+#define LPSETMODE	0x0612  /* set printer to a specific mode */
+
+#define LPWRITEDATA	0x0613	/* write data to printer */
+#define LPWRITEADDR	0x0614  /* write address to printer */
+#define LPREADDATA	0x0615	/* read data from pinter */
+#define LPREADADDR	0x0616	/* read address from pinter */
+
+#define LPSETID		0x0617  /* set process id to printer, added by Joey */
+
+struct print_buffer{
+int len;
+char *buf;
+};
+/*===========================================================================*/
+
+
+#ifdef LP_STATS
+#define LPGETSTATS  0x060d  /* get statistics (struct lp_stats) */
+#endif
+#define LPGETFLAGS  0x060e  /* get status flags */
+#define LPSETTIMEOUT 0x060f /* set parport timeout */
+
+
+/* timeout for printk'ing a timeout, in jiffies (100ths of a second).
+   This is also used for re-checking error conditions if LP_ABORT is
+   not set.  This is the default behavior. */
+
+#define LP_TIMEOUT_INTERRUPT	(60 * HZ)
+#define LP_TIMEOUT_POLLED	(10 * HZ)
+
+#endif /* _ASUS_LP_H */
+
+void check_prn_status(char *status_prn, char *cliadd_prn);
+int open_printer(void);
+void processReq_LPR(int talk);
+void send_ack_packet(int *talk, int ack);
+int get_queue_name(char *input);
+int Link_file_read_test(char *host, int *sock, int readtimeout, int writetimeout,
+      int fd, double *count, int *ack );
+
+//JYWENG20031106status
+int *currten_sock;//JY1120
+char printerstatus[32];
+char clientaddr[32];//JY1110
+int fd_print;//JY1110
+FILE *STATUSFILE;//JY1113
+typedef struct lptStatus//JY1114: move from lpd.c
+{
+    int     pid;        //PID of the process using the printer
+    char    addr[32];   //IP address of the Process
+    char    busy;       //TRUE if the Printer is busy otherwise FALSE
+} LPT_STATUS;
+LPT_STATUS          lptstatus;  //Golbal variable to store the status of server
+
diff -urNBp LPRng-3.8.22/src/include/lp.h LPRng/src/include/lp.h
--- LPRng-3.8.22/src/include/lp.h	2003-09-06 00:07:21.000000000 +0400
+++ LPRng/src/include/lp.h	2011-06-09 00:46:30.000000000 +0400
@@ -467,3 +467,9 @@ extern int dmalloc_outfile;
 #endif
 
 #endif
+
+#define FALSE   0
+#define TRUE    1
+#define ONLINE	"On-line"
+#define printf(fmt, args...) 
+
diff -urNBp LPRng-3.8.22/src/include/wlancom.h LPRng/src/include/wlancom.h
--- LPRng-3.8.22/src/include/wlancom.h	1970-01-01 03:00:00.000000000 +0300
+++ LPRng/src/include/wlancom.h	2011-06-09 00:48:01.000000000 +0400
@@ -0,0 +1,96 @@
+
+#ifndef __WLAN_COMMON__
+#define __WLAN_COMMON__
+
+
+/****************************************/
+/*              FOR LINUX               */
+/****************************************/
+#ifndef  WIN32
+#define ULONG   unsigned long
+#define DWORD   unsigned long
+#define BYTE    char
+#define PBYTE   char *
+#define WORD    unsigned short
+#define INT     int
+#endif //#ifndef  WIN32
+
+
+//Define Error Code
+
+/************ Use Internally in Program************/
+#define	ERR_SUCCESS				0
+#define	ERR_SOCKET				-1
+#define	ERR_CONNFAILED			-2
+#define	ERR_SERVERBUSY			-3
+/************ Use Internally in Program************/
+
+#define	ERR_BASE				100
+#define	ERR_SERVER_OCCUPIED		ERR_BASE + 1
+#define	ERR_SERVER_LPT_FAIL		ERR_BASE + 2
+#define	ERR_SERVER_LPT_INTR		ERR_BASE + 3
+#define	ERR_SERVER_LPT_BUSY		ERR_BASE + 4
+#define	ERR_SERVER_LPT_OUTP		ERR_BASE + 5
+#define	ERR_SERVER_LPT_OFFL		ERR_BASE + 6
+
+//Use For Network Communication Protocol
+
+//Packet Type Section
+#define NET_SERVICE_ID_BASE	10
+#define NET_SERVICE_ID_LPT_EMU	NET_SERVICE_ID_BASE + 1
+
+
+//Packet Type Section
+#define NET_PACKET_TYPE_BASE	20
+#define NET_PACKET_TYPE_CMD	NET_PACKET_TYPE_BASE + 1
+#define NET_PACKET_TYPE_RES	NET_PACKET_TYPE_BASE + 2
+#define NET_PACKET_TYPE_DATA	NET_PACKET_TYPE_BASE + 3
+
+
+//Command ID Section
+#define NET_CMD_ID_BASE		30
+#define NET_CMD_ID_OPEN		NET_CMD_ID_BASE + 1
+#define NET_CMD_ID_CLOSE	NET_CMD_ID_BASE + 2
+#define NET_CMD_ID_DATA_RES	NET_CMD_ID_BASE + 3
+#define NET_CMD_ID_READ		NET_CMD_ID_BASE + 4
+
+
+//Command Packet Header Structure
+
+typedef struct lptCmdPKT
+{
+	BYTE		ServiceID;
+	BYTE		PacketType;
+	BYTE		CommandID;
+	BYTE		ParaLength;
+} LPT_CMD_PKT_HDR;
+
+
+//Response Packet Header Structure
+
+typedef struct lptResPKT
+{
+	BYTE		ServiceID;
+	BYTE		PacketType;
+	BYTE		CommandID;
+	BYTE		ResLength;
+} LPT_RES_PKT_HDR;
+
+
+
+
+//Data Packet Header Structure
+
+typedef struct lptDataPKT
+{
+	BYTE		ServiceID;
+	BYTE		PacketType;
+	WORD		DataLength;
+} LPT_DATA_PKT_HDR;
+
+typedef struct paraRes
+{
+	INT			msgid;
+}ParaRes;
+
+#endif
diff -urNBp LPRng-3.8.22/UTILS/tcpsend.c LPRng/UTILS/tcpsend.c
--- LPRng-3.8.22/UTILS/tcpsend.c	2001-08-25 21:57:08.000000000 +0400
+++ LPRng/UTILS/tcpsend.c	2011-06-09 00:48:45.000000000 +0400
@@ -103,6 +103,13 @@ int main( int argc, char **argv )
 		if( sock != -1 ) close(sock );
 		sock = -1;
 		sock = socket(AF_INET, SOCK_STREAM, 0 );
+#ifdef WINDOW_1
+int windowsize=1024;
+setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&windowsize, sizeof(windowsize));
+//aaaaaa=fopen("/tmp/qqqqq", "a");
+//fprintf(aaaaaa, "tcp_send: main\n");
+//fclose(aaaaaa);
+#endif
 		if( sock == -1 ){
 			fprintf(stderr,"%s: socket() failed '%s'\n", Prog, strerror(errno) );
 			exit(1);
