IPv6: keep permanent addresses on admin down

 dc2b99f71ef477a31020511876ab4403fb7c4420 IPv6: keep permanent addresses on admin down
 84e8b803f1e16f3a2b8b80f80a63fa2f2f8a9be6 IPv6: addrconf notify when address is unavailable
 8f37ada5b5f6bfb4d251a7f510f249cb855b77b3 IPv6: fix race between cleanup and add/delete address

---
 net/ipv6/addrconf.c |   36 ++++++++++++++++++++++++++++++++++--
 1 file changed, 34 insertions(+), 2 deletions(-)

diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -2532,7 +2532,7 @@ static struct notifier_block ipv6_dev_no
 static int addrconf_ifdown(struct net_device *dev, int how)
 {
 	struct inet6_dev *idev;
-	struct inet6_ifaddr *ifa;
+	struct inet6_ifaddr *ifa, *keep_list, **bifa;
 
 	ASSERT_RTNL();
 
@@ -2589,11 +2589,40 @@ static int addrconf_ifdown(struct net_de
 		write_lock_bh(&idev->lock);
 	}
 #endif
+	keep_list = NULL;
+	bifa = &keep_list;
 	while ((ifa = idev->addr_list) != NULL) {
 		idev->addr_list = ifa->if_next;
 		ifa->if_next = NULL;
-		ifa->dead = 1;
+
 		addrconf_del_timer(ifa);
+
+		/* If just doing link down, and address is permanent
+		   and not link-local, then retain it. */
+		if (how == 0 &&
+		    (ifa->flags&IFA_F_PERMANENT) &&
+		    !(ipv6_addr_type(&ifa->addr) & IPV6_ADDR_LINKLOCAL)) {
+
+			/* Move to holding list */
+			*bifa = ifa;
+			bifa = &ifa->if_next;
+
+			/* If not doing DAD on this address, just keep it. */
+			if ((dev->flags&(IFF_NOARP|IFF_LOOPBACK)) ||
+//			    idev->cnf.accept_dad <= 0 ||
+			    (ifa->flags & IFA_F_NODAD))
+				continue;
+
+			/* If it was tentative already, no need to notify */
+			if (ifa->flags & IFA_F_TENTATIVE)
+				continue;
+
+			/* Flag it for later restoration when link comes up */
+			ifa->flags |= IFA_F_TENTATIVE;
+			in6_ifa_hold(ifa);
+		} else {
+			ifa->dead = 1;
+		}
 		write_unlock_bh(&idev->lock);
 
 		/* clear hash table */
@@ -2607,6 +2636,9 @@ static int addrconf_ifdown(struct net_de
 
 		write_lock_bh(&idev->lock);
 	}
+
+	idev->addr_list = keep_list;
+
 	write_unlock_bh(&idev->lock);
 
 	/* Step 5: Discard multicast list */
-- 
