diff -BurpN linux-2.6.22.orig/scripts/squashfs/Makefile linux-2.6.22/scripts/squashfs/Makefile
--- linux-2.6.22.orig/scripts/squashfs/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/Makefile	2009-10-24 17:47:57.000000000 +0000
@@ -0,0 +1,22 @@
+INCLUDEDIR = $(SRCBASE)/linux/linux-2.6/include/linux
+
+CFLAGS := -I. -idirafter$(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_GNU_SOURCE -O2
+
+all: mksquashfs unsquashfs
+
+mksquashfs: mksquashfs.o read_fs.o sort.o
+	$(CC) mksquashfs.o read_fs.o sort.o -lz -lpthread -lm -o $@
+
+mksquashfs.o: mksquashfs.c mksquashfs.h global.h sort.h
+
+read_fs.o: read_fs.c read_fs.h global.h
+
+sort.o: sort.c global.h sort.h
+
+unsquashfs: unsquashfs.o
+	$(CC) unsquashfs.o -lz -lpthread -lm -o $@
+
+unsquashfs.o: unsquashfs.c read_fs.h global.h
+
+clean:
+	-rm -f *.o mksquashfs unsquashfs
diff -BurpN linux-2.6.22.orig/scripts/squashfs/global.h linux-2.6.22/scripts/squashfs/global.h
--- linux-2.6.22.orig/scripts/squashfs/global.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/global.h	2008-08-20 04:45:40.000000000 +0000
@@ -0,0 +1,74 @@
+#ifndef GLOBAL_H 
+#define GLOBAL_H
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * global.h
+ */
+
+typedef struct squashfs_super_block squashfs_super_block;
+typedef struct squashfs_dir_index squashfs_dir_index;
+typedef struct squashfs_base_inode_header squashfs_base_inode_header;
+typedef struct squashfs_ipc_inode_header squashfs_ipc_inode_header;
+typedef struct squashfs_dev_inode_header squashfs_dev_inode_header;
+typedef struct squashfs_symlink_inode_header squashfs_symlink_inode_header;
+typedef struct squashfs_reg_inode_header squashfs_reg_inode_header;
+typedef struct squashfs_lreg_inode_header squashfs_lreg_inode_header;
+typedef struct squashfs_dir_inode_header squashfs_dir_inode_header;
+typedef struct squashfs_ldir_inode_header squashfs_ldir_inode_header;
+typedef struct squashfs_dir_entry squashfs_dir_entry;
+typedef struct squashfs_dir_header squashfs_dir_header;
+typedef struct squashfs_fragment_entry squashfs_fragment_entry;
+typedef union squashfs_inode_header squashfs_inode_header;
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+typedef struct squashfs_dir_index_1 squashfs_dir_index_1;
+typedef struct squashfs_base_inode_header_1 squashfs_base_inode_header_1;
+typedef struct squashfs_ipc_inode_header_1 squashfs_ipc_inode_header_1;
+typedef struct squashfs_dev_inode_header_1 squashfs_dev_inode_header_1;
+typedef struct squashfs_symlink_inode_header_1 squashfs_symlink_inode_header_1;
+typedef struct squashfs_reg_inode_header_1 squashfs_reg_inode_header_1;
+typedef struct squashfs_dir_inode_header_1 squashfs_dir_inode_header_1;
+typedef union squashfs_inode_header_1 squashfs_inode_header_1;
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+typedef struct squashfs_dir_index_2 squashfs_dir_index_2;
+typedef struct squashfs_base_inode_header_2 squashfs_base_inode_header_2;
+typedef struct squashfs_ipc_inode_header_2 squashfs_ipc_inode_header_2;
+typedef struct squashfs_dev_inode_header_2 squashfs_dev_inode_header_2;
+typedef struct squashfs_symlink_inode_header_2 squashfs_symlink_inode_header_2;
+typedef struct squashfs_reg_inode_header_2 squashfs_reg_inode_header_2;
+typedef struct squashfs_lreg_inode_header_2 squashfs_lreg_inode_header_2;
+typedef struct squashfs_dir_inode_header_2 squashfs_dir_inode_header_2;
+typedef struct squashfs_ldir_inode_header_2 squashfs_ldir_inode_header_2;
+typedef struct squashfs_dir_entry_2 squashfs_dir_entry_2;
+typedef struct squashfs_dir_header_2 squashfs_dir_header_2;
+typedef struct squashfs_fragment_entry_2 squashfs_fragment_entry_2;
+typedef union squashfs_inode_header_2 squashfs_inode_header_2;
+#endif
+
+typedef unsigned int squashfs_uid;
+typedef long long squashfs_fragment_index;
+typedef squashfs_inode_t squashfs_inode;
+typedef squashfs_block_t squashfs_block;
+
+#endif
diff -BurpN linux-2.6.22.orig/scripts/squashfs/mksquashfs.c linux-2.6.22/scripts/squashfs/mksquashfs.c
--- linux-2.6.22.orig/scripts/squashfs/mksquashfs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/mksquashfs.c	2008-08-26 07:01:39.000000000 +0000
@@ -0,0 +1,4223 @@
+/*
+ * Create a squashfs filesystem.  This is a highly compressed read only filesystem.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * mksquashfs.c
+ */
+
+#define FALSE 0
+#define TRUE 1
+
+#include <pwd.h>
+#include <grp.h>
+#include <time.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <string.h>
+#include <zlib.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <setjmp.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <pthread.h>
+#include <math.h>
+#include <regex.h>
+#include <fnmatch.h>
+
+#ifndef linux
+#define __BYTE_ORDER BYTE_ORDER
+#define __BIG_ENDIAN BIG_ENDIAN
+#define __LITTLE_ENDIAN LITTLE_ENDIAN
+#include <sys/sysctl.h>
+#else
+#include <endian.h>
+#include <sys/sysinfo.h>
+#endif
+
+#include <squashfs_fs.h>
+#include "mksquashfs.h"
+#include "global.h"
+#include "sort.h"
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	do { \
+					if(progress_enabled) \
+						printf("\n"); \
+					printf("mksquashfs: "s, ## args); \
+				} while(0)
+#else
+#define TRACE(s, args...)
+#endif
+
+#define INFO(s, args...)	do {\
+					 if(!silent)\
+						printf("mksquashfs: "s, ## args);\
+				} while(0)
+#define ERROR(s, args...)	do {\
+					pthread_mutex_lock(&progress_mutex); \
+					if(progress_enabled) \
+						fprintf(stderr, "\n"); \
+					fprintf(stderr, s, ## args);\
+					pthread_mutex_unlock(&progress_mutex); \
+				} while(0)
+#define EXIT_MKSQUASHFS()	do {\
+					if(restore)\
+						restorefs();\
+					if(delete && destination_file && !block_device)\
+						unlink(destination_file);\
+					exit(1);\
+				} while(0)
+#define BAD_ERROR(s, args...)	do {\
+					pthread_mutex_lock(&progress_mutex); \
+					if(progress_enabled) \
+						fprintf(stderr, "\n"); \
+					fprintf(stderr, "FATAL ERROR:" s, ##args);\
+					pthread_mutex_unlock(&progress_mutex); \
+					EXIT_MKSQUASHFS();\
+				} while(0)
+
+int delete = FALSE;
+int fd;
+int cur_uncompressed = 0, estimated_uncompressed = 0;
+int columns;
+
+/* filesystem flags for building */
+int duplicate_checking = 1, noF = 0, no_fragments = 0, always_use_fragments = 0;
+int noI = 0, noD = 0, check_data = 0;
+int swap, silent = TRUE;
+long long global_uid = -1, global_gid = -1;
+int exportable = TRUE;
+int progress = TRUE;
+int progress_enabled = FALSE;
+int sparse_files = TRUE;
+int old_exclude = TRUE;
+int use_regex = FALSE;
+
+/* superblock attributes */
+int block_size = SQUASHFS_FILE_SIZE, block_log;
+unsigned short uid_count = 0, guid_count = 0;
+squashfs_uid uids[SQUASHFS_UIDS], guids[SQUASHFS_GUIDS];
+int block_offset;
+int file_count = 0, sym_count = 0, dev_count = 0, dir_count = 0, fifo_count = 0, sock_count = 0;
+
+/* write position within data section */
+long long bytes = 0, total_bytes = 0;
+
+/* in memory directory table - possibly compressed */
+char *directory_table = NULL;
+unsigned int directory_bytes = 0, directory_size = 0, total_directory_bytes = 0;
+
+/* cached directory table */
+char *directory_data_cache = NULL;
+unsigned int directory_cache_bytes = 0, directory_cache_size = 0;
+
+/* in memory inode table - possibly compressed */
+char *inode_table = NULL;
+unsigned int inode_bytes = 0, inode_size = 0, total_inode_bytes = 0;
+
+/* cached inode table */
+char *data_cache = NULL;
+unsigned int cache_bytes = 0, cache_size = 0, inode_count = 0;
+
+/* inode lookup table */
+squashfs_inode *inode_lookup_table = NULL;
+
+/* in memory directory data */
+#define I_COUNT_SIZE		128
+#define DIR_ENTRIES		32
+#define INODE_HASH_SIZE		65536
+#define INODE_HASH_MASK		(INODE_HASH_SIZE - 1)
+#define INODE_HASH(dev, ino)	(ino & INODE_HASH_MASK)
+
+struct cached_dir_index {
+	squashfs_dir_index	index;
+	char			*name;
+};
+
+struct directory {
+	unsigned int		start_block;
+	unsigned int		size;
+	unsigned char		*buff;
+	unsigned char		*p;
+	unsigned int		entry_count;
+	unsigned char		*entry_count_p;
+	unsigned int		i_count;
+	unsigned int		i_size;
+	struct cached_dir_index	*index;
+	unsigned char		*index_count_p;
+	unsigned int		inode_number;
+};
+
+struct inode_info *inode_info[INODE_HASH_SIZE];
+
+/* hash tables used to do fast duplicate searches in duplicate check */
+struct file_info *dupl[65536];
+int dup_files = 0;
+
+/* exclude file handling */
+/* list of exclude dirs/files */
+struct exclude_info {
+	dev_t			st_dev;
+	ino_t			st_ino;
+};
+
+#define EXCLUDE_SIZE 8192
+int exclude = 0;
+struct exclude_info *exclude_paths = NULL;
+int old_excluded(char *filename, struct stat *buf);
+
+struct path_entry {
+	char *name;
+	regex_t *preg;
+	struct pathname *paths;
+};
+
+struct pathname {
+	int names;
+	struct path_entry *name;
+};
+
+struct pathnames {
+	int count;
+	struct pathname *path[0];
+};
+#define PATHS_ALLOC_SIZE 10
+
+struct pathnames *paths = NULL;
+struct pathname *path = NULL;
+struct pathname *stickypath = NULL;
+int excluded(struct pathnames *paths, char *name, struct pathnames **new);
+
+/* fragment block data structures */
+int fragments = 0;
+struct file_buffer *fragment_data = NULL;
+int fragment_size = 0;
+
+struct fragment {
+	unsigned int		index;
+	int			offset;
+	int			size;
+};
+
+#define FRAG_SIZE 32768
+#define FRAG_INDEX (1LL << 32)
+
+squashfs_fragment_entry *fragment_table = NULL;
+int fragments_outstanding = 0;
+
+/* current inode number for directories and non directories */
+unsigned int dir_inode_no = 1;
+unsigned int inode_no = 0;
+unsigned int root_inode_number = 0;
+
+/* list of source dirs/files */
+int source = 0;
+char **source_path;
+
+/* list of root directory entries read from original filesystem */
+int old_root_entries = 0;
+struct old_root_entry_info {
+	char			name[SQUASHFS_NAME_LEN + 1];
+	squashfs_inode		inode;
+	int			type;
+	int			inode_number;
+};
+struct old_root_entry_info *old_root_entry;
+
+/* in memory file info */
+struct file_info {
+	long long		file_size;
+	long long		bytes;
+	unsigned short		checksum;
+	unsigned short		fragment_checksum;
+	long long		start;
+	unsigned int		*block_list;
+	struct file_info	*next;
+	struct fragment		*fragment;
+	char			checksum_flag;
+};
+
+/* count of how many times SIGINT or SIGQUIT has been sent */
+int interrupted = 0;
+
+/* restore orignal filesystem state if appending to existing filesystem is cancelled */
+jmp_buf env;
+char *sdata_cache, *sdirectory_data_cache, *sdirectory_compressed;
+
+long long sbytes, stotal_bytes;
+
+unsigned int sinode_bytes, scache_bytes, sdirectory_bytes,
+	sdirectory_cache_bytes, sdirectory_compressed_bytes, suid_count, sguid_count,
+	stotal_inode_bytes, stotal_directory_bytes,
+	sinode_count = 0, sfile_count, ssym_count, sdev_count,
+	sdir_count, sfifo_count, ssock_count, sdup_files;
+int sfragments;
+int restore = 0;
+int threads;
+
+/* flag whether destination file is a block device */
+int block_device = 0;
+
+/* flag indicating whether files are sorted using sort list(s) */
+int sorted = 0;
+
+/* save destination file name for deleting on error */
+char *destination_file = NULL;
+
+/* recovery file for abnormal exit on appending */
+char recovery_file[1024] = "";
+int recover = TRUE;
+
+/* struct describing a cache entry passed between threads */
+struct file_buffer {
+	struct cache *cache;
+	int keep;
+	long long file_size;
+	long long index;
+	long long block;
+	long long sequence;
+	int size;
+	int c_byte;
+	int used;
+	int	fragment;
+	int error;
+	struct file_buffer *hash_next;
+	struct file_buffer *hash_prev;
+	struct file_buffer *free_next;
+	struct file_buffer *free_prev;
+	struct file_buffer *next;
+	char data[0];
+};
+
+
+/* struct describing queues used to pass data between threads */
+struct queue {
+	int			size;
+	int			readp;
+	int			writep;
+	pthread_mutex_t		mutex;
+	pthread_cond_t		empty;
+	pthread_cond_t		full;
+	void			**data;
+};
+
+/* describes the list of blocks in a file which is a possible
+   duplicate.  For each block, it indicates whether the block is
+   in memory or on disk */
+struct buffer_list {
+	long long start;
+	int size;
+	struct file_buffer *read_buffer;
+};
+
+struct cache *reader_buffer, *writer_buffer, *fragment_buffer;
+struct queue *to_reader, *from_reader, *to_writer, *from_writer, *from_deflate, *to_frag;
+pthread_t *thread, *deflator_thread, *frag_deflator_thread, progress_thread;
+pthread_mutex_t	fragment_mutex;
+pthread_cond_t fragment_waiting;
+pthread_mutex_t	pos_mutex;
+pthread_mutex_t progress_mutex;
+pthread_cond_t progress_wait;
+int rotate = 0;
+
+/* user options that control parallelisation */
+int processors = -1;
+/* default size of output buffer in Mbytes */
+#define WRITER_BUFFER_DEFAULT 512
+/* default size of input buffer in Mbytes */
+#define READER_BUFFER_DEFAULT 64
+/* default size of fragment buffer in Mbytes */
+#define FRAGMENT_BUFFER_DEFAULT 64
+int writer_buffer_size;
+int reader_buffer_size;
+int fragment_buffer_size;
+
+void add_old_root_entry(char *name, squashfs_inode inode, int inode_number, int type);
+extern int read_super(int fd, squashfs_super_block *sBlk, int *be, char *source);
+extern long long read_filesystem(char *root_name, int fd, squashfs_super_block *sBlk, char **cinode_table,
+		char **data_cache, char **cdirectory_table, char **directory_data_cache,
+		unsigned int *last_directory_block, unsigned int *inode_dir_offset, unsigned int *inode_dir_file_size,
+		unsigned int *root_inode_size, unsigned int *inode_dir_start_block, int *file_count, int *sym_count,
+		int *dev_count, int *dir_count, int *fifo_count, int *sock_count, squashfs_uid *uids,
+		unsigned short *uid_count, squashfs_uid *guids, unsigned short *guid_count,
+		long long *uncompressed_file, unsigned int *uncompressed_inode, unsigned int *uncompressed_directory,
+		unsigned int *inode_dir_inode_number, unsigned int *inode_dir_parent_inode,
+		void (push_directory_entry)(char *, squashfs_inode, int, int),
+		squashfs_fragment_entry **fragment_table, squashfs_inode **inode_lookup_table);
+extern int read_sort_file(char *filename, int source, char *source_path[]);
+extern void sort_files_and_write(struct dir_info *dir);
+struct file_info *duplicate(long long file_size, long long bytes, unsigned int **block_list, long long *start, struct fragment **fragment, struct file_buffer *file_buffer, struct buffer_list *buffer_list, int blocks, unsigned short checksum, unsigned short fragment_checksum, int checksum_flag);
+struct dir_info *dir_scan1(char *, struct pathnames *, int (_readdir)(char *, char *, struct dir_info *));
+void dir_scan2(squashfs_inode *inode, struct dir_info *dir_info);
+struct file_info *add_non_dup(long long file_size, long long bytes, unsigned int *block_list, long long start, struct fragment *fragment, unsigned short checksum, unsigned short fragment_checksum, int checksum_flag);
+extern void generate_file_priorities(struct dir_info *dir, int priority, struct stat *buf);
+extern struct priority_entry *priority_list[65536];
+void progress_bar(long long current, long long max, int columns);
+
+
+struct queue *queue_init(int size)
+{
+	struct queue *queue = malloc(sizeof(struct queue));
+
+	if(queue == NULL)
+		return NULL;
+
+	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL) {
+		free(queue);
+		return NULL;
+	}
+
+	queue->size = size + 1;
+	queue->readp = queue->writep = 0;
+	pthread_mutex_init(&queue->mutex, NULL);
+	pthread_cond_init(&queue->empty, NULL);
+	pthread_cond_init(&queue->full, NULL);
+
+	return queue;
+}
+
+
+void queue_put(struct queue *queue, void *data)
+{
+	int nextp;
+
+	pthread_mutex_lock(&queue->mutex);
+
+	while((nextp = (queue->writep + 1) % queue->size) == queue->readp)
+		pthread_cond_wait(&queue->full, &queue->mutex);
+
+	queue->data[queue->writep] = data;
+	queue->writep = nextp;
+	pthread_cond_signal(&queue->empty);
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+
+void *queue_get(struct queue *queue)
+{
+	void *data;
+	pthread_mutex_lock(&queue->mutex);
+
+	while(queue->readp == queue->writep)
+		pthread_cond_wait(&queue->empty, &queue->mutex);
+
+	data = queue->data[queue->readp];
+	queue->readp = (queue->readp + 1) % queue->size;
+	pthread_cond_signal(&queue->full);
+	pthread_mutex_unlock(&queue->mutex);
+
+	return data;
+}
+
+
+/* Cache status struct.  Caches are used to keep
+  track of memory buffers passed between different threads */
+struct cache {
+	int	max_buffers;
+	int	count;
+	int	buffer_size;
+	pthread_mutex_t	mutex;
+	pthread_cond_t wait_for_free;
+	struct file_buffer *free_list;
+	struct file_buffer *hash_table[65536];
+};
+
+
+#define INSERT_LIST(NAME, TYPE) \
+void insert_##NAME##_list(TYPE **list, TYPE *entry) { \
+	if(*list) { \
+		entry->NAME##_next = *list; \
+		entry->NAME##_prev = (*list)->NAME##_prev; \
+		(*list)->NAME##_prev->NAME##_next = entry; \
+		(*list)->NAME##_prev = entry; \
+	} else { \
+		*list = entry; \
+		entry->NAME##_prev = entry->NAME##_next = entry; \
+	} \
+}
+
+
+#define REMOVE_LIST(NAME, TYPE) \
+void remove_##NAME##_list(TYPE **list, TYPE *entry) { \
+	if(entry->NAME##_prev == entry && entry->NAME##_next == entry) { \
+		/* only this entry in the list */ \
+		*list = NULL; \
+	} else if(entry->NAME##_prev != NULL && entry->NAME##_next != NULL) { \
+		/* more than one entry in the list */ \
+		entry->NAME##_next->NAME##_prev = entry->NAME##_prev; \
+		entry->NAME##_prev->NAME##_next = entry->NAME##_next; \
+		if(*list == entry) \
+			*list = entry->NAME##_next; \
+	} \
+	entry->NAME##_prev = entry->NAME##_next = NULL; \
+}
+
+
+#define CALCULATE_HASH(start)	(start & 0xffff) \
+
+
+/* Called with the cache mutex held */
+void insert_hash_table(struct cache *cache, struct file_buffer *entry)
+{
+	int hash = CALCULATE_HASH(entry->index);
+
+	entry->hash_next = cache->hash_table[hash];
+	cache->hash_table[hash] = entry;
+	entry->hash_prev = NULL;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry;
+}
+
+
+/* Called with the cache mutex held */
+void remove_hash_table(struct cache *cache, struct file_buffer *entry)
+{
+	if(entry->hash_prev)
+		entry->hash_prev->hash_next = entry->hash_next;
+	else
+		cache->hash_table[CALCULATE_HASH(entry->index)] = entry->hash_next;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry->hash_prev;
+
+	entry->hash_prev = entry->hash_next = NULL;
+}
+
+
+/* Called with the cache mutex held */
+INSERT_LIST(free, struct file_buffer)
+
+/* Called with the cache mutex held */
+REMOVE_LIST(free, struct file_buffer)
+
+
+struct cache *cache_init(int buffer_size, int max_buffers)
+{
+	struct cache *cache = malloc(sizeof(struct cache));
+
+	if(cache == NULL)
+		return NULL;
+
+	cache->max_buffers = max_buffers;
+	cache->buffer_size = buffer_size;
+	cache->count = 0;
+	cache->free_list = NULL;
+	memset(cache->hash_table, 0, sizeof(struct file_buffer *) * 65536);
+	pthread_mutex_init(&cache->mutex, NULL);
+	pthread_cond_init(&cache->wait_for_free, NULL);
+
+	return cache;
+}
+
+
+struct file_buffer *cache_lookup(struct cache *cache, long long index)
+{
+	/* Lookup block in the cache, if found return with usage count
+ 	 * incremented, if not found return NULL */
+	int hash = CALCULATE_HASH(index);
+	struct file_buffer *entry;
+
+	pthread_mutex_lock(&cache->mutex);
+
+	for(entry = cache->hash_table[hash]; entry; entry = entry->hash_next)
+		if(entry->index == index)
+			break;
+
+	if(entry) {
+		/* found the block in the cache, increment used count and
+ 		 * if necessary remove from free list so it won't disappear
+ 		 */
+		entry->used ++;
+		remove_free_list(&cache->free_list, entry);
+	}
+
+	pthread_mutex_unlock(&cache->mutex);
+
+	return entry;
+}
+
+
+#define GET_FREELIST 1
+
+struct file_buffer *cache_get(struct cache *cache, long long index, int keep)
+{
+	/* Get a free block out of the cache indexed on index. */
+	struct file_buffer *entry;
+
+	pthread_mutex_lock(&cache->mutex);
+
+	while(1) {
+		/* first try to get a block from the free list */
+#ifdef GET_FREELIST
+		if(cache->free_list) {
+			/* a block on the free_list is a "keep" block */
+			entry = cache->free_list;
+			remove_free_list(&cache->free_list, entry);
+			remove_hash_table(cache, entry);
+			break;
+		} else
+#endif
+		if(cache->count < cache->max_buffers) {
+			/* next try to allocate new block */
+			entry = malloc(sizeof(struct file_buffer) + cache->buffer_size);
+			if(entry == NULL)
+				goto failed;
+			entry->cache = cache;
+			entry->free_prev = entry->free_next = NULL;
+			cache->count ++;
+			break;
+		} else
+#ifndef GET_FREELIST
+		if(cache->free_list) {
+			/* a block on the free_list is a "keep" block */
+			entry = cache->free_list;
+			remove_free_list(&cache->free_list, entry);
+			remove_hash_table(cache, entry);
+			break;
+		}
+#endif
+			/* wait for a block */
+			pthread_cond_wait(&cache->wait_for_free, &cache->mutex);
+	}
+
+	/* initialise block and if a keep block insert into the hash table */
+	entry->used = 1;
+	entry->error = FALSE;
+	entry->keep = keep;
+	if(keep) {
+		entry->index = index;
+		insert_hash_table(cache, entry);
+	}
+	pthread_mutex_unlock(&cache->mutex);
+
+	return entry;
+
+failed:
+	pthread_mutex_unlock(&cache->mutex);
+	return NULL;
+}
+
+
+void cache_rehash(struct file_buffer *entry, long long index)
+{
+	struct cache *cache = entry->cache;
+
+	pthread_mutex_lock(&cache->mutex);
+	if(entry->keep)
+		remove_hash_table(cache, entry);
+	entry->keep = TRUE;
+	entry->index = index;
+	insert_hash_table(cache, entry);
+	pthread_mutex_unlock(&cache->mutex);
+}
+
+
+void cache_block_put(struct file_buffer *entry)
+{
+	struct cache *cache;
+
+	/* finished with this cache entry, once the usage count reaches zero it
+ 	 * can be reused and if a keep block put onto the free list.  As keep
+ 	 * blocks remain accessible via the hash table they can be found getting a
+ 	 * new lease of life before they are reused. */
+
+	if(entry == NULL)
+		return;
+
+	cache = entry->cache;
+
+	pthread_mutex_lock(&cache->mutex);
+
+	entry->used --;
+	if(entry->used == 0) {
+		if(entry->keep)
+			insert_free_list(&cache->free_list, entry);
+		else {
+			free(entry);
+			cache->count --;
+		}
+
+		/* One or more threads may be waiting on this block */
+		pthread_cond_signal(&cache->wait_for_free);
+	}
+
+	pthread_mutex_unlock(&cache->mutex);
+}
+
+
+#define MKINODE(A)	((squashfs_inode)(((squashfs_inode) inode_bytes << 16) + (((char *)A) - data_cache)))
+
+
+inline void inc_progress_bar()
+{
+	cur_uncompressed ++;
+}
+
+
+inline void update_progress_bar()
+{
+	pthread_mutex_lock(&progress_mutex);
+	pthread_cond_signal(&progress_wait);
+	pthread_mutex_unlock(&progress_mutex);
+}
+
+
+inline void waitforthread(int i)
+{
+	TRACE("Waiting for thread %d\n", i);
+	while(thread[i] != 0)
+		sched_yield();
+}
+
+
+void restorefs()
+{
+	int i;
+
+	if(thread == NULL || thread[0] == 0)
+		return;
+
+	ERROR("Exiting - restoring original filesystem!\n\n");
+
+	for(i = 0; i < 2 + processors * 2; i++)
+		if(thread[i])
+			pthread_kill(thread[i], SIGUSR1);
+	for(i = 0; i < 2 + processors * 2; i++)
+		waitforthread(i);
+	TRACE("All threads in signal handler\n");
+	bytes = sbytes;
+	memcpy(data_cache, sdata_cache, cache_bytes = scache_bytes);
+	memcpy(directory_data_cache, sdirectory_data_cache, directory_cache_bytes = sdirectory_cache_bytes);
+	inode_bytes = sinode_bytes;
+	directory_bytes = sdirectory_bytes;
+	memcpy(directory_table + directory_bytes, sdirectory_compressed, sdirectory_compressed_bytes);
+	directory_bytes += sdirectory_compressed_bytes;
+	uid_count = suid_count;
+	guid_count = sguid_count;
+	total_bytes = stotal_bytes;
+	total_inode_bytes = stotal_inode_bytes;
+	total_directory_bytes = stotal_directory_bytes;
+	inode_count = sinode_count;
+	file_count = sfile_count;
+	sym_count = ssym_count;
+	dev_count = sdev_count;
+	dir_count = sdir_count;
+	fifo_count = sfifo_count;
+	sock_count = ssock_count;
+	dup_files = sdup_files;
+	fragments = sfragments;
+	fragment_size = 0;
+	longjmp(env, 1);
+}
+
+
+void sighandler()
+{
+	if(++interrupted > 2)
+		return;
+	if(interrupted == 2)
+		restorefs();
+	else {
+		ERROR("Interrupting will restore original filesystem!\n");
+		ERROR("Interrupt again to quit\n");
+	}
+}
+
+
+void sighandler2()
+{
+	EXIT_MKSQUASHFS();
+}
+
+
+void sigusr1_handler()
+{
+	int i;
+	sigset_t sigmask;
+	pthread_t thread_id = pthread_self();
+
+	for(i = 0; i < (2 + processors * 2) && thread[i] != thread_id; i++);
+	thread[i] = (pthread_t) 0;
+
+	TRACE("Thread %d(%p) in sigusr1_handler\n", i, &thread_id);
+
+	sigemptyset(&sigmask);
+	sigaddset(&sigmask, SIGINT);
+	sigaddset(&sigmask, SIGQUIT);
+	sigaddset(&sigmask, SIGUSR1);
+	while(1) {
+		sigsuspend(&sigmask);
+		TRACE("After wait in sigusr1_handler :(\n");
+	}
+}
+
+
+void sigwinch_handler()
+{
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		printf("TIOCGWINSZ ioctl failed, defaulting to 80 columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+}
+
+
+void sigalrm_handler()
+{
+	rotate = (rotate + 1) % 4;
+}
+
+
+unsigned int mangle2(z_stream **strm, char *d, char *s, int size, int block_size, int uncompressed, int data_block)
+{
+	unsigned long c_byte;
+	unsigned int res;
+	z_stream *stream = *strm;
+
+	if(uncompressed)
+		goto notcompressed;
+
+	if(stream == NULL) {
+		if((stream = *strm = malloc(sizeof(z_stream))) == NULL)
+			BAD_ERROR("mangle::compress failed, not enough memory\n");
+
+		stream->zalloc = Z_NULL;
+		stream->zfree = Z_NULL;
+		stream->opaque = 0;
+
+		if((res = deflateInit(stream, 9)) != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				BAD_ERROR("zlib::compress failed, not enough memory\n");
+			else if(res == Z_STREAM_ERROR)
+				BAD_ERROR("zlib::compress failed, not a valid compression level\n");
+			else if(res == Z_VERSION_ERROR)
+				BAD_ERROR("zlib::compress failed, incorrect zlib version\n");
+			else
+				BAD_ERROR("zlib::compress failed, unknown error %d\n", res);
+		}
+	} else if((res = deflateReset(stream)) != Z_OK) {
+		if(res == Z_STREAM_ERROR)
+			BAD_ERROR("zlib::compress failed, stream state inconsistent\n");
+		else
+			BAD_ERROR("zlib::compress failed, unknown error %d\n", res);
+	}
+
+	stream->next_in = (unsigned char *) s;
+	stream->avail_in = size;
+	stream->next_out = (unsigned char *) d;
+	stream->avail_out = block_size;
+
+	res = deflate(stream, Z_FINISH);
+	if(res != Z_STREAM_END && res != Z_OK) {
+		if(res == Z_STREAM_ERROR)
+			BAD_ERROR("zlib::compress failed, stream state inconsistent\n");
+		else if(res == Z_BUF_ERROR)
+			BAD_ERROR("zlib::compress failed, no progress possible\n");
+		else
+			BAD_ERROR("zlib::compress failed, unknown error %d\n", res);
+	}
+
+	c_byte = stream->total_out;
+
+	if(res != Z_STREAM_END || c_byte >= size) {
+notcompressed:
+		memcpy(d, s, size);
+		return size | (data_block ? SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT);
+	}
+
+	return (unsigned int) c_byte;
+}
+
+
+unsigned int mangle(char *d, char *s, int size, int block_size, int uncompressed, int data_block)
+{
+	static z_stream *stream = NULL;
+
+	return mangle2(&stream, d, s, size, block_size, uncompressed, data_block);
+}
+
+
+squashfs_base_inode_header *get_inode(int req_size)
+{
+	int data_space;
+	unsigned short c_byte;
+
+	while(cache_bytes >= SQUASHFS_METADATA_SIZE) {
+		if((inode_size - inode_bytes) < ((SQUASHFS_METADATA_SIZE << 1)) + 2) {
+			if((inode_table = (char *) realloc(inode_table, inode_size + (SQUASHFS_METADATA_SIZE << 1) + 2))
+					== NULL) {
+				goto failed;
+			}
+			inode_size += (SQUASHFS_METADATA_SIZE << 1) + 2;
+		}
+
+		c_byte = mangle(inode_table + inode_bytes + block_offset, data_cache,
+								SQUASHFS_METADATA_SIZE, SQUASHFS_METADATA_SIZE, noI, 0);
+		TRACE("Inode block @ 0x%x, size %d\n", inode_bytes, c_byte);
+		if(!swap)
+			memcpy(inode_table + inode_bytes, &c_byte, sizeof(unsigned short));
+		else
+			SQUASHFS_SWAP_SHORTS((&c_byte), (inode_table + inode_bytes), 1);
+		if(check_data)
+			*((unsigned char *)(inode_table + inode_bytes + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
+		inode_bytes += SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
+		total_inode_bytes += SQUASHFS_METADATA_SIZE + block_offset;
+		memcpy(data_cache, data_cache + SQUASHFS_METADATA_SIZE, cache_bytes - SQUASHFS_METADATA_SIZE);
+		cache_bytes -= SQUASHFS_METADATA_SIZE;
+	}
+
+	data_space = (cache_size - cache_bytes);
+	if(data_space < req_size) {
+			int realloc_size = cache_size == 0 ? ((req_size + SQUASHFS_METADATA_SIZE) & ~(SQUASHFS_METADATA_SIZE - 1)) : req_size - data_space;
+
+			if((data_cache = (char *) realloc(data_cache, cache_size + realloc_size)) == NULL) {
+				goto failed;
+			}
+			cache_size += realloc_size;
+	}
+
+	cache_bytes += req_size;
+
+	return (squashfs_base_inode_header *)(data_cache + (cache_bytes - req_size));
+
+failed:
+	BAD_ERROR("Out of memory in inode table reallocation!\n");
+}
+
+
+void read_bytes(int fd, long long byte, int bytes, char *buff)
+{
+	off_t off = byte;
+
+	pthread_mutex_lock(&pos_mutex);
+	if(lseek(fd, off, SEEK_SET) == -1)
+		BAD_ERROR("Lseek on destination failed because %s\n", strerror(errno));
+
+	if(read(fd, buff, bytes) == -1)
+		BAD_ERROR("Read on destination failed because %s\n", strerror(errno));
+	pthread_mutex_unlock(&pos_mutex);
+}
+
+
+void write_bytes(int fd, long long byte, int bytes, char *buff)
+{
+	off_t off = byte;
+
+	if(interrupted < 2)
+		pthread_mutex_lock(&pos_mutex);
+
+	if(lseek(fd, off, SEEK_SET) == -1)
+		BAD_ERROR("Lseek on destination failed because %s\n", strerror(errno));
+
+	if(write(fd, buff, bytes) == -1)
+		BAD_ERROR("Write on destination failed because %s\n", strerror(errno));
+	
+	if(interrupted < 2)
+		pthread_mutex_unlock(&pos_mutex);
+}
+
+
+long long write_inodes()
+{
+	unsigned short c_byte;
+	int avail_bytes;
+	char *datap = data_cache;
+	long long start_bytes = bytes;
+
+	while(cache_bytes) {
+		if(inode_size - inode_bytes < ((SQUASHFS_METADATA_SIZE << 1) + 2)) {
+			if((inode_table = (char *) realloc(inode_table, inode_size + ((SQUASHFS_METADATA_SIZE << 1) + 2))) == NULL) {
+				BAD_ERROR("Out of memory in inode table reallocation!\n");
+			}
+			inode_size += (SQUASHFS_METADATA_SIZE << 1) + 2;
+		}
+		avail_bytes = cache_bytes > SQUASHFS_METADATA_SIZE ? SQUASHFS_METADATA_SIZE : cache_bytes;
+		c_byte = mangle(inode_table + inode_bytes + block_offset, datap, avail_bytes, SQUASHFS_METADATA_SIZE, noI, 0);
+		TRACE("Inode block @ 0x%x, size %d\n", inode_bytes, c_byte);
+		if(!swap)
+			memcpy(inode_table + inode_bytes, &c_byte, sizeof(unsigned short));
+		else
+			SQUASHFS_SWAP_SHORTS((&c_byte), (inode_table + inode_bytes), 1); 
+		if(check_data)
+			*((unsigned char *)(inode_table + inode_bytes + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
+		inode_bytes += SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
+		total_inode_bytes += avail_bytes + block_offset;
+		datap += avail_bytes;
+		cache_bytes -= avail_bytes;
+	}
+
+	write_bytes(fd, bytes, inode_bytes, (char *) inode_table);
+	bytes += inode_bytes;
+
+	return start_bytes;
+}
+
+
+long long write_directories()
+{
+	unsigned short c_byte;
+	int avail_bytes;
+	char *directoryp = directory_data_cache;
+	long long start_bytes = bytes;
+
+	while(directory_cache_bytes) {
+		if(directory_size - directory_bytes < ((SQUASHFS_METADATA_SIZE << 1) + 2)) {
+			if((directory_table = (char *) realloc(directory_table, directory_size +
+					((SQUASHFS_METADATA_SIZE << 1) + 2))) == NULL) {
+				BAD_ERROR("Out of memory in directory table reallocation!\n");
+			}
+			directory_size += (SQUASHFS_METADATA_SIZE << 1) + 2;
+		}
+		avail_bytes = directory_cache_bytes > SQUASHFS_METADATA_SIZE ? SQUASHFS_METADATA_SIZE : directory_cache_bytes;
+		c_byte = mangle(directory_table + directory_bytes + block_offset, directoryp, avail_bytes, SQUASHFS_METADATA_SIZE, noI, 0);
+		TRACE("Directory block @ 0x%x, size %d\n", directory_bytes, c_byte);
+		if(!swap)
+			memcpy(directory_table + directory_bytes, &c_byte, sizeof(unsigned short));
+		else
+			SQUASHFS_SWAP_SHORTS((&c_byte), (directory_table + directory_bytes), 1);
+		if(check_data)
+			*((unsigned char *)(directory_table + directory_bytes + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
+		directory_bytes += SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
+		total_directory_bytes += avail_bytes + block_offset;
+		directoryp += avail_bytes;
+		directory_cache_bytes -= avail_bytes;
+	}
+	write_bytes(fd, bytes, directory_bytes, (char *) directory_table);
+	bytes += directory_bytes;
+
+	return start_bytes;
+}
+
+
+unsigned int get_uid(squashfs_uid uid)
+{
+	int i;
+
+	for(i = 0; (i < uid_count) && uids[i] != uid; i++);
+	if(i == uid_count) {
+		if(uid_count == SQUASHFS_UIDS) {
+			ERROR("Out of uids! - using uid 0 - probably not what's wanted!\n");
+			i = 0;
+		} else
+			uids[uid_count++] = uid;
+	}
+
+	return i;
+}
+
+
+unsigned int get_guid(squashfs_uid uid, squashfs_uid guid)
+{
+	int i;
+
+	if(uid == guid)
+		return SQUASHFS_GUIDS;
+
+	for(i = 0; (i < guid_count) && guids[i] != guid; i++);
+	if(i == guid_count) {
+		if(guid_count == SQUASHFS_GUIDS) {
+			ERROR("Out of gids! - using gid 0 - probably not what's wanted!\n");
+			return SQUASHFS_GUIDS;
+		} else
+			guids[guid_count++] = guid;
+	}
+
+	return i;
+}
+
+
+int create_inode(squashfs_inode *i_no, struct dir_ent *dir_ent, int type, long long byte_size, long long start_block, unsigned int offset, unsigned int *block_list, struct fragment *fragment, struct directory *dir_in)
+{
+	struct stat *buf = &dir_ent->inode->buf;
+	squashfs_inode_header inode_header;
+	squashfs_base_inode_header *inode, *base = &inode_header.base;
+	char *filename = dir_ent->pathname;
+	int nlink = dir_ent->inode->nlink;
+	int inode_number = (type == SQUASHFS_LDIR_TYPE || type == SQUASHFS_DIR_TYPE) ? dir_ent->inode->inode_number : dir_ent->inode->inode_number + dir_inode_no;
+
+	base->mode = SQUASHFS_MODE(buf->st_mode);
+	base->uid = get_uid((squashfs_uid) global_uid == -1 ? buf->st_uid : global_uid);
+	base->inode_type = type;
+	base->guid = get_guid((squashfs_uid) global_uid == -1 ? buf->st_uid : global_uid, (squashfs_uid) global_gid == -1 ? buf->st_gid : global_gid);
+	base->mtime = buf->st_mtime;
+	base->inode_number = inode_number;
+
+	if(type == SQUASHFS_FILE_TYPE) {
+		int i;
+		squashfs_reg_inode_header *reg = &inode_header.reg, *inodep;
+
+		inode = get_inode(sizeof(*reg) + offset * sizeof(unsigned int));
+		inodep = (squashfs_reg_inode_header *) inode;
+		reg->file_size = byte_size;
+		reg->start_block = start_block;
+		reg->fragment = fragment->index;
+		reg->offset = fragment->offset;
+		if(!swap) {
+			memcpy(inodep, reg, sizeof(*reg));
+			memcpy(inodep->block_list, block_list, offset * sizeof(unsigned int));
+		} else {
+			SQUASHFS_SWAP_REG_INODE_HEADER(reg, inodep);
+			SQUASHFS_SWAP_INTS(block_list, inodep->block_list, offset);
+		}
+		TRACE("File inode, file_size %lld, start_block 0x%llx, blocks %d, fragment %d, offset %d, size %d\n", byte_size,
+			start_block, offset, fragment->index, fragment->offset, fragment->size);
+		for(i = 0; i < offset; i++)
+			TRACE("Block %d, size %d\n", i, block_list[i]);
+	}
+	else if(type == SQUASHFS_LREG_TYPE) {
+		int i;
+		squashfs_lreg_inode_header *reg = &inode_header.lreg, *inodep;
+
+		inode = get_inode(sizeof(*reg) + offset * sizeof(unsigned int));
+		inodep = (squashfs_lreg_inode_header *) inode;
+		reg->nlink = nlink;
+		reg->file_size = byte_size;
+		reg->start_block = start_block;
+		reg->fragment = fragment->index;
+		reg->offset = fragment->offset;
+		if(!swap) {
+			memcpy(inodep, reg, sizeof(*reg));
+			memcpy(inodep->block_list, block_list, offset * sizeof(unsigned int));
+		} else {
+			SQUASHFS_SWAP_LREG_INODE_HEADER(reg, inodep);
+			SQUASHFS_SWAP_INTS(block_list, inodep->block_list, offset);
+		}
+		TRACE("Long file inode, file_size %lld, start_block 0x%llx, blocks %d, fragment %d, offset %d, size %d, nlink %d\n", byte_size,
+			start_block, offset, fragment->index, fragment->offset, fragment->size, nlink);
+		for(i = 0; i < offset; i++)
+			TRACE("Block %d, size %d\n", i, block_list[i]);
+	}
+	else if(type == SQUASHFS_LDIR_TYPE) {
+		int i;
+		unsigned char *p;
+		squashfs_ldir_inode_header *dir = &inode_header.ldir, *inodep;
+		struct cached_dir_index *index = dir_in->index;
+		unsigned int i_count = dir_in->i_count;
+		unsigned int i_size = dir_in->i_size;
+
+		if(byte_size >= 1 << 27)
+			BAD_ERROR("directory greater than 2^27-1 bytes!\n");
+
+		inode = get_inode(sizeof(*dir) + i_size);
+		inodep = (squashfs_ldir_inode_header *) inode;
+		dir->inode_type = SQUASHFS_LDIR_TYPE;
+		dir->nlink = dir_ent->dir->directory_count + 2;
+		dir->file_size = byte_size;
+		dir->offset = offset;
+		dir->start_block = start_block;
+		dir->i_count = i_count;
+		dir->parent_inode = dir_ent->our_dir ? dir_ent->our_dir->dir_ent->inode->inode_number : dir_inode_no + inode_no;
+
+		if(!swap)
+			memcpy(inode, dir, sizeof(*dir));
+		else
+			SQUASHFS_SWAP_LDIR_INODE_HEADER(dir, inode);
+		p = (unsigned char *) inodep->index;
+		for(i = 0; i < i_count; i++) {
+			if(!swap)
+				memcpy(p, &index[i].index, sizeof(squashfs_dir_index));
+			else
+				SQUASHFS_SWAP_DIR_INDEX(&index[i].index, p);
+			memcpy(((squashfs_dir_index *)p)->name, index[i].name, index[i].index.size + 1);
+			p += sizeof(squashfs_dir_index) + index[i].index.size + 1;
+		}
+		TRACE("Long directory inode, file_size %lld, start_block 0x%llx, offset 0x%x, nlink %d\n", byte_size,
+			start_block, offset, dir_ent->dir->directory_count + 2);
+	}
+	else if(type == SQUASHFS_DIR_TYPE) {
+		squashfs_dir_inode_header *dir = &inode_header.dir;
+
+		inode = get_inode(sizeof(*dir));
+		dir->nlink = dir_ent->dir->directory_count + 2;
+		dir->file_size = byte_size;
+		dir->offset = offset;
+		dir->start_block = start_block;
+		dir->parent_inode = dir_ent->our_dir ? dir_ent->our_dir->dir_ent->inode->inode_number : dir_inode_no + inode_no;
+		if(!swap)
+			memcpy(inode, dir, sizeof(*dir));
+		else
+			SQUASHFS_SWAP_DIR_INODE_HEADER(dir, inode);
+		TRACE("Directory inode, file_size %lld, start_block 0x%llx, offset 0x%x, nlink %d\n", byte_size,
+			start_block, offset, dir_ent->dir->directory_count + 2);
+	}
+	else if(type == SQUASHFS_CHRDEV_TYPE || type == SQUASHFS_BLKDEV_TYPE) {
+		squashfs_dev_inode_header *dev = &inode_header.dev;
+
+		inode = get_inode(sizeof(*dev));
+		dev->nlink = nlink;
+		dev->rdev = (unsigned short) ((major(buf->st_rdev) << 8) |
+			(minor(buf->st_rdev) & 0xff));
+		if(!swap)
+			memcpy(inode, dev, sizeof(*dev));
+		else
+			SQUASHFS_SWAP_DEV_INODE_HEADER(dev, inode);
+		TRACE("Device inode, rdev 0x%x, nlink %d\n", dev->rdev, nlink);
+	}
+	else if(type == SQUASHFS_SYMLINK_TYPE) {
+		squashfs_symlink_inode_header *symlink = &inode_header.symlink, *inodep;
+		int byte;
+		char buff[65536];
+
+		if((byte = readlink(filename, buff, 65536)) == -1) {
+			ERROR("Failed to read symlink %s, creating empty symlink\n", filename);
+			byte = 0;
+		}
+
+		if(byte == 65536) {
+			ERROR("Symlink %s is greater than 65536 bytes! Creating empty symlink\n", filename);
+			byte = 0;
+		}
+
+		inode = get_inode(sizeof(*symlink) + byte);
+		symlink->nlink = nlink;
+		inodep = (squashfs_symlink_inode_header *) inode;
+		symlink->symlink_size = byte;
+		if(!swap)
+			memcpy(inode, symlink, sizeof(*symlink));
+		else
+			SQUASHFS_SWAP_SYMLINK_INODE_HEADER(symlink, inode);
+		strncpy(inodep->symlink, buff, byte);
+		TRACE("Symbolic link inode, symlink_size %d, nlink %d\n", byte, nlink);
+	}
+	else if(type == SQUASHFS_FIFO_TYPE || type == SQUASHFS_SOCKET_TYPE) {
+		squashfs_ipc_inode_header *ipc = &inode_header.ipc;
+
+		inode = get_inode(sizeof(*ipc));
+		ipc->nlink = nlink;
+		if(!swap)
+			memcpy(inode, ipc, sizeof(*ipc));
+		else
+			SQUASHFS_SWAP_IPC_INODE_HEADER(ipc, inode);
+		TRACE("ipc inode, type %s, nlink %d\n", type == SQUASHFS_FIFO_TYPE ? "fifo" : "socket", nlink);
+	} else
+		BAD_ERROR("Unrecognised inode %d in create_inode\n", type);
+
+	*i_no = MKINODE(inode);
+	inode_count ++;
+
+	TRACE("Created inode 0x%llx, type %d, uid %d, guid %d\n", *i_no, type, base->uid, base->guid);
+
+	return TRUE;
+}
+
+
+void scan2_init_dir(struct directory *dir)
+{
+	if((dir->buff = malloc(SQUASHFS_METADATA_SIZE)) == NULL) {
+		BAD_ERROR("Out of memory allocating directory buffer\n");
+	}
+
+	dir->size = SQUASHFS_METADATA_SIZE;
+	dir->p = dir->index_count_p = dir->buff;
+	dir->entry_count = 256;
+	dir->entry_count_p = NULL;
+	dir->index = NULL;
+	dir->i_count = dir->i_size = 0;
+}
+
+
+void add_dir(squashfs_inode inode, unsigned int inode_number, char *name, int type, struct directory *dir)
+{
+	unsigned char *buff;
+	squashfs_dir_entry idir, *idirp;
+	unsigned int start_block = inode >> 16;
+	unsigned int offset = inode & 0xffff;
+	unsigned int size;
+
+	if((size = strlen(name)) > SQUASHFS_NAME_LEN) {
+		size = SQUASHFS_NAME_LEN;
+		ERROR("Filename is greater than %d characters, truncating! ...\n", SQUASHFS_NAME_LEN);
+	}
+
+	if(dir->p + sizeof(squashfs_dir_entry) + size + sizeof(squashfs_dir_header) >= dir->buff + dir->size) {
+		if((buff = realloc(dir->buff, dir->size += SQUASHFS_METADATA_SIZE)) == NULL)  {
+			BAD_ERROR("Out of memory reallocating directory buffer\n");
+		}
+
+		dir->p = (dir->p - dir->buff) + buff;
+		if(dir->entry_count_p) 
+			dir->entry_count_p = (dir->entry_count_p - dir->buff + buff);
+		dir->index_count_p = dir->index_count_p - dir->buff + buff;
+		dir->buff = buff;
+	}
+
+	if(dir->entry_count == 256 || start_block != dir->start_block || ((dir->entry_count_p != NULL) && ((dir->p + sizeof(squashfs_dir_entry) + size - dir->index_count_p) > SQUASHFS_METADATA_SIZE)) || ((long long) inode_number - dir->inode_number) > 32767 || ((long long) inode_number - dir->inode_number) < - 32768) {
+		if(dir->entry_count_p) {
+			squashfs_dir_header dir_header;
+
+			if((dir->p + sizeof(squashfs_dir_entry) + size - dir->index_count_p) > SQUASHFS_METADATA_SIZE) {
+				if(dir->i_count % I_COUNT_SIZE == 0)
+					if((dir->index = realloc(dir->index, (dir->i_count + I_COUNT_SIZE) * sizeof(struct cached_dir_index))) == NULL)
+						BAD_ERROR("Out of memory in directory index table reallocation!\n");
+				dir->index[dir->i_count].index.index = dir->p - dir->buff;
+				dir->index[dir->i_count].index.size = size - 1;
+				dir->index[dir->i_count++].name = name;
+				dir->i_size += sizeof(squashfs_dir_index) + size;
+				dir->index_count_p = dir->p;
+			}
+
+			dir_header.count = dir->entry_count - 1;
+			dir_header.start_block = dir->start_block;
+			dir_header.inode_number = dir->inode_number;
+			if(!swap)
+				memcpy(dir->entry_count_p, &dir_header, sizeof(dir_header));
+			else
+				SQUASHFS_SWAP_DIR_HEADER((&dir_header), (squashfs_dir_header *) dir->entry_count_p);
+
+		}
+
+
+		dir->entry_count_p = dir->p;
+		dir->start_block = start_block;
+		dir->entry_count = 0;
+		dir->inode_number = inode_number;
+		dir->p += sizeof(squashfs_dir_header);
+	}
+
+	idirp = (squashfs_dir_entry *) dir->p;
+	idir.offset = offset;
+	idir.type = type;
+	idir.size = size - 1;
+	idir.inode_number = ((long long) inode_number - dir->inode_number);
+	if(!swap)
+		memcpy(idirp, &idir, sizeof(idir));
+	else
+		SQUASHFS_SWAP_DIR_ENTRY((&idir), idirp);
+	strncpy(idirp->name, name, size);
+	dir->p += sizeof(squashfs_dir_entry) + size;
+	dir->entry_count ++;
+}
+
+
+void write_dir(squashfs_inode *inode, struct dir_info *dir_info, struct directory *dir)
+{
+	unsigned int dir_size = dir->p - dir->buff;
+	int data_space = (directory_cache_size - directory_cache_bytes);
+	unsigned int directory_block, directory_offset, i_count, index;
+	unsigned short c_byte;
+
+	if(data_space < dir_size) {
+		int realloc_size = directory_cache_size == 0 ? ((dir_size + SQUASHFS_METADATA_SIZE) & ~(SQUASHFS_METADATA_SIZE - 1)) : dir_size - data_space;
+
+		if((directory_data_cache = (char *) realloc(directory_data_cache, directory_cache_size + realloc_size)) == NULL) {
+			goto failed;
+		}
+		directory_cache_size += realloc_size;
+	}
+
+	if(dir_size) {
+		squashfs_dir_header dir_header;
+
+		dir_header.count = dir->entry_count - 1;
+		dir_header.start_block = dir->start_block;
+		dir_header.inode_number = dir->inode_number;
+		if(!swap)
+			memcpy(dir->entry_count_p, &dir_header, sizeof(dir_header));
+		else
+			SQUASHFS_SWAP_DIR_HEADER((&dir_header), (squashfs_dir_header *) dir->entry_count_p);
+		memcpy(directory_data_cache + directory_cache_bytes, dir->buff, dir_size);
+	}
+	directory_offset = directory_cache_bytes;
+	directory_block = directory_bytes;
+	directory_cache_bytes += dir_size;
+	i_count = 0;
+	index = SQUASHFS_METADATA_SIZE - directory_offset;
+
+	while(1) {
+		while(i_count < dir->i_count && dir->index[i_count].index.index < index)
+			dir->index[i_count++].index.start_block = directory_bytes;
+		index += SQUASHFS_METADATA_SIZE;
+
+		if(directory_cache_bytes < SQUASHFS_METADATA_SIZE)
+			break;
+
+		if((directory_size - directory_bytes) < ((SQUASHFS_METADATA_SIZE << 1) + 2)) {
+			if((directory_table = (char *) realloc(directory_table,
+							directory_size + (SQUASHFS_METADATA_SIZE << 1) + 2)) == NULL) {
+				goto failed;
+			}
+			directory_size += SQUASHFS_METADATA_SIZE << 1;
+		}
+
+		c_byte = mangle(directory_table + directory_bytes + block_offset, directory_data_cache,
+				SQUASHFS_METADATA_SIZE, SQUASHFS_METADATA_SIZE, noI, 0);
+		TRACE("Directory block @ 0x%x, size %d\n", directory_bytes, c_byte);
+		if(!swap)
+			memcpy(directory_table + directory_bytes, &c_byte, sizeof(unsigned short));
+		else
+			SQUASHFS_SWAP_SHORTS((&c_byte), (directory_table + directory_bytes), 1);
+		if(check_data)
+			*((unsigned char *)(directory_table + directory_bytes + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
+		directory_bytes += SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
+		total_directory_bytes += SQUASHFS_METADATA_SIZE + block_offset;
+		memcpy(directory_data_cache, directory_data_cache + SQUASHFS_METADATA_SIZE, directory_cache_bytes - SQUASHFS_METADATA_SIZE);
+		directory_cache_bytes -= SQUASHFS_METADATA_SIZE;
+	}
+
+	if(dir_info->dir_is_ldir)
+		create_inode(inode, dir_info->dir_ent, SQUASHFS_LDIR_TYPE, dir_size + 3, directory_block, directory_offset, NULL, NULL, dir);
+	else
+		create_inode(inode, dir_info->dir_ent, SQUASHFS_DIR_TYPE, dir_size + 3, directory_block, directory_offset, NULL, NULL, NULL);
+
+#ifdef SQUASHFS_TRACE
+	if(!swap) {
+		unsigned char *dirp;
+		int count;
+
+		TRACE("Directory contents of inode 0x%llx\n", *inode);
+		dirp = dir->buff;
+		while(dirp < dir->p) {
+			char buffer[SQUASHFS_NAME_LEN + 1];
+			squashfs_dir_entry idir, *idirp;
+			squashfs_dir_header *dirh = (squashfs_dir_header *) dirp;
+			count = dirh->count + 1;
+			dirp += sizeof(squashfs_dir_header);
+
+			TRACE("\tStart block 0x%x, count %d\n", dirh->start_block, count);
+
+			while(count--) {
+				idirp = (squashfs_dir_entry *) dirp;
+				memcpy((char *) &idir, (char *) idirp, sizeof(idir));
+				strncpy(buffer, idirp->name, idir.size + 1);
+				buffer[idir.size + 1] = '\0';
+				TRACE("\t\tname %s, inode offset 0x%x, type %d\n", buffer,
+						  idir.offset, idir.type);
+				dirp += sizeof(squashfs_dir_entry) + idir.size + 1;
+			}
+		}
+	}
+#endif
+	dir_count ++;
+
+	return;
+
+failed:
+	BAD_ERROR("Out of memory in directory table reallocation!\n");
+}
+
+
+struct file_buffer *get_fragment(struct fragment *fragment)
+{
+	squashfs_fragment_entry *disk_fragment;
+	int size;
+	long long start_block;
+	struct file_buffer *buffer, *compressed_buffer;
+
+	if(fragment->index == SQUASHFS_INVALID_FRAG)
+		return NULL;
+
+	buffer = cache_lookup(fragment_buffer, fragment->index);
+	if(buffer)
+		return buffer;
+
+	compressed_buffer = cache_lookup(writer_buffer, fragment->index + FRAG_INDEX);
+
+	buffer = cache_get(fragment_buffer, fragment->index, 1);
+
+	pthread_mutex_lock(&fragment_mutex);
+	disk_fragment = &fragment_table[fragment->index];
+	size = SQUASHFS_COMPRESSED_SIZE_BLOCK(disk_fragment->size);
+	start_block = disk_fragment->start_block;
+	pthread_mutex_unlock(&fragment_mutex);
+
+	if(SQUASHFS_COMPRESSED_BLOCK(disk_fragment->size)) {
+		int res;
+		unsigned long bytes = block_size;
+		char *data;
+		char cbuffer[block_size];
+
+		if(compressed_buffer)
+			data = compressed_buffer->data;
+		else {
+			data = cbuffer;
+			read_bytes(fd, start_block, size, data);
+		}
+
+		if((res = uncompress((unsigned char *) buffer->data, &bytes, (const unsigned char *) data, size)) != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				BAD_ERROR("zlib::uncompress failed, not enough memory\n");
+			else if(res == Z_BUF_ERROR)
+				BAD_ERROR("zlib::uncompress failed, not enough room in output buffer\n");
+			else
+				BAD_ERROR("zlib::uncompress failed, unknown error %d\n", res);
+		}
+	} else if(compressed_buffer)
+		memcpy(buffer->data, compressed_buffer->data, size);
+	else
+		read_bytes(fd, start_block, size, buffer->data);
+
+	return buffer;
+}
+
+
+struct frag_locked {
+	struct file_buffer *buffer;
+	int c_byte;
+	int fragment;
+	struct frag_locked *fragment_prev;
+	struct frag_locked *fragment_next;
+};
+
+int fragments_locked = FALSE;
+struct frag_locked *frag_locked_list = NULL;
+
+INSERT_LIST(fragment, struct frag_locked)
+REMOVE_LIST(fragment, struct frag_locked)
+
+int lock_fragments()
+{
+	int count;
+	pthread_mutex_lock(&fragment_mutex);
+	fragments_locked = TRUE;
+	count = fragments_outstanding;
+	pthread_mutex_unlock(&fragment_mutex);
+	return count;
+}
+
+
+void unlock_fragments()
+{
+	struct frag_locked *entry;
+	int compressed_size;
+
+	pthread_mutex_lock(&fragment_mutex);
+	while(frag_locked_list) {
+		entry = frag_locked_list;
+		remove_fragment_list(&frag_locked_list, entry);
+		compressed_size = SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->c_byte);
+		fragment_table[entry->fragment].size = entry->c_byte;
+		fragment_table[entry->fragment].start_block = bytes;
+		entry->buffer->block = bytes;
+		bytes += compressed_size;
+		fragments_outstanding --;
+		pthread_mutex_unlock(&fragment_mutex);
+		queue_put(to_writer, entry->buffer);
+		pthread_mutex_lock(&fragment_mutex);
+		TRACE("fragment_locked writing fragment %d, compressed size %d\n", entry->fragment, compressed_size);
+		free(entry);
+	}
+	fragments_locked = FALSE;
+	pthread_mutex_unlock(&fragment_mutex);
+}
+
+
+int add_pending_fragment(struct file_buffer *write_buffer, int c_byte, int fragment)
+{
+	struct frag_locked *entry = malloc(sizeof(struct frag_locked));
+	if(entry == NULL)
+		return FALSE;
+	entry->buffer = write_buffer;
+	entry->c_byte = c_byte;
+	entry->fragment = fragment;
+	entry->fragment_prev = entry->fragment_next = NULL;
+	pthread_mutex_lock(&fragment_mutex);
+	insert_fragment_list(&frag_locked_list, entry);
+	pthread_mutex_unlock(&fragment_mutex);
+}
+
+
+void write_fragment()
+{
+	if(fragment_size == 0)
+		return;
+
+	pthread_mutex_lock(&fragment_mutex);
+	if(fragments % FRAG_SIZE == 0) {
+		if((fragment_table = (squashfs_fragment_entry *) realloc(fragment_table, (fragments + FRAG_SIZE) * sizeof(squashfs_fragment_entry))) == NULL) {
+			pthread_mutex_unlock(&fragment_mutex);
+			BAD_ERROR("Out of memory in fragment table\n");
+		}
+	}
+	fragment_data->size = fragment_size;
+	fragment_data->block = fragments;
+	fragment_table[fragments].unused = 0;
+	fragments_outstanding ++;
+	queue_put(to_frag, fragment_data);
+	fragments ++;
+	fragment_size = 0;
+	pthread_mutex_unlock(&fragment_mutex);
+}
+
+
+static struct fragment empty_fragment = {SQUASHFS_INVALID_FRAG, 0, 0};
+struct fragment *get_and_fill_fragment(struct file_buffer *file_buffer)
+{
+	struct fragment *ffrg;
+	
+
+	if(file_buffer == NULL || file_buffer->size == 0)
+		return &empty_fragment;
+
+	if(fragment_size + file_buffer->size > block_size)
+		write_fragment();
+
+	if((ffrg = (struct fragment *) malloc(sizeof(struct fragment))) == NULL)
+		BAD_ERROR("Out of memory in fragment block allocation!\n");
+
+	if(fragment_size == 0)
+		fragment_data = cache_get(fragment_buffer, fragments, 1);
+
+	ffrg->index = fragments;
+	ffrg->offset = fragment_size;
+	ffrg->size = file_buffer->size;
+	memcpy(fragment_data->data + fragment_size, file_buffer->data, file_buffer->size);
+	fragment_size += file_buffer->size;
+
+	return ffrg;
+}
+
+
+long long generic_write_table(int length, char *buffer, int uncompressed)
+{
+	int meta_blocks = (length + SQUASHFS_METADATA_SIZE - 1) / SQUASHFS_METADATA_SIZE;
+	long long list[meta_blocks], start_bytes;
+	int compressed_size, i;
+	unsigned short c_byte;
+	char cbuffer[(SQUASHFS_METADATA_SIZE << 2) + 2];
+	
+	long long obytes = bytes;
+
+	for(i = 0; i < meta_blocks; i++) {
+		int avail_bytes = length > SQUASHFS_METADATA_SIZE ? SQUASHFS_METADATA_SIZE : length;
+		c_byte = mangle(cbuffer + block_offset, buffer + i * SQUASHFS_METADATA_SIZE , avail_bytes, SQUASHFS_METADATA_SIZE, uncompressed, 0);
+		if(!swap)
+			memcpy(cbuffer, &c_byte, sizeof(unsigned short));
+		else
+			SQUASHFS_SWAP_SHORTS((&c_byte), cbuffer, 1);
+		if(check_data)
+			*((unsigned char *)(cbuffer + block_offset - 1)) = SQUASHFS_MARKER_BYTE;
+		list[i] = bytes;
+		compressed_size = SQUASHFS_COMPRESSED_SIZE(c_byte) + block_offset;
+		TRACE("block %d @ 0x%llx, compressed size %d\n", i, bytes, compressed_size);
+		write_bytes(fd, bytes, compressed_size, cbuffer);
+		bytes += compressed_size;
+		length -= avail_bytes;
+	}
+
+	if(!swap)
+		write_bytes(fd, bytes, sizeof(list), (char *) list);
+	else {
+		long long slist[meta_blocks];
+		SQUASHFS_SWAP_LONG_LONGS(list, slist, meta_blocks);
+		write_bytes(fd, bytes, sizeof(list), (char *) slist);
+	}
+
+	start_bytes = bytes;
+	bytes += sizeof(list);
+
+	TRACE("total uncompressed %d compressed %lld\n", inode_count * sizeof(squashfs_inode), bytes - obytes);
+
+	return start_bytes;
+}
+
+
+long long write_fragment_table()
+{
+	unsigned int frag_bytes = SQUASHFS_FRAGMENT_BYTES(fragments);
+	char buffer[frag_bytes];
+	squashfs_fragment_entry *p = (squashfs_fragment_entry *) buffer;
+	int i;
+
+	TRACE("write_fragment_table: fragments %d, frag_bytes %d\n", fragments, frag_bytes);
+	for(i = 0; i < fragments; i++, p++) {
+		TRACE("write_fragment_table: fragment %d, start_block 0x%llx, size %d\n", i, fragment_table[i].start_block, fragment_table[i].size);
+		if(!swap)
+			memcpy(p, &fragment_table[i], sizeof(squashfs_fragment_entry));
+		else
+			SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_table[i], p);
+	}
+
+	return generic_write_table(frag_bytes, buffer, noF);
+}
+
+
+char read_from_file_buffer[SQUASHFS_FILE_MAX_SIZE];
+char *read_from_disk(long long start, unsigned int avail_bytes)
+{
+	read_bytes(fd, start, avail_bytes, read_from_file_buffer);
+	return read_from_file_buffer;
+}
+
+
+/*
+ * Compute 16 bit BSD checksum over the data
+ */
+unsigned short get_checksum(char *buff, int bytes, unsigned short chksum)
+{
+	unsigned char *b = (unsigned char *) buff;
+
+	while(bytes --) {
+		chksum = (chksum & 1) ? (chksum >> 1) | 0x8000 : chksum >> 1;
+		chksum += *b++;
+	}
+
+	return chksum;
+}
+
+
+unsigned short get_checksum_disk(long long start, long long l, unsigned int *blocks)
+{
+	unsigned short chksum = 0;
+	unsigned int bytes;
+	struct file_buffer *write_buffer;
+	int i;
+
+	for(i = 0; l; i++)  {
+		bytes = SQUASHFS_COMPRESSED_SIZE_BLOCK(blocks[i]);
+		if(bytes == 0) /* sparse block */
+			continue;
+		write_buffer = cache_lookup(writer_buffer, start);
+		if(write_buffer) {
+			chksum = get_checksum(write_buffer->data, bytes, chksum);
+			cache_block_put(write_buffer);
+		} else
+			chksum = get_checksum(read_from_disk(start, bytes), bytes, chksum);
+		l -= bytes;
+		start += bytes;
+	}
+
+	return chksum;
+}
+
+
+unsigned short get_checksum_mem(char *buff, int bytes)
+{
+	return get_checksum(buff, bytes, 0);
+}
+
+
+unsigned short get_checksum_mem_buffer(struct file_buffer *file_buffer)
+{
+	if(file_buffer == NULL)
+		return 0;
+	else
+		return get_checksum(file_buffer->data, file_buffer->size, 0);
+}
+
+
+#define DUP_HASH(a) (a & 0xffff)
+void add_file(long long start, long long file_size, long long file_bytes, unsigned int *block_listp, int blocks, unsigned int fragment, int offset, int bytes)
+{
+	struct fragment *frg;
+	unsigned int *block_list = block_listp;
+	struct file_info *dupl_ptr = dupl[DUP_HASH(file_size)];
+
+	if(!duplicate_checking || file_size == 0)
+		return;
+
+	for(; dupl_ptr; dupl_ptr = dupl_ptr->next) {
+		if(file_size != dupl_ptr->file_size)
+			continue;
+		if(blocks != 0 && start != dupl_ptr->start)
+			continue;
+		if(fragment != dupl_ptr->fragment->index)
+			continue;
+		if(fragment != SQUASHFS_INVALID_FRAG && (offset != dupl_ptr->fragment->offset || bytes != dupl_ptr->fragment->size))
+			continue;
+		return;
+	}
+
+	if((frg = (struct fragment *) malloc(sizeof(struct fragment))) == NULL)
+		BAD_ERROR("Out of memory in fragment block allocation!\n");
+
+	frg->index = fragment;
+	frg->offset = offset;
+	frg->size = bytes;
+
+	add_non_dup(file_size, file_bytes, block_list, start, frg, 0, 0, FALSE);
+}
+
+
+int pre_duplicate(long long file_size)
+{
+	struct file_info *dupl_ptr = dupl[DUP_HASH(file_size)];
+
+	for(; dupl_ptr; dupl_ptr = dupl_ptr->next)
+		if(dupl_ptr->file_size == file_size)
+			return TRUE;
+
+	return FALSE;
+}
+
+
+int pre_duplicate_frag(long long file_size, unsigned short checksum)
+{
+	struct file_info *dupl_ptr = dupl[DUP_HASH(file_size)];
+
+	for(; dupl_ptr; dupl_ptr = dupl_ptr->next)
+		if(dupl_ptr->file_size == file_size) {
+			if(dupl_ptr->checksum_flag == FALSE) {
+				struct file_buffer *frag_buffer = get_fragment(dupl_ptr->fragment);
+				dupl_ptr->checksum = get_checksum_disk(dupl_ptr->start, dupl_ptr->bytes, dupl_ptr->block_list);
+				dupl_ptr->fragment_checksum = get_checksum_mem(frag_buffer->data + dupl_ptr->fragment->offset, file_size);
+				cache_block_put(frag_buffer);
+				dupl_ptr->checksum_flag = TRUE;
+			}
+			if(dupl_ptr->fragment_checksum == checksum)
+				return TRUE;
+		}
+
+	return FALSE;
+}
+
+
+struct file_info *add_non_dup(long long file_size, long long bytes, unsigned int *block_list, long long start, struct fragment *fragment, unsigned short checksum, unsigned short fragment_checksum, int checksum_flag)
+{
+	struct file_info *dupl_ptr;
+
+	if((dupl_ptr = (struct file_info *) malloc(sizeof(struct file_info))) == NULL) {
+		BAD_ERROR("Out of memory in dup_files allocation!\n");
+	}
+
+	dupl_ptr->file_size = file_size;
+	dupl_ptr->bytes = bytes;
+	dupl_ptr->block_list = block_list;
+	dupl_ptr->start = start;
+	dupl_ptr->fragment = fragment;
+	dupl_ptr->checksum = checksum;
+	dupl_ptr->fragment_checksum = fragment_checksum;
+	dupl_ptr->checksum_flag = checksum_flag;
+	dupl_ptr->next = dupl[DUP_HASH(file_size)];
+	dupl[DUP_HASH(file_size)] = dupl_ptr;
+	dup_files ++;
+
+	return dupl_ptr;
+}
+
+
+char buffer2[SQUASHFS_FILE_MAX_SIZE];
+struct file_info *duplicate(long long file_size, long long bytes, unsigned int **block_list, long long *start, struct fragment **fragment, struct file_buffer *file_buffer, struct buffer_list *buffer_list, int blocks, unsigned short checksum, unsigned short fragment_checksum, int checksum_flag)
+{
+	struct file_info *dupl_ptr = dupl[DUP_HASH(file_size)];
+	int frag_bytes = file_buffer ? file_buffer->size : 0;
+
+	for(; dupl_ptr; dupl_ptr = dupl_ptr->next)
+		if(file_size == dupl_ptr->file_size && bytes == dupl_ptr->bytes && frag_bytes == dupl_ptr->fragment->size) {
+			long long dup_start = dupl_ptr->start;
+			int block;
+
+			if(memcmp(*block_list, dupl_ptr->block_list, blocks * sizeof(unsigned int)) != 0)
+				continue;
+
+			if(checksum_flag == FALSE) {
+				checksum = get_checksum_disk(*start, bytes, *block_list);
+				fragment_checksum = get_checksum_mem_buffer(file_buffer);
+				checksum_flag = TRUE;
+			}
+
+			if(dupl_ptr->checksum_flag == FALSE) {
+				struct file_buffer *frag_buffer = get_fragment(dupl_ptr->fragment);
+				dupl_ptr->checksum = get_checksum_disk(dupl_ptr->start, dupl_ptr->bytes, dupl_ptr->block_list);
+				dupl_ptr->fragment_checksum = get_checksum_mem(frag_buffer->data + dupl_ptr->fragment->offset, frag_bytes);
+				cache_block_put(frag_buffer);
+				dupl_ptr->checksum_flag = TRUE;
+			}
+
+			if(checksum != dupl_ptr->checksum || fragment_checksum != dupl_ptr->fragment_checksum)
+				continue;
+
+			for(block = 0; block < blocks; block ++) {
+				struct buffer_list *b = &buffer_list[block];
+				struct file_buffer *target_buffer = NULL;
+				struct file_buffer *dup_buffer = NULL;
+				char *target_data, *dup_data;
+				int res;
+
+				if(b->read_buffer)
+					target_data = b->read_buffer->data;
+				else if(b->size) {
+					target_buffer = cache_lookup(writer_buffer, b->start);
+					if(target_buffer)
+						target_data = target_buffer->data;
+					else
+						target_data = read_from_disk(b->start, b->size);
+				} else
+					continue;
+
+				dup_buffer = cache_lookup(writer_buffer, dup_start);
+				if(dup_buffer)
+					dup_data = dup_buffer->data;
+				else {
+					read_bytes(fd, dup_start, b->size, buffer2);
+					dup_data = buffer2;
+				}
+				res = memcmp(target_data, dup_data, b->size);
+				if(target_buffer)
+					cache_block_put(target_buffer);
+				if(dup_buffer)
+					cache_block_put(dup_buffer);
+				if(res != 0)
+					break;
+				dup_start += b->size;
+			}
+			if(block == blocks) {
+				struct file_buffer *frag_buffer = get_fragment(dupl_ptr->fragment);
+
+				if(frag_bytes == 0 || memcmp(file_buffer->data, frag_buffer->data + dupl_ptr->fragment->offset, frag_bytes) == 0) {
+					TRACE("Found duplicate file, start 0x%llx, size %lld, checksum 0x%x, fragment %d, size %d, offset %d, checksum 0x%x\n", dupl_ptr->start,
+						dupl_ptr->bytes, dupl_ptr->checksum, dupl_ptr->fragment->index, frag_bytes, dupl_ptr->fragment->offset, fragment_checksum);
+					*block_list = dupl_ptr->block_list;
+					*start = dupl_ptr->start;
+					*fragment = dupl_ptr->fragment;
+					cache_block_put(frag_buffer);
+					return 0;
+				}
+				cache_block_put(frag_buffer);
+			}
+		}
+
+
+	return add_non_dup(file_size, bytes, *block_list, *start, *fragment, checksum, fragment_checksum, checksum_flag);
+}
+
+
+void reader_read_file(struct dir_ent *dir_ent)
+{
+	struct stat *buf = &dir_ent->inode->buf, buf2;
+	struct file_buffer *file_buffer;
+	static int index = 0;
+	int blocks, byte, count, expected, file, frag_block;
+	long long bytes, read_size;
+
+	if(dir_ent->inode->read)
+		return;
+
+	dir_ent->inode->read = TRUE;
+again:
+	bytes = 0;
+	count = 0;
+	file_buffer = NULL;
+	read_size = buf->st_size;
+	blocks = (read_size + block_size - 1) >> block_log;
+	frag_block = !no_fragments && (always_use_fragments ||
+		(read_size < block_size)) ? read_size >> block_log : -1;
+
+	if((file = open(dir_ent->pathname, O_RDONLY)) == -1)
+		goto read_err;
+
+	do {
+		expected = read_size - ((long long) count * block_size) > block_size ? block_size : read_size - ((long long) count * block_size);
+
+		if(file_buffer)
+			queue_put(from_reader, file_buffer);
+		file_buffer = cache_get(reader_buffer, 0, 0);
+		file_buffer->sequence = index ++;
+
+		byte = file_buffer->size = read(file, file_buffer->data, block_size);
+
+		file_buffer->file_size = read_size;
+
+		if(byte != expected)
+			goto restat;
+
+		file_buffer->block = count;
+		file_buffer->error = FALSE;
+
+		bytes += byte;
+		count ++;
+	} while(count < blocks);
+
+	if(read_size != bytes)
+		goto restat;
+
+	if(expected == block_size) {
+		char buffer;
+
+		if(read(file, &buffer, 1) == 1)
+			goto restat;
+	}
+
+	file_buffer->fragment = (file_buffer->block == frag_block);
+
+	if(file_buffer->fragment)
+		queue_put(from_deflate, file_buffer);
+	else
+		queue_put(from_reader, file_buffer);
+
+	close(file);
+
+	return;
+
+read_err:
+	file_buffer = cache_get(reader_buffer, 0, 0);
+	file_buffer->sequence = index ++;
+read_err2:
+	file_buffer->error = TRUE;
+	queue_put(from_deflate, file_buffer);
+	return;
+restat:
+	fstat(file, &buf2);
+	close(file);
+	if(read_size != buf2.st_size) {
+		memcpy(buf, &buf2, sizeof(struct stat));
+		file_buffer->error = 2;
+		queue_put(from_deflate, file_buffer);
+		goto again;
+	}
+	goto read_err2;
+}
+
+
+void reader_scan(struct dir_info *dir) {
+	int i;
+
+	for(i = 0; i < dir->count; i++) {
+		struct dir_ent *dir_ent = dir->list[i];
+		struct stat *buf = &dir_ent->inode->buf;
+		if(dir_ent->data)
+			continue;
+
+		switch(buf->st_mode & S_IFMT) {
+			case S_IFREG:
+				reader_read_file(dir_ent);
+				break;
+			case S_IFDIR:
+				reader_scan(dir_ent->dir);
+				break;
+		}
+	}
+}
+
+
+void *reader(void *arg)
+{
+	int oldstate;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
+
+	if(!sorted)
+		reader_scan(queue_get(to_reader));
+	else {
+		int i;
+		struct priority_entry *entry;
+
+		queue_get(to_reader);
+		for(i = 65535; i >= 0; i--)
+			for(entry = priority_list[i]; entry; entry = entry->next)
+				reader_read_file(entry->dir);
+	}
+
+	thread[0] = 0;
+
+	pthread_exit(NULL);
+}
+
+
+void *writer(void *arg)
+{
+	int write_error = FALSE;
+	int oldstate;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
+
+	while(1) {
+		struct file_buffer *file_buffer = queue_get(to_writer);
+		off_t off;
+
+		if(file_buffer == NULL) {
+			queue_put(from_writer, write_error ? (void *) &write_error : NULL);
+			continue;
+		}
+
+		off = file_buffer->block;
+
+		pthread_mutex_lock(&pos_mutex);
+
+		if(!write_error && lseek(fd, off, SEEK_SET) == -1) {
+			ERROR("Lseek on destination failed because %s\n", strerror(errno));
+			write_error = TRUE;
+		}
+
+		if(!write_error && write(fd, file_buffer->data, file_buffer->size) == -1) {
+			ERROR("Write on destination failed because %s\n", strerror(errno));
+			write_error = TRUE;
+		}
+		pthread_mutex_unlock(&pos_mutex);
+
+		cache_block_put(file_buffer);
+	}
+}
+
+
+int all_zero(struct file_buffer *file_buffer)
+{
+	int i;
+	long entries = file_buffer->size / sizeof(long);
+	long *p = (long *) file_buffer->data;
+
+	for(i = 0; i < entries && p[i] == 0; i++);
+
+	if(i == entries) {
+		for(i = file_buffer->size & ~(sizeof(long) - 1); i < file_buffer->size &&
+						file_buffer->data[i] == 0; i++);
+
+		return i == file_buffer->size;
+	}
+
+	return 0;
+}
+
+
+void *deflator(void *arg)
+{
+	z_stream *stream = NULL;
+	int oldstate;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
+
+	while(1) {
+		struct file_buffer *file_buffer = queue_get(from_reader);
+		struct file_buffer *write_buffer = cache_get(writer_buffer, 0, 0);
+
+		if(sparse_files && all_zero(file_buffer)) 
+			write_buffer->c_byte = 0;
+		else
+			write_buffer->c_byte = mangle2(&stream, write_buffer->data, file_buffer->data, file_buffer->size, block_size, noD, 1);
+		write_buffer->sequence = file_buffer->sequence;
+		write_buffer->file_size = file_buffer->file_size;
+		write_buffer->block = file_buffer->block;
+		write_buffer->size = SQUASHFS_COMPRESSED_SIZE_BLOCK(write_buffer->c_byte);
+		write_buffer->fragment = FALSE;
+		write_buffer->error = FALSE;
+		cache_block_put(file_buffer);
+		queue_put(from_deflate, write_buffer);
+	}
+}
+
+
+void *frag_deflator(void *arg)
+{
+	z_stream *stream = NULL;
+	int oldstate;
+
+	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
+
+	while(1) {
+		int c_byte, compressed_size;
+		struct file_buffer *file_buffer = queue_get(to_frag);
+		struct file_buffer *write_buffer = cache_get(writer_buffer, file_buffer->block + FRAG_INDEX, 1);
+
+		c_byte = mangle2(&stream, write_buffer->data, file_buffer->data, file_buffer->size, block_size, noF, 1);
+		compressed_size = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+		write_buffer->size = compressed_size;
+		pthread_mutex_lock(&fragment_mutex);
+		if(fragments_locked == FALSE) {
+			fragment_table[file_buffer->block].size = c_byte;
+			fragment_table[file_buffer->block].start_block = bytes;
+			write_buffer->block = bytes;
+			bytes += compressed_size;
+			fragments_outstanding --;
+			pthread_mutex_unlock(&fragment_mutex);
+			queue_put(to_writer, write_buffer);
+			TRACE("Writing fragment %lld, uncompressed size %d, compressed size %d\n", file_buffer->block, file_buffer->size, compressed_size);
+		} else {
+				pthread_mutex_unlock(&fragment_mutex);
+				add_pending_fragment(write_buffer, c_byte, file_buffer->block);
+		}
+		cache_block_put(file_buffer);
+	}
+}
+
+
+#define HASH_ENTRIES		256
+#define BLOCK_HASH(a)		(a % HASH_ENTRIES)
+struct file_buffer		*block_hash[HASH_ENTRIES];
+
+void push_buffer(struct file_buffer *file_buffer)
+{
+	int hash = BLOCK_HASH(file_buffer->sequence);
+
+	file_buffer->next = block_hash[hash];
+	block_hash[hash] = file_buffer;
+}
+
+
+struct file_buffer *get_file_buffer(struct queue *queue)
+{
+	static unsigned int sequence = 0;
+	int hash = BLOCK_HASH(sequence);
+	struct file_buffer *file_buffer = block_hash[hash], *prev = NULL;
+
+	for(;file_buffer; prev = file_buffer, file_buffer = file_buffer->next)
+		if(file_buffer->sequence == sequence)
+			break;
+
+	if(file_buffer) {
+		if(prev)
+			prev->next = file_buffer->next;
+		else
+			block_hash[hash] = file_buffer->next;
+	} else {
+		while(1) {
+			file_buffer = queue_get(queue);
+			if(file_buffer->sequence == sequence)
+				break;
+			push_buffer(file_buffer);
+		}
+	}
+
+	sequence ++;
+
+	return file_buffer;
+}
+
+
+void *progress_thrd(void *arg)
+{
+	struct timeval timeval;
+	struct timespec timespec;
+	struct itimerval itimerval;
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		printf("TIOCGWINZ ioctl failed, defaulting to 80 columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+	signal(SIGWINCH, sigwinch_handler);
+	signal(SIGALRM, sigalrm_handler);
+
+	itimerval.it_value.tv_sec = 0;
+	itimerval.it_value.tv_usec = 250000;
+	itimerval.it_interval.tv_sec = 0;
+	itimerval.it_interval.tv_usec = 250000;
+	setitimer(ITIMER_REAL, &itimerval, NULL);
+
+	pthread_cond_init(&progress_wait, NULL);
+
+	pthread_mutex_lock(&progress_mutex);
+
+	while(1) {
+		gettimeofday(&timeval, NULL);
+		timespec.tv_sec = timeval.tv_sec;
+		if(timeval.tv_usec + 250000 > 999999)
+			timespec.tv_sec++;
+		timespec.tv_nsec = ((timeval.tv_usec + 250000) % 1000000) * 1000;
+		pthread_cond_timedwait(&progress_wait, &progress_mutex, &timespec);
+		if(progress_enabled && estimated_uncompressed)
+			progress_bar(cur_uncompressed, estimated_uncompressed, columns);
+	}
+}
+
+
+void enable_progress_bar()
+{
+	pthread_mutex_lock(&progress_mutex);
+	progress_enabled = TRUE;
+	pthread_mutex_unlock(&progress_mutex);
+}
+
+
+void disable_progress_bar()
+{
+	pthread_mutex_lock(&progress_mutex);
+	progress_enabled = FALSE;
+	pthread_mutex_unlock(&progress_mutex);
+}
+
+
+void progress_bar(long long current, long long max, int columns)
+{
+	char rotate_list[] = { '|', '/', '-', '\\' };
+	int max_digits = floor(log10(max)) + 1;
+	int used = max_digits * 2 + 11;
+	int hashes = (current * (columns - used)) / max;
+	int spaces = columns - used - hashes;
+
+	if(current > max) {
+		printf("%lld %lld\n", current, max);
+		return;
+	}
+
+	if(columns - used < 0)
+		return;
+
+	printf("\r[");
+
+	while (hashes --)
+		putchar('=');
+
+	putchar(rotate_list[rotate]);
+
+	while(spaces --)
+		putchar(' ');
+
+	printf("] %*lld/%*lld", max_digits, current, max_digits, max);
+	printf(" %3lld%%", current * 100 / max);
+	fflush(stdout);
+}
+
+
+void write_file_empty(squashfs_inode *inode, struct dir_ent *dir_ent, int *duplicate_file)
+{
+	file_count ++;
+	*duplicate_file = FALSE;
+	if(dir_ent->inode->nlink == 1)
+		create_inode(inode, dir_ent, SQUASHFS_FILE_TYPE, 0, 0, 0, NULL, &empty_fragment, NULL);
+	else
+		create_inode(inode, dir_ent, SQUASHFS_LREG_TYPE, 0, 0, 0, NULL, &empty_fragment, NULL);
+}
+
+
+void write_file_frag_dup(squashfs_inode *inode, struct dir_ent *dir_ent, int size, int *duplicate_file, struct file_buffer *file_buffer, unsigned short checksum)
+{
+	struct file_info *dupl_ptr;
+	struct fragment *fragment;
+	unsigned int *block_listp = NULL;
+	long long start = 0;
+
+	dupl_ptr = duplicate(size, 0, &block_listp, &start, &fragment, file_buffer, NULL, 0, 0, checksum, TRUE);
+
+	if(dupl_ptr) {
+		*duplicate_file = FALSE;
+		fragment = get_and_fill_fragment(file_buffer);
+		dupl_ptr->fragment = fragment;
+	} else
+		*duplicate_file = TRUE;
+
+	cache_block_put(file_buffer);
+
+	total_bytes += size;
+	file_count ++;
+
+	inc_progress_bar();
+
+	if(dir_ent->inode->nlink == 1)
+		create_inode(inode, dir_ent, SQUASHFS_FILE_TYPE, size, 0, 0, NULL, fragment, NULL);
+	else
+		create_inode(inode, dir_ent, SQUASHFS_LREG_TYPE, size, 0, 0, NULL, fragment, NULL);
+}
+
+
+void write_file_frag(squashfs_inode *inode, struct dir_ent *dir_ent, int size, struct file_buffer *file_buffer, int *duplicate_file)
+{
+	struct fragment *fragment;
+	unsigned short checksum;
+
+	checksum = get_checksum_mem_buffer(file_buffer);
+
+	if(pre_duplicate_frag(size, checksum)) {
+		write_file_frag_dup(inode, dir_ent, size, duplicate_file, file_buffer, checksum);
+		return;
+	}
+		
+	fragment = get_and_fill_fragment(file_buffer);
+
+	cache_block_put(file_buffer);
+
+	if(duplicate_checking)
+		add_non_dup(size, 0, NULL, 0, fragment, 0, checksum, TRUE);
+
+	total_bytes += size;
+	file_count ++;
+
+	*duplicate_file = FALSE;
+
+	inc_progress_bar();
+
+	if(dir_ent->inode->nlink == 1)
+		create_inode(inode, dir_ent, SQUASHFS_FILE_TYPE, size, 0, 0, NULL, fragment, NULL);
+	else
+		create_inode(inode, dir_ent, SQUASHFS_LREG_TYPE, size, 0, 0, NULL, fragment, NULL);
+
+	return;
+}
+
+
+int write_file_blocks(squashfs_inode *inode, struct dir_ent *dir_ent, long long read_size, struct file_buffer *reader_buffer, int *duplicate_file)
+{
+	int block;
+	unsigned int frag_bytes;
+	long long file_bytes, start;
+	struct fragment *fragment;
+	int blocks = (read_size + block_size - 1) >> block_log;
+	unsigned int *block_list;
+	struct file_buffer *read_buffer;
+	int status;
+
+	*duplicate_file = FALSE;
+
+	if(!no_fragments && always_use_fragments) {
+		blocks = read_size >> block_log;
+		frag_bytes = read_size % block_size;
+	} else
+		frag_bytes = 0;
+
+	if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL)
+		BAD_ERROR("Out of memory allocating block_list\n");
+
+	lock_fragments();
+
+	file_bytes = 0;
+	start = bytes;
+	for(block = 0; block < blocks; block ++) {
+		if(reader_buffer) {
+			read_buffer = reader_buffer;
+			reader_buffer = NULL;
+		} else {
+			read_buffer = get_file_buffer(from_deflate);
+			if(read_buffer->error)
+				goto read_err;
+		}
+
+		block_list[block] = read_buffer->c_byte;
+		if(read_buffer->c_byte) {
+			read_buffer->block = bytes;
+			bytes += read_buffer->size;
+			cache_rehash(read_buffer, read_buffer->block);
+			file_bytes += read_buffer->size;
+			queue_put(to_writer, read_buffer);
+		} else
+			cache_block_put(read_buffer);
+		inc_progress_bar();
+	}
+
+	if(frag_bytes != 0) {
+		read_buffer = get_file_buffer(from_deflate);
+		if(read_buffer->error)
+			goto read_err;
+		inc_progress_bar();
+	} else
+		read_buffer = NULL;
+
+	unlock_fragments();
+	fragment = get_and_fill_fragment(read_buffer);
+	cache_block_put(read_buffer);
+
+	if(duplicate_checking)
+		add_non_dup(read_size, file_bytes, block_list, start, fragment, 0, 0, FALSE);
+	file_count ++;
+	total_bytes += read_size;
+
+	if(dir_ent->inode->nlink == 1 && read_size < ((long long) (1<<30) - 1))
+		create_inode(inode, dir_ent, SQUASHFS_FILE_TYPE, read_size, start, blocks, block_list, fragment, NULL);
+	else
+		create_inode(inode, dir_ent, SQUASHFS_LREG_TYPE, read_size, start, blocks, block_list, fragment, NULL);
+
+	if(duplicate_checking == FALSE)
+		free(block_list);
+
+	return 0;
+
+read_err:
+	cur_uncompressed -= block;
+	status = read_buffer->error;
+	bytes = start;
+	if(!block_device) {
+		queue_put(to_writer, NULL);
+		if(queue_get(from_writer) != 0)
+			EXIT_MKSQUASHFS();
+		ftruncate(fd, bytes);
+	}
+	unlock_fragments();
+	free(block_list);
+	cache_block_put(read_buffer);
+	return status;
+}
+
+
+int write_file_blocks_dup(squashfs_inode *inode, struct dir_ent *dir_ent, long long read_size, struct file_buffer *reader_buffer, int *duplicate_file)
+{
+	int block, thresh;
+	unsigned int frag_bytes;
+	long long file_bytes, start;
+	struct fragment *fragment;
+	struct file_info *dupl_ptr;
+	int blocks = (read_size + block_size - 1) >> block_log;
+	unsigned int *block_list, *block_listp;
+	struct file_buffer *read_buffer;
+	struct buffer_list *buffer_list;
+	int status, num_locked_fragments;
+
+	if(!no_fragments && always_use_fragments) {
+		blocks = read_size >> block_log;
+		frag_bytes = read_size % block_size;
+	} else
+		frag_bytes = 0;
+
+	if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL)
+		BAD_ERROR("Out of memory allocating block_list\n");
+	block_listp = block_list;
+
+	if((buffer_list = malloc(blocks * sizeof(struct buffer_list))) == NULL)
+		BAD_ERROR("Out of memory allocating file block list\n");
+
+	num_locked_fragments = lock_fragments();
+
+	file_bytes = 0;
+	start = bytes;
+	thresh = blocks > (writer_buffer_size - num_locked_fragments) ? blocks - (writer_buffer_size - num_locked_fragments): 0;
+	for(block = 0; block < blocks; block ++) {
+		if(reader_buffer) {
+			read_buffer = reader_buffer;
+			reader_buffer = NULL;
+		 } else {
+			read_buffer = get_file_buffer(from_deflate);
+			if(read_buffer->error)
+				goto read_err;
+		}
+
+		block_list[block] = read_buffer->c_byte;
+		buffer_list[block].start = bytes;
+		buffer_list[block].size = read_buffer->size;
+
+		if(read_buffer->c_byte) {
+			read_buffer->block = bytes;
+			bytes += read_buffer->size;
+			cache_rehash(read_buffer, read_buffer->block);
+			file_bytes += read_buffer->size;
+			if(block < thresh) {
+				buffer_list[block].read_buffer = NULL;
+				queue_put(to_writer, read_buffer);
+			} else
+				buffer_list[block].read_buffer = read_buffer;
+		} else {
+			buffer_list[block].read_buffer = NULL;
+			cache_block_put(read_buffer);
+		}
+		inc_progress_bar();
+	}
+
+	if(frag_bytes != 0) {
+		read_buffer = get_file_buffer(from_deflate);
+		if(read_buffer->error)
+			goto read_err;
+	} else
+		read_buffer = NULL;
+
+	dupl_ptr = duplicate(read_size, file_bytes, &block_listp, &start, &fragment, read_buffer, buffer_list, blocks, 0, 0, FALSE);
+
+	if(dupl_ptr) {
+		*duplicate_file = FALSE;
+		for(block = thresh; block < blocks; block ++)
+			if(buffer_list[block].read_buffer)
+				queue_put(to_writer, buffer_list[block].read_buffer);
+		fragment = get_and_fill_fragment(read_buffer);
+		dupl_ptr->fragment = fragment;
+	} else {
+		*duplicate_file = TRUE;
+		for(block = thresh; block < blocks; block ++)
+			cache_block_put(buffer_list[block].read_buffer);
+		bytes = buffer_list[0].start;
+		if(thresh && !block_device) {
+			queue_put(to_writer, NULL);
+			if(queue_get(from_writer) != 0)
+				EXIT_MKSQUASHFS();
+			ftruncate(fd, bytes);
+		}
+	}
+
+	unlock_fragments();
+	cache_block_put(read_buffer);
+	free(buffer_list);
+	file_count ++;
+	total_bytes += read_size;
+
+	if(dir_ent->inode->nlink == 1 && read_size < ((long long) (1<<30) - 1))
+		create_inode(inode, dir_ent, SQUASHFS_FILE_TYPE, read_size, start, blocks, block_listp, fragment, NULL);
+	else
+		create_inode(inode, dir_ent, SQUASHFS_LREG_TYPE, read_size, start, blocks, block_listp, fragment, NULL);
+
+	if(*duplicate_file == TRUE)
+		free(block_list);
+
+	return 0;
+
+read_err:
+	cur_uncompressed -= block;
+	status = read_buffer->error;
+	bytes = start;
+	if(thresh && !block_device) {
+		queue_put(to_writer, NULL);
+		if(queue_get(from_writer) != 0)
+			EXIT_MKSQUASHFS();
+		ftruncate(fd, bytes);
+	}
+	unlock_fragments();
+	for(blocks = thresh; blocks < block; blocks ++)
+		cache_block_put(buffer_list[blocks].read_buffer);
+	free(buffer_list);
+	free(block_list);
+	cache_block_put(read_buffer);
+	return status;
+}
+
+
+void write_file(squashfs_inode *inode, struct dir_ent *dir_ent, int *duplicate_file)
+{
+	int status;
+	struct file_buffer *read_buffer;
+	long long read_size;
+
+again:
+	read_buffer = get_file_buffer(from_deflate);
+	status = read_buffer->error;
+	if(status) {
+		cache_block_put(read_buffer);
+		goto file_err;
+	}
+	
+	read_size = read_buffer->file_size;
+
+	if(read_size == 0) {
+		write_file_empty(inode, dir_ent, duplicate_file);
+		cache_block_put(read_buffer);
+	} else if(!no_fragments && (read_size < block_size))
+		write_file_frag(inode, dir_ent, read_size, read_buffer, duplicate_file);
+	else if(pre_duplicate(read_size))
+		status = write_file_blocks_dup(inode, dir_ent, read_size, read_buffer, duplicate_file);
+	else
+		status = write_file_blocks(inode, dir_ent, read_size, read_buffer, duplicate_file);
+
+file_err:
+	if(status == 2) {
+		ERROR("File %s changed size while reading filesystem, attempting to re-read\n", dir_ent->pathname);
+		goto again;
+	} else if(status == 1) {
+		ERROR("Failed to read file %s, creating empty file\n", dir_ent->pathname);
+		write_file_empty(inode, dir_ent, duplicate_file);
+	}
+}
+
+
+char b_buffer[8192];
+char *name;
+char *basename_r();
+
+char *getbase(char *pathname)
+{
+	char *result;
+
+	if(*pathname != '/') {
+		result = getenv("PWD");
+		strcat(strcat(strcpy(b_buffer, result), "/"), pathname);
+	} else
+		strcpy(b_buffer, pathname);
+	name = b_buffer;
+	if(((result = basename_r()) == NULL) || (strcmp(result, "..") == 0))
+		return NULL;
+	else
+		return result;
+}
+
+
+char *basename_r()
+{
+	char *s;
+	char *p;
+	int n = 1;
+
+	for(;;) {
+		s = name;
+		if(*name == '\0')
+			return NULL;
+		if(*name != '/') {
+			while(*name != '\0' && *name != '/') name++;
+			n = name - s;
+		}
+		while(*name == '/') name++;
+		if(strncmp(s, ".", n) == 0)
+			continue;
+		if((*name == '\0') || (strncmp(s, "..", n) == 0) || ((p = basename_r()) == NULL)) {
+			s[n] = '\0';
+			return s;
+		}
+		if(strcmp(p, "..") == 0)
+			continue;
+		return p;
+	}
+}
+
+
+struct inode_info *lookup_inode(struct stat *buf)
+{
+	int inode_hash = INODE_HASH(buf->st_dev, buf->st_ino);
+	struct inode_info *inode = inode_info[inode_hash];
+
+	while(inode != NULL) {
+		if(memcmp(buf, &inode->buf, sizeof(struct stat)) == 0) {
+			inode->nlink ++;
+			return inode;
+		}
+		inode = inode->next;
+	}
+
+	if((inode = malloc(sizeof(struct inode_info))) == NULL)
+		BAD_ERROR("Out of memory in inode hash table entry allocation\n");
+
+	memcpy(&inode->buf, buf, sizeof(struct stat));
+	inode->read = FALSE;
+	inode->inode = SQUASHFS_INVALID_BLK;
+	inode->nlink = 1;
+
+	if((buf->st_mode & S_IFMT) == S_IFREG)
+		estimated_uncompressed += (buf->st_size + block_size - 1) >> block_log;
+
+	if((buf->st_mode & S_IFMT) == S_IFDIR)
+		inode->inode_number = dir_inode_no ++;
+	else
+		inode->inode_number = inode_no ++;
+
+	inode->next = inode_info[inode_hash];
+	inode_info[inode_hash] = inode;
+
+	return inode;
+}
+
+
+inline void add_dir_entry(char *name, char *pathname, struct dir_info *sub_dir, struct inode_info *inode_info, void *data, struct dir_info *dir)
+{
+	if((dir->count % DIR_ENTRIES) == 0)
+		if((dir->list = realloc(dir->list, (dir->count + DIR_ENTRIES) * sizeof(struct dir_ent *))) == NULL)
+			BAD_ERROR("Out of memory in add_dir_entry\n");
+
+	if((dir->list[dir->count] = malloc(sizeof(struct dir_ent))) == NULL)
+		BAD_ERROR("Out of memory in linux_opendir\n");
+
+	if(sub_dir)
+		sub_dir->dir_ent = dir->list[dir->count];
+	dir->list[dir->count]->name = strdup(name);
+	dir->list[dir->count]->pathname = pathname != NULL ? strdup(pathname) : NULL;
+	dir->list[dir->count]->inode = inode_info;
+	dir->list[dir->count]->dir = sub_dir;
+	dir->list[dir->count]->our_dir = dir;
+	dir->list[dir->count++]->data = data;
+	dir->byte_count += strlen(name) + sizeof(squashfs_dir_entry);
+}
+
+
+int compare_name(const void *ent1_ptr, const void *ent2_ptr)
+{
+	struct dir_ent *ent1 = *((struct dir_ent **) ent1_ptr);
+	struct dir_ent *ent2 = *((struct dir_ent **) ent2_ptr);
+
+	return strcmp(ent1->name, ent2->name);
+}
+
+
+void sort_directory(struct dir_info *dir)
+{
+	qsort(dir->list, dir->count, sizeof(struct dir_ent *), compare_name);
+
+	if((dir->count < 257 && dir->byte_count < SQUASHFS_METADATA_SIZE))
+		dir->dir_is_ldir = FALSE;
+}
+
+
+struct dir_info *scan1_opendir(char *pathname)
+{
+	struct dir_info *dir;
+
+	if((dir = malloc(sizeof(struct dir_info))) == NULL)
+		return NULL;
+
+	if(pathname[0] != '\0' && (dir->linuxdir = opendir(pathname)) == NULL) {
+		free(dir);
+		return NULL;
+	}
+	dir->pathname = strdup(pathname);
+	dir->count = dir->directory_count = dir->current_count = dir->byte_count = 0;
+	dir->dir_is_ldir = TRUE;
+	dir->list = NULL;
+
+	return dir;
+}
+
+
+int scan1_encomp_readdir(char *pathname, char *dir_name, struct dir_info *dir)
+{
+	int i, n, pass;
+	char *basename;
+	static int index = 0;
+
+	if(dir->count < old_root_entries)
+		for(i = 0; i < old_root_entries; i++) {
+			if(old_root_entry[i].type == SQUASHFS_DIR_TYPE)
+				dir->directory_count ++;
+			add_dir_entry(old_root_entry[i].name, "", NULL, NULL, &old_root_entry[i], dir);
+		}
+
+	while(index < source) {
+		if((basename = getbase(source_path[index])) == NULL) {
+			ERROR("Bad source directory %s - skipping ...\n", source_path[index]);
+			index ++;
+			continue;
+		}
+		strcpy(dir_name, basename);
+		pass = 1;
+		for(;;) {
+			for(n = 0; n < dir->count && strcmp(dir->list[n]->name, dir_name) != 0; n++);
+			if(n == dir->count)
+				break;
+			ERROR("Source directory entry %s already used! - trying ", dir_name);
+			sprintf(dir_name, "%s_%d", basename, pass++);
+			ERROR("%s\n", dir_name);
+		}
+		strcpy(pathname, source_path[index ++]);
+		return 1;
+	}
+	return 0;
+}
+
+
+int scan1_single_readdir(char *pathname, char *dir_name, struct dir_info *dir)
+{
+	struct dirent *d_name;
+	int i, pass;
+
+	if(dir->count < old_root_entries)
+		for(i = 0; i < old_root_entries; i++) {
+			if(old_root_entry[i].type == SQUASHFS_DIR_TYPE)
+				dir->directory_count ++;
+			add_dir_entry(old_root_entry[i].name, "", NULL, NULL, &old_root_entry[i], dir);
+		}
+
+	if((d_name = readdir(dir->linuxdir)) != NULL) {
+		strcpy(dir_name, d_name->d_name);
+		pass = 1;
+		for(;;) {
+			for(i = 0; i < dir->count && strcmp(dir->list[i]->name, dir_name) != 0; i++);
+			if(i == dir->count)
+				break;
+			ERROR("Source directory entry %s already used! - trying ", dir_name);
+			sprintf(dir_name, "%s_%d", d_name->d_name, pass++);
+			ERROR("%s\n", dir_name);
+		}
+		strcat(strcat(strcpy(pathname, dir->pathname), "/"), d_name->d_name);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+int scan1_readdir(char *pathname, char *dir_name, struct dir_info *dir)
+{
+	struct dirent *d_name;
+
+	if((d_name = readdir(dir->linuxdir)) != NULL) {
+		strcpy(dir_name, d_name->d_name);
+		strcat(strcat(strcpy(pathname, dir->pathname), "/"), d_name->d_name);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+struct dir_ent *scan2_readdir(struct directory *dir, struct dir_info *dir_info)
+{
+	int current_count;
+
+	while((current_count = dir_info->current_count++) < dir_info->count)
+		if(dir_info->list[current_count]->data)
+			add_dir(dir_info->list[current_count]->data->inode, dir_info->list[current_count]->data->inode_number,
+				dir_info->list[current_count]->name, dir_info->list[current_count]->data->type, dir);
+		else 
+			return dir_info->list[current_count];
+	return FALSE;	
+}
+
+
+void scan1_freedir(struct dir_info *dir)
+{
+	if(dir->pathname[0] != '\0')
+		closedir(dir->linuxdir);
+}
+
+
+void scan2_freedir(struct directory *dir)
+{
+	if(dir->index)
+		free(dir->index);
+	free(dir->buff);
+}
+
+
+void dir_scan(squashfs_inode *inode, char *pathname, int (_readdir)(char *, char *, struct dir_info *))
+{
+	struct stat buf;
+	struct dir_info *dir_info = dir_scan1(pathname, paths, _readdir);
+	struct dir_ent *dir_ent;
+	
+	if(dir_info == NULL)
+		return;
+
+	if((dir_ent = malloc(sizeof(struct dir_ent))) == NULL)
+		BAD_ERROR("Out of memory in dir_scan\n");
+
+	if(pathname[0] == '\0') {
+		/* dummy top level directory, if multiple sources specified on command line */
+		buf.st_mode = S_IRWXU | S_IRWXG | S_IRWXO | S_IFDIR;
+		buf.st_uid = getuid();
+		buf.st_gid = getgid();
+		buf.st_mtime = time(NULL);
+		buf.st_dev = 0;
+		buf.st_ino = 0;
+	} else if(lstat(pathname, &buf) == -1) {
+		ERROR("Cannot stat dir/file %s because %s, ignoring", pathname, strerror(errno));
+		return;
+	}
+
+	dir_ent->inode = lookup_inode(&buf);
+	if(root_inode_number) {
+		dir_ent->inode->inode_number = root_inode_number;
+		dir_inode_no --;
+	}
+	dir_ent->name = dir_ent->pathname = strdup(pathname);
+	dir_ent->dir = dir_info;
+	dir_ent->our_dir = NULL;
+	dir_ent->data = NULL;
+	dir_info->dir_ent = dir_ent;
+
+	if(sorted)
+		generate_file_priorities(dir_info, 0, &dir_info->dir_ent->inode->buf);
+	queue_put(to_reader, dir_info);
+	if(sorted)
+		sort_files_and_write(dir_info);
+	if(progress)
+		enable_progress_bar();
+	dir_scan2(inode, dir_info);
+	dir_ent->inode->inode = *inode;
+	dir_ent->inode->type = SQUASHFS_DIR_TYPE;
+}
+
+
+struct dir_info *dir_scan1(char *pathname, struct pathnames *paths, int (_readdir)(char *, char *, struct dir_info *))
+{
+	struct dir_info *dir, *sub_dir;
+	struct stat buf;
+	char filename[8192], dir_name[8192];
+	struct pathnames *new;
+
+	if((dir = scan1_opendir(pathname)) == NULL) {
+		ERROR("Could not open %s, skipping...\n", pathname);
+		goto error;
+	}
+
+	while(_readdir(filename, dir_name, dir) != FALSE) {
+
+		if(strcmp(dir_name, ".") == 0 || strcmp(dir_name, "..") == 0)
+			continue;
+
+		if(lstat(filename, &buf) == -1) {
+			ERROR("Cannot stat dir/file %s because %s, ignoring", filename, strerror(errno));
+			continue;
+		}
+
+		if((buf.st_mode & S_IFMT) != S_IFREG &&
+			(buf.st_mode & S_IFMT) != S_IFDIR &&
+			(buf.st_mode & S_IFMT) != S_IFLNK &&
+			(buf.st_mode & S_IFMT) != S_IFCHR &&
+			(buf.st_mode & S_IFMT) != S_IFBLK &&
+			(buf.st_mode & S_IFMT) != S_IFIFO &&
+			(buf.st_mode & S_IFMT) != S_IFSOCK) {
+			ERROR("File %s has unrecognised filetype %d, ignoring\n", filename, buf.st_mode & S_IFMT);
+			continue;
+		}
+
+		if(old_exclude) {
+			if(old_excluded(filename, &buf))
+				continue;
+		} else {
+			if(excluded(paths, dir_name, &new))
+				continue;
+		}
+
+		if((buf.st_mode & S_IFMT) == S_IFDIR) {
+			if((sub_dir = dir_scan1(filename, new, scan1_readdir)) == NULL)
+				continue;
+			dir->directory_count ++;
+		} else
+			sub_dir = NULL;
+
+		add_dir_entry(dir_name, filename, sub_dir, lookup_inode(&buf), NULL, dir);
+	}
+
+	scan1_freedir(dir);
+	sort_directory(dir);
+
+error:
+	return dir;
+}
+
+
+void dir_scan2(squashfs_inode *inode, struct dir_info *dir_info)
+{
+	int squashfs_type;
+	int duplicate_file;
+	char *pathname = dir_info->pathname;
+	struct directory dir;
+	struct dir_ent *dir_ent;
+	
+	scan2_init_dir(&dir);
+	
+	while((dir_ent = scan2_readdir(&dir, dir_info)) != NULL) {
+		struct inode_info *inode_info = dir_ent->inode;
+		struct stat *buf = &inode_info->buf;
+		char *filename = dir_ent->pathname;
+		char *dir_name = dir_ent->name;
+		unsigned int inode_number = ((buf->st_mode & S_IFMT) == S_IFDIR) ? dir_ent->inode->inode_number : dir_ent->inode->inode_number + dir_inode_no;
+
+		if(dir_ent->inode->inode == SQUASHFS_INVALID_BLK) {
+			switch(buf->st_mode & S_IFMT) {
+				case S_IFREG:
+					squashfs_type = SQUASHFS_FILE_TYPE;
+					write_file(inode, dir_ent, &duplicate_file);
+					INFO("file %s, uncompressed size %lld bytes %s\n", filename, buf->st_size, duplicate_file ? "DUPLICATE" : "");
+					break;
+
+				case S_IFDIR:
+					squashfs_type = SQUASHFS_DIR_TYPE;
+					dir_scan2(inode, dir_ent->dir);
+					break;
+
+				case S_IFLNK:
+					squashfs_type = SQUASHFS_SYMLINK_TYPE;
+					create_inode(inode, dir_ent, squashfs_type, 0, 0, 0, NULL, NULL, NULL);
+					INFO("symbolic link %s inode 0x%llx\n", dir_name, *inode);
+					sym_count ++;
+					break;
+
+				case S_IFCHR:
+					squashfs_type = SQUASHFS_CHRDEV_TYPE;
+					create_inode(inode, dir_ent, squashfs_type, 0, 0, 0, NULL, NULL, NULL);
+					INFO("character device %s inode 0x%llx\n", dir_name, *inode);
+					dev_count ++;
+					break;
+
+				case S_IFBLK:
+					squashfs_type = SQUASHFS_BLKDEV_TYPE;
+					create_inode(inode, dir_ent, squashfs_type, 0, 0, 0, NULL, NULL, NULL);
+					INFO("block device %s inode 0x%llx\n", dir_name, *inode);
+					dev_count ++;
+					break;
+
+				case S_IFIFO:
+					squashfs_type = SQUASHFS_FIFO_TYPE;
+					create_inode(inode, dir_ent, squashfs_type, 0, 0, 0, NULL, NULL, NULL);
+					INFO("fifo %s inode 0x%llx\n", dir_name, *inode);
+					fifo_count ++;
+					break;
+
+				case S_IFSOCK:
+					squashfs_type = SQUASHFS_SOCKET_TYPE;
+					create_inode(inode, dir_ent, squashfs_type, 0, 0, 0, NULL, NULL, NULL);
+					INFO("unix domain socket %s inode 0x%llx\n", dir_name, *inode);
+					sock_count ++;
+					break;
+
+				default:
+					BAD_ERROR("%s unrecognised file type, mode is %x\n", filename, buf->st_mode);
+			}
+			dir_ent->inode->inode = *inode;
+			dir_ent->inode->type = squashfs_type;
+		 } else {
+			*inode = dir_ent->inode->inode;
+			squashfs_type = dir_ent->inode->type;
+			switch(squashfs_type) {
+				case SQUASHFS_FILE_TYPE:
+					if(!sorted)
+						INFO("file %s, uncompressed size %lld bytes LINK\n", filename, buf->st_size);
+					break;
+				case SQUASHFS_SYMLINK_TYPE:
+					INFO("symbolic link %s inode 0x%llx LINK\n", dir_name, *inode);
+					break;
+				case SQUASHFS_CHRDEV_TYPE:
+					INFO("character device %s inode 0x%llx LINK\n", dir_name, *inode);
+					break;
+				case SQUASHFS_BLKDEV_TYPE:
+					INFO("block device %s inode 0x%llx LINK\n", dir_name, *inode);
+					break;
+				case SQUASHFS_FIFO_TYPE:
+					INFO("fifo %s inode 0x%llx LINK\n", dir_name, *inode);
+					break;
+				case SQUASHFS_SOCKET_TYPE:
+					INFO("unix domain socket %s inode 0x%llx LINK\n", dir_name, *inode);
+					break;
+			}
+		}
+		
+		add_dir(*inode, inode_number, dir_name, squashfs_type, &dir);
+		update_progress_bar();
+	}
+
+	write_dir(inode, dir_info, &dir);
+	INFO("directory %s inode 0x%llx\n", pathname, *inode);
+
+	scan2_freedir(&dir);
+}
+
+
+unsigned int slog(unsigned int block)
+{
+	int i;
+
+	for(i = 12; i <= 20; i++)
+		if(block == (1 << i))
+			return i;
+	return 0;
+}
+
+
+int old_excluded(char *filename, struct stat *buf)
+{
+	int i;
+
+	for(i = 0; i < exclude; i++)
+		if((exclude_paths[i].st_dev == buf->st_dev) && (exclude_paths[i].st_ino == buf->st_ino))
+			return TRUE;
+	return FALSE;
+}
+
+
+#define ADD_ENTRY(buf) \
+	if(exclude % EXCLUDE_SIZE == 0) {\
+		if((exclude_paths = (struct exclude_info *) realloc(exclude_paths, (exclude + EXCLUDE_SIZE) * sizeof(struct exclude_info))) == NULL)\
+			BAD_ERROR("Out of memory in exclude dir/file table\n");\
+	}\
+	exclude_paths[exclude].st_dev = buf.st_dev;\
+	exclude_paths[exclude++].st_ino = buf.st_ino;
+int old_add_exclude(char *path)
+{
+	int i;
+	char filename[4096];
+	struct stat buf;
+
+	if(path[0] == '/' || strncmp(path, "./", 2) == 0 || strncmp(path, "../", 3) == 0) {
+		if(lstat(path, &buf) == -1) {
+			ERROR("Cannot stat exclude dir/file %s because %s, ignoring", path, strerror(errno));
+			return TRUE;
+		}
+		ADD_ENTRY(buf);
+		return TRUE;
+	}
+
+	for(i = 0; i < source; i++) {
+		strcat(strcat(strcpy(filename, source_path[i]), "/"), path);
+		if(lstat(filename, &buf) == -1) {
+			if(!(errno == ENOENT || errno == ENOTDIR))
+				ERROR("Cannot stat exclude dir/file %s because %s, ignoring", filename, strerror(errno));
+			continue;
+		}
+		ADD_ENTRY(buf);
+	}
+	return TRUE;
+}
+
+
+void add_old_root_entry(char *name, squashfs_inode inode, int inode_number, int type)
+{
+	if((old_root_entry = (struct old_root_entry_info *) realloc(old_root_entry, sizeof(struct old_root_entry_info)
+				* (old_root_entries + 1))) == NULL)
+		BAD_ERROR("Out of memory in old root directory entries reallocation\n");
+
+	strcpy(old_root_entry[old_root_entries].name, name);
+	old_root_entry[old_root_entries].inode = inode;
+	old_root_entry[old_root_entries].inode_number = inode_number;
+	old_root_entry[old_root_entries++].type = type;
+}
+
+
+void initialise_threads()
+{
+	int i;
+	sigset_t sigmask, old_mask;
+
+	sigemptyset(&sigmask);
+	sigaddset(&sigmask, SIGINT);
+	sigaddset(&sigmask, SIGQUIT);
+	if(sigprocmask(SIG_BLOCK, &sigmask, &old_mask) == -1)
+		BAD_ERROR("Failed to set signal mask in intialise_threads\n");
+
+	signal(SIGUSR1, sigusr1_handler);
+
+	if(processors == -1) {
+#ifndef linux
+		int mib[2];
+		size_t len = sizeof(processors);
+
+		mib[0] = CTL_HW;
+#ifdef HW_AVAILCPU
+		mib[1] = HW_AVAILCPU;
+#else
+		mib[1] = HW_NCPU;
+#endif
+
+		if(sysctl(mib, 2, &processors, &len, NULL, 0) == -1) {
+			ERROR("Failed to get number of available processors.  Defaulting to 1\n");
+			processors = 1;
+		}
+#else
+		processors = get_nprocs();
+#endif
+	}
+
+	if((thread = malloc((2 + processors * 2) * sizeof(pthread_t))) == NULL)
+		BAD_ERROR("Out of memory allocating thread descriptors\n");
+	deflator_thread = &thread[2];
+	frag_deflator_thread = &deflator_thread[processors];
+
+	to_reader = queue_init(1);
+	from_reader = queue_init(reader_buffer_size);
+	to_writer = queue_init(writer_buffer_size);
+	from_writer = queue_init(1);
+	from_deflate = queue_init(reader_buffer_size);
+	to_frag = queue_init(fragment_buffer_size);
+	reader_buffer = cache_init(block_size, reader_buffer_size);
+	writer_buffer = cache_init(block_size, writer_buffer_size);
+	fragment_buffer = cache_init(block_size, fragment_buffer_size);
+	pthread_create(&thread[0], NULL, reader, NULL);
+	pthread_create(&thread[1], NULL, writer, NULL);
+	pthread_create(&progress_thread, NULL, progress_thrd, NULL);
+	pthread_mutex_init(&fragment_mutex, NULL);
+	pthread_cond_init(&fragment_waiting, NULL);
+
+	for(i = 0; i < processors; i++) {
+		if(pthread_create(&deflator_thread[i], NULL, deflator, NULL) != 0 )
+			BAD_ERROR("Failed to create thread\n");
+		if(pthread_create(&frag_deflator_thread[i], NULL, frag_deflator, NULL) != 0)
+			BAD_ERROR("Failed to create thread\n");
+	}
+
+	printf("Parallel mksquashfs: Using %d processor%s\n", processors,
+			processors == 1 ? "" : "s");
+
+	if(sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1)
+		BAD_ERROR("Failed to set signal mask in intialise_threads\n");
+}
+
+
+long long write_inode_lookup_table()
+{
+	int i, inode_number, lookup_bytes = SQUASHFS_LOOKUP_BYTES(inode_count);
+
+	if(inode_count == sinode_count)
+		goto skip_inode_hash_table;
+
+	if((inode_lookup_table = realloc(inode_lookup_table, lookup_bytes)) == NULL)
+		BAD_ERROR("Out of memory in write_inode_table\n");
+
+	for(i = 0; i < INODE_HASH_SIZE; i ++) {
+		struct inode_info *inode = inode_info[i];
+
+		for(inode = inode_info[i]; inode; inode = inode->next) {
+
+			inode_number = inode->type == SQUASHFS_DIR_TYPE ?
+				inode->inode_number : inode->inode_number + dir_inode_no;
+
+			if(!swap)
+				memcpy(&inode_lookup_table[inode_number - 1], &inode->inode, sizeof(squashfs_inode));
+			else
+				SQUASHFS_SWAP_LONG_LONGS((&inode->inode), &inode_lookup_table[inode_number - 1], 1);
+
+		}
+	}
+
+skip_inode_hash_table:
+	return generic_write_table(lookup_bytes, (char *) inode_lookup_table, 0);
+}
+
+
+char *get_component(char *target, char *targname)
+{
+	while(*target == '/')
+		target ++;
+
+	while(*target != '/' && *target!= '\0')
+		*targname ++ = *target ++;
+
+	*targname = '\0';
+
+	return target;
+}
+
+
+void free_path(struct pathname *paths)
+{
+	int i;
+
+	for(i = 0; i < paths->names; i++) {
+		if(paths->name[i].paths)
+			free_path(paths->name[i].paths);
+		free(paths->name[i].name);
+		if(paths->name[i].preg) {
+			regfree(paths->name[i].preg);
+			free(paths->name[i].preg);
+		}
+	}
+
+	free(paths);
+}
+
+
+struct pathname *add_path(struct pathname *paths, char *target, char *alltarget)
+{
+	char targname[1024];
+	int i, error;
+
+	target = get_component(target, targname);
+
+	if(paths == NULL) {
+		if((paths = malloc(sizeof(struct pathname))) == NULL)
+			BAD_ERROR("failed to allocate paths\n");
+
+		paths->names = 0;
+		paths->name = NULL;
+	}
+
+	for(i = 0; i < paths->names; i++)
+		if(strcmp(paths->name[i].name, targname) == 0)
+			break;
+
+	if(i == paths->names) {
+		/* allocate new name entry */
+		paths->names ++;
+		paths->name = realloc(paths->name, (i + 1) * sizeof(struct path_entry));
+		paths->name[i].name = strdup(targname);
+		paths->name[i].paths = NULL;
+		if(use_regex) {
+			paths->name[i].preg = malloc(sizeof(regex_t));
+			error = regcomp(paths->name[i].preg, targname, REG_EXTENDED|REG_NOSUB);
+			if(error) {
+				char str[1024];
+
+				regerror(error, paths->name[i].preg, str, 1024);
+				BAD_ERROR("invalid regex %s in export %s, because %s\n", targname, alltarget, str);
+			}
+		} else
+			paths->name[i].preg = NULL;
+
+		if(target[0] == '\0')
+			/* at leaf pathname component */
+			paths->name[i].paths = NULL;
+		else
+			/* recurse adding child components */
+			paths->name[i].paths = add_path(NULL, target, alltarget);
+	} else {
+		/* existing matching entry */
+		if(paths->name[i].paths == NULL) {
+			/* No sub-directory which means this is the leaf component of a
+		   	   pre-existing exclude which subsumes the exclude currently
+		   	   being added, in which case stop adding components */
+		} else if(target[0] == '\0') {
+			/* at leaf pathname component and child components exist from more
+		       specific excludes, delete as they're subsumed by this exclude
+			*/
+			free_path(paths->name[i].paths);
+			paths->name[i].paths = NULL;
+		} else
+			/* recurse adding child components */
+			add_path(paths->name[i].paths, target, alltarget);
+	}
+
+	return paths;
+}
+
+
+void add_exclude(char *target)
+{
+
+	if(target[0] == '/' || strncmp(target, "./", 2) == 0 || strncmp(target, "../", 3) == 0)
+		BAD_ERROR("/, ./ and ../ prefixed excludes not supported with -wildcards or -regex options\n");	
+	else if(strncmp(target, "... ", 4) == 0)
+		stickypath = add_path(stickypath, target + 4, target + 4);
+	else	
+		path = add_path(path, target, target);
+}
+
+
+void display_path(int depth, struct pathname *paths)
+{
+	int i, n;
+
+	if(paths == NULL)
+		return;
+
+	for(i = 0; i < paths->names; i++) {
+		for(n = 0; n < depth; n++)
+			printf("\t");
+		printf("%d: %s\n", depth, paths->name[i].name);
+		display_path(depth + 1, paths->name[i].paths);
+	}
+}
+
+
+void display_path2(struct pathname *paths, char *string)
+{
+	int i;
+	char path[1024];
+
+	if(paths == NULL) {
+		printf("%s\n", string);
+		return;
+	}
+
+	for(i = 0; i < paths->names; i++) {
+		strcat(strcat(strcpy(path, string), "/"), paths->name[i].name);
+		display_path2(paths->name[i].paths, path);
+	}
+}
+
+
+struct pathnames *init_subdir()
+{
+	struct pathnames *new = malloc(sizeof(struct pathnames *));
+	new->count = 0;
+	return new;
+}
+
+
+struct pathnames *add_subdir(struct pathnames *paths, struct pathname *path)
+{
+	if(paths->count % PATHS_ALLOC_SIZE == 0)
+		paths = realloc(paths, sizeof(struct pathnames *) + (paths->count + PATHS_ALLOC_SIZE) * sizeof(struct pathname *));
+
+	paths->path[paths->count++] = path;
+	return paths;
+}
+
+
+void free_subdir(struct pathnames *paths)
+{
+	free(paths);
+}
+
+
+int excluded(struct pathnames *paths, char *name, struct pathnames **new)
+{
+	int i, n, res;
+		
+	if(paths == NULL) {
+		*new = NULL;
+		return FALSE;
+	}
+
+
+	*new = init_subdir();
+	if(stickypath)
+		*new = add_subdir(*new, stickypath);
+
+	for(n = 0; n < paths->count; n++) {
+		struct pathname *path = paths->path[n];
+
+		for(i = 0; i < path->names; i++) {
+			int match = use_regex ?
+				regexec(path->name[i].preg, name, (size_t) 0, NULL, 0) == 0 :
+				fnmatch(path->name[i].name, name, FNM_PATHNAME|FNM_PERIOD|FNM_EXTMATCH) == 0;
+
+			if(match && path->name[i].paths == NULL) {
+				/* match on a leaf component, any subdirectories in the
+				 * filesystem should be excluded */
+				res = TRUE;
+				goto empty_set;
+			}
+
+			if(match)
+				/* match on a non-leaf component, add any subdirectories to
+				 * the new set of subdirectories to scan for this name */
+				*new = add_subdir(*new, path->name[i].paths);
+		}
+	}
+
+	if((*new)->count == 0) {
+			/* no matching names found, return empty new search set */
+			res = FALSE;
+			goto empty_set;
+	}
+
+	/* one or more matches with sub-directories found (no leaf matches).
+	 * Return new set */
+	return FALSE;
+
+empty_set:
+	free_subdir(*new);
+	*new = NULL;
+	return res;
+}
+
+
+#define RECOVER_ID "Squashfs recovery file v1.0\n"
+#define RECOVER_ID_SIZE 28
+
+void write_recovery_data(squashfs_super_block *sBlk)
+{
+	int recoverfd, bytes = sBlk->bytes_used - sBlk->inode_table_start;
+	pid_t pid = getpid();
+	char *metadata;
+	char header[] = RECOVER_ID;
+
+	if(recover == FALSE) {
+		printf("No recovery data option specified.\n");
+		printf("Skipping saving recovery file.\n\n");
+		return;
+	}
+
+	if((metadata = malloc(bytes)) == NULL)
+		BAD_ERROR("Failed to alloc metadata buffer in write_recovery_data\n");
+
+	read_bytes(fd, sBlk->inode_table_start, bytes, metadata);
+
+	sprintf(recovery_file, "squashfs_recovery_%s_%d", getbase(destination_file), pid);
+	if((recoverfd = open(recovery_file, O_CREAT | O_TRUNC | O_RDWR, S_IRWXU)) == -1)
+		BAD_ERROR("Failed to create recovery file, because %s.  Aborting\n", strerror(errno));
+		
+	if(write(recoverfd, header, RECOVER_ID_SIZE) == -1)
+		BAD_ERROR("Failed to write recovery file, because %s\n", strerror(errno));
+
+	if(write(recoverfd, sBlk, sizeof(squashfs_super_block)) == -1)
+		BAD_ERROR("Failed to write recovery file, because %s\n", strerror(errno));
+
+	if(write(recoverfd, metadata, bytes) == -1)
+		BAD_ERROR("Failed to write recovery file, because %s\n", strerror(errno));
+
+	close(recoverfd);
+	free(metadata);
+	
+	printf("Recovery file \"%s\" written\n", recovery_file);
+	printf("If Mksquashfs aborts abnormally (i.e. power failure), run\n");
+	printf("mksquashfs dummy %s -recover %s\n", destination_file, recovery_file);
+	printf("to restore filesystem\n\n");
+}
+
+
+void read_recovery_data(char *recovery_file, char *destination_file)
+{
+	int fd, recoverfd, bytes;
+	squashfs_super_block orig_sBlk, sBlk;
+	char *metadata;
+	int readbytes;
+	struct stat buf;
+	char header[] = RECOVER_ID;
+	char header2[RECOVER_ID_SIZE];
+
+	if((recoverfd = open(recovery_file, O_RDONLY)) == -1)
+		BAD_ERROR("Failed to open recovery file because %s\n", strerror(errno));
+
+	if(stat(destination_file, &buf) == -1)
+		BAD_ERROR("Failed to stat destination file, because %s\n", strerror(errno));
+
+	if((fd = open(destination_file, O_RDWR)) == -1)
+		BAD_ERROR("Failed to open destination file because %s\n", strerror(errno));
+
+	if(read(recoverfd, header2, RECOVER_ID_SIZE) == -1)
+		BAD_ERROR("Failed to read recovery file, because %s\n", strerror(errno));
+	if(strncmp(header, header2, RECOVER_ID_SIZE) !=0 )
+		BAD_ERROR("Not a recovery file\n");
+
+	if(read(recoverfd, &sBlk, sizeof(squashfs_super_block)) == -1)
+		BAD_ERROR("Failed to read recovery file, because %s\n", strerror(errno));
+
+	read_bytes(fd, 0, sizeof(squashfs_super_block), (char *) &orig_sBlk);
+
+	if(memcmp(((char *) &sBlk) + 4, ((char *) &orig_sBlk) + 4, sizeof(squashfs_super_block) - 4) != 0)
+		BAD_ERROR("Recovery file and destination file do not seem to match\n");
+
+	bytes = sBlk.bytes_used - sBlk.inode_table_start;
+
+	if((metadata = malloc(bytes)) == NULL)
+		BAD_ERROR("Failed to alloc metadata buffer in read_recovery_data\n");
+
+	if((readbytes = read(recoverfd, metadata, bytes)) == -1)
+		BAD_ERROR("Failed to read recovery file, because %s\n", strerror(errno));
+
+	if(readbytes != bytes)
+		BAD_ERROR("Recovery file appears to be truncated\n");
+
+	write_bytes(fd, 0, sizeof(squashfs_super_block), (char *) &sBlk);
+
+	write_bytes(fd, sBlk.inode_table_start, bytes, metadata);
+
+	close(recoverfd);
+	close(fd);
+
+	printf("Successfully wrote recovery file \"%s\".  Exiting\n", recovery_file);
+	
+	exit(0);
+}
+
+
+#define VERSION() \
+	printf("mksquashfs version 3.4 (2008/08/26)\n");\
+	printf("copyright (C) 2008 Phillip Lougher <phillip@lougher.demon.co.uk>\n\n"); \
+	printf("This program is free software; you can redistribute it and/or\n");\
+	printf("modify it under the terms of the GNU General Public License\n");\
+	printf("as published by the Free Software Foundation; either version 2,\n");\
+	printf("or (at your option) any later version.\n\n");\
+	printf("This program is distributed in the hope that it will be useful,\n");\
+	printf("but WITHOUT ANY WARRANTY; without even the implied warranty of\n");\
+	printf("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n");\
+	printf("GNU General Public License for more details.\n");
+int main(int argc, char *argv[])
+{
+	struct stat buf, source_buf;
+	int i;
+	squashfs_super_block sBlk;
+	char *b, *root_name = NULL;
+	int be, nopad = FALSE, keep_as_directory = FALSE, orig_be;
+	squashfs_inode inode;
+	int readb_mbytes = READER_BUFFER_DEFAULT, writeb_mbytes = WRITER_BUFFER_DEFAULT, fragmentb_mbytes = FRAGMENT_BUFFER_DEFAULT;
+	int s_minor;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	be = TRUE;
+#else
+	be = FALSE;
+#endif
+
+	pthread_mutex_init(&progress_mutex, NULL);
+	block_log = slog(block_size);
+	if(argc > 1 && strcmp(argv[1], "-version") == 0) {
+		VERSION();
+		exit(0);
+	}
+        for(i = 1; i < argc && argv[i][0] != '-'; i++);
+	if(i < 3)
+		goto printOptions;
+	source_path = argv + 1;
+	source = i - 2;
+	for(; i < argc; i++) {
+		if(strcmp(argv[i], "-recover") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -recover missing recovery file\n", argv[0]);
+				exit(1);
+			}
+			read_recovery_data(argv[i], argv[source + 1]);
+		} else if(strcmp(argv[i], "-no-recovery") == 0)
+			recover = FALSE;
+		else if(strcmp(argv[i], "-wildcards") == 0) {
+			old_exclude = FALSE;
+			use_regex = FALSE;
+		} else if(strcmp(argv[i], "-regex") == 0) {
+			old_exclude = FALSE;
+			use_regex = TRUE;
+		} else if(strcmp(argv[i], "-no-sparse") == 0)
+			sparse_files = FALSE;
+		else if(strcmp(argv[i], "-no-progress") == 0)
+			progress = FALSE;
+		else if(strcmp(argv[i], "-no-exports") == 0)
+			exportable = FALSE;
+		else if(strcmp(argv[i], "-processors") == 0) {
+			if((++i == argc) || (processors = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -processors missing or invalid processor number\n", argv[0]);
+				exit(1);
+			}
+			if(processors < 1) {
+				ERROR("%s: -processors should be 1 or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-read-queue") == 0) {
+			if((++i == argc) || (readb_mbytes = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -read-queue missing or invalid queue size\n", argv[0]);
+				exit(1);
+			}
+			if(readb_mbytes < 1) {
+				ERROR("%s: -read-queue should be 1 megabyte or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-write-queue") == 0) {
+			if((++i == argc) || (writeb_mbytes = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -write-queue missing or invalid queue size\n", argv[0]);
+				exit(1);
+			}
+			if(writeb_mbytes < 1) {
+				ERROR("%s: -write-queue should be 1 megabyte or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-fragment-queue") == 0) {
+			if((++i == argc) || (fragmentb_mbytes = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -fragment-queue missing or invalid queue size\n", argv[0]);
+				exit(1);
+			}
+			if(fragmentb_mbytes < 1) {
+				ERROR("%s: -fragment-queue should be 1 megabyte or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-b") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -b missing block size\n", argv[0]);
+				exit(1);
+			}
+			block_size = strtol(argv[i], &b, 10);
+			if(*b == 'm' || *b == 'M')
+				block_size *= 1048576;
+			else if(*b == 'k' || *b == 'K')
+				block_size *= 1024;
+			else if(*b != '\0') {
+				ERROR("%s: -b invalid block size\n", argv[0]);
+				exit(1);
+			}
+			if((block_log = slog(block_size)) == 0) {
+				ERROR("%s: -b block size not power of two or not between 4096 and 1Mbyte\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-ef") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -ef missing filename\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-no-duplicates") == 0)
+			duplicate_checking = FALSE;
+
+		else if(strcmp(argv[i], "-no-fragments") == 0)
+			no_fragments = TRUE;
+
+		 else if(strcmp(argv[i], "-always-use-fragments") == 0)
+			always_use_fragments = TRUE;
+
+		 else if(strcmp(argv[i], "-sort") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -sort missing filename\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-all-root") == 0 ||
+				strcmp(argv[i], "-root-owned") == 0)
+			global_uid = global_gid = 0;
+
+		else if(strcmp(argv[i], "-force-uid") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -force-uid missing uid or user\n", argv[0]);
+				exit(1);
+			}
+			if((global_uid = strtoll(argv[i], &b, 10)), *b =='\0') {
+				if(global_uid < 0 || global_uid > (((long long) 1 << 32) - 1)) {
+					ERROR("%s: -force-uid uid out of range\n", argv[0]);
+					exit(1);
+				}
+			} else {
+				struct passwd *uid = getpwnam(argv[i]);
+				if(uid)
+					global_uid = uid->pw_uid;
+				else {
+					ERROR("%s: -force-uid invalid uid or unknown user\n", argv[0]);
+					exit(1);
+				}
+			}
+		} else if(strcmp(argv[i], "-force-gid") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -force-gid missing gid or group\n", argv[0]);
+				exit(1);
+			}
+			if((global_gid = strtoll(argv[i], &b, 10)), *b =='\0') {
+				if(global_gid < 0 || global_gid > (((long long) 1 << 32) - 1)) {
+					ERROR("%s: -force-gid gid out of range\n", argv[0]);
+					exit(1);
+				}
+			} else {
+				struct group *gid = getgrnam(argv[i]);
+				if(gid)
+					global_gid = gid->gr_gid;
+				else {
+					ERROR("%s: -force-gid invalid gid or unknown group\n", argv[0]);
+					exit(1);
+				}
+			}
+		} else if(strcmp(argv[i], "-noI") == 0 ||
+				strcmp(argv[i], "-noInodeCompression") == 0)
+			noI = TRUE;
+
+		else if(strcmp(argv[i], "-noD") == 0 ||
+				strcmp(argv[i], "-noDataCompression") == 0)
+			noD = TRUE;
+
+		else if(strcmp(argv[i], "-noF") == 0 ||
+				strcmp(argv[i], "-noFragmentCompression") == 0)
+			noF = TRUE;
+
+		else if(strcmp(argv[i], "-nopad") == 0)
+			nopad = TRUE;
+
+		else if(strcmp(argv[i], "-check_data") == 0)
+			check_data = TRUE;
+
+		else if(strcmp(argv[i], "-info") == 0) {
+			silent = FALSE;
+			progress = FALSE;
+		}
+		else if(strcmp(argv[i], "-be") == 0)
+			be = TRUE;
+
+		else if(strcmp(argv[i], "-le") == 0)
+			be = FALSE;
+
+		else if(strcmp(argv[i], "-e") == 0)
+			break;
+
+		else if(strcmp(argv[i], "-noappend") == 0)
+			delete = TRUE;
+
+		else if(strcmp(argv[i], "-keep-as-directory") == 0)
+			keep_as_directory = TRUE;
+
+		else if(strcmp(argv[i], "-root-becomes") == 0) {
+			if(++i == argc) {
+				ERROR("%s: -root-becomes: missing name\n", argv[0]);
+				exit(1);
+			}	
+			root_name = argv[i];
+		} else if(strcmp(argv[i], "-version") == 0) {
+			VERSION();
+		} else {
+			ERROR("%s: invalid option\n\n", argv[0]);
+printOptions:
+			ERROR("SYNTAX:%s source1 source2 ...  dest [options] [-e list of exclude\ndirs/files]\n", argv[0]);
+			ERROR("\nOptions are\n");
+			ERROR("-version\t\tprint version, licence and copyright message\n");
+			ERROR("-recover <name>\t\trecover filesystem data using recovery file <name>\n");
+			ERROR("-no-recovery\t\tdon't generate a recovery file\n");
+			ERROR("-info\t\t\tprint files written to filesystem\n");
+			ERROR("-no-exports\t\tdon't make the filesystem exportable via NFS\n");
+			ERROR("-no-progress\t\tdon't display the progress bar\n");
+			ERROR("-no-sparse\t\tdon't detect sparse files\n");
+			ERROR("-b <block_size>\t\tset data block to <block_size>.  Default %d bytes\n", SQUASHFS_FILE_SIZE);
+			ERROR("-processors <number>\tUse <number> processors.  By default will use number of\n\t\t\tprocessors available\n");
+			ERROR("-read-queue <size>\tSet input queue to <size> Mbytes.  Default %d Mbytes\n", READER_BUFFER_DEFAULT);
+			ERROR("-write-queue <size>\tSet output queue to <size> Mbytes.  Default %d Mbytes\n", WRITER_BUFFER_DEFAULT);
+			ERROR("-fragment-queue <size>\tSet fagment queue to <size> Mbytes.  Default %d Mbytes\n", FRAGMENT_BUFFER_DEFAULT);
+			ERROR("-noI\t\t\tdo not compress inode table\n");
+			ERROR("-noD\t\t\tdo not compress data blocks\n");
+			ERROR("-noF\t\t\tdo not compress fragment blocks\n");
+			ERROR("-no-fragments\t\tdo not use fragments\n");
+			ERROR("-always-use-fragments\tuse fragment blocks for files larger than block size\n");
+			ERROR("-no-duplicates\t\tdo not perform duplicate checking\n");
+			ERROR("-noappend\t\tdo not append to existing filesystem\n");
+			ERROR("-keep-as-directory\tif one source directory is specified, create a root\n");
+			ERROR("\t\t\tdirectory containing that directory, rather than the\n");
+			ERROR("\t\t\tcontents of the directory\n");
+			ERROR("-root-becomes <name>\twhen appending source files/directories, make the\n");
+			ERROR("\t\t\toriginal root become a subdirectory in the new root\n");
+			ERROR("\t\t\tcalled <name>, rather than adding the new source items\n");
+			ERROR("\t\t\tto the original root\n");
+			ERROR("-all-root\t\tmake all files owned by root\n");
+			ERROR("-force-uid uid\t\tset all file uids to uid\n");
+			ERROR("-force-gid gid\t\tset all file gids to gid\n");
+			ERROR("-le\t\t\tcreate a little endian filesystem\n");
+			ERROR("-be\t\t\tcreate a big endian filesystem\n");
+			ERROR("-nopad\t\t\tdo not pad filesystem to a multiple of 4K\n");
+			ERROR("-check_data\t\tadd checkdata for greater filesystem checks\n");
+			ERROR("-root-owned\t\talternative name for -all-root\n");
+			ERROR("-noInodeCompression\talternative name for -noI\n");
+			ERROR("-noDataCompression\talternative name for -noD\n");
+			ERROR("-noFragmentCompression\talternative name for -noF\n");
+			ERROR("-sort <sort_file>\tsort files according to priorities in <sort_file>.  One\n");
+			ERROR("\t\t\tfile or dir with priority per line.  Priority -32768 to\n");
+			ERROR("\t\t\t32767, default priority 0\n");
+			ERROR("-ef <exclude_file>\tlist of exclude dirs/files.  One per line\n");
+			ERROR("-wildcards\t\tAllow extended shell wildcards (globbing) to be used in\n\t\t\texclude dirs/files\n");
+			ERROR("-regex\t\t\tAllow POSIX regular expressions to be used in exclude\n\t\t\tdirs/files\n");
+			exit(1);
+		}
+	}
+
+	reader_buffer_size = readb_mbytes << (20 - block_log);
+	writer_buffer_size = writeb_mbytes << (20 - block_log);
+	fragment_buffer_size = fragmentb_mbytes << (20 - block_log);
+
+	if(block_size <= 65536 && sparse_files == FALSE)
+		s_minor = 0;
+	else
+		s_minor = SQUASHFS_MINOR;
+
+	for(i = 0; i < source; i++)
+		if(lstat(source_path[i], &source_buf) == -1) {
+			fprintf(stderr, "Cannot stat source directory \"%s\" because %s\n", source_path[i], strerror(errno));
+			EXIT_MKSQUASHFS();
+		}
+
+	destination_file = argv[source + 1];
+	if(stat(argv[source + 1], &buf) == -1) {
+		if(errno == ENOENT) { /* Does not exist */
+			if((fd = open(argv[source + 1], O_CREAT | O_TRUNC | O_RDWR, S_IRWXU)) == -1) {
+				perror("Could not create destination file");
+				exit(1);
+			}
+			delete = TRUE;
+		} else {
+			perror("Could not stat destination file");
+			exit(1);
+		}
+
+	} else {
+		if(S_ISBLK(buf.st_mode)) {
+			if((fd = open(argv[source + 1], O_RDWR)) == -1) {
+				perror("Could not open block device as destination");
+				exit(1);
+			}
+			block_device = 1;
+
+		} else if(S_ISREG(buf.st_mode))	 {
+			if((fd = open(argv[source + 1], (delete ? O_TRUNC : 0) | O_RDWR)) == -1) {
+				perror("Could not open regular file for writing as destination");
+				exit(1);
+			}
+		}
+		else {
+			ERROR("Destination not block device or regular file\n");
+			exit(1);
+		}
+
+	}
+
+	signal(SIGTERM, sighandler2);
+	signal(SIGINT, sighandler2);
+
+	/* process the exclude files - must be done afer destination file has been possibly created */
+	for(i = source + 2; i < argc; i++)
+		if(strcmp(argv[i], "-ef") == 0) {
+			FILE *fd;
+			char filename[16385];
+			if((fd = fopen(argv[++i], "r")) == NULL) {
+				perror("Could not open exclude file...");
+				EXIT_MKSQUASHFS();
+			}
+			while(fscanf(fd, "%16384[^\n]\n", filename) != EOF)
+					if(old_exclude)
+						old_add_exclude(filename);
+					else
+						add_exclude(filename);
+			fclose(fd);
+		} else if(strcmp(argv[i], "-e") == 0)
+			break;
+		else if(strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "-root-becomes") == 0 || strcmp(argv[i], "-sort") == 0)
+			i++;
+
+	if(i != argc) {
+		if(++i == argc) {
+			ERROR("%s: -e missing arguments\n", argv[0]);
+			EXIT_MKSQUASHFS();
+		}
+		while(i < argc)
+			if(old_exclude)
+				old_add_exclude(argv[i++]);
+			else
+				add_exclude(argv[i++]);
+	}
+
+	/* process the sort files - must be done afer the exclude files  */
+	for(i = source + 2; i < argc; i++)
+		if(strcmp(argv[i], "-sort") == 0) {
+			read_sort_file(argv[++i], source, source_path);
+			sorted ++;
+		} else if(strcmp(argv[i], "-e") == 0)
+			break;
+		else if(strcmp(argv[i], "-b") == 0 || strcmp(argv[i], "-root-becomes") == 0 || strcmp(argv[i], "-ef") == 0)
+			i++;
+
+#ifdef SQUASHFS_TRACE
+	progress = FALSE;
+#endif
+
+	if(!delete) {
+	        if(read_super(fd, &sBlk, &orig_be, argv[source + 1]) == 0) {
+			ERROR("Failed to read existing filesystem - will not overwrite - ABORTING!\n");
+			ERROR("To force Mksquashfs to write to this block device or file use -noappend\n");
+			EXIT_MKSQUASHFS();
+		}
+
+		be = orig_be;
+		block_log = slog(block_size = sBlk.block_size);
+		s_minor = sBlk.s_minor;
+		noI = SQUASHFS_UNCOMPRESSED_INODES(sBlk.flags);
+		noD = SQUASHFS_UNCOMPRESSED_DATA(sBlk.flags);
+		noF = SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.flags);
+		check_data = SQUASHFS_CHECK_DATA(sBlk.flags);
+		no_fragments = SQUASHFS_NO_FRAGMENTS(sBlk.flags);
+		always_use_fragments = SQUASHFS_ALWAYS_FRAGMENTS(sBlk.flags);
+		duplicate_checking = SQUASHFS_DUPLICATES(sBlk.flags);
+		exportable = SQUASHFS_EXPORTABLE(sBlk.flags);
+	}
+
+	initialise_threads();
+
+	if(delete) {
+		printf("Creating %s %d.%d filesystem on %s, block size %d.\n",
+				be ? "big endian" : "little endian", SQUASHFS_MAJOR, s_minor, argv[source + 1], block_size);
+		bytes = sizeof(squashfs_super_block);
+	} else {
+		unsigned int last_directory_block, inode_dir_offset, inode_dir_file_size, root_inode_size,
+		inode_dir_start_block, uncompressed_data, compressed_data, inode_dir_inode_number,
+		inode_dir_parent_inode;
+		unsigned int root_inode_start = SQUASHFS_INODE_BLK(sBlk.root_inode), root_inode_offset =
+		SQUASHFS_INODE_OFFSET(sBlk.root_inode);
+
+		if((bytes = read_filesystem(root_name, fd, &sBlk, &inode_table, &data_cache,
+				&directory_table, &directory_data_cache, &last_directory_block, &inode_dir_offset,
+				&inode_dir_file_size, &root_inode_size, &inode_dir_start_block,
+				&file_count, &sym_count, &dev_count, &dir_count, &fifo_count, &sock_count,
+				(squashfs_uid *) uids, &uid_count, (squashfs_uid *) guids, &guid_count,
+				&total_bytes, &total_inode_bytes, &total_directory_bytes, &inode_dir_inode_number,
+				&inode_dir_parent_inode, add_old_root_entry, &fragment_table, &inode_lookup_table)) == 0) {
+			ERROR("Failed to read existing filesystem - will not overwrite - ABORTING!\n");
+			ERROR("To force Mksquashfs to write to this block device or file use -noappend\n");
+			EXIT_MKSQUASHFS();
+		}
+		if((fragments = sBlk.fragments))
+			fragment_table = (squashfs_fragment_entry *) realloc((char *) fragment_table, ((fragments + FRAG_SIZE - 1) & ~(FRAG_SIZE - 1)) * sizeof(squashfs_fragment_entry)); 
+
+		printf("Appending to existing %s %d.%d filesystem on %s, block size %d\n", be ? "big endian" :
+			"little endian", SQUASHFS_MAJOR, s_minor, argv[source + 1], block_size);
+		printf("All -be, -le, -b, -noI, -noD, -noF, -check_data, no-duplicates, no-fragments, -always-use-fragments and -exportable options ignored\n");
+		printf("\nIf appending is not wanted, please re-run with -noappend specified!\n\n");
+
+		compressed_data = (inode_dir_offset + inode_dir_file_size) & ~(SQUASHFS_METADATA_SIZE - 1);
+		uncompressed_data = (inode_dir_offset + inode_dir_file_size) & (SQUASHFS_METADATA_SIZE - 1);
+		
+		/* save original filesystem state for restoring ... */
+		sfragments = fragments;
+		sbytes = bytes;
+		sinode_count = sBlk.inodes;
+		scache_bytes = root_inode_offset + root_inode_size;
+		sdirectory_cache_bytes = uncompressed_data;
+		sdata_cache = (char *)malloc(scache_bytes);
+		sdirectory_data_cache = (char *)malloc(sdirectory_cache_bytes);
+		memcpy(sdata_cache, data_cache, scache_bytes);
+		memcpy(sdirectory_data_cache, directory_data_cache + compressed_data, sdirectory_cache_bytes);
+		sinode_bytes = root_inode_start;
+		suid_count = uid_count;
+		sguid_count = guid_count;
+		stotal_bytes = total_bytes;
+		stotal_inode_bytes = total_inode_bytes;
+		stotal_directory_bytes = total_directory_bytes + compressed_data;
+		sfile_count = file_count;
+		ssym_count = sym_count;
+		sdev_count = dev_count;
+		sdir_count = dir_count + 1;
+		sfifo_count = fifo_count;
+		ssock_count = sock_count;
+		sdup_files = dup_files;
+		write_recovery_data(&sBlk);
+		restore = TRUE;
+		if(setjmp(env))
+			goto restore_filesystem;
+		signal(SIGTERM, sighandler);
+		signal(SIGINT, sighandler);
+		write_bytes(fd, SQUASHFS_START, 4, "\0\0\0\0");
+
+		/* set the filesystem state up to be able to append to the original filesystem.  The filesystem state
+		 * differs depending on whether we're appending to the original root directory, or if the original
+		 * root directory becomes a sub-directory (root-becomes specified on command line, here root_name != NULL)
+		 */
+		inode_bytes = inode_size = root_inode_start;
+		directory_size = last_directory_block;
+		cache_size = root_inode_offset + root_inode_size;
+		directory_cache_size = inode_dir_offset + inode_dir_file_size;
+		if(root_name) {
+			sdirectory_bytes = last_directory_block;
+			sdirectory_compressed_bytes = 0;
+			root_inode_number = inode_dir_parent_inode;
+			dir_inode_no = sBlk.inodes + 2;
+			directory_bytes = last_directory_block;
+			directory_cache_bytes = uncompressed_data;
+			memmove(directory_data_cache, directory_data_cache + compressed_data, uncompressed_data);
+			cache_bytes = root_inode_offset + root_inode_size;
+			add_old_root_entry(root_name, sBlk.root_inode, inode_dir_inode_number, SQUASHFS_DIR_TYPE);
+			total_directory_bytes += compressed_data;
+			dir_count ++;
+		} else {
+			sdirectory_compressed_bytes = last_directory_block - inode_dir_start_block;
+			sdirectory_compressed = malloc(sdirectory_compressed_bytes);
+			memcpy(sdirectory_compressed, directory_table + inode_dir_start_block, sdirectory_compressed_bytes); 
+			sdirectory_bytes = inode_dir_start_block;
+			root_inode_number = inode_dir_inode_number;
+			dir_inode_no = sBlk.inodes + 1;
+			directory_bytes = inode_dir_start_block;
+			directory_cache_bytes = inode_dir_offset;
+			cache_bytes = root_inode_offset;
+		}
+
+		inode_count = file_count + dir_count + sym_count + dev_count + fifo_count + sock_count;
+	}
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	swap = !be;
+#else
+	swap = be;
+#endif
+
+	block_offset = check_data ? 3 : 2;
+
+	if(path || stickypath) {
+		paths = init_subdir();
+		if(path)
+			paths = add_subdir(paths, path);
+		if(stickypath)
+			paths = add_subdir(paths, stickypath);
+	}
+
+	if(delete && !keep_as_directory && source == 1 && S_ISDIR(source_buf.st_mode))
+		dir_scan(&inode, source_path[0], scan1_readdir);
+	else if(!keep_as_directory && source == 1 && S_ISDIR(source_buf.st_mode))
+		dir_scan(&inode, source_path[0], scan1_single_readdir);
+	else
+		dir_scan(&inode, "", scan1_encomp_readdir);
+	sBlk.root_inode = inode;
+	sBlk.inodes = inode_count;
+	sBlk.s_magic = SQUASHFS_MAGIC;
+	sBlk.s_major = SQUASHFS_MAJOR;
+	sBlk.s_minor = s_minor;
+	sBlk.block_size = block_size;
+	sBlk.block_log = block_log;
+	sBlk.flags = SQUASHFS_MKFLAGS(noI, noD, check_data, noF, no_fragments, always_use_fragments, duplicate_checking, exportable);
+	sBlk.mkfs_time = time(NULL);
+
+restore_filesystem:
+	if(progress && estimated_uncompressed) {
+		disable_progress_bar();
+		progress_bar(cur_uncompressed, estimated_uncompressed, columns);
+	}
+
+	write_fragment();
+	sBlk.fragments = fragments;
+	if(interrupted < 2) {
+		unlock_fragments();
+		pthread_mutex_lock(&fragment_mutex);
+		while(fragments_outstanding) {
+			pthread_mutex_unlock(&fragment_mutex);
+			sched_yield();
+			pthread_mutex_lock(&fragment_mutex);
+		}
+		queue_put(to_writer, NULL);
+		if(queue_get(from_writer) != 0)
+			EXIT_MKSQUASHFS();
+	}
+
+	sBlk.inode_table_start = write_inodes();
+	sBlk.directory_table_start = write_directories();
+	sBlk.fragment_table_start = write_fragment_table();
+	sBlk.lookup_table_start = exportable ? write_inode_lookup_table() : SQUASHFS_INVALID_BLK;
+
+	TRACE("sBlk->inode_table_start 0x%llx\n", sBlk.inode_table_start);
+	TRACE("sBlk->directory_table_start 0x%llx\n", sBlk.directory_table_start);
+	TRACE("sBlk->fragment_table_start 0x%llx\n", sBlk.fragment_table_start);
+	if(exportable)
+		TRACE("sBlk->lookup_table_start 0x%llx\n", sBlk.lookup_table_start);
+
+	sBlk.no_uids = uid_count;
+	if(sBlk.no_uids) {
+		if(!swap)
+			write_bytes(fd, bytes, uid_count * sizeof(squashfs_uid), (char *) uids);
+		else {
+			squashfs_uid uids_copy[uid_count];
+
+			SQUASHFS_SWAP_DATA(uids, uids_copy, uid_count, sizeof(squashfs_uid) * 8);
+			write_bytes(fd, bytes, uid_count * sizeof(squashfs_uid), (char *) uids_copy);
+		}
+		sBlk.uid_start = bytes;
+		bytes += uid_count * sizeof(squashfs_uid);
+	} else
+		sBlk.uid_start = 0;
+
+	sBlk.no_guids = guid_count;
+	if(sBlk.no_guids) {
+		if(!swap)
+			write_bytes(fd, bytes, guid_count * sizeof(squashfs_uid), (char *) guids);
+		else {
+			squashfs_uid guids_copy[guid_count];
+
+			SQUASHFS_SWAP_DATA(guids, guids_copy, guid_count, sizeof(squashfs_uid) * 8);
+			write_bytes(fd, bytes, guid_count * sizeof(squashfs_uid), (char *) guids_copy);
+		}
+		sBlk.guid_start = bytes;
+		bytes += guid_count * sizeof(squashfs_uid);
+	} else
+		sBlk.guid_start = 0;
+
+	sBlk.bytes_used = bytes;
+
+	if(!swap)
+		write_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block), (char *) &sBlk);
+	else {
+		squashfs_super_block sBlk_copy;
+
+		SQUASHFS_SWAP_SUPER_BLOCK((&sBlk), &sBlk_copy); 
+		write_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block), (char *) &sBlk_copy);
+	}
+
+	if(!nopad && (i = bytes & (4096 - 1))) {
+		char temp[4096] = {0};
+		write_bytes(fd, bytes, 4096 - i, temp);
+	}
+
+	close(fd);
+
+	if(recovery_file[0] != '\0')
+		unlink(recovery_file);
+
+	total_bytes += total_inode_bytes + total_directory_bytes + uid_count
+		* sizeof(unsigned short) + guid_count * sizeof(unsigned short) +
+		sizeof(squashfs_super_block);
+
+	printf("\n%s%s filesystem, data block size %d, %s data, %s metadata, %s fragments, duplicates are %sremoved\n",
+		exportable ? "Exportable " : "", be ?  "Big endian" : "Little endian", block_size,
+		noD ? "uncompressed" : "compressed", noI ?  "uncompressed" : "compressed",
+		no_fragments ? "no" : noF ? "uncompressed" : "compressed", duplicate_checking ? "" : "not ");
+	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n", bytes / 1024.0, bytes / (1024.0 * 1024.0));
+	printf("\t%.2f%% of uncompressed filesystem size (%.2f Kbytes)\n",
+		((float) bytes / total_bytes) * 100.0, total_bytes / 1024.0);
+	printf("Inode table size %d bytes (%.2f Kbytes)\n",
+		inode_bytes, inode_bytes / 1024.0);
+	printf("\t%.2f%% of uncompressed inode table size (%d bytes)\n",
+		((float) inode_bytes / total_inode_bytes) * 100.0, total_inode_bytes);
+	printf("Directory table size %d bytes (%.2f Kbytes)\n",
+		directory_bytes, directory_bytes / 1024.0);
+	printf("\t%.2f%% of uncompressed directory table size (%d bytes)\n",
+		((float) directory_bytes / total_directory_bytes) * 100.0, total_directory_bytes);
+	if(duplicate_checking)
+		printf("Number of duplicate files found %d\n", file_count - dup_files);
+	else
+		printf("No duplicate files removed\n");
+	printf("Number of inodes %d\n", inode_count);
+	printf("Number of files %d\n", file_count);
+	if(!no_fragments)
+		printf("Number of fragments %d\n", fragments);
+	printf("Number of symbolic links  %d\n", sym_count);
+	printf("Number of device nodes %d\n", dev_count);
+	printf("Number of fifo nodes %d\n", fifo_count);
+	printf("Number of socket nodes %d\n", sock_count);
+	printf("Number of directories %d\n", dir_count);
+	printf("Number of uids %d\n", uid_count);
+
+	for(i = 0; i < uid_count; i++) {
+		int uid = uids[i];
+		struct passwd *user = getpwuid(uid);
+		printf("\t%s (%d)\n", user == NULL ? "unknown" : user->pw_name, uids[i]);
+	}
+
+	printf("Number of gids %d\n", guid_count);
+
+	for(i = 0; i < guid_count; i++) {
+		struct group *group = getgrgid(guids[i]);
+		printf("\t%s (%d)\n", group == NULL ? "unknown" : group->gr_name, guids[i]);
+	}
+
+	return 0;
+}
diff -BurpN linux-2.6.22.orig/scripts/squashfs/mksquashfs.h linux-2.6.22/scripts/squashfs/mksquashfs.h
--- linux-2.6.22.orig/scripts/squashfs/mksquashfs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/mksquashfs.h	2008-08-20 04:45:55.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating a filesystem on a
+ * machine with different byte ordering to the target architecture.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uK>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * mksquashfs.h
+ *
+ */
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing architectures
+ */
+#if __BYTE_ORDER == __BIG_ENDIAN
+	/* convert from big endian to little endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, b_pos)
+#else
+	/* convert from little endian to big endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	int bits;\
+	int b_pos = pos % 8;\
+	unsigned long long val = (long long) value << (SHIFT);\
+	unsigned char *s = ((unsigned char *) &val) + 7;\
+	unsigned char *d = ((unsigned char *)p) + (pos / 8);\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d++ |= *s--;\
+}
+#define SQUASHFS_MEMSET(s, d, n)	memset(d, 0, n);
diff -BurpN linux-2.6.22.orig/scripts/squashfs/read_fs.c linux-2.6.22/scripts/squashfs/read_fs.c
--- linux-2.6.22.orig/scripts/squashfs/read_fs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/read_fs.c	2008-08-20 04:46:08.000000000 +0000
@@ -0,0 +1,661 @@
+/*
+ * Read a squashfs filesystem.  This is a highly compressed read only filesystem.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * read_fs.c
+ */
+
+extern void read_bytes(int, long long, int, char *);
+extern int add_file(long long, long long, long long, unsigned int *, int, unsigned int, int, int);
+
+#define TRUE 1
+#define FALSE 0
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <zlib.h>
+#include <sys/mman.h>
+
+#ifndef linux
+#define __BYTE_ORDER BYTE_ORDER
+#define __BIG_ENDIAN BIG_ENDIAN
+#define __LITTLE_ENDIAN LITTLE_ENDIAN
+#else
+#include <endian.h>
+#endif
+
+#include <squashfs_fs.h>
+#include "read_fs.h"
+#include "global.h"
+
+#include <stdlib.h>
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)		do { \
+						printf("mksquashfs: "s, ## args); \
+					} while(0)
+#else
+#define TRACE(s, args...)
+#endif
+
+#define ERROR(s, args...)		do { \
+						fprintf(stderr, s, ## args); \
+					} while(0)
+
+int swap;
+
+int read_block(int fd, long long start, long long *next, unsigned char *block, squashfs_super_block *sBlk)
+{
+	unsigned short c_byte;
+	int offset = 2;
+	
+	if(swap) {
+		read_bytes(fd, start, 2, (char *) block);
+		((unsigned char *) &c_byte)[1] = block[0];
+		((unsigned char *) &c_byte)[0] = block[1]; 
+	} else 
+		read_bytes(fd, start, 2, (char *)&c_byte);
+
+	if(SQUASHFS_CHECK_DATA(sBlk->flags))
+		offset = 3;
+	if(SQUASHFS_COMPRESSED(c_byte)) {
+		char buffer[SQUASHFS_METADATA_SIZE];
+		int res;
+		unsigned long bytes = SQUASHFS_METADATA_SIZE;
+
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+		read_bytes(fd, start + offset, c_byte, buffer);
+
+		if((res = uncompress(block, &bytes, (const unsigned char *) buffer, c_byte)) != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				ERROR("zlib::uncompress failed, not enough memory\n");
+			else if(res == Z_BUF_ERROR)
+				ERROR("zlib::uncompress failed, not enough room in output buffer\n");
+			else
+				ERROR("zlib::uncompress failed, unknown error %d\n", res);
+			return 0;
+		}
+		if(next)
+			*next = start + offset + c_byte;
+		return bytes;
+	} else {
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+		read_bytes(fd, start + offset, c_byte, (char *) block);
+		if(next)
+			*next = start + offset + c_byte;
+		return c_byte;
+	}
+}
+
+
+int scan_inode_table(int fd, long long start, long long end, long long root_inode_start, int root_inode_offset,
+		squashfs_super_block *sBlk,
+		squashfs_inode_header *dir_inode, unsigned char **inode_table, unsigned int *root_inode_block,
+		unsigned int *root_inode_size, long long *uncompressed_file, unsigned int *uncompressed_directory,
+		int *file_count, int *sym_count, int *dev_count, int *dir_count, int *fifo_count, int *sock_count)
+{
+	unsigned char *cur_ptr;
+	int byte, bytes = 0, size = 0, files = 0;
+	squashfs_reg_inode_header inode;
+	unsigned int directory_start_block;
+
+	TRACE("scan_inode_table: start 0x%llx, end 0x%llx, root_inode_start 0x%llx\n", start, end, root_inode_start);
+	while(start < end) {
+		if(start == root_inode_start) {
+			TRACE("scan_inode_table: read compressed block 0x%llx containing root inode\n", start);
+			*root_inode_block = bytes;
+		}
+		if((size - bytes < SQUASHFS_METADATA_SIZE) &&
+				((*inode_table = realloc(*inode_table, size += SQUASHFS_METADATA_SIZE)) == NULL))
+			return FALSE;
+		TRACE("scan_inode_table: reading block 0x%llx\n", start);
+		if((byte = read_block(fd, start, &start, *inode_table + bytes, sBlk)) == 0) {
+			free(*inode_table);
+			return FALSE;
+		}
+		bytes += byte;
+	}
+
+	/*
+	 * Read last inode entry which is the root directory inode, and obtain the last
+	 * directory start block index.  This is used when calculating the total uncompressed
+	 * directory size.  The directory bytes in the last block will be counted as normal.
+	 *
+	 * The root inode is ignored in the inode scan.  This ensures there is
+	 * always enough bytes left to read a regular file inode entry
+	 */
+	*root_inode_size = bytes - (*root_inode_block + root_inode_offset);
+	bytes = *root_inode_block + root_inode_offset;
+	if(swap) {
+		squashfs_base_inode_header sinode;
+		memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->base));
+		SQUASHFS_SWAP_BASE_INODE_HEADER(&dir_inode->base, &sinode, sizeof(squashfs_base_inode_header));
+	} else
+		memcpy(&dir_inode->base, *inode_table + bytes, sizeof(dir_inode->base));
+	if(dir_inode->base.inode_type == SQUASHFS_DIR_TYPE) {
+		if(swap) {
+			squashfs_dir_inode_header sinode;
+			memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->dir));
+			SQUASHFS_SWAP_DIR_INODE_HEADER(&dir_inode->dir, &sinode);
+		} else
+			memcpy(&dir_inode->dir, *inode_table + bytes, sizeof(dir_inode->dir));
+		directory_start_block = dir_inode->dir.start_block;
+	} else {
+		if(swap) {
+			squashfs_ldir_inode_header sinode;
+			memcpy(&sinode, *inode_table + bytes, sizeof(dir_inode->ldir));
+			SQUASHFS_SWAP_LDIR_INODE_HEADER(&dir_inode->ldir, &sinode);
+		} else
+			memcpy(&dir_inode->ldir, *inode_table + bytes, sizeof(dir_inode->ldir));
+		directory_start_block = dir_inode->ldir.start_block;
+	}
+
+	for(cur_ptr = *inode_table; cur_ptr < *inode_table + bytes; files ++) {
+		if(swap) {
+			squashfs_reg_inode_header sinode;
+			memcpy(&sinode, cur_ptr, sizeof(inode));
+			SQUASHFS_SWAP_REG_INODE_HEADER(&inode, &sinode);
+		} else
+			memcpy(&inode, cur_ptr, sizeof(inode));
+
+		TRACE("scan_inode_table: processing inode @ byte position 0x%x, type 0x%x\n", cur_ptr - *inode_table,
+				inode.inode_type);
+		switch(inode.inode_type) {
+			case SQUASHFS_FILE_TYPE: {
+				int frag_bytes = inode.fragment == SQUASHFS_INVALID_FRAG ? 0 : inode.file_size % sBlk->block_size;
+				int blocks = inode.fragment == SQUASHFS_INVALID_FRAG ? (inode.file_size
+					+ sBlk->block_size - 1) >> sBlk->block_log : inode.file_size >>
+					sBlk->block_log;
+				long long file_bytes = 0;
+				int i;
+				long long start = inode.start_block;
+				unsigned int *block_list;
+
+				TRACE("scan_inode_table: regular file, file_size %d, blocks %d\n", inode.file_size, blocks);
+
+				if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL) {
+					ERROR("Out of memory in block list malloc\n");
+					goto failed;
+				}
+
+				cur_ptr += sizeof(inode);
+				if(swap) {
+					unsigned int sblock_list[blocks];
+					memcpy(sblock_list, cur_ptr, blocks * sizeof(unsigned int));
+					SQUASHFS_SWAP_INTS(block_list, sblock_list, blocks);
+				} else
+					memcpy(block_list, cur_ptr, blocks * sizeof(unsigned int));
+
+				*uncompressed_file += inode.file_size;
+				(*file_count) ++;
+
+				for(i = 0; i < blocks; i++)
+					file_bytes += SQUASHFS_COMPRESSED_SIZE_BLOCK(block_list[i]);
+
+	                        add_file(start, inode.file_size, file_bytes, block_list, blocks, inode.fragment, inode.offset, frag_bytes);
+				cur_ptr += blocks * sizeof(unsigned int);
+				break;
+			}	
+			case SQUASHFS_LREG_TYPE: {
+				squashfs_lreg_inode_header inode;
+				int frag_bytes;
+				int blocks;
+				long long file_bytes = 0;
+				int i;
+				long long start;
+				unsigned int *block_list;
+
+				if(swap) {
+					squashfs_lreg_inode_header sinodep;
+					memcpy(&sinodep, cur_ptr, sizeof(sinodep));
+					SQUASHFS_SWAP_LREG_INODE_HEADER(&inode, &sinodep);
+				} else
+					memcpy(&inode, cur_ptr, sizeof(inode));
+
+				frag_bytes = inode.fragment == SQUASHFS_INVALID_FRAG ? 0 : inode.file_size % sBlk->block_size;
+				blocks = inode.fragment == SQUASHFS_INVALID_FRAG ? (inode.file_size
+					+ sBlk->block_size - 1) >> sBlk->block_log : inode.file_size >>
+					sBlk->block_log;
+				start = inode.start_block;
+
+				TRACE("scan_inode_table: extended regular file, file_size %lld, blocks %d\n", inode.file_size, blocks);
+
+				if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL) {
+					ERROR("Out of memory in block list malloc\n");
+					goto failed;
+				}
+
+				cur_ptr += sizeof(inode);
+				if(swap) {
+					unsigned int sblock_list[blocks];
+					memcpy(sblock_list, cur_ptr, blocks * sizeof(unsigned int));
+					SQUASHFS_SWAP_INTS(block_list, sblock_list, blocks);
+				} else
+					memcpy(block_list, cur_ptr, blocks * sizeof(unsigned int));
+
+				*uncompressed_file += inode.file_size;
+				(*file_count) ++;
+
+				for(i = 0; i < blocks; i++)
+					file_bytes += SQUASHFS_COMPRESSED_SIZE_BLOCK(block_list[i]);
+
+	                        add_file(start, inode.file_size, file_bytes, block_list, blocks, inode.fragment, inode.offset, frag_bytes);
+				cur_ptr += blocks * sizeof(unsigned int);
+				break;
+			}	
+			case SQUASHFS_SYMLINK_TYPE: {
+				squashfs_symlink_inode_header inodep;
+	
+				if(swap) {
+					squashfs_symlink_inode_header sinodep;
+					memcpy(&sinodep, cur_ptr, sizeof(sinodep));
+					SQUASHFS_SWAP_SYMLINK_INODE_HEADER(&inodep, &sinodep);
+				} else
+					memcpy(&inodep, cur_ptr, sizeof(inodep));
+				(*sym_count) ++;
+				cur_ptr += sizeof(inodep) + inodep.symlink_size;
+				break;
+			}
+			case SQUASHFS_DIR_TYPE: {
+				squashfs_dir_inode_header dir_inode;
+
+				if(swap) {
+					squashfs_dir_inode_header sinode;
+					memcpy(&sinode, cur_ptr, sizeof(dir_inode));
+					SQUASHFS_SWAP_DIR_INODE_HEADER(&dir_inode, &sinode);
+				} else
+					memcpy(&dir_inode, cur_ptr, sizeof(dir_inode));
+				if(dir_inode.start_block < directory_start_block)
+					*uncompressed_directory += dir_inode.file_size;
+				(*dir_count) ++;
+				cur_ptr += sizeof(squashfs_dir_inode_header);
+				break;
+			}
+			case SQUASHFS_LDIR_TYPE: {
+				squashfs_ldir_inode_header dir_inode;
+				int i;
+
+				if(swap) {
+					squashfs_ldir_inode_header sinode;
+					memcpy(&sinode, cur_ptr, sizeof(dir_inode));
+					SQUASHFS_SWAP_LDIR_INODE_HEADER(&dir_inode, &sinode);
+				} else
+					memcpy(&dir_inode, cur_ptr, sizeof(dir_inode));
+				if(dir_inode.start_block < directory_start_block)
+					*uncompressed_directory += dir_inode.file_size;
+				(*dir_count) ++;
+				cur_ptr += sizeof(squashfs_ldir_inode_header);
+				for(i = 0; i < dir_inode.i_count; i++) {
+					squashfs_dir_index index;
+					if(swap) {
+						squashfs_dir_index sindex;
+						memcpy(&sindex, cur_ptr, sizeof(squashfs_dir_index));
+						SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+					} else
+						memcpy(&index, cur_ptr, sizeof(squashfs_dir_index));
+					cur_ptr += sizeof(squashfs_dir_index) + index.size + 1;
+				}
+				break;
+			}
+		 	case SQUASHFS_BLKDEV_TYPE:
+		 	case SQUASHFS_CHRDEV_TYPE:
+				(*dev_count) ++;
+				cur_ptr += sizeof(squashfs_dev_inode_header);
+				break;
+
+			case SQUASHFS_FIFO_TYPE:
+				(*fifo_count) ++;
+				cur_ptr += sizeof(squashfs_ipc_inode_header);
+				break;
+			case SQUASHFS_SOCKET_TYPE:
+				(*sock_count) ++;
+				cur_ptr += sizeof(squashfs_ipc_inode_header);
+				break;
+		 	default:
+				ERROR("Unknown inode type %d in scan_inode_table!\n", inode.inode_type);
+				goto failed;
+		}
+	}
+	
+	return files;
+
+
+failed:
+	free(*inode_table);
+	return FALSE;
+}
+
+
+int read_super(int fd, squashfs_super_block *sBlk, int *be, char *source)
+{
+	read_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block), (char *) sBlk);
+
+	/* Check it is a SQUASHFS superblock */
+	swap = 0;
+	if(sBlk->s_magic != SQUASHFS_MAGIC) {
+		if(sBlk->s_magic == SQUASHFS_MAGIC_SWAP) {
+			squashfs_super_block sblk;
+			ERROR("Reading a different endian SQUASHFS filesystem on %s - ignoring -le/-be options\n", source);
+			SQUASHFS_SWAP_SUPER_BLOCK(&sblk, sBlk);
+			memcpy(sBlk, &sblk, sizeof(squashfs_super_block));
+			swap = 1;
+		} else  {
+			ERROR("Can't find a SQUASHFS superblock on %s\n", source);
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(sBlk->s_major != SQUASHFS_MAJOR || sBlk->s_minor > SQUASHFS_MINOR) {
+		if(sBlk->s_major < 3)
+			ERROR("Filesystem on %s is a SQUASHFS %d.%d filesystem.  Appending\nto SQUASHFS %d.%d filesystems is not supported.  Please convert it to a SQUASHFS 3 filesystem\n", source, sBlk->s_major, sBlk->s_minor, sBlk->s_major, sBlk->s_minor);
+		else
+			ERROR("Filesystem on %s is %d.%d, which is a later filesystem version than I support\n",
+				source, sBlk->s_major, sBlk->s_minor);
+		goto failed_mount;
+	}
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	*be = !swap;
+#else
+	*be = swap;
+#endif
+
+	printf("Found a valid %s%s SQUASHFS superblock on %s.\n", SQUASHFS_EXPORTABLE(sBlk->flags) ? "exportable " : "", *be ? "big endian" : "little endian", source);
+	printf("\tInodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sBlk->flags) ? "un" : "");
+	printf("\tData is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sBlk->flags) ? "un" : "");
+	printf("\tFragments are %scompressed\n", SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk->flags) ? "un" : "");
+	printf("\tCheck data is %spresent in the filesystem\n", SQUASHFS_CHECK_DATA(sBlk->flags) ? "" : "not ");
+	printf("\tFragments are %spresent in the filesystem\n", SQUASHFS_NO_FRAGMENTS(sBlk->flags) ? "not " : "");
+	printf("\tAlways_use_fragments option is %sspecified\n", SQUASHFS_ALWAYS_FRAGMENTS(sBlk->flags) ? "" : "not ");
+	printf("\tDuplicates are %sremoved\n", SQUASHFS_DUPLICATES(sBlk->flags) ? "" : "not ");
+	printf("\tFilesystem size %.2f Kbytes (%.2f Mbytes)\n", sBlk->bytes_used / 1024.0, sBlk->bytes_used / (1024.0 * 1024.0));
+	printf("\tBlock size %d\n", sBlk->block_size);
+	printf("\tNumber of fragments %d\n", sBlk->fragments);
+	printf("\tNumber of inodes %d\n", sBlk->inodes);
+	printf("\tNumber of uids %d\n", sBlk->no_uids);
+	printf("\tNumber of gids %d\n", sBlk->no_guids);
+	TRACE("sBlk->inode_table_start %llx\n", sBlk->inode_table_start);
+	TRACE("sBlk->directory_table_start %llx\n", sBlk->directory_table_start);
+	TRACE("sBlk->uid_start %llx\n", sBlk->uid_start);
+	TRACE("sBlk->fragment_table_start %llx\n", sBlk->fragment_table_start);
+	TRACE("sBlk->lookup_table_start %llx\n", sBlk->lookup_table_start);
+	printf("\n");
+
+	return TRUE;
+
+failed_mount:
+	return FALSE;
+}
+
+
+unsigned char *squashfs_readdir(int fd, int root_entries, unsigned int directory_start_block, int offset, int size,
+		unsigned int *last_directory_block, squashfs_super_block *sBlk, void (push_directory_entry)(char *, squashfs_inode, int, int))
+{
+	squashfs_dir_header dirh;
+	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1];
+	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+	unsigned char *directory_table = NULL;
+	int byte, bytes = 0, dir_count;
+	long long start = sBlk->directory_table_start + directory_start_block, last_start_block = start; 
+
+	size += offset;
+	if((directory_table = malloc((size + SQUASHFS_METADATA_SIZE * 2 - 1) & ~(SQUASHFS_METADATA_SIZE - 1))) == NULL)
+		return NULL;
+	while(bytes < size) {
+		TRACE("squashfs_readdir: reading block 0x%llx, bytes read so far %d\n", start, bytes);
+		last_start_block = start;
+		if((byte = read_block(fd, start, &start, directory_table + bytes, sBlk)) == 0) {
+			free(directory_table);
+			return NULL;
+		}
+		bytes += byte;
+	}
+
+	if(!root_entries)
+		goto all_done;
+
+	bytes = offset;
+ 	while(bytes < size) {			
+		if(swap) {
+			squashfs_dir_header sdirh;
+			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else
+			memcpy(&dirh, directory_table + bytes, sizeof(dirh));
+
+		dir_count = dirh.count + 1;
+		TRACE("squashfs_readdir: Read directory header @ byte position 0x%x, 0x%x directory entries\n", bytes, dir_count);
+		bytes += sizeof(dirh);
+
+		while(dir_count--) {
+			if(swap) {
+				squashfs_dir_entry sdire;
+				memcpy(&sdire, directory_table + bytes, sizeof(sdire));
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else
+				memcpy(dire, directory_table + bytes, sizeof(*dire));
+			bytes += sizeof(*dire);
+
+			memcpy(dire->name, directory_table + bytes, dire->size + 1);
+			dire->name[dire->size + 1] = '\0';
+			TRACE("squashfs_readdir: pushing directory entry %s, inode %x:%x, type 0x%x\n", dire->name, dirh.start_block, dire->offset, dire->type);
+			push_directory_entry(dire->name, SQUASHFS_MKINODE(dirh.start_block, dire->offset), dirh.inode_number + dire->inode_number, dire->type);
+			bytes += dire->size + 1;
+		}
+	}
+
+all_done:
+	*last_directory_block = (unsigned int) last_start_block - sBlk->directory_table_start;
+	return directory_table;
+}
+
+
+int read_fragment_table(int fd, squashfs_super_block *sBlk, squashfs_fragment_entry **fragment_table)
+{
+	int i, indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk->fragments);
+	squashfs_fragment_index fragment_table_index[indexes];
+
+	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes from 0x%llx\n", sBlk->fragments, indexes, sBlk->fragment_table_start);
+	if(sBlk->fragments == 0)
+		return 1;
+
+	if((*fragment_table = (squashfs_fragment_entry *) malloc(sBlk->fragments * sizeof(squashfs_fragment_entry))) == NULL) {
+		ERROR("Failed to allocate fragment table\n");
+		return 0;
+	}
+
+	if(swap) {
+		squashfs_fragment_index sfragment_table_index[indexes];
+
+		read_bytes(fd, sBlk->fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments), (char *) sfragment_table_index);
+		SQUASHFS_SWAP_FRAGMENT_INDEXES(fragment_table_index, sfragment_table_index, indexes);
+	} else
+		read_bytes(fd, sBlk->fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments), (char *) fragment_table_index);
+
+	for(i = 0; i < indexes; i++) {
+		int length = read_block(fd, fragment_table_index[i], NULL, ((unsigned char *) *fragment_table) + (i * SQUASHFS_METADATA_SIZE), sBlk);
+		TRACE("Read fragment table block %d, from 0x%llx, length %d\n", i, fragment_table_index[i], length);
+	}
+
+	if(swap) {
+		squashfs_fragment_entry sfragment;
+		for(i = 0; i < sBlk->fragments; i++) {
+			SQUASHFS_SWAP_FRAGMENT_ENTRY((&sfragment), (&(*fragment_table)[i]));
+			memcpy((char *) &(*fragment_table)[i], (char *) &sfragment, sizeof(squashfs_fragment_entry));
+		}
+	}
+
+	return 1;
+}
+
+
+int read_inode_lookup_table(int fd, squashfs_super_block *sBlk, squashfs_inode **inode_lookup_table)
+{
+	int lookup_bytes = SQUASHFS_LOOKUP_BYTES(sBlk->inodes);
+	int indexes = SQUASHFS_LOOKUP_BLOCKS(sBlk->inodes);
+	long long index[indexes];
+	int i;
+
+	if(sBlk->lookup_table_start == SQUASHFS_INVALID_BLK)
+		return 1;
+
+	if((*inode_lookup_table = malloc(lookup_bytes)) == NULL) {
+		ERROR("Failed to allocate inode lookup table\n");
+		return 0;
+	}
+
+	if(swap) {
+		long long sindex[indexes];
+
+		read_bytes(fd, sBlk->lookup_table_start, SQUASHFS_LOOKUP_BLOCK_BYTES(sBlk->inodes), (char *) sindex);
+		SQUASHFS_SWAP_FRAGMENT_INDEXES(index, sindex, indexes);
+	} else
+		read_bytes(fd, sBlk->lookup_table_start, SQUASHFS_LOOKUP_BLOCK_BYTES(sBlk->inodes), (char *) index);
+
+	for(i = 0; i <  indexes; i++) {
+		int length = read_block(fd, index[i], NULL, ((unsigned char *) *inode_lookup_table) + (i * SQUASHFS_METADATA_SIZE), sBlk);
+		TRACE("Read inode lookup table block %d, from 0x%llx, length %d\n", i, index[i], length);
+	}
+
+	if(swap) {
+		squashfs_inode_t sinode;
+		for(i = 0; i < sBlk->inodes; i++) {
+			SQUASHFS_SWAP_INODE_T((&sinode), (&(*inode_lookup_table)[i]));
+			memcpy((char *) &(*inode_lookup_table)[i], (char *) &sinode, sizeof(squashfs_inode_t));
+		}
+	}
+
+	return 1;
+}
+
+
+long long read_filesystem(char *root_name, int fd, squashfs_super_block *sBlk, char **cinode_table,
+		char **data_cache, char **cdirectory_table, char **directory_data_cache,
+		unsigned int *last_directory_block, unsigned int *inode_dir_offset, unsigned int *inode_dir_file_size,
+		unsigned int *root_inode_size, unsigned int *inode_dir_start_block, int *file_count, int *sym_count,
+		int *dev_count, int *dir_count, int *fifo_count, int *sock_count, squashfs_uid *uids,
+		unsigned short *uid_count, squashfs_uid *guids, unsigned short *guid_count,
+		long long *uncompressed_file, unsigned int *uncompressed_inode, unsigned int *uncompressed_directory,
+		unsigned int *inode_dir_inode_number, unsigned int *inode_dir_parent_inode,
+		void (push_directory_entry)(char *, squashfs_inode, int, int), squashfs_fragment_entry **fragment_table,
+		squashfs_inode **inode_lookup_table)
+{
+	unsigned char *inode_table = NULL, *directory_table;
+	long long start = sBlk->inode_table_start, end = sBlk->directory_table_start, root_inode_start = start +
+		SQUASHFS_INODE_BLK(sBlk->root_inode);
+	unsigned int root_inode_offset = SQUASHFS_INODE_OFFSET(sBlk->root_inode), root_inode_block, files;
+	squashfs_inode_header inode;
+
+	printf("Scanning existing filesystem...\n");
+
+	if(read_fragment_table(fd, sBlk, fragment_table) == 0)
+		goto error;
+
+	if(read_inode_lookup_table(fd, sBlk, inode_lookup_table) == 0)
+		goto error;
+
+	if((files = scan_inode_table(fd, start, end, root_inode_start, root_inode_offset, sBlk, &inode, &inode_table,
+			&root_inode_block, root_inode_size, uncompressed_file, uncompressed_directory, file_count, sym_count,
+			dev_count, dir_count, fifo_count, sock_count)) == 0) {
+		ERROR("read_filesystem: inode table read failed\n");
+		goto error;
+	}
+
+	*uncompressed_inode = root_inode_block;
+
+	printf("Read existing filesystem, %d inodes scanned\n", files);
+
+	if(inode.base.inode_type == SQUASHFS_DIR_TYPE || inode.base.inode_type == SQUASHFS_LDIR_TYPE) {
+		if(inode.base.inode_type == SQUASHFS_DIR_TYPE) {
+			*inode_dir_start_block = inode.dir.start_block;
+			*inode_dir_offset = inode.dir.offset;
+			*inode_dir_file_size = inode.dir.file_size - 3;
+			*inode_dir_inode_number = inode.dir.inode_number;
+			*inode_dir_parent_inode = inode.dir.parent_inode;
+		} else {
+			*inode_dir_start_block = inode.ldir.start_block;
+			*inode_dir_offset = inode.ldir.offset;
+			*inode_dir_file_size = inode.ldir.file_size - 3;
+			*inode_dir_inode_number = inode.ldir.inode_number;
+			*inode_dir_parent_inode = inode.ldir.parent_inode;
+		}
+
+		if((directory_table = squashfs_readdir(fd, !root_name, *inode_dir_start_block, *inode_dir_offset,
+				*inode_dir_file_size, last_directory_block, sBlk, push_directory_entry)) == NULL) {
+			ERROR("read_filesystem: Could not read root directory\n");
+			goto error;
+		}
+
+		root_inode_start -= start;
+		if((*cinode_table = (char *) malloc(root_inode_start)) == NULL) {
+			ERROR("read_filesystem: failed to alloc space for existing filesystem inode table\n");
+			goto error;
+		}
+	       	read_bytes(fd, start, root_inode_start, *cinode_table);
+
+		if((*cdirectory_table = (char *) malloc(*last_directory_block)) == NULL) {
+			ERROR("read_filesystem: failed to alloc space for existing filesystem directory table\n");
+			goto error;
+		}
+		read_bytes(fd, sBlk->directory_table_start, *last_directory_block, *cdirectory_table);
+
+		if((*data_cache = (char *) malloc(root_inode_offset + *root_inode_size)) == NULL) {
+			ERROR("read_filesystem: failed to alloc inode cache\n");
+			goto error;
+		}
+		memcpy(*data_cache, inode_table + root_inode_block, root_inode_offset + *root_inode_size);
+
+		if((*directory_data_cache = (char *) malloc(*inode_dir_offset + *inode_dir_file_size)) == NULL) {
+			ERROR("read_filesystem: failed to alloc directory cache\n");
+			goto error;
+		}
+		memcpy(*directory_data_cache, directory_table, *inode_dir_offset + *inode_dir_file_size);
+
+		if(!swap)
+			read_bytes(fd, sBlk->uid_start, sBlk->no_uids * sizeof(squashfs_uid), (char *) uids);
+		else {
+			squashfs_uid uids_copy[sBlk->no_uids];
+
+			read_bytes(fd, sBlk->uid_start, sBlk->no_uids * sizeof(squashfs_uid), (char *) uids_copy);
+			SQUASHFS_SWAP_DATA(uids, uids_copy, sBlk->no_uids, sizeof(squashfs_uid) * 8);
+		}
+
+		if(!swap)
+			read_bytes(fd, sBlk->guid_start, sBlk->no_guids * sizeof(squashfs_uid), (char *) guids);
+		else {
+			squashfs_uid guids_copy[sBlk->no_guids];
+
+			read_bytes(fd, sBlk->guid_start, sBlk->no_guids * sizeof(squashfs_uid), (char *) guids_copy);
+			SQUASHFS_SWAP_DATA(guids, guids_copy, sBlk->no_guids, sizeof(squashfs_uid) * 8);
+		}
+		*uid_count = sBlk->no_uids;
+		*guid_count = sBlk->no_guids;
+
+		free(inode_table);
+		free(directory_table);
+		return sBlk->inode_table_start;
+	}
+
+error:
+	return 0;
+}
diff -BurpN linux-2.6.22.orig/scripts/squashfs/read_fs.h linux-2.6.22/scripts/squashfs/read_fs.h
--- linux-2.6.22.orig/scripts/squashfs/read_fs.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/read_fs.h	2008-08-20 04:46:21.000000000 +0000
@@ -0,0 +1,49 @@
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating a filesystem on a
+ * machine with different byte ordering to the target architecture.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * mksquashfs.h
+ *
+ */
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing architectures
+ */
+#if __BYTE_ORDER == __BIG_ENDIAN
+	/* convert from big endian to little endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, b_pos)
+#else
+	/* convert from little endian to big endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	int bits;\
+	int b_pos = pos % 8;\
+	unsigned long long val = 0;\
+	unsigned char *s = (unsigned char *)p + (pos / 8);\
+	unsigned char *d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
diff -BurpN linux-2.6.22.orig/scripts/squashfs/sort.c linux-2.6.22/scripts/squashfs/sort.c
--- linux-2.6.22.orig/scripts/squashfs/sort.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/sort.c	2008-08-20 04:46:33.000000000 +0000
@@ -0,0 +1,248 @@
+/*
+ * Create a squashfs filesystem.  This is a highly compressed read only filesystem.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * sort.c
+ */
+
+#define TRUE 1
+#define FALSE 0
+
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <squashfs_fs.h>
+#include "global.h"
+#include "sort.h"
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)		do { \
+						printf("mksquashfs: "s, ## args); \
+					} while(0)
+#else
+#define TRACE(s, args...)
+#endif
+
+#define INFO(s, args...)		do { \
+						if(!silent) printf("mksquashfs: "s, ## args); \
+					} while(0)
+#define ERROR(s, args...)		do { \
+						fprintf(stderr, s, ## args); \
+					} while(0)
+#define EXIT_MKSQUASHFS()		do { \
+						exit(1); \
+					} while(0)
+#define BAD_ERROR(s, args...)		do {\
+						fprintf(stderr, "FATAL ERROR:" s, ##args);\
+						EXIT_MKSQUASHFS();\
+					} while(0);
+
+int mkisofs_style = -1;
+
+struct sort_info {
+	dev_t			st_dev;
+	ino_t			st_ino;
+	int			priority;
+	struct sort_info	*next;
+};
+
+struct sort_info *sort_info_list[65536];
+
+struct priority_entry *priority_list[65536];
+
+extern int silent;
+extern void write_file(squashfs_inode *inode, struct dir_ent *dir_ent, int *c_size);
+
+
+int add_priority_list(struct dir_ent *dir, int priority)
+{
+	struct priority_entry *new_priority_entry;
+
+	priority += 32768;
+	if((new_priority_entry = malloc(sizeof(struct priority_entry))) == NULL) {
+		ERROR("Out of memory allocating priority entry\n");
+		return FALSE;
+	}
+
+	new_priority_entry->dir = dir;;
+	new_priority_entry->next = priority_list[priority];
+	priority_list[priority] = new_priority_entry;
+	return TRUE;
+}
+
+
+int get_priority(char *filename, struct stat *buf, int priority)
+{
+	int hash = buf->st_ino & 0xffff;
+	struct sort_info *s;
+
+	for(s = sort_info_list[hash]; s; s = s->next)
+		if((s->st_dev == buf->st_dev) && (s->st_ino == buf->st_ino)) {
+			TRACE("returning priority %d (%s)\n", s->priority, filename);
+			return s->priority;
+		}
+	TRACE("returning priority %d (%s)\n", priority, filename);
+	return priority;
+}
+
+
+#define ADD_ENTRY(buf, priority) {\
+	int hash = buf.st_ino & 0xffff;\
+	struct sort_info *s;\
+	if((s = malloc(sizeof(struct sort_info))) == NULL) {\
+		ERROR("Out of memory allocating sort list entry\n");\
+		return FALSE;\
+	}\
+	s->st_dev = buf.st_dev;\
+	s->st_ino = buf.st_ino;\
+	s->priority = priority;\
+	s->next = sort_info_list[hash];\
+	sort_info_list[hash] = s;\
+	}
+int add_sort_list(char *path, int priority, int source, char *source_path[])
+{
+	int i, n;
+	char filename[4096];
+	struct stat buf;
+
+	TRACE("add_sort_list: filename %s, priority %d\n", path, priority);
+	if(strlen(path) > 1 && strcmp(path + strlen(path) - 2, "/*") == 0)
+		path[strlen(path) - 2] = '\0';
+
+	TRACE("add_sort_list: filename %s, priority %d\n", path, priority);
+re_read:
+	if(path[0] == '/' || strncmp(path, "./", 2) == 0 || strncmp(path, "../", 3) == 0 || mkisofs_style == 1) {
+		if(lstat(path, &buf) == -1)
+			goto error;
+		TRACE("adding filename %s, priority %d, st_dev %llx, st_ino %llx\n", path, priority, buf.st_dev, buf.st_ino);
+		ADD_ENTRY(buf, priority);
+		return TRUE;
+	}
+
+	for(i = 0, n = 0; i < source; i++) {
+		strcat(strcat(strcpy(filename, source_path[i]), "/"), path);
+		if(lstat(filename, &buf) == -1) {
+			if(!(errno == ENOENT || errno == ENOTDIR))
+				goto error;
+			continue;
+		}
+		ADD_ENTRY(buf, priority);
+		n ++;
+	}
+
+	if(n == 0 && mkisofs_style == -1 && lstat(path, &buf) != -1) {
+		ERROR("WARNING: Mkisofs style sortlist detected! This is supported but please\n");
+		ERROR("convert to mksquashfs style sortlist! A sortlist entry ");
+	        ERROR("should be\neither absolute (starting with ");
+		ERROR("'/') start with './' or '../' (taken to be\nrelative to $PWD), otherwise it ");
+		ERROR("is assumed the entry is relative to one\nof the source directories, i.e. with ");
+		ERROR("\"mksquashfs test test.sqsh\",\nthe sortlist ");
+		ERROR("entry \"file\" is assumed to be inside the directory test.\n\n");
+		mkisofs_style = 1;
+		goto re_read;
+	}
+
+	mkisofs_style = 0;
+
+	if(n == 1)
+		return TRUE;
+	if(n > 1)
+		BAD_ERROR(" Ambiguous sortlist entry \"%s\"\n\nIt maps to more than one source entry!  Please use an absolute path.\n", path);
+
+error:
+        fprintf(stderr, "Cannot stat sortlist entry \"%s\"\n", path);
+        fprintf(stderr, "This is probably because you're using the wrong file\n");
+        fprintf(stderr, "path relative to the source directories\n");
+        return FALSE;
+}
+
+
+void generate_file_priorities(struct dir_info *dir, int priority, struct stat *buf)
+{
+	priority = get_priority(dir->pathname, buf, priority);
+
+	while(dir->current_count < dir->count) {
+		struct dir_ent *dir_ent = dir->list[dir->current_count++];
+		struct stat *buf = &dir_ent->inode->buf;
+		if(dir_ent->data)
+			continue;
+
+		switch(buf->st_mode & S_IFMT) {
+			case S_IFREG:
+				add_priority_list(dir_ent, get_priority(dir_ent->pathname, buf, priority));
+				break;
+			case S_IFDIR:
+				generate_file_priorities(dir_ent->dir, priority, buf);
+				break;
+		}
+	}
+	dir->current_count = 0;
+}
+
+
+int read_sort_file(char *filename, int source, char *source_path[])
+{
+	FILE *fd;
+	char sort_filename[16385];
+	int priority;
+
+	if((fd = fopen(filename, "r")) == NULL) {
+		perror("Could not open sort_list file...");
+		return FALSE;
+	}
+	while(fscanf(fd, "%s %d", sort_filename, &priority) != EOF)
+		if(priority >= -32768 && priority <= 32767)
+			add_sort_list(sort_filename, priority, source, source_path);
+		else
+			ERROR("Sort file %s, priority %d outside range of -32767:32768 - skipping...\n", sort_filename, priority);
+	fclose(fd);
+	return TRUE;
+}
+
+
+void sort_files_and_write(struct dir_info *dir)
+{
+	int i;
+	struct priority_entry *entry;
+	squashfs_inode inode;
+	int duplicate_file;
+
+	for(i = 65535; i >= 0; i--)
+		for(entry = priority_list[i]; entry; entry = entry->next) {
+			TRACE("%d: %s\n", i - 32768, entry->dir->pathname);
+			if(entry->dir->inode->inode == SQUASHFS_INVALID_BLK) {
+				write_file(&inode, entry->dir, &duplicate_file);
+				INFO("file %s, uncompressed size %lld bytes %s\n",
+					entry->dir->pathname,
+					entry->dir->inode->buf.st_size,
+					duplicate_file ? "DUPLICATE" : "");
+				entry->dir->inode->inode = inode;
+				entry->dir->inode->type = SQUASHFS_FILE_TYPE;
+			} else
+				INFO("file %s, uncompressed size %lld bytes LINK\n",
+					entry->dir->pathname, entry->dir->inode->buf.st_size);
+		}
+}
diff -BurpN linux-2.6.22.orig/scripts/squashfs/sort.h linux-2.6.22/scripts/squashfs/sort.h
--- linux-2.6.22.orig/scripts/squashfs/sort.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/sort.h	2007-08-19 03:33:25.000000000 +0000
@@ -0,0 +1,62 @@
+#ifndef SORT_H 
+#define SORT_H
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * sort.h
+ */
+
+struct dir_info {
+	char			*pathname;
+	unsigned int		count;
+	unsigned int		directory_count;
+	unsigned int		current_count;
+	unsigned int		byte_count;
+	char			dir_is_ldir;
+	struct dir_ent		*dir_ent;
+	struct dir_ent		**list;
+	DIR			*linuxdir;
+};
+
+struct dir_ent {
+	char			*name;
+	char			*pathname;
+	struct inode_info	*inode;
+	struct dir_info		*dir;
+	struct dir_info		*our_dir;
+	struct old_root_entry_info *data;
+};
+
+struct inode_info {
+	unsigned int		nlink;
+	struct stat		buf;
+	squashfs_inode		inode;
+	unsigned int		type;
+	unsigned int		inode_number;
+	char			read;
+	struct inode_info	*next;
+};
+
+struct priority_entry {
+	struct dir_ent *dir;
+	struct priority_entry *next;
+};
+#endif
diff -BurpN linux-2.6.22.orig/scripts/squashfs/unsquashfs.c linux-2.6.22/scripts/squashfs/unsquashfs.c
--- linux-2.6.22.orig/scripts/squashfs/unsquashfs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22/scripts/squashfs/unsquashfs.c	2008-08-26 07:01:54.000000000 +0000
@@ -0,0 +1,2719 @@
+/*
+ * Unsquash a squashfs filesystem.  This is a highly compressed read only filesystem.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * unsquash.c
+ */
+
+#define CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+#define TRUE 1
+#define FALSE 0
+#include <stdio.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <zlib.h>
+#include <sys/mman.h>
+#include <utime.h>
+#include <pwd.h>
+#include <grp.h>
+#include <time.h>
+#include <regex.h>
+#include <fnmatch.h>
+#include <signal.h>
+#include <pthread.h>
+#include <math.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+
+#ifndef linux
+#define __BYTE_ORDER BYTE_ORDER
+#define __BIG_ENDIAN BIG_ENDIAN
+#define __LITTLE_ENDIAN LITTLE_ENDIAN
+#else
+#include <endian.h>
+#endif
+
+#include "squashfs_fs.h"
+#include "read_fs.h"
+#include "global.h"
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)		do { \
+						pthread_mutex_lock(&screen_mutex); \
+						if(progress_enabled) \
+							printf("\n"); \
+						printf("unsquashfs: "s, ## args); \
+						pthread_mutex_unlock(&screen_mutex);\
+					} while(0)
+#else
+#define TRACE(s, args...)
+#endif
+
+#define ERROR(s, args...)		do { \
+						pthread_mutex_lock(&screen_mutex); \
+						if(progress_enabled) \
+							fprintf(stderr, "\n"); \
+						fprintf(stderr, s, ## args); \
+						pthread_mutex_unlock(&screen_mutex);\
+					} while(0)
+
+#define EXIT_UNSQUASH(s, args...)	do { \
+						pthread_mutex_lock(&screen_mutex); \
+						fprintf(stderr, "FATAL ERROR aborting: "s, ## args); \
+						pthread_mutex_unlock(&screen_mutex);\
+						exit(1); \
+					} while(0)
+
+#define CALCULATE_HASH(start)	(start & 0xffff)
+
+struct hash_table_entry {
+	int	start;
+	int	bytes;
+	struct hash_table_entry *next;
+};
+
+struct inode {
+	int blocks;
+	char *block_ptr;
+	long long data;
+	int fragment;
+	int frag_bytes;
+	gid_t gid;
+	int inode_number;
+	int mode;
+	int offset;
+	long long start;
+	char symlink[65536];
+	time_t time;
+	int type;
+	uid_t uid;
+};
+
+typedef struct squashfs_operations {
+	struct dir *(*squashfs_opendir)(unsigned int block_start, unsigned int offset, struct inode **i);
+	void (*read_fragment)(unsigned int fragment, long long *start_block, int *size);
+	void (*read_fragment_table)();
+	void (*read_block_list)(unsigned int *block_list, char *block_ptr, int blocks);
+	struct inode *(*read_inode)(unsigned int start_block, unsigned int offset);
+} squashfs_operations;
+
+struct test {
+	int mask;
+	int value;
+	int position;
+	char mode;
+};
+
+
+/* Cache status struct.  Caches are used to keep
+  track of memory buffers passed between different threads */
+struct cache {
+	int	max_buffers;
+	int	count;
+	int	buffer_size;
+	int	wait_free;
+	int	wait_pending;
+	pthread_mutex_t	mutex;
+	pthread_cond_t wait_for_free;
+	pthread_cond_t wait_for_pending;
+	struct cache_entry *free_list;
+	struct cache_entry *hash_table[65536];
+};
+
+/* struct describing a cache entry passed between threads */
+struct cache_entry {
+	struct cache *cache;
+	long long block;
+	int	size;
+	int	used;
+	int error;
+	int	pending;
+	struct cache_entry *hash_next;
+	struct cache_entry *hash_prev;
+	struct cache_entry *free_next;
+	struct cache_entry *free_prev;
+	char *data;
+};
+
+/* struct describing queues used to pass data between threads */
+struct queue {
+	int	size;
+	int	readp;
+	int	writep;
+	pthread_mutex_t	mutex;
+	pthread_cond_t empty;
+	pthread_cond_t full;
+	void **data;
+};
+
+struct cache *fragment_cache, *data_cache;
+struct queue *to_reader, *to_deflate, *to_writer, *from_writer;
+pthread_t *thread, *deflator_thread;
+pthread_mutex_t	fragment_mutex;
+
+/* user options that control parallelisation */
+int processors = -1;
+/* default size of fragment buffer in Mbytes */
+#define FRAGMENT_BUFFER_DEFAULT 256
+/* default size of data buffer in Mbytes */
+#define DATA_BUFFER_DEFAULT 256
+
+squashfs_super_block sBlk;
+squashfs_operations s_ops;
+
+int bytes = 0, swap, file_count = 0, dir_count = 0, sym_count = 0,
+	dev_count = 0, fifo_count = 0;
+char *inode_table = NULL, *directory_table = NULL;
+struct hash_table_entry *inode_table_hash[65536], *directory_table_hash[65536];
+int fd;
+squashfs_fragment_entry *fragment_table;
+squashfs_fragment_entry_2 *fragment_table_2;
+unsigned int *uid_table, *guid_table;
+unsigned int cached_frag = SQUASHFS_INVALID_FRAG;
+char *fragment_data;
+char *file_data;
+char *data;
+unsigned int block_size;
+unsigned int block_log;
+int lsonly = FALSE, info = FALSE, force = FALSE, short_ls = TRUE, use_regex = FALSE;
+char **created_inode;
+int root_process;
+int columns;
+int rotate = 0;
+pthread_mutex_t	screen_mutex;
+pthread_cond_t progress_wait;
+int progress = TRUE, progress_enabled = FALSE;
+unsigned int total_blocks = 0, total_files = 0, total_inodes = 0;
+unsigned int cur_blocks = 0;
+
+int lookup_type[] = {
+	0,
+	S_IFDIR,
+	S_IFREG,
+	S_IFLNK,
+	S_IFBLK,
+	S_IFCHR,
+	S_IFIFO,
+	S_IFSOCK,
+	S_IFDIR,
+	S_IFREG
+};
+
+struct test table[] = {
+	{ S_IFMT, S_IFSOCK, 0, 's' },
+	{ S_IFMT, S_IFLNK, 0, 'l' },
+	{ S_IFMT, S_IFBLK, 0, 'b' },
+	{ S_IFMT, S_IFDIR, 0, 'd' },
+	{ S_IFMT, S_IFCHR, 0, 'c' },
+	{ S_IFMT, S_IFIFO, 0, 'p' },
+	{ S_IRUSR, S_IRUSR, 1, 'r' },
+	{ S_IWUSR, S_IWUSR, 2, 'w' },
+	{ S_IRGRP, S_IRGRP, 4, 'r' },
+	{ S_IWGRP, S_IWGRP, 5, 'w' },
+	{ S_IROTH, S_IROTH, 7, 'r' },
+	{ S_IWOTH, S_IWOTH, 8, 'w' },
+	{ S_IXUSR | S_ISUID, S_IXUSR | S_ISUID, 3, 's' },
+	{ S_IXUSR | S_ISUID, S_ISUID, 3, 'S' },
+	{ S_IXUSR | S_ISUID, S_IXUSR, 3, 'x' },
+	{ S_IXGRP | S_ISGID, S_IXGRP | S_ISGID, 6, 's' },
+	{ S_IXGRP | S_ISGID, S_ISGID, 6, 'S' },
+	{ S_IXGRP | S_ISGID, S_IXGRP, 6, 'x' },
+	{ S_IXOTH | S_ISVTX, S_IXOTH | S_ISVTX, 9, 't' },
+	{ S_IXOTH | S_ISVTX, S_ISVTX, 9, 'T' },
+	{ S_IXOTH | S_ISVTX, S_IXOTH, 9, 'x' },
+	{ 0, 0, 0, 0}
+};
+
+void progress_bar(long long current, long long max, int columns);
+void update_progress_bar();
+
+void sigwinch_handler()
+{
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		ERROR("TIOCGWINSZ ioctl failed, defaulting to 80 columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+}
+
+
+void sigalrm_handler()
+{
+	rotate = (rotate + 1) % 4;
+}
+
+
+struct queue *queue_init(int size)
+{
+	struct queue *queue = malloc(sizeof(struct queue));
+
+	if(queue == NULL)
+		return NULL;
+
+	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL) {
+		free(queue);
+		return NULL;
+	}
+
+	queue->size = size + 1;
+	queue->readp = queue->writep = 0;
+	pthread_mutex_init(&queue->mutex, NULL);
+	pthread_cond_init(&queue->empty, NULL);
+	pthread_cond_init(&queue->full, NULL);
+
+	return queue;
+}
+
+
+void queue_put(struct queue *queue, void *data)
+{
+	int nextp;
+
+	pthread_mutex_lock(&queue->mutex);
+
+	while((nextp = (queue->writep + 1) % queue->size) == queue->readp)
+		pthread_cond_wait(&queue->full, &queue->mutex);
+
+	queue->data[queue->writep] = data;
+	queue->writep = nextp;
+	pthread_cond_signal(&queue->empty);
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+
+void *queue_get(struct queue *queue)
+{
+	void *data;
+	pthread_mutex_lock(&queue->mutex);
+
+	while(queue->readp == queue->writep)
+		pthread_cond_wait(&queue->empty, &queue->mutex);
+
+	data = queue->data[queue->readp];
+	queue->readp = (queue->readp + 1) % queue->size;
+	pthread_cond_signal(&queue->full);
+	pthread_mutex_unlock(&queue->mutex);
+
+	return data;
+}
+
+
+/* Called with the cache mutex held */
+void insert_hash_table(struct cache *cache, struct cache_entry *entry)
+{
+	int hash = CALCULATE_HASH(entry->block);
+
+	entry->hash_next = cache->hash_table[hash];
+	cache->hash_table[hash] = entry;
+	entry->hash_prev = NULL;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry;
+}
+
+
+/* Called with the cache mutex held */
+void remove_hash_table(struct cache *cache, struct cache_entry *entry)
+{
+	if(entry->hash_prev)
+		entry->hash_prev->hash_next = entry->hash_next;
+	else
+		cache->hash_table[CALCULATE_HASH(entry->block)] = entry->hash_next;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry->hash_prev;
+
+	entry->hash_prev = entry->hash_next = NULL;
+}
+
+
+/* Called with the cache mutex held */
+void insert_free_list(struct cache *cache, struct cache_entry *entry)
+{
+	if(cache->free_list) {
+		entry->free_next = cache->free_list;
+		entry->free_prev = cache->free_list->free_prev;
+		cache->free_list->free_prev->free_next = entry;
+		cache->free_list->free_prev = entry;
+	} else {
+		cache->free_list = entry;
+		entry->free_prev = entry->free_next = entry;
+	}
+}
+
+
+/* Called with the cache mutex held */
+void remove_free_list(struct cache *cache, struct cache_entry *entry)
+{
+	if(entry->free_prev == NULL && entry->free_next == NULL)
+		/* not in free list */
+		return;
+	else if(entry->free_prev == entry && entry->free_next == entry) {
+		/* only this entry in the free list */
+		cache->free_list = NULL;
+	} else {
+		/* more than one entry in the free list */
+		entry->free_next->free_prev = entry->free_prev;
+		entry->free_prev->free_next = entry->free_next;
+		if(cache->free_list == entry)
+			cache->free_list = entry->free_next;
+	}
+
+	entry->free_prev = entry->free_next = NULL;
+}
+
+
+struct cache *cache_init(int buffer_size, int max_buffers)
+{
+	struct cache *cache = malloc(sizeof(struct cache));
+
+	if(cache == NULL)
+		return NULL;
+
+	cache->max_buffers = max_buffers;
+	cache->buffer_size = buffer_size;
+	cache->count = 0;
+	cache->free_list = NULL;
+	memset(cache->hash_table, 0, sizeof(struct cache_entry *) * 65536);
+	cache->wait_free = FALSE;
+	cache->wait_pending = FALSE;
+	pthread_mutex_init(&cache->mutex, NULL);
+	pthread_cond_init(&cache->wait_for_free, NULL);
+	pthread_cond_init(&cache->wait_for_pending, NULL);
+
+	return cache;
+}
+
+
+struct cache_entry *cache_get(struct cache *cache, long long block, int size)
+{
+	/* Get a block out of the cache.  If the block isn't in the cache
+ 	 * it is added and queued to the reader() and deflate() threads for reading
+ 	 * off disk and decompression.  The cache grows until max_blocks is reached,
+ 	 * once this occurs existing discarded blocks on the free list are reused */
+	int hash = CALCULATE_HASH(block);
+	struct cache_entry *entry;
+
+	pthread_mutex_lock(&cache->mutex);
+
+	for(entry = cache->hash_table[hash]; entry; entry = entry->hash_next)
+		if(entry->block == block)
+			break;
+
+	if(entry) {
+		/* found the block in the cache, increment used count and
+ 		 * if necessary remove from free list so it won't disappear
+ 		 */
+		entry->used ++;
+		remove_free_list(cache, entry);
+		pthread_mutex_unlock(&cache->mutex);
+	} else {
+		/* not in the cache */
+		
+		/* first try to allocate new block */
+		if(cache->count < cache->max_buffers) {
+			entry = malloc(sizeof(struct cache_entry));
+			if(entry == NULL)
+				goto failed;
+			entry->data = malloc(cache->buffer_size);
+			if(entry->data == NULL) {
+				free(entry);
+				goto failed;
+			}
+			entry->cache = cache;
+			entry->free_prev = entry->free_next = NULL;
+			cache->count ++;
+		} else {
+			/* try to get from free list */
+			while(cache->free_list == NULL) {
+				cache->wait_free = TRUE;
+				pthread_cond_wait(&cache->wait_for_free, &cache->mutex);
+			}
+			entry = cache->free_list;
+			remove_free_list(cache, entry);
+			remove_hash_table(cache, entry);
+		}
+
+		/* initialise block and insert into the hash table */
+		entry->block = block;
+		entry->size = size;
+		entry->used = 1;
+		entry->error = FALSE;
+		entry->pending = TRUE;
+		insert_hash_table(cache, entry);
+
+		/* queue to read thread to read and ultimately (via the decompress
+ 		 * threads) decompress the buffer
+ 		 */
+		pthread_mutex_unlock(&cache->mutex);
+		queue_put(to_reader, entry);
+	}
+
+	return entry;
+
+failed:
+	pthread_mutex_unlock(&cache->mutex);
+	return NULL;
+}
+
+	
+void cache_block_ready(struct cache_entry *entry, int error)
+{
+	/* mark cache entry as being complete, reading and (if necessary)
+ 	 * decompression has taken place, and the buffer is valid for use.
+ 	 * If an error occurs reading or decompressing, the buffer also 
+ 	 * becomes ready but with an error... */
+	pthread_mutex_lock(&entry->cache->mutex);
+	entry->pending = FALSE;
+	entry->error = error;
+
+	/* if the wait_pending flag is set, one or more threads may be waiting on
+ 	 * this buffer */
+	if(entry->cache->wait_pending) {
+		entry->cache->wait_pending = FALSE;
+		pthread_cond_broadcast(&entry->cache->wait_for_pending);
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+void cache_block_wait(struct cache_entry *entry)
+{
+	/* wait for this cache entry to become ready, when reading and (if necessary)
+ 	 * decompression has taken place */
+	pthread_mutex_lock(&entry->cache->mutex);
+
+	while(entry->pending) {
+		entry->cache->wait_pending = TRUE;
+		pthread_cond_wait(&entry->cache->wait_for_pending, &entry->cache->mutex);
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+void cache_block_put(struct cache_entry *entry)
+{
+	/* finished with this cache entry, once the usage count reaches zero it
+ 	 * can be reused and is put onto the free list.  As it remains accessible
+ 	 * via the hash table it can be found getting a new lease of life before it
+ 	 * is reused. */
+	pthread_mutex_lock(&entry->cache->mutex);
+
+	entry->used --;
+	if(entry->used == 0) {
+		insert_free_list(entry->cache, entry);
+
+		/* if the wait_free flag is set, one or more threads may be waiting on
+ 	 	 * this buffer */
+		if(entry->cache->wait_free) {
+			entry->cache->wait_free = FALSE;
+			pthread_cond_broadcast(&entry->cache->wait_for_free);
+		}
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+char *modestr(char *str, int mode)
+{
+	int i;
+
+	strcpy(str, "----------");
+
+	for(i = 0; table[i].mask != 0; i++) {
+		if((mode & table[i].mask) == table[i].value)
+			str[table[i].position] = table[i].mode;
+	}
+
+	return str;
+}
+
+
+#define TOTALCHARS  25
+int print_filename(char *pathname, struct inode *inode)
+{
+	char str[11], dummy[100], dummy2[100], *userstr, *groupstr;
+	int padchars;
+	struct passwd *user;
+	struct group *group;
+	struct tm *t;
+
+	if(short_ls) {
+		printf("%s\n", pathname);
+		return 1;
+	}
+
+	if((user = getpwuid(inode->uid)) == NULL) {
+		sprintf(dummy, "%d", inode->uid);
+		userstr = dummy;
+	} else
+		userstr = user->pw_name;
+		 
+	if((group = getgrgid(inode->gid)) == NULL) {
+		sprintf(dummy2, "%d", inode->gid);
+		groupstr = dummy2;
+	} else
+		groupstr = group->gr_name;
+
+	printf("%s %s/%s ", modestr(str, inode->mode), userstr, groupstr);
+
+	switch(inode->mode & S_IFMT) {
+		case S_IFREG:
+		case S_IFDIR:
+		case S_IFSOCK:
+		case S_IFIFO:
+		case S_IFLNK:
+			padchars = TOTALCHARS - strlen(userstr) - strlen(groupstr);
+
+			printf("%*lld ", padchars > 0 ? padchars : 0, inode->data);
+			break;
+		case S_IFCHR:
+		case S_IFBLK:
+			padchars = TOTALCHARS - strlen(userstr) - strlen(groupstr) - 7; 
+
+			printf("%*s%3d,%3d ", padchars > 0 ? padchars : 0, " ", (int) inode->data >> 8, (int) inode->data & 0xff);
+			break;
+	}
+
+	t = localtime(&inode->time);
+
+	printf("%d-%02d-%02d %02d:%02d %s", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, pathname);
+	if((inode->mode & S_IFMT) == S_IFLNK)
+		printf(" -> %s", inode->symlink);
+	printf("\n");
+		
+	return 1;
+}
+	
+
+int add_entry(struct hash_table_entry *hash_table[], int start, int bytes)
+{
+	int hash = CALCULATE_HASH(start);
+	struct hash_table_entry *hash_table_entry;
+
+	if((hash_table_entry = malloc(sizeof(struct hash_table_entry))) == NULL) {
+		ERROR("add_hash: out of memory in malloc\n");
+		return FALSE;
+	}
+
+	hash_table_entry->start = start;
+	hash_table_entry->bytes = bytes;
+	hash_table_entry->next = hash_table[hash];
+	hash_table[hash] = hash_table_entry;
+
+	return TRUE;
+}
+
+
+int lookup_entry(struct hash_table_entry *hash_table[], int start)
+{
+	int hash = CALCULATE_HASH(start);
+	struct hash_table_entry *hash_table_entry;
+
+	for(hash_table_entry = hash_table[hash]; hash_table_entry;
+				hash_table_entry = hash_table_entry->next)
+		if(hash_table_entry->start == start)
+			return hash_table_entry->bytes;
+
+	return -1;
+}
+
+
+int read_bytes(long long byte, int bytes, char *buff)
+{
+	off_t off = byte;
+
+	TRACE("read_bytes: reading from position 0x%llx, bytes %d\n", byte, bytes);
+
+	if(lseek(fd, off, SEEK_SET) == -1) {
+		ERROR("Lseek failed because %s\n", strerror(errno));
+		return FALSE;
+	}
+
+	if(read(fd, buff, bytes) == -1) {
+		ERROR("Read on destination failed because %s\n", strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+int read_block(long long start, long long *next, char *block)
+{
+	unsigned short c_byte;
+	int offset = 2;
+	
+	if(swap) {
+		if(read_bytes(start, 2, block) == FALSE)
+			goto failed;
+		((unsigned char *) &c_byte)[1] = block[0];
+		((unsigned char *) &c_byte)[0] = block[1]; 
+	} else 
+		if(read_bytes(start, 2, (char *)&c_byte) == FALSE)
+			goto failed;
+
+	TRACE("read_block: block @0x%llx, %d %s bytes\n", start, SQUASHFS_COMPRESSED_SIZE(c_byte), SQUASHFS_COMPRESSED(c_byte) ? "compressed" : "uncompressed");
+
+	if(SQUASHFS_CHECK_DATA(sBlk.flags))
+		offset = 3;
+	if(SQUASHFS_COMPRESSED(c_byte)) {
+		char buffer[SQUASHFS_METADATA_SIZE];
+		int res;
+		unsigned long bytes = SQUASHFS_METADATA_SIZE;
+
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+		if(read_bytes(start + offset, c_byte, buffer) == FALSE)
+			goto failed;
+
+		res = uncompress((unsigned char *) block, &bytes, (const unsigned char *) buffer, c_byte);
+
+		if(res != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				ERROR("zlib::uncompress failed, not enough memory\n");
+			else if(res == Z_BUF_ERROR)
+				ERROR("zlib::uncompress failed, not enough room in output buffer\n");
+			else
+				ERROR("zlib::uncompress failed, unknown error %d\n", res);
+			goto failed;
+		}
+		if(next)
+			*next = start + offset + c_byte;
+		return bytes;
+	} else {
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+		if(read_bytes(start + offset, c_byte, block) == FALSE)
+			goto failed;
+		if(next)
+			*next = start + offset + c_byte;
+		return c_byte;
+	}
+
+failed:
+	return FALSE;
+}
+
+
+int read_data_block(long long start, unsigned int size, char *block)
+{
+	int res;
+	unsigned long bytes = block_size;
+	int c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(size);
+
+	TRACE("read_data_block: block @0x%llx, %d %s bytes\n", start, SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte), SQUASHFS_COMPRESSED_BLOCK(c_byte) ? "compressed" : "uncompressed");
+
+	if(SQUASHFS_COMPRESSED_BLOCK(size)) {
+		if(read_bytes(start, c_byte, data) == FALSE)
+			return 0;
+
+		res = uncompress((unsigned char *) block, &bytes, (const unsigned char *) data, c_byte);
+
+		if(res != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				ERROR("zlib::uncompress failed, not enough memory\n");
+			else if(res == Z_BUF_ERROR)
+				ERROR("zlib::uncompress failed, not enough room in output buffer\n");
+			else
+				ERROR("zlib::uncompress failed, unknown error %d\n", res);
+			return 0;
+		}
+
+		return bytes;
+	} else {
+		if(read_bytes(start, c_byte, block) == FALSE)
+			return 0;
+
+		return c_byte;
+	}
+}
+
+
+void read_block_list(unsigned int *block_list, char *block_ptr, int blocks)
+{
+	if(swap) {
+		unsigned int sblock_list[blocks];
+		memcpy(sblock_list, block_ptr, blocks * sizeof(unsigned int));
+		SQUASHFS_SWAP_INTS(block_list, sblock_list, blocks);
+	} else
+		memcpy(block_list, block_ptr, blocks * sizeof(unsigned int));
+}
+
+
+void read_block_list_1(unsigned int *block_list, char *block_ptr, int blocks)
+{
+	unsigned short block_size;
+	int i;
+
+	for(i = 0; i < blocks; i++, block_ptr += 2) {
+		if(swap) {
+			unsigned short sblock_size;
+			memcpy(&sblock_size, block_ptr, sizeof(unsigned short));
+			SQUASHFS_SWAP_SHORTS((&block_size), &sblock_size, 1);
+		} else
+			memcpy(&block_size, block_ptr, sizeof(unsigned short));
+		block_list[i] = SQUASHFS_COMPRESSED_SIZE(block_size) | (SQUASHFS_COMPRESSED(block_size) ? 0 : SQUASHFS_COMPRESSED_BIT_BLOCK);
+	}
+}
+
+
+void uncompress_inode_table(long long start, long long end)
+{
+	int size = 0, bytes = 0, res;
+
+	while(start < end) {
+		if((size - bytes < SQUASHFS_METADATA_SIZE) &&
+				((inode_table = realloc(inode_table, size +=
+				SQUASHFS_METADATA_SIZE)) == NULL))
+			EXIT_UNSQUASH("uncompress_inode_table: out of memory in realloc\n");
+		TRACE("uncompress_inode_table: reading block 0x%llx\n", start);
+		add_entry(inode_table_hash, start, bytes);
+		if((res = read_block(start, &start, inode_table + bytes)) == 0) {
+			free(inode_table);
+			EXIT_UNSQUASH("uncompress_inode_table: failed to read block\n");
+		}
+		bytes += res;
+	}
+}
+
+
+int set_attributes(char *pathname, int mode, uid_t uid, gid_t guid, time_t time, unsigned int set_mode)
+{
+	struct utimbuf times = { time, time };
+
+	if(utime(pathname, &times) == -1) {
+		ERROR("set_attributes: failed to set time on %s, because %s\n", pathname, strerror(errno));
+		return FALSE;
+	}
+
+	if(root_process) {
+		if(chown(pathname, uid, guid) == -1) {
+			ERROR("set_attributes: failed to change uid and gids on %s, because %s\n", pathname, strerror(errno));
+			return FALSE;
+		}
+	} else
+		mode &= ~07000;
+
+	if((set_mode || (mode & 07000)) && chmod(pathname, (mode_t) mode) == -1) {
+		ERROR("set_attributes: failed to change mode %s, because %s\n", pathname, strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+void read_uids_guids()
+{
+	if((uid_table = malloc((sBlk.no_uids + sBlk.no_guids) * sizeof(unsigned int))) == NULL)
+		EXIT_UNSQUASH("read_uids_guids: failed to allocate uid/gid table\n");
+
+	guid_table = uid_table + sBlk.no_uids;
+
+	if(swap) {
+		unsigned int suid_table[sBlk.no_uids + sBlk.no_guids];
+
+		if(read_bytes(sBlk.uid_start, (sBlk.no_uids + sBlk.no_guids)
+				* sizeof(unsigned int), (char *) suid_table) ==
+				FALSE)
+			EXIT_UNSQUASH("read_uids_guids: failed to read uid/gid table\n");
+		SQUASHFS_SWAP_INTS(uid_table, suid_table, sBlk.no_uids + sBlk.no_guids);
+	} else
+		if(read_bytes(sBlk.uid_start, (sBlk.no_uids + sBlk.no_guids)
+				* sizeof(unsigned int), (char *) uid_table) ==
+				FALSE)
+			EXIT_UNSQUASH("read_uids_guids: failed to read uid/gid table\n");
+}
+
+
+void read_fragment_table()
+{
+	int i, indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.fragments);
+	squashfs_fragment_index fragment_table_index[indexes];
+
+	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes from 0x%llx\n", sBlk.fragments, indexes, sBlk.fragment_table_start);
+
+	if(sBlk.fragments == 0)
+		return;
+
+	if((fragment_table = (squashfs_fragment_entry *)
+			malloc(sBlk.fragments *
+			sizeof(squashfs_fragment_entry))) == NULL)
+		EXIT_UNSQUASH("read_fragment_table: failed to allocate fragment table\n");
+
+	if(swap) {
+		squashfs_fragment_index sfragment_table_index[indexes];
+
+		read_bytes(sBlk.fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.fragments), (char *) sfragment_table_index);
+		SQUASHFS_SWAP_FRAGMENT_INDEXES(fragment_table_index, sfragment_table_index, indexes);
+	} else
+		read_bytes(sBlk.fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.fragments), (char *) fragment_table_index);
+
+	for(i = 0; i < indexes; i++) {
+		int length = read_block(fragment_table_index[i], NULL,
+		((char *) fragment_table) + (i * SQUASHFS_METADATA_SIZE));
+		TRACE("Read fragment table block %d, from 0x%llx, length %d\n", i, fragment_table_index[i], length);
+	}
+
+	if(swap) {
+		squashfs_fragment_entry sfragment;
+		for(i = 0; i < sBlk.fragments; i++) {
+			SQUASHFS_SWAP_FRAGMENT_ENTRY((&sfragment), (&fragment_table[i]));
+			memcpy((char *) &fragment_table[i], (char *) &sfragment, sizeof(squashfs_fragment_entry));
+		}
+	}
+}
+
+
+void read_fragment_table_2()
+{
+	int i, indexes = SQUASHFS_FRAGMENT_INDEXES_2(sBlk.fragments);
+	unsigned int fragment_table_index[indexes];
+
+	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes from 0x%llx\n", sBlk.fragments, indexes, sBlk.fragment_table_start);
+
+	if(sBlk.fragments == 0)
+		return;
+
+	if((fragment_table_2 = (squashfs_fragment_entry_2 *)
+			malloc(sBlk.fragments *
+			sizeof(squashfs_fragment_entry))) == NULL)
+		EXIT_UNSQUASH("read_fragment_table: failed to allocate fragment table\n");
+
+	if(swap) {
+		 unsigned int sfragment_table_index[indexes];
+
+		read_bytes(sBlk.fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sBlk.fragments), (char *) sfragment_table_index);
+		SQUASHFS_SWAP_FRAGMENT_INDEXES_2(fragment_table_index, sfragment_table_index, indexes);
+	} else
+		read_bytes(sBlk.fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sBlk.fragments), (char *) fragment_table_index);
+
+	for(i = 0; i < indexes; i++) {
+		int length = read_block(fragment_table_index[i], NULL,
+		((char *) fragment_table_2) + (i * SQUASHFS_METADATA_SIZE));
+		TRACE("Read fragment table block %d, from 0x%x, length %d\n", i, fragment_table_index[i], length);
+	}
+
+	if(swap) {
+		squashfs_fragment_entry_2 sfragment;
+		for(i = 0; i < sBlk.fragments; i++) {
+			SQUASHFS_SWAP_FRAGMENT_ENTRY_2((&sfragment), (&fragment_table_2[i]));
+			memcpy((char *) &fragment_table_2[i], (char *) &sfragment, sizeof(squashfs_fragment_entry_2));
+		}
+	}
+}
+
+
+void read_fragment_table_1()
+{
+}
+
+
+void read_fragment(unsigned int fragment, long long *start_block, int *size)
+{
+	TRACE("read_fragment: reading fragment %d\n", fragment);
+
+	squashfs_fragment_entry *fragment_entry = &fragment_table[fragment];
+	*start_block = fragment_entry->start_block;
+	*size = fragment_entry->size;
+}
+
+
+void read_fragment_2(unsigned int fragment, long long *start_block, int *size)
+{
+	TRACE("read_fragment: reading fragment %d\n", fragment);
+
+	squashfs_fragment_entry_2 *fragment_entry = &fragment_table_2[fragment];
+	*start_block = fragment_entry->start_block;
+	*size = fragment_entry->size;
+}
+
+
+int lseek_broken = FALSE;
+char *zero_data;
+
+int write_block(int file_fd, char *buffer, int size, int hole)
+{
+	off_t off = hole;
+
+	if(hole) {
+		if(lseek_broken == FALSE && lseek(file_fd, off, SEEK_CUR) == -1) {
+			/* failed to seek beyond end of file */
+			if((zero_data = malloc(block_size)) == NULL)
+				EXIT_UNSQUASH("write_block: failed to alloc zero data block\n");
+			memset(zero_data, 0, block_size);
+			lseek_broken = TRUE;
+		}
+		if(lseek_broken) {
+			int blocks = (hole + block_size -1) / block_size;
+			int avail_bytes, i;
+			for(i = 0; i < blocks; i++, hole -= avail_bytes) {
+				avail_bytes = hole > block_size ? block_size : hole;
+				if(write(file_fd, zero_data, avail_bytes) < avail_bytes)
+					goto failure;
+			}
+		}
+	}
+
+	if(write(file_fd, buffer, size) < size)
+		goto failure;
+
+	return TRUE;
+
+failure:
+	return FALSE;
+}
+
+
+struct file_entry {
+	int offset;
+	int size;
+	struct cache_entry *buffer;
+};
+
+
+struct squashfs_file {
+	int fd;
+	int blocks;
+	long long file_size;
+	int mode;
+	uid_t uid;
+	gid_t gid;
+	time_t time;
+	char *pathname;
+};
+
+
+int write_file(struct inode *inode, char *pathname)
+{
+	unsigned int file_fd, i;
+	unsigned int *block_list;
+	int file_end = inode->data / block_size;
+	long long start = inode->start;
+	struct squashfs_file *file;
+
+	TRACE("write_file: regular file, blocks %d\n", inode->blocks);
+
+	if((file_fd = open(pathname, O_CREAT | O_WRONLY | (force ? O_TRUNC : 0), (mode_t) inode->mode & 0777)) == -1) {
+		ERROR("write_file: failed to create file %s, because %s\n", pathname,
+			strerror(errno));
+		return FALSE;
+	}
+
+	if((block_list = malloc(inode->blocks * sizeof(unsigned int))) == NULL)
+		EXIT_UNSQUASH("write_file: unable to malloc block list\n");
+
+	s_ops.read_block_list(block_list, inode->block_ptr, inode->blocks);
+
+	if((file = malloc(sizeof(struct squashfs_file))) == NULL)
+		EXIT_UNSQUASH("write_file: unable to malloc file\n");
+
+	/* the writer thread is queued a squashfs_file structure describing the
+ 	 * file.  If the file has one or more blocks or a fragments they are queued
+ 	 * separately (references to blocks in the cache). */
+	file->fd = file_fd;
+	file->file_size = inode->data;
+	file->mode = inode->mode;
+	file->gid = inode->gid;
+	file->uid = inode->uid;
+	file->time = inode->time;
+	file->pathname = strdup(pathname);
+	file->blocks = inode->blocks + (inode->frag_bytes > 0);
+	queue_put(to_writer, file);
+
+	for(i = 0; i < inode->blocks; i++) {
+		int c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(block_list[i]);
+		struct file_entry *block = malloc(sizeof(struct file_entry *));
+
+		if(block == NULL)
+			EXIT_UNSQUASH("write_file: unable to malloc file\n");
+		block->offset = 0;
+		block->size = i == file_end ? inode->data & (block_size - 1) : block_size;
+		if(block_list[i] == 0) /* sparse file */
+			block->buffer = NULL;
+		else {
+			block->buffer = cache_get(data_cache, start, block_list[i]);
+			if(block->buffer == NULL)
+				EXIT_UNSQUASH("write_file: cache_get failed\n");
+			start += c_byte;
+		}
+		queue_put(to_writer, block);
+	}
+
+	if(inode->frag_bytes) {
+		int size;
+		long long start;
+		struct file_entry *block = malloc(sizeof(struct file_entry *));
+
+		if(block == NULL)
+			EXIT_UNSQUASH("write_file: unable to malloc file\n");
+		s_ops.read_fragment(inode->fragment, &start, &size);
+		block->buffer = cache_get(fragment_cache, start, size);
+		if(block->buffer == NULL)
+			EXIT_UNSQUASH("write_file: cache_get failed\n");
+		block->offset = inode->offset;
+		block->size = inode->frag_bytes;
+		queue_put(to_writer, block);
+	}
+
+	free(block_list);
+	return TRUE;
+}
+
+
+static struct inode *read_inode(unsigned int start_block, unsigned int offset)
+{
+	static squashfs_inode_header header;
+	long long start = sBlk.inode_table_start + start_block;
+	int bytes = lookup_entry(inode_table_hash, start);
+	char *block_ptr = inode_table + bytes + offset;
+	static struct inode i;
+
+	if(bytes == -1)
+		goto error;
+
+	if(swap) {
+		squashfs_base_inode_header sinode;
+		memcpy(&sinode, block_ptr, sizeof(header.base));
+		SQUASHFS_SWAP_BASE_INODE_HEADER(&header.base, &sinode, sizeof(squashfs_base_inode_header));
+	} else
+		memcpy(&header.base, block_ptr, sizeof(header.base));
+
+	i.uid = (uid_t) uid_table[header.base.uid];
+	i.gid = header.base.guid == SQUASHFS_GUIDS ? i.uid : (uid_t) guid_table[header.base.guid];
+	i.mode = lookup_type[header.base.inode_type] | header.base.mode;
+	i.type = header.base.inode_type;
+	i.time = header.base.mtime;
+	i.inode_number = header.base.inode_number;
+
+	switch(header.base.inode_type) {
+		case SQUASHFS_DIR_TYPE: {
+			squashfs_dir_inode_header *inode = &header.dir;
+
+			if(swap) {
+				squashfs_dir_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(header.dir));
+				SQUASHFS_SWAP_DIR_INODE_HEADER(&header.dir, &sinode);
+			} else
+				memcpy(&header.dir, block_ptr, sizeof(header.dir));
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			squashfs_ldir_inode_header *inode = &header.ldir;
+
+			if(swap) {
+				squashfs_ldir_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(header.ldir));
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(&header.ldir, &sinode);
+			} else
+				memcpy(&header.ldir, block_ptr, sizeof(header.ldir));
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			break;
+		}
+		case SQUASHFS_FILE_TYPE: {
+			squashfs_reg_inode_header *inode = &header.reg;
+
+			if(swap) {
+				squashfs_reg_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(sinode));
+				SQUASHFS_SWAP_REG_INODE_HEADER(inode, &sinode);
+			} else
+				memcpy(inode, block_ptr, sizeof(*inode));
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				0 : inode->file_size % sBlk.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(inode->file_size + sBlk.block_size - 1) >>
+				sBlk.block_log : inode->file_size >> sBlk.block_log;
+			i.start = inode->start_block;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			break;
+		}	
+		case SQUASHFS_LREG_TYPE: {
+			squashfs_lreg_inode_header *inode = &header.lreg;
+
+			if(swap) {
+				squashfs_lreg_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(sinode));
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inode, &sinode);
+			} else
+				memcpy(inode, block_ptr, sizeof(*inode));
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				0 : inode->file_size % sBlk.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(inode->file_size + sBlk.block_size - 1) >>
+				sBlk.block_log : inode->file_size >> sBlk.block_log;
+			i.start = inode->start_block;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			break;
+		}	
+		case SQUASHFS_SYMLINK_TYPE: {
+			squashfs_symlink_inode_header *inodep = &header.symlink;
+
+			if(swap) {
+				squashfs_symlink_inode_header sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			strncpy(i.symlink, block_ptr + sizeof(squashfs_symlink_inode_header), inodep->symlink_size);
+			i.symlink[inodep->symlink_size] = '\0';
+			i.data = inodep->symlink_size;
+			break;
+		}
+ 		case SQUASHFS_BLKDEV_TYPE:
+	 	case SQUASHFS_CHRDEV_TYPE: {
+			squashfs_dev_inode_header *inodep = &header.dev;
+
+			if(swap) {
+				squashfs_dev_inode_header sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			i.data = inodep->rdev;
+			break;
+			}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_SOCKET_TYPE:
+			i.data = 0;
+			break;
+		default:
+			ERROR("Unknown inode type %d in read_inode!\n", header.base.inode_type);
+			return NULL;
+	}
+	return &i;
+
+error:
+	return NULL;
+}
+
+
+int create_inode(char *pathname, struct inode *i)
+{
+	TRACE("create_inode: pathname %s\n", pathname);
+
+	if(created_inode[i->inode_number - 1]) {
+		TRACE("create_inode: hard link\n");
+		if(force)
+			unlink(pathname);
+
+		if(link(created_inode[i->inode_number - 1], pathname) == -1) {
+			ERROR("create_inode: failed to create hardlink, because %s\n", strerror(errno));
+			return FALSE;
+		}
+
+		return TRUE;
+	}
+
+	switch(i->type) {
+		case SQUASHFS_FILE_TYPE:
+		case SQUASHFS_LREG_TYPE:
+			TRACE("create_inode: regular file, file_size %lld, blocks %d\n", i->data, i->blocks);
+
+			if(write_file(i, pathname))
+				file_count ++;
+			break;
+		case SQUASHFS_SYMLINK_TYPE:
+			TRACE("create_inode: symlink, symlink_size %lld\n", i->data);
+
+			if(force)
+				unlink(pathname);
+
+			if(symlink(i->symlink, pathname) == -1) {
+				ERROR("create_inode: failed to create symlink %s, because %s\n", pathname,
+					strerror(errno));
+				break;
+			}
+
+			if(root_process) {
+				if(lchown(pathname, i->uid, i->gid) == -1)
+					ERROR("create_inode: failed to change uid and gids on %s, because %s\n", pathname, strerror(errno));
+			}
+
+			sym_count ++;
+			break;
+ 		case SQUASHFS_BLKDEV_TYPE:
+	 	case SQUASHFS_CHRDEV_TYPE: {
+			int chrdev = i->type == SQUASHFS_CHRDEV_TYPE;
+			TRACE("create_inode: dev, rdev 0x%llx\n", i->data);
+
+			if(root_process) {
+				if(force)
+					unlink(pathname);
+
+				if(mknod(pathname, chrdev ? S_IFCHR : S_IFBLK,
+					makedev((i->data >> 8) & 0xff, i->data & 0xff)) == -1) {
+					ERROR("create_inode: failed to create %s device %s, because %s\n",
+						chrdev ? "character" : "block", pathname, strerror(errno));
+					break;
+				}
+				set_attributes(pathname, i->mode, i->uid, i->gid, i->time, TRUE);
+				dev_count ++;
+			} else
+				ERROR("create_inode: could not create %s device %s, because you're not superuser!\n",
+					chrdev ? "character" : "block", pathname);
+			break;
+		}
+		case SQUASHFS_FIFO_TYPE:
+			TRACE("create_inode: fifo\n");
+
+			if(force)
+				unlink(pathname);
+
+			if(mknod(pathname, S_IFIFO, 0) == -1) {
+				ERROR("create_inode: failed to create fifo %s, because %s\n",
+					pathname, strerror(errno));
+				break;
+			}
+			set_attributes(pathname, i->mode, i->uid, i->gid, i->time, TRUE);
+			fifo_count ++;
+			break;
+		case SQUASHFS_SOCKET_TYPE:
+			TRACE("create_inode: socket\n");
+			ERROR("create_inode: socket %s ignored\n", pathname);
+			break;
+		default:
+			ERROR("Unknown inode type %d in create_inode_table!\n", i->type);
+			return FALSE;
+	}
+
+	created_inode[i->inode_number - 1] = strdup(pathname);
+
+	return TRUE;
+}
+
+
+struct inode *read_inode_2(unsigned int start_block, unsigned int offset)
+{
+	static squashfs_inode_header_2 header;
+	long long start = sBlk.inode_table_start + start_block;
+	int bytes = lookup_entry(inode_table_hash, start);
+	char *block_ptr = inode_table + bytes + offset;
+	static struct inode i;
+	static int inode_number = 1;
+
+	if(bytes == -1)
+		goto error;
+
+	if(swap) {
+		squashfs_base_inode_header_2 sinode;
+		memcpy(&sinode, block_ptr, sizeof(header.base));
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(&header.base, &sinode, sizeof(squashfs_base_inode_header_2));
+	} else
+		memcpy(&header.base, block_ptr, sizeof(header.base));
+
+    i.uid = (uid_t) uid_table[header.base.uid];
+    i.gid = header.base.guid == SQUASHFS_GUIDS ? i.uid : (uid_t) guid_table[header.base.guid];
+	i.mode = lookup_type[header.base.inode_type] | header.base.mode;
+	i.type = header.base.inode_type;
+	i.time = sBlk.mkfs_time;
+	i.inode_number = inode_number++;
+
+	switch(header.base.inode_type) {
+		case SQUASHFS_DIR_TYPE: {
+			squashfs_dir_inode_header_2 *inode = &header.dir;
+
+			if(swap) {
+				squashfs_dir_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(header.dir));
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(&header.dir, &sinode);
+			} else
+				memcpy(&header.dir, block_ptr, sizeof(header.dir));
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.time = inode->mtime;
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			squashfs_ldir_inode_header_2 *inode = &header.ldir;
+
+			if(swap) {
+				squashfs_ldir_inode_header sinode;
+				memcpy(&sinode, block_ptr, sizeof(header.ldir));
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(&header.ldir, &sinode);
+			} else
+				memcpy(&header.ldir, block_ptr, sizeof(header.ldir));
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.time = inode->mtime;
+			break;
+		}
+		case SQUASHFS_FILE_TYPE: {
+			squashfs_reg_inode_header_2 *inode = &header.reg;
+
+			if(swap) {
+				squashfs_reg_inode_header_2 sinode;
+				memcpy(&sinode, block_ptr, sizeof(sinode));
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inode, &sinode);
+			} else
+				memcpy(inode, block_ptr, sizeof(*inode));
+
+			i.data = inode->file_size;
+			i.time = inode->mtime;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				0 : inode->file_size % sBlk.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(inode->file_size + sBlk.block_size - 1) >>
+				sBlk.block_log : inode->file_size >> sBlk.block_log;
+			i.start = inode->start_block;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			break;
+		}	
+		case SQUASHFS_SYMLINK_TYPE: {
+			squashfs_symlink_inode_header_2 *inodep = &header.symlink;
+
+			if(swap) {
+				squashfs_symlink_inode_header_2 sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			strncpy(i.symlink, block_ptr + sizeof(squashfs_symlink_inode_header_2), inodep->symlink_size);
+			i.symlink[inodep->symlink_size] = '\0';
+			i.data = inodep->symlink_size;
+			break;
+		}
+ 		case SQUASHFS_BLKDEV_TYPE:
+	 	case SQUASHFS_CHRDEV_TYPE: {
+			squashfs_dev_inode_header_2 *inodep = &header.dev;
+
+			if(swap) {
+				squashfs_dev_inode_header_2 sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			i.data = inodep->rdev;
+			break;
+			}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_SOCKET_TYPE:
+			i.data = 0;
+			break;
+		default:
+			ERROR("Unknown inode type %d in read_inode_header_2!\n", header.base.inode_type);
+			return NULL;
+	}
+	return &i;
+
+error:
+	return NULL;
+}
+
+
+struct inode *read_inode_1(unsigned int start_block, unsigned int offset)
+{
+	static squashfs_inode_header_1 header;
+	long long start = sBlk.inode_table_start + start_block;
+	int bytes = lookup_entry(inode_table_hash, start);
+	char *block_ptr = inode_table + bytes + offset;
+	static struct inode i;
+	static int inode_number = 1;
+
+	if(bytes == -1)
+		goto error;
+
+	if(swap) {
+		squashfs_base_inode_header_1 sinode;
+		memcpy(&sinode, block_ptr, sizeof(header.base));
+		SQUASHFS_SWAP_BASE_INODE_HEADER_1(&header.base, &sinode, sizeof(squashfs_base_inode_header_1));
+	} else
+		memcpy(&header.base, block_ptr, sizeof(header.base));
+
+    i.uid = (uid_t) uid_table[(header.base.inode_type - 1) / SQUASHFS_TYPES * 16 + header.base.uid];
+	if(header.base.inode_type == SQUASHFS_IPC_TYPE) {
+		squashfs_ipc_inode_header_1 *inodep = &header.ipc;
+
+		if(swap) {
+			squashfs_ipc_inode_header_1 sinodep;
+			memcpy(&sinodep, block_ptr, sizeof(sinodep));
+			SQUASHFS_SWAP_IPC_INODE_HEADER_1(inodep, &sinodep);
+		} else
+			memcpy(inodep, block_ptr, sizeof(*inodep));
+
+		if(inodep->type == SQUASHFS_SOCKET_TYPE) {
+			i.mode = S_IFSOCK | header.base.mode;
+			i.type = SQUASHFS_SOCKET_TYPE;
+		} else {
+			i.mode = S_IFIFO | header.base.mode;
+			i.type = SQUASHFS_FIFO_TYPE;
+		}
+		i.uid = (uid_t) uid_table[inodep->offset * 16 + inodep->uid];
+	} else {
+		i.mode = lookup_type[(header.base.inode_type - 1) % SQUASHFS_TYPES + 1] | header.base.mode;
+		i.type = (header.base.inode_type - 1) % SQUASHFS_TYPES + 1;
+	}
+    i.gid = header.base.guid == 15 ? i.uid : (uid_t) guid_table[header.base.guid];
+	i.time = sBlk.mkfs_time;
+	i.inode_number = inode_number ++;
+
+	switch(i.type) {
+		case SQUASHFS_DIR_TYPE: {
+			squashfs_dir_inode_header_1 *inode = &header.dir;
+
+			if(swap) {
+				squashfs_dir_inode_header_1 sinode;
+				memcpy(&sinode, block_ptr, sizeof(header.dir));
+				SQUASHFS_SWAP_DIR_INODE_HEADER_1(inode, &sinode);
+			} else
+			memcpy(inode, block_ptr, sizeof(header.dir));
+
+			i.data = inode->file_size;
+			i.start = inode->start_block;
+			i.time = inode->mtime;
+			break;
+		}
+		case SQUASHFS_FILE_TYPE: {
+			squashfs_reg_inode_header_1 *inode = &header.reg;
+
+			if(swap) {
+				squashfs_reg_inode_header_1 sinode;
+				memcpy(&sinode, block_ptr, sizeof(sinode));
+				SQUASHFS_SWAP_REG_INODE_HEADER_1(inode, &sinode);
+			} else
+				memcpy(inode, block_ptr, sizeof(*inode));
+
+			i.data = inode->file_size;
+			i.time = inode->mtime;
+			i.blocks = (inode->file_size + sBlk.block_size - 1) >>
+				sBlk.block_log;
+			i.start = inode->start_block;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			i.fragment = 0;
+			i.frag_bytes = 0;
+			i.offset = 0;
+			break;
+		}	
+		case SQUASHFS_SYMLINK_TYPE: {
+			squashfs_symlink_inode_header_1 *inodep = &header.symlink;
+
+			if(swap) {
+				squashfs_symlink_inode_header_1 sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			strncpy(i.symlink, block_ptr + sizeof(squashfs_symlink_inode_header_1), inodep->symlink_size);
+			i.symlink[inodep->symlink_size] = '\0';
+			i.data = inodep->symlink_size;
+			break;
+		}
+ 		case SQUASHFS_BLKDEV_TYPE:
+	 	case SQUASHFS_CHRDEV_TYPE: {
+			squashfs_dev_inode_header_1 *inodep = &header.dev;
+
+			if(swap) {
+				squashfs_dev_inode_header_1 sinodep;
+				memcpy(&sinodep, block_ptr, sizeof(sinodep));
+				SQUASHFS_SWAP_DEV_INODE_HEADER_1(inodep, &sinodep);
+			} else
+				memcpy(inodep, block_ptr, sizeof(*inodep));
+
+			i.data = inodep->rdev;
+			break;
+			}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_SOCKET_TYPE: {
+			i.data = 0;
+			break;
+			}
+		default:
+			ERROR("Unknown inode type %d in read_inode_header_1!\n", header.base.inode_type);
+			return NULL;
+	}
+	return &i;
+
+error:
+	return NULL;
+}
+
+
+void uncompress_directory_table(long long start, long long end)
+{
+	int bytes = 0, size = 0, res;
+
+	while(start < end) {
+		if(size - bytes < SQUASHFS_METADATA_SIZE && (directory_table =
+				realloc(directory_table, size +=
+				SQUASHFS_METADATA_SIZE)) == NULL)
+			EXIT_UNSQUASH("uncompress_directory_table: out of memory in realloc\n");
+		TRACE("uncompress_directory_table: reading block 0x%llx\n", start);
+		add_entry(directory_table_hash, start, bytes);
+		if((res = read_block(start, &start, directory_table + bytes)) == 0)
+			EXIT_UNSQUASH("uncompress_directory_table: failed to read block\n");
+		bytes += res;
+	}
+}
+
+
+#define DIR_ENT_SIZE	16
+
+struct dir_ent	{
+	char		name[SQUASHFS_NAME_LEN + 1];
+	unsigned int	start_block;
+	unsigned int	offset;
+	unsigned int	type;
+};
+
+struct dir {
+	int		dir_count;
+	int 		cur_entry;
+	unsigned int	mode;
+	uid_t		uid;
+	gid_t		guid;
+	unsigned int	mtime;
+	struct dir_ent	*dirs;
+};
+
+
+struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i)
+{
+	squashfs_dir_header dirh;
+	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1];
+	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+	long long start;
+	int bytes;
+	int dir_count, size;
+	struct dir_ent *new_dir;
+	struct dir *dir;
+
+	TRACE("squashfs_opendir: inode start block %d, offset %d\n", block_start, offset);
+
+	if((*i = s_ops.read_inode(block_start, offset)) == NULL) {
+		ERROR("squashfs_opendir: failed to read directory inode %d\n", block_start);
+		return NULL;
+	}
+
+	start = sBlk.directory_table_start + (*i)->start;
+	bytes = lookup_entry(directory_table_hash, start);
+
+	if(bytes == -1) {
+		ERROR("squashfs_opendir: directory block %d not found!\n", block_start);
+		return NULL;
+	}
+
+	bytes += (*i)->offset;
+	size = (*i)->data + bytes - 3;
+
+	if((dir = malloc(sizeof(struct dir))) == NULL) {
+		ERROR("squashfs_opendir: malloc failed!\n");
+		return NULL;
+	}
+
+	dir->dir_count = 0;
+	dir->cur_entry = 0;
+	dir->mode = (*i)->mode;
+	dir->uid = (*i)->uid;
+	dir->guid = (*i)->gid;
+	dir->mtime = (*i)->time;
+	dir->dirs = NULL;
+
+	while(bytes < size) {			
+		if(swap) {
+			squashfs_dir_header sdirh;
+			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else
+			memcpy(&dirh, directory_table + bytes, sizeof(dirh));
+	
+		dir_count = dirh.count + 1;
+		TRACE("squashfs_opendir: Read directory header @ byte position %d, %d directory entries\n", bytes, dir_count);
+		bytes += sizeof(dirh);
+
+		while(dir_count--) {
+			if(swap) {
+				squashfs_dir_entry sdire;
+				memcpy(&sdire, directory_table + bytes, sizeof(sdire));
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else
+				memcpy(dire, directory_table + bytes, sizeof(*dire));
+			bytes += sizeof(*dire);
+
+			memcpy(dire->name, directory_table + bytes, dire->size + 1);
+			dire->name[dire->size + 1] = '\0';
+			TRACE("squashfs_opendir: directory entry %s, inode %d:%d, type %d\n", dire->name, dirh.start_block, dire->offset, dire->type);
+			if((dir->dir_count % DIR_ENT_SIZE) == 0) {
+				if((new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent))) == NULL) {
+					ERROR("squashfs_opendir: realloc failed!\n");
+					free(dir->dirs);
+					free(dir);
+					return NULL;
+				}
+				dir->dirs = new_dir;
+			}
+			strcpy(dir->dirs[dir->dir_count].name, dire->name);
+			dir->dirs[dir->dir_count].start_block = dirh.start_block;
+			dir->dirs[dir->dir_count].offset = dire->offset;
+			dir->dirs[dir->dir_count].type = dire->type;
+			dir->dir_count ++;
+			bytes += dire->size + 1;
+		}
+	}
+
+	return dir;
+}
+
+
+struct dir *squashfs_opendir_2(unsigned int block_start, unsigned int offset, struct inode **i)
+{
+	squashfs_dir_header_2 dirh;
+	char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1];
+	squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;
+	long long start;
+	int bytes;
+	int dir_count, size;
+	struct dir_ent *new_dir;
+	struct dir *dir;
+
+	TRACE("squashfs_opendir: inode start block %d, offset %d\n", block_start, offset);
+
+	if(((*i) = s_ops.read_inode(block_start, offset)) == NULL) {
+		ERROR("squashfs_opendir: failed to read directory inode %d\n", block_start);
+		return NULL;
+	}
+
+	start = sBlk.directory_table_start + (*i)->start;
+	bytes = lookup_entry(directory_table_hash, start);
+
+	if(bytes == -1) {
+		ERROR("squashfs_opendir: directory block %d not found!\n", block_start);
+		return NULL;
+	}
+
+	bytes += (*i)->offset;
+	size = (*i)->data + bytes;
+
+	if((dir = malloc(sizeof(struct dir))) == NULL) {
+		ERROR("squashfs_opendir: malloc failed!\n");
+		return NULL;
+	}
+
+	dir->dir_count = 0;
+	dir->cur_entry = 0;
+	dir->mode = (*i)->mode;
+	dir->uid = (*i)->uid;
+	dir->guid = (*i)->gid;
+	dir->mtime = (*i)->time;
+	dir->dirs = NULL;
+
+	while(bytes < size) {			
+		if(swap) {
+			squashfs_dir_header_2 sdirh;
+			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else
+			memcpy(&dirh, directory_table + bytes, sizeof(dirh));
+	
+		dir_count = dirh.count + 1;
+		TRACE("squashfs_opendir: Read directory header @ byte position %d, %d directory entries\n", bytes, dir_count);
+		bytes += sizeof(dirh);
+
+		while(dir_count--) {
+			if(swap) {
+				squashfs_dir_entry_2 sdire;
+				memcpy(&sdire, directory_table + bytes, sizeof(sdire));
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else
+				memcpy(dire, directory_table + bytes, sizeof(*dire));
+			bytes += sizeof(*dire);
+
+			memcpy(dire->name, directory_table + bytes, dire->size + 1);
+			dire->name[dire->size + 1] = '\0';
+			TRACE("squashfs_opendir: directory entry %s, inode %d:%d, type %d\n", dire->name, dirh.start_block, dire->offset, dire->type);
+			if((dir->dir_count % DIR_ENT_SIZE) == 0) {
+				if((new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent))) == NULL) {
+					ERROR("squashfs_opendir: realloc failed!\n");
+					free(dir->dirs);
+					free(dir);
+					return NULL;
+				}
+				dir->dirs = new_dir;
+			}
+			strcpy(dir->dirs[dir->dir_count].name, dire->name);
+			dir->dirs[dir->dir_count].start_block = dirh.start_block;
+			dir->dirs[dir->dir_count].offset = dire->offset;
+			dir->dirs[dir->dir_count].type = dire->type;
+			dir->dir_count ++;
+			bytes += dire->size + 1;
+		}
+	}
+
+	return dir;
+}
+
+
+int squashfs_readdir(struct dir *dir, char **name, unsigned int *start_block,
+unsigned int *offset, unsigned int *type)
+{
+	if(dir->cur_entry == dir->dir_count)
+		return FALSE;
+
+	*name = dir->dirs[dir->cur_entry].name;
+	*start_block = dir->dirs[dir->cur_entry].start_block;
+	*offset = dir->dirs[dir->cur_entry].offset;
+	*type = dir->dirs[dir->cur_entry].type;
+	dir->cur_entry ++;
+
+	return TRUE;
+}
+
+
+void squashfs_closedir(struct dir *dir)
+{
+	free(dir->dirs);
+	free(dir);
+}
+
+
+char *get_component(char *target, char *targname)
+{
+	while(*target == '/')
+		target ++;
+
+	while(*target != '/' && *target!= '\0')
+		*targname ++ = *target ++;
+
+	*targname = '\0';
+
+	return target;
+}
+
+
+struct path_entry {
+	char *name;
+	regex_t *preg;
+	struct pathname *paths;
+};
+
+struct pathname {
+	int names;
+	struct path_entry *name;
+};
+
+struct pathnames {
+	int count;
+	struct pathname *path[0];
+};
+#define PATHS_ALLOC_SIZE 10
+
+void free_path(struct pathname *paths)
+{
+	int i;
+
+	for(i = 0; i < paths->names; i++) {
+		if(paths->name[i].paths)
+			free_path(paths->name[i].paths);
+		free(paths->name[i].name);
+		if(paths->name[i].preg) {
+			regfree(paths->name[i].preg);
+			free(paths->name[i].preg);
+		}
+	}
+
+	free(paths);
+}
+
+
+struct pathname *add_path(struct pathname *paths, char *target, char *alltarget)
+{
+	char targname[1024];
+	int i, error;
+
+	target = get_component(target, targname);
+
+	if(paths == NULL) {
+		if((paths = malloc(sizeof(struct pathname))) == NULL)
+			EXIT_UNSQUASH("failed to allocate paths\n");
+
+		paths->names = 0;
+		paths->name = NULL;
+	}
+
+	for(i = 0; i < paths->names; i++)
+		if(strcmp(paths->name[i].name, targname) == 0)
+			break;
+
+	if(i == paths->names) {
+		/* allocate new name entry */
+		paths->names ++;
+		paths->name = realloc(paths->name, (i + 1) * sizeof(struct path_entry));
+		paths->name[i].name = strdup(targname);
+		paths->name[i].paths = NULL;
+		if(use_regex) {
+			paths->name[i].preg = malloc(sizeof(regex_t));
+			error = regcomp(paths->name[i].preg, targname, REG_EXTENDED|REG_NOSUB);
+			if(error) {
+				char str[1024];
+
+				regerror(error, paths->name[i].preg, str, 1024);
+				EXIT_UNSQUASH("invalid regex %s in export %s, because %s\n", targname, alltarget, str);
+			}
+		} else
+			paths->name[i].preg = NULL;
+
+		if(target[0] == '\0')
+			/* at leaf pathname component */
+			paths->name[i].paths = NULL;
+		else
+			/* recurse adding child components */
+			paths->name[i].paths = add_path(NULL, target, alltarget);
+	} else {
+		/* existing matching entry */
+		if(paths->name[i].paths == NULL) {
+			/* No sub-directory which means this is the leaf component of a
+		   	   pre-existing extract which subsumes the extract currently
+		   	   being added, in which case stop adding components */
+		} else if(target[0] == '\0') {
+			/* at leaf pathname component and child components exist from more
+		       specific extracts, delete as they're subsumed by this extract
+			*/
+			free_path(paths->name[i].paths);
+			paths->name[i].paths = NULL;
+		} else
+			/* recurse adding child components */
+			add_path(paths->name[i].paths, target, alltarget);
+	}
+
+	return paths;
+}
+
+
+struct pathnames *init_subdir()
+{
+	struct pathnames *new = malloc(sizeof(struct pathnames *));
+	new->count = 0;
+	return new;
+}
+
+
+struct pathnames *add_subdir(struct pathnames *paths, struct pathname *path)
+{
+	if(paths->count % PATHS_ALLOC_SIZE == 0)
+		paths = realloc(paths, sizeof(struct pathnames *) + (paths->count + PATHS_ALLOC_SIZE) * sizeof(struct pathname *));
+
+	paths->path[paths->count++] = path;
+	return paths;
+}
+
+
+void free_subdir(struct pathnames *paths)
+{
+	free(paths);
+}
+
+
+int matches(struct pathnames *paths, char *name, struct pathnames **new)
+{
+	int i, n;
+
+	if(paths == NULL) {
+		*new = NULL;
+		return TRUE;
+	}
+
+	*new = init_subdir();
+
+	for(n = 0; n < paths->count; n++) {
+		struct pathname *path = paths->path[n];
+		for(i = 0; i < path->names; i++) {
+			int match = use_regex ?
+				regexec(path->name[i].preg, name, (size_t) 0, NULL, 0) == 0 :
+				fnmatch(path->name[i].name, name, FNM_PATHNAME|FNM_PERIOD|FNM_EXTMATCH) == 0;
+			if(match && path->name[i].paths == NULL)
+				/* match on a leaf component, any subdirectories will
+				 * implicitly match, therefore return an empty new search set */
+				goto empty_set;
+
+			if(match)
+				/* match on a non-leaf component, add any subdirectories to
+				 * the new set of subdirectories to scan for this name */
+				*new = add_subdir(*new, path->name[i].paths);
+		}
+	}
+
+	if((*new)->count == 0) {
+		/* no matching names found, delete empty search set, and return
+        * FALSE */
+		free_subdir(*new);
+		*new = NULL;
+		return FALSE;
+	}
+
+	/* one or more matches with sub-directories found (no leaf matches),
+     * return new search set and return TRUE */
+	return TRUE;
+
+empty_set:
+   /* found matching leaf exclude, return empty search set and return TRUE */
+	free_subdir(*new);
+	*new = NULL;
+	return TRUE;
+}
+
+
+int pre_scan(char *parent_name, unsigned int start_block, unsigned int offset, struct pathnames *paths)
+{
+	unsigned int type;
+	char *name, pathname[1024];
+	struct pathnames *new;
+	struct inode *i;
+	struct dir *dir = s_ops.squashfs_opendir(start_block, offset, &i);
+
+	if(dir == NULL) {
+		ERROR("pre_scan: Failed to read directory %s (%x:%x)\n", parent_name, start_block, offset);
+		return FALSE;
+	}
+
+	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
+		struct inode *i;
+
+		TRACE("pre_scan: name %s, start_block %d, offset %d, type %d\n", name, start_block, offset, type);
+
+		if(!matches(paths, name, &new))
+			continue;
+
+		strcat(strcat(strcpy(pathname, parent_name), "/"), name);
+
+		if(type == SQUASHFS_DIR_TYPE)
+			pre_scan(parent_name, start_block, offset, new);
+		else if(new == NULL) {
+			if(type == SQUASHFS_FILE_TYPE || type == SQUASHFS_LREG_TYPE) {
+				if((i = s_ops.read_inode(start_block, offset)) == NULL) {
+					ERROR("failed to read header\n");
+					continue;
+				}
+				if(created_inode[i->inode_number - 1] == NULL) {
+					created_inode[i->inode_number - 1] = (char *) i;
+					total_blocks += (i->data + (block_size - 1)) >> block_log;
+				}
+				total_files ++;
+			}
+			total_inodes ++;
+		}
+
+		free_subdir(new);
+	}
+
+	squashfs_closedir(dir);
+
+	return TRUE;
+}
+
+
+int dir_scan(char *parent_name, unsigned int start_block, unsigned int offset, struct pathnames *paths)
+{
+	unsigned int type;
+	char *name, pathname[1024];
+	struct pathnames *new;
+	struct inode *i;
+	struct dir *dir = s_ops.squashfs_opendir(start_block, offset, &i);
+
+	if(dir == NULL) {
+		ERROR("dir_scan: Failed to read directory %s (%x:%x)\n", parent_name, start_block, offset);
+		return FALSE;
+	}
+
+	if(lsonly || info)
+		print_filename(parent_name, i);
+
+	if(!lsonly && mkdir(parent_name, (mode_t) dir->mode) == -1 && (!force || errno != EEXIST)) {
+		ERROR("dir_scan: failed to open directory %s, because %s\n", parent_name, strerror(errno));
+		return FALSE;
+	}
+
+	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
+		TRACE("dir_scan: name %s, start_block %d, offset %d, type %d\n", name, start_block, offset, type);
+
+
+		if(!matches(paths, name, &new))
+			continue;
+
+		strcat(strcat(strcpy(pathname, parent_name), "/"), name);
+
+		if(type == SQUASHFS_DIR_TYPE)
+			dir_scan(pathname, start_block, offset, new);
+		else if(new == NULL) {
+			if((i = s_ops.read_inode(start_block, offset)) == NULL) {
+				ERROR("failed to read header\n");
+				continue;
+			}
+
+			if(lsonly || info)
+				print_filename(pathname, i);
+
+			if(!lsonly) {
+				create_inode(pathname, i);
+				update_progress_bar();
+				}
+		}
+
+		free_subdir(new);
+	}
+
+	if(!lsonly)
+		set_attributes(parent_name, dir->mode, dir->uid, dir->guid, dir->mtime, force);
+
+	squashfs_closedir(dir);
+	dir_count ++;
+
+	return TRUE;
+}
+
+
+void squashfs_stat(char *source)
+{
+	time_t mkfs_time = (time_t) sBlk.mkfs_time;
+	char *mkfs_str = ctime(&mkfs_time);
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	printf("Found a valid %s endian SQUASHFS %d:%d superblock on %s.\n", swap ? "little" : "big", sBlk.s_major, sBlk.s_minor, source);
+#else
+	printf("Found a valid %s endian SQUASHFS %d:%d superblock on %s.\n", swap ? "big" : "little", sBlk.s_major, sBlk.s_minor, source);
+#endif
+	printf("Creation or last append time %s", mkfs_str ? mkfs_str : "failed to get time\n");
+	printf("Filesystem is %sexportable via NFS\n", SQUASHFS_EXPORTABLE(sBlk.flags) ? "" : "not ");
+
+	printf("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sBlk.flags) ? "un" : "");
+	printf("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sBlk.flags) ? "un" : "");
+	if(sBlk.s_major > 1 && !SQUASHFS_NO_FRAGMENTS(sBlk.flags))
+		printf("Fragments are %scompressed\n", SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.flags) ? "un" : "");
+	printf("Check data is %spresent in the filesystem\n", SQUASHFS_CHECK_DATA(sBlk.flags) ? "" : "not ");
+	if(sBlk.s_major > 1) {
+		printf("Fragments are %spresent in the filesystem\n", SQUASHFS_NO_FRAGMENTS(sBlk.flags) ? "not " : "");
+		printf("Always_use_fragments option is %sspecified\n", SQUASHFS_ALWAYS_FRAGMENTS(sBlk.flags) ? "" : "not ");
+	} else
+		printf("Fragments are not supported by the filesystem\n");
+
+	if(sBlk.s_major > 1)
+		printf("Duplicates are %sremoved\n", SQUASHFS_DUPLICATES(sBlk.flags) ? "" : "not ");
+	else
+		printf("Duplicates are removed\n");
+	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n", sBlk.bytes_used / 1024.0, sBlk.bytes_used / (1024.0 * 1024.0));
+	printf("Block size %d\n", sBlk.block_size);
+	if(sBlk.s_major > 1)
+		printf("Number of fragments %d\n", sBlk.fragments);
+	printf("Number of inodes %d\n", sBlk.inodes);
+	printf("Number of uids %d\n", sBlk.no_uids);
+	printf("Number of gids %d\n", sBlk.no_guids);
+
+	TRACE("sBlk.inode_table_start 0x%llx\n", sBlk.inode_table_start);
+	TRACE("sBlk.directory_table_start 0x%llx\n", sBlk.directory_table_start);
+	TRACE("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
+	if(sBlk.s_major > 1)
+		TRACE("sBlk.fragment_table_start 0x%llx\n\n", sBlk.fragment_table_start);
+}
+
+
+int read_super(char *source)
+{
+	read_bytes(SQUASHFS_START, sizeof(squashfs_super_block), (char *) &sBlk);
+
+	/* Check it is a SQUASHFS superblock */
+	swap = 0;
+	if(sBlk.s_magic != SQUASHFS_MAGIC) {
+		if(sBlk.s_magic == SQUASHFS_MAGIC_SWAP) {
+			squashfs_super_block sblk;
+			ERROR("Reading a different endian SQUASHFS filesystem on %s\n", source);
+			SQUASHFS_SWAP_SUPER_BLOCK(&sblk, &sBlk);
+			memcpy(&sBlk, &sblk, sizeof(squashfs_super_block));
+			swap = 1;
+		} else  {
+			ERROR("Can't find a SQUASHFS superblock on %s\n", source);
+			goto failed_mount;
+		}
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	if(sBlk.s_major == 1 || sBlk.s_major == 2) {
+		sBlk.bytes_used = sBlk.bytes_used_2;
+		sBlk.uid_start = sBlk.uid_start_2;
+		sBlk.guid_start = sBlk.guid_start_2;
+		sBlk.inode_table_start = sBlk.inode_table_start_2;
+		sBlk.directory_table_start = sBlk.directory_table_start_2;
+		
+		if(sBlk.s_major == 1) {
+			sBlk.block_size = sBlk.block_size_1;
+			sBlk.fragment_table_start = sBlk.uid_start;
+			s_ops.squashfs_opendir = squashfs_opendir_2;
+			s_ops.read_fragment_table = read_fragment_table_1;
+			s_ops.read_block_list = read_block_list_1;
+			s_ops.read_inode = read_inode_1;
+		} else {
+			sBlk.fragment_table_start = sBlk.fragment_table_start_2;
+			s_ops.squashfs_opendir = squashfs_opendir_2;
+			s_ops.read_fragment = read_fragment_2;
+			s_ops.read_fragment_table = read_fragment_table_2;
+			s_ops.read_block_list = read_block_list;
+			s_ops.read_inode = read_inode_2;
+		}
+	} else if(sBlk.s_major == 3 && sBlk.s_minor <= 1) {
+		s_ops.squashfs_opendir = squashfs_opendir;
+		s_ops.read_fragment = read_fragment;
+		s_ops.read_fragment_table = read_fragment_table;
+		s_ops.read_block_list = read_block_list;
+		s_ops.read_inode = read_inode;
+	} else {
+		ERROR("Filesystem on %s is (%d:%d), ", source, sBlk.s_major, sBlk.s_minor);
+		ERROR("which is a later filesystem version than I support!\n");
+		goto failed_mount;
+	}
+
+	return TRUE;
+
+failed_mount:
+	return FALSE;
+}
+
+
+struct pathname *process_extract_files(struct pathname *path, char *filename)
+{
+	FILE *fd;
+	char name[16384];
+
+	if((fd = fopen(filename, "r")) == NULL)
+		EXIT_UNSQUASH("Could not open %s, because %s\n", filename, strerror(errno));
+
+	while(fscanf(fd, "%16384[^\n]\n", name) != EOF)
+		path = add_path(path, name, name);
+
+	fclose(fd);
+	return path;
+}
+		
+
+/* reader thread.  This thread processes read requests queued by the
+ * cache_get() routine. */
+void *reader(void *arg)
+{
+	while(1) {
+		struct cache_entry *entry = queue_get(to_reader);
+		int res = read_bytes(entry->block,
+			SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size),
+			entry->data);
+
+		if(res && SQUASHFS_COMPRESSED_BLOCK(entry->size))
+			/* queue successfully read block to the deflate thread(s)
+ 			 * for further processing */
+			queue_put(to_deflate, entry);
+		else
+			/* block has either been successfully read and is uncompressed,
+ 			 * or an error has occurred, clear pending flag, set
+ 			 * error appropriately, and wake up any threads waiting on
+ 			 * this buffer */
+			cache_block_ready(entry, !res);
+	}
+}
+
+
+/* writer thread.  This processes file write requests queued by the
+ * write_file() routine. */
+void *writer(void *arg)
+{
+	int i;
+
+	while(1) {
+		struct squashfs_file *file = queue_get(to_writer);
+		int file_fd;
+		int hole = 0;
+		int failed = FALSE;
+
+		if(file == NULL) {
+			queue_put(from_writer, NULL);
+			continue;
+		}
+
+		TRACE("writer: regular file, blocks %d\n", file->blocks);
+
+		file_fd = file->fd;
+
+		for(i = 0; i < file->blocks; i++, cur_blocks ++) {
+			struct file_entry *block = queue_get(to_writer);
+
+			if(block->buffer == 0) { /* sparse file */
+				hole += block->size;
+				free(block);
+				continue;
+			}
+
+			cache_block_wait(block->buffer);
+
+			if(block->buffer->error)
+				failed = TRUE;
+
+			if(failed == FALSE && write_block(file_fd, block->buffer->data + block->offset, block->size, hole) == FALSE) {
+				ERROR("writer: failed to write data block %d\n", i);
+				failed = TRUE;
+			}
+			hole = 0;
+			cache_block_put(block->buffer);
+			free(block);
+		}
+
+		if(hole && failed == FALSE) {
+			/* corner case for hole extending to end of file */
+			if(lseek(file_fd, hole, SEEK_CUR) == -1) {
+				/* for broken lseeks which cannot seek beyond end of
+ 			 	* file, write_block will do the right thing */
+				hole --;
+				if(write_block(file_fd, "\0", 1, hole) == FALSE) {
+					ERROR("writer: failed to write sparse data block\n");
+					failed = TRUE;
+				}
+			} else if(ftruncate(file_fd, file->file_size) == -1) {
+				ERROR("writer: failed to write sparse data block\n");
+				failed = TRUE;
+			}
+		}
+
+		close(file_fd);
+		if(failed == FALSE)
+			set_attributes(file->pathname, file->mode, file->uid, file->gid, file->time, force);
+		else {
+			ERROR("Failed to write %s, skipping\n", file->pathname);
+			unlink(file->pathname);
+		}
+		free(file->pathname);
+		free(file);
+
+	}
+}
+
+
+/* decompress thread.  This decompresses buffers queued by the read thread */
+void *deflator(void *arg)
+{
+	char tmp[block_size];
+
+	while(1) {
+		struct cache_entry *entry = queue_get(to_deflate);
+		int res;
+		unsigned long bytes = block_size;
+
+		res = uncompress((unsigned char *) tmp, &bytes, (const unsigned char *) entry->data, SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size));
+
+		if(res != Z_OK) {
+			if(res == Z_MEM_ERROR)
+				ERROR("zlib::uncompress failed, not enough memory\n");
+			else if(res == Z_BUF_ERROR)
+				ERROR("zlib::uncompress failed, not enough room in output buffer\n");
+			else
+				ERROR("zlib::uncompress failed, unknown error %d\n", res);
+		} else
+			memcpy(entry->data, tmp, bytes);
+
+		/* block has been either successfully decompressed, or an error
+ 		 * occurred, clear pending flag, set error appropriately and
+ 		 * wake up any threads waiting on this block */ 
+		cache_block_ready(entry, res != Z_OK);
+	}
+}
+
+
+void *progress_thread(void *arg)
+{
+	struct timeval timeval;
+	struct timespec timespec;
+	struct itimerval itimerval;
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		ERROR("TIOCGWINZ ioctl failed, defaulting to 80 columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+	signal(SIGWINCH, sigwinch_handler);
+	signal(SIGALRM, sigalrm_handler);
+
+	itimerval.it_value.tv_sec = 0;
+	itimerval.it_value.tv_usec = 250000;
+	itimerval.it_interval.tv_sec = 0;
+	itimerval.it_interval.tv_usec = 250000;
+	setitimer(ITIMER_REAL, &itimerval, NULL);
+
+	pthread_cond_init(&progress_wait, NULL);
+
+	pthread_mutex_lock(&screen_mutex);
+	while(1) {
+		gettimeofday(&timeval, NULL);
+		timespec.tv_sec = timeval.tv_sec;
+		if(timeval.tv_usec + 250000 > 999999)
+			timespec.tv_sec++;
+		timespec.tv_nsec = ((timeval.tv_usec + 250000) % 1000000) * 1000;
+		pthread_cond_timedwait(&progress_wait, &screen_mutex, &timespec);
+		if(progress_enabled)
+			progress_bar(sym_count + dev_count +
+				fifo_count + cur_blocks, total_inodes - total_files +
+				total_blocks, columns);
+	}
+}
+
+
+void initialise_threads(int fragment_buffer_size, int data_buffer_size)
+{
+	int i;
+	sigset_t sigmask, old_mask;
+	int all_buffers_size = fragment_buffer_size + data_buffer_size;
+
+	sigemptyset(&sigmask);
+	sigaddset(&sigmask, SIGINT);
+	sigaddset(&sigmask, SIGQUIT);
+	if(sigprocmask(SIG_BLOCK, &sigmask, &old_mask) == -1)
+		EXIT_UNSQUASH("Failed to set signal mask in intialise_threads\n");
+
+	if(processors == -1) {
+#ifndef linux
+		int mib[2];
+		size_t len = sizeof(processors);
+
+		mib[0] = CTL_HW;
+#ifdef HW_AVAILCPU
+		mib[1] = HW_AVAILCPU;
+#else
+		mib[1] = HW_NCPU;
+#endif
+
+		if(sysctl(mib, 2, &processors, &len, NULL, 0) == -1) {
+			ERROR("Failed to get number of available processors.  Defaulting to 1\n");
+			processors = 1;
+		}
+#else
+		processors = get_nprocs();
+#endif
+	}
+
+	if((thread = malloc((3 + processors) * sizeof(pthread_t))) == NULL)
+		EXIT_UNSQUASH("Out of memory allocating thread descriptors\n");
+	deflator_thread = &thread[3];
+
+	to_reader = queue_init(all_buffers_size);
+	to_deflate = queue_init(all_buffers_size);
+	to_writer = queue_init(1000);
+	from_writer = queue_init(1);
+	fragment_cache = cache_init(block_size, fragment_buffer_size);
+	data_cache = cache_init(block_size, data_buffer_size);
+	pthread_create(&thread[0], NULL, reader, NULL);
+	pthread_create(&thread[1], NULL, writer, NULL);
+	pthread_create(&thread[2], NULL, progress_thread, NULL);
+	pthread_mutex_init(&fragment_mutex, NULL);
+
+	for(i = 0; i < processors; i++) {
+		if(pthread_create(&deflator_thread[i], NULL, deflator, NULL) != 0 )
+			EXIT_UNSQUASH("Failed to create thread\n");
+	}
+
+	printf("Parallel unsquashfs: Using %d processor%s\n", processors,
+			processors == 1 ? "" : "s");
+
+	if(sigprocmask(SIG_SETMASK, &old_mask, NULL) == -1)
+		EXIT_UNSQUASH("Failed to set signal mask in intialise_threads\n");
+}
+
+
+void enable_progress_bar()
+{
+	pthread_mutex_lock(&screen_mutex);
+	progress_enabled = TRUE;
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void disable_progress_bar()
+{
+	pthread_mutex_lock(&screen_mutex);
+	progress_enabled = FALSE;
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void update_progress_bar()
+{
+	pthread_mutex_lock(&screen_mutex);
+	pthread_cond_signal(&progress_wait);
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void progress_bar(long long current, long long max, int columns)
+{
+	char rotate_list[] = { '|', '/', '-', '\\' };
+	int max_digits = floor(log10(max)) + 1;
+	int used = max_digits * 2 + 11;
+	int hashes = (current * (columns - used)) / max;
+	int spaces = columns - used - hashes;
+
+	if(current > max) {
+		printf("%lld %lld\n", current, max);
+		return;
+	}
+
+	if(columns - used < 0)
+		return;
+
+	printf("\r[");
+
+	while (hashes --)
+		putchar('=');
+
+	putchar(rotate_list[rotate]);
+
+	while(spaces --)
+		putchar(' ');
+
+	printf("] %*lld/%*lld", max_digits, current, max_digits, max);
+	printf(" %3lld%%", current * 100 / max);
+	fflush(stdout);
+}
+
+
+#define VERSION() \
+	printf("unsquashfs version 3.4 (2008/08/26)\n");\
+	printf("copyright (C) 2008 Phillip Lougher <phillip@lougher.demon.co.uk>\n\n"); \
+    	printf("This program is free software; you can redistribute it and/or\n");\
+	printf("modify it under the terms of the GNU General Public License\n");\
+	printf("as published by the Free Software Foundation; either version 2,\n");\
+	printf("or (at your option) any later version.\n\n");\
+	printf("This program is distributed in the hope that it will be useful,\n");\
+	printf("but WITHOUT ANY WARRANTY; without even the implied warranty of\n");\
+	printf("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n");\
+	printf("GNU General Public License for more details.\n");
+int main(int argc, char *argv[])
+{
+	char *dest = "squashfs-root";
+	int i, stat_sys = FALSE, version = FALSE;
+	int n;
+	struct pathnames *paths = NULL;
+	struct pathname *path = NULL;
+	int fragment_buffer_size = FRAGMENT_BUFFER_DEFAULT;
+	int data_buffer_size = DATA_BUFFER_DEFAULT;
+	char *b;
+	struct winsize winsize;
+
+	pthread_mutex_init(&screen_mutex, NULL);
+	root_process = geteuid() == 0;
+	if(root_process)
+		umask(0);
+	
+	for(i = 1; i < argc; i++) {
+		if(*argv[i] != '-')
+			break;
+		if(strcmp(argv[i], "-version") == 0 || strcmp(argv[i], "-v") == 0) {
+			VERSION();
+			version = TRUE;
+		} else if(strcmp(argv[i], "-info") == 0 || strcmp(argv[i], "-i") == 0)
+			info = TRUE;
+		else if(strcmp(argv[i], "-ls") == 0 || strcmp(argv[i], "-l") == 0)
+			lsonly = TRUE;
+		else if(strcmp(argv[i], "-no-progress") == 0 || strcmp(argv[i], "-n") == 0)
+			progress = FALSE;
+		else if(strcmp(argv[i], "-dest") == 0 || strcmp(argv[i], "-d") == 0) {
+			if(++i == argc) {
+				fprintf(stderr, "%s: -dest missing filename\n", argv[0]);
+				exit(1);
+			}
+			dest = argv[i];
+		} else if(strcmp(argv[i], "-processors") == 0 || strcmp(argv[i], "-p") == 0) {
+			if((++i == argc) || (processors = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -processors missing or invalid processor number\n", argv[0]);
+				exit(1);
+			}
+			if(processors < 1) {
+				ERROR("%s: -processors should be 1 or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-data-queue") == 0 || strcmp(argv[i], "-da") == 0) {
+			if((++i == argc) || (data_buffer_size = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -data-queue missing or invalid queue size\n", argv[0]);
+				exit(1);
+			}
+			if(data_buffer_size < 1) {
+				ERROR("%s: -data-queue should be 1 Mbyte or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-frag-queue") == 0 || strcmp(argv[i], "-fr") == 0) {
+			if((++i == argc) || (fragment_buffer_size = strtol(argv[i], &b, 10), *b != '\0')) {
+				ERROR("%s: -frag-queue missing or invalid queue size\n", argv[0]);
+				exit(1);
+			}
+			if(fragment_buffer_size < 1) {
+				ERROR("%s: -frag-queue should be 1 Mbyte or larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-force") == 0 || strcmp(argv[i], "-f") == 0)
+			force = TRUE;
+		else if(strcmp(argv[i], "-stat") == 0 || strcmp(argv[i], "-s") == 0)
+			stat_sys = TRUE;
+		else if(strcmp(argv[i], "-lls") == 0 || strcmp(argv[i], "-ll") == 0) {
+			lsonly = TRUE;
+			short_ls = FALSE;
+		} else if(strcmp(argv[i], "-linfo") == 0 || strcmp(argv[i], "-li") == 0) {
+			info = TRUE;
+			short_ls = FALSE;
+		} else if(strcmp(argv[i], "-ef") == 0 || strcmp(argv[i], "-e") == 0) {
+			if(++i == argc) {
+				fprintf(stderr, "%s: -ef missing filename\n", argv[0]);
+				exit(1);
+			}
+			path = process_extract_files(path, argv[i]);
+		} else if(strcmp(argv[i], "-regex") == 0 || strcmp(argv[i], "-r") == 0)
+			use_regex = TRUE;
+		else
+			goto options;
+	}
+
+	if(lsonly || info)
+		progress = FALSE;
+
+	if(i == argc) {
+		if(!version) {
+options:
+			ERROR("SYNTAX: %s [options] filesystem [directories or files to extract]\n", argv[0]);
+			ERROR("\t-v[ersion]\t\tprint version, licence and copyright information\n");
+			ERROR("\t-d[est] <pathname>\tunsquash to <pathname>, default \"squashfs-root\"\n");
+			ERROR("\t-n[o-progress]\t\tdon't display the progress bar\n");
+			ERROR("\t-p[rocessors] <number>\tuse <number> processors.  By default will use\n\t\t\t\tnumber of processors available\n");
+			ERROR("\t-i[nfo]\t\t\tprint files as they are unsquashed\n");
+			ERROR("\t-li[nfo]\t\tprint files as they are unsquashed with file\n\t\t\t\tattributes (like ls -l output)\n");
+			ERROR("\t-l[s]\t\t\tlist filesystem, but don't unsquash\n");
+			ERROR("\t-ll[s]\t\t\tlist filesystem with file attributes (like\n\t\t\t\tls -l output), but don't unsquash\n");
+			ERROR("\t-f[orce]\t\tif file already exists then overwrite\n");
+			ERROR("\t-s[tat]\t\t\tdisplay filesystem superblock information\n");
+			ERROR("\t-e[f] <extract file>\tlist of directories or files to extract.\n\t\t\t\tOne per line\n");
+			ERROR("\t-da[ta-queue] <size>\tSet data queue to <size> Mbytes.  Default %d\n\t\t\t\tMbytes\n", DATA_BUFFER_DEFAULT);
+			ERROR("\t-fr[ag-queue] <size>\tSet fagment queue to <size> Mbytes.  Default %d\n\t\t\t\tMbytes\n", FRAGMENT_BUFFER_DEFAULT);
+			ERROR("\t-r[egex]\t\ttreat extract names as POSIX regular expressions\n\t\t\t\trather than use the default shell wildcard\n\t\t\t\texpansion (globbing)\n");
+		}
+		exit(1);
+	}
+
+	for(n = i + 1; n < argc; n++)
+		path = add_path(path, argv[n], argv[n]);
+
+	if((fd = open(argv[i], O_RDONLY)) == -1) {
+		ERROR("Could not open %s, because %s\n", argv[i], strerror(errno));
+		exit(1);
+	}
+
+	if(read_super(argv[i]) == FALSE)
+		exit(1);
+
+	if(stat_sys) {
+		squashfs_stat(argv[i]);
+		exit(0);
+	}
+
+	block_size = sBlk.block_size;
+	block_log = sBlk.block_log;
+
+	fragment_buffer_size <<= 20 - block_log;
+	data_buffer_size <<= 20 - block_log;
+	initialise_threads(fragment_buffer_size, data_buffer_size);
+
+	if((fragment_data = malloc(block_size)) == NULL)
+		EXIT_UNSQUASH("failed to allocate fragment_data\n");
+
+	if((file_data = malloc(block_size)) == NULL)
+		EXIT_UNSQUASH("failed to allocate file_data");
+
+	if((data = malloc(block_size)) == NULL)
+		EXIT_UNSQUASH("failed to allocate data\n");
+
+	if((created_inode = malloc(sBlk.inodes * sizeof(char *))) == NULL)
+		EXIT_UNSQUASH("failed to allocate created_inode\n");
+
+	memset(created_inode, 0, sBlk.inodes * sizeof(char *));
+
+	read_uids_guids();
+
+	s_ops.read_fragment_table();
+
+	uncompress_inode_table(sBlk.inode_table_start, sBlk.directory_table_start);
+
+	uncompress_directory_table(sBlk.directory_table_start, sBlk.fragment_table_start);
+
+	if(path) {
+		paths = init_subdir();
+		paths = add_subdir(paths, path);
+	}
+
+	pre_scan(dest, SQUASHFS_INODE_BLK(sBlk.root_inode), SQUASHFS_INODE_OFFSET(sBlk.root_inode), paths);
+
+	memset(created_inode, 0, sBlk.inodes * sizeof(char *));
+
+	printf("%d inodes (%d blocks) to write\n\n", total_inodes, total_inodes - total_files + total_blocks);
+
+	if(progress)
+		enable_progress_bar();
+
+	dir_scan(dest, SQUASHFS_INODE_BLK(sBlk.root_inode), SQUASHFS_INODE_OFFSET(sBlk.root_inode), paths);
+
+	queue_put(to_writer, NULL);
+	queue_get(from_writer);
+
+	if(progress) {
+		disable_progress_bar();
+		progress_bar(sym_count + dev_count + fifo_count + cur_blocks,
+			total_inodes - total_files + total_blocks, columns);
+	}
+
+	if(!lsonly) {
+		printf("\n");
+		printf("created %d files\n", file_count);
+		printf("created %d directories\n", dir_count);
+		printf("created %d symlinks\n", sym_count);
+		printf("created %d devices\n", dev_count);
+		printf("created %d fifos\n", fifo_count);
+	}
+
+	return 0;
+}
