From 2b4e7934b793ae6c1ddabdd9cfac55ce310a04d5 
From: Fedor <fedork@ubuntu.(none)>
Date: Sat, 4 Sep 2010 01:14:23 -0400
Subject: [PATCH] [NET/IPv4/netfilter]: patches from upstream

 kernel.org commits:
 aeed9e82cd258b9699eaa6568efefba9cc6d5f01 [NET] loopback: Panic if registration fails
 be9164e769d57aa10b2bbe15d103edc041b9e7de [IPv4] UFO: prevent generation of chained skb destined to UFO device
 9958da0501fced47c1ac5c5a3a7731c87e45472c net: remove time limit in process_backlog()
 b1e93a68ca41e7e73766f95ba32ca05cf9052e15 netfilter: conntrack: don't deliver events for racy packets

---
 drivers/net/loopback.c                    |    7 ++++++-
 include/net/netfilter/nf_conntrack_core.h |    3 ++-
 net/core/dev.c                            |    3 +--
 net/ipv4/ip_output.c                      |   22 +++++++---------------
 4 files changed, 16 insertions(+), 19 deletions(-)

diff --git a/drivers/net/loopback.c b/drivers/net/loopback.c
index 6ba6ed2..5106c23 100644
--- a/drivers/net/loopback.c
+++ b/drivers/net/loopback.c
@@ -229,7 +229,12 @@ struct net_device loopback_dev = {
 /* Setup and register the loopback device. */
 static int __init loopback_init(void)
 {
-	return register_netdev(&loopback_dev);
+	int err = register_netdev(&loopback_dev);
+
+	if (err)
+		panic("loopback: Failed to register netdevice: %d\n", err);
+
+	return err;
 };
 
 module_init(loopback_init);
diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
index 0d48275..a42cc07 100644
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@ -67,7 +67,8 @@ static inline int nf_conntrack_confirm(struct sk_buff **pskb)
 	if (ct && ct != &nf_conntrack_untracked) {
 		if (!nf_ct_is_confirmed(ct))
 			ret = __nf_conntrack_confirm(pskb);
-		nf_ct_deliver_cached_events(ct);
+		if (likely(ret == NF_ACCEPT))
+			nf_ct_deliver_cached_events(ct);
 	}
 	return ret;
 }
diff --git a/net/core/dev.c b/net/core/dev.c
index d631f17..c10c25e 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -1950,7 +1950,6 @@ static int process_backlog(struct net_device *backlog_dev, int *budget)
 	int work = 0;
 	int quota = min(backlog_dev->quota, *budget);
 	struct softnet_data *queue = &__get_cpu_var(softnet_data);
-	unsigned long start_time = jiffies;
 
 	backlog_dev->weight = weight_p;
 	for (;;) {
@@ -1971,7 +1970,7 @@ static int process_backlog(struct net_device *backlog_dev, int *budget)
 
 		work++;
 
-		if (work >= quota || jiffies - start_time > 1)
+		if (work >= quota)
 			break;
 
 	}
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 34ea454..463e976 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -732,23 +732,15 @@ static inline int ip_ufo_append_data(struct sock *sk,
 		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 		sk->sk_sndmsg_off = 0;
-	}
 
-	err = skb_append_datato_frags(sk,skb, getfrag, from,
-			       (length - transhdrlen));
-	if (!err) {
-		/* specify the length of each IP datagram fragment*/
+		/* specify the length of each IP datagram fragment */
 		skb_shinfo(skb)->gso_size = mtu - fragheaderlen;
 		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(&sk->sk_write_queue, skb);
-
-		return 0;
 	}
-	/* There is not enough support do UFO ,
-	 * so follow normal path
-	 */
-	kfree_skb(skb);
-	return err;
+
+	return skb_append_datato_frags(sk, skb, getfrag, from,
+				       (length - transhdrlen));
 }
 
 /*
@@ -842,9 +834,9 @@ int ip_append_data(struct sock *sk,
 		csummode = CHECKSUM_PARTIAL;
 
 	inet->cork.length += length;
-	if (((length > mtu) && (sk->sk_protocol == IPPROTO_UDP)) &&
-			(rt->u.dst.dev->features & NETIF_F_UFO)) {
-
+	if (((length> mtu) || !skb_queue_empty(&sk->sk_write_queue)) &&
+	    (sk->sk_protocol == IPPROTO_UDP) &&
+	    (rt->u.dst.dev->features & NETIF_F_UFO)) {
 		err = ip_ufo_append_data(sk, getfrag, from, length, hh_len,
 					 fragheaderlen, transhdrlen, mtu,
 					 flags);
-- 
1.6.5.GIT
