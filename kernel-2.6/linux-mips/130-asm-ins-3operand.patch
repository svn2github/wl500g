From 94daeb90698c56a85ed219eeb18d4a8cddde7b03
From: David Daney
Date: Wed, 11 Jun 2008 10:04:25 -0700
Subject: [PATCH] [MIPS] Fix asm constraints for 'ins' instructions.

The third operand to 'ins' must be a constant int, not a register.

[Ralf: The bug was actually intensional.  Some versions used to throw an
error under certain circumstances for code like:

static inline void f(unsigned nr, unsigned *p)
{
	unsigned short bit = nr & 5;

	if (__builtin_constant_p(bit)) {
		__asm__ __volatile__ ("  foo %0, %1" : "=m" (*p) : "i" (bit));
  	} else {
		/* Do something else. */
	}
}

because gcc was not able to figure out that the "i" constraint was possibly
at the early stage when the constraint are getting verified.  The solution
was using "ri" instead of "i".  The "ri" would keep gcc happy but in the
end for code generation always the "i" constraint would be satisfied.  The
problem afair originally appeared in the i386 io.h and also hit it's mips
equivalent.  From there the workaround spread to many of the inline
assembler functions.]

Signed-off-by: David Daney <ddaney@avtrex.com>
Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
---
 include/asm-mips/bitops.h |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/include/asm-mips/bitops.h b/include/asm-mips/bitops.h
--- a/include/asm-mips/bitops.h
+++ b/include/asm-mips/bitops.h
@@ -82,7 +82,7 @@ static inline void set_bit(unsigned long nr, volatile unsigned long *addr)
 		"2:	b	1b					\n"
 		"	.previous					\n"
 		: "=&r" (temp), "=m" (*m)
-		: "ir" (bit), "m" (*m), "r" (~0));
+		: "i" (bit), "m" (*m), "r" (~0));
 #endif /* CONFIG_CPU_MIPSR2 */
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
@@ -147,7 +147,7 @@ static inline void clear_bit(unsigned long nr, volatile unsigned long *addr)
 		"2:	b	1b					\n"
 		"	.previous					\n"
 		: "=&r" (temp), "=m" (*m)
-		: "ir" (bit), "m" (*m));
+		: "i" (bit), "m" (*m));
 #endif /* CONFIG_CPU_MIPSR2 */
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
@@ -428,7 +428,7 @@ static inline int test_and_clear_bit(unsigned long nr,
 		"2:	b	1b					\n"
 		"	.previous					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
-		: "ri" (bit), "m" (*m)
+		: "i" (bit), "m" (*m)
 		: "memory");
 #endif
 	} else if (cpu_has_llsc) {
-- 
1.7.1

