diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/bcm947xx.h linux-2.6/arch/mips/brcm-boards/bcm947xx/bcm947xx.h
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/bcm947xx.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/bcm947xx.h	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,24 @@
+/*
+ * Broadcom HND MIPS boards configuration
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: bcm947xx.h,v 1.1 2007/09/04 04:45:20 Exp $
+ */
+
+#ifndef _bcm947xx_h_
+#define _bcm947xx_h_
+
+/* Virtual IRQ base, after last hw IRQ */
+#define SBMIPS_VIRTIRQ_BASE	6
+
+/* # IRQs, hw and sw IRQs */
+#define SBMIPS_NUMIRQS	8
+
+#endif	/* _bcm947xx_h_ */ 
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/gpio.c linux-2.6/arch/mips/brcm-boards/bcm947xx/gpio.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/gpio.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/gpio.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,158 @@
+/*
+ * GPIO char driver
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: gpio.c,v 1.5 2008/04/03 03:49:45 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmdevs.h>
+
+static si_t *gpio_sih;
+static int gpio_major;
+static devfs_handle_t gpio_dir;
+static struct {
+	char *name;
+	devfs_handle_t handle;
+} gpio_file[] = {
+	{ "in", NULL },
+	{ "out", NULL },
+	{ "outen", NULL },
+	{ "control", NULL }
+};
+
+static int
+gpio_open(struct inode *inode, struct file * file)
+{
+	if (MINOR(inode->i_rdev) > ARRAYSIZE(gpio_file))
+		return -ENODEV;
+
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static int
+gpio_release(struct inode *inode, struct file * file)
+{
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static ssize_t
+gpio_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	u32 val;
+
+	switch (MINOR(file->f_dentry->d_inode->i_rdev)) {
+	case 0:
+		val = si_gpioin(gpio_sih);
+		break;
+	case 1:
+		val = si_gpioout(gpio_sih, 0, 0);
+		break;
+	case 2:
+		val = si_gpioouten(gpio_sih, 0, 0);
+		break;
+	case 3:
+		val = si_gpiocontrol(gpio_sih, 0, 0);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	if (put_user(val, (u32 *) buf))
+		return -EFAULT;
+
+	return sizeof(val);
+}
+
+static ssize_t
+gpio_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	u32 val;
+
+	if (get_user(val, (u32 *) buf))
+		return -EFAULT;
+
+	switch (MINOR(file->f_dentry->d_inode->i_rdev)) {
+	case 0:
+		return -EACCES;
+	case 1:
+		si_gpioout(gpio_sih, ~0, val);
+		break;
+	case 2:
+		si_gpioouten(gpio_sih, ~0, val);
+		break;
+	case 3:
+		si_gpiocontrol(gpio_sih, ~0, val);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	return sizeof(val);
+}
+
+static struct file_operations gpio_fops = {
+	owner:		THIS_MODULE,
+	open:		gpio_open,
+	release:	gpio_release,
+	read:		gpio_read,
+	write:		gpio_write,
+};
+
+static int __init
+gpio_init(void)
+{
+	int i;
+
+	if (!(gpio_sih = si_kattach(SI_OSH)))
+		return -ENODEV;
+
+	si_gpiosetcore(gpio_sih);
+
+	if ((gpio_major = devfs_register_chrdev(0, "gpio", &gpio_fops)) < 0)
+		return gpio_major;
+
+	gpio_dir = devfs_mk_dir(NULL, "gpio", NULL);
+
+	for (i = 0; i < ARRAYSIZE(gpio_file); i++) {
+		gpio_file[i].handle = devfs_register(gpio_dir,
+						     gpio_file[i].name,
+						     DEVFS_FL_DEFAULT, gpio_major, i,
+						     S_IFCHR | S_IRUGO | S_IWUGO,
+						     &gpio_fops, NULL);
+	}
+
+	return 0;
+}
+
+static void __exit
+gpio_exit(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAYSIZE(gpio_file); i++)
+		devfs_unregister(gpio_file[i].handle);
+	devfs_unregister(gpio_dir);
+	devfs_unregister_chrdev(gpio_major, "gpio");
+	si_detach(gpio_sih);
+}
+
+module_init(gpio_init);
+module_exit(gpio_exit);
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/irq.c linux-2.6/arch/mips/brcm-boards/bcm947xx/irq.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/irq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/irq.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * Broadcom HND BCM47xx chips interrupt dispatcher.
+ * Derived from ../generic/irq.c
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------------------
+ *             0	Software
+ *             1        Software
+ *             2        Hardware (shared)
+ *             3        Hardware
+ *             4        Hardware
+ *             5        Hardware
+ *             6        Hardware
+ *             7        Hardware (r4k timer)
+ *
+ *      MIPS IRQ        Linux IRQ
+ *      --------        -----------
+ *         0 - 1        0 - 1
+ *             2        8 and above
+ *         3 - 7        3 - 7
+ *
+ * MIPS has 8 IRQs as indicated and assigned above. SB cores
+ * that use dedicated MIPS IRQ3 to IRQ6 are 1-to-1 mapped to
+ * linux IRQ3 to IRQ6. SB cores sharing MIPS IRQ2 are mapped
+ * to linux IRQ8 and above as virtual IRQs using the following
+ * mapping:
+ *
+ *   <linux-IRQ#> = <SB-core-flag> + <base-IRQ> + 2
+ *
+ * where <base-IRQ> is specified in setup.c when calling
+ * sb_mips_init(), 2 is to offset the two software IRQs.
+ *
+ * $Id: irq.c,v 1.8 2008/07/04 01:20:42 Exp $
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SMP
+/*
+ * This code is designed to work on Uniprocessor only.
+ *
+ * To support SMP we must know:
+ *   - interrupt architecture
+ *   - interrupt distribution machenism
+ */
+#error "This implementation does not support SMP"
+#endif
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/mipsregs.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <hndcpu.h>
+#include <hndsoc.h>
+#include <mips74k_core.h>
+#include "bcm947xx.h"
+
+/* cp0 SR register IM field */
+#define SR_IM(irq)	(1 << ((irq) + STATUSB_IP0))
+
+/* cp0 CR register IP field */
+#define CR_IP(irq)	(1 << ((irq) + CAUSEB_IP0))
+
+/* other local constants */
+#define NUM_IRQS	32
+
+/* local variables and functions */
+static sbconfig_t *ccsbr = NULL;	/* Chipc core SB config regs */
+static sbconfig_t *mipssbr = NULL;	/* MIPS core SB config regs */
+static int mipsirq = -1;		/* MIPS core virtual IRQ number */
+static uint32 shints = 0;		/* Set of shared interrupts */
+static int irq2en = 0;			/* MIPS IRQ2 enable count */
+static uint *mips_corereg = NULL;
+
+/* global variables and functions */
+extern si_t *bcm947xx_sih;		/* defined in setup.c */
+
+extern asmlinkage void brcmIRQ(void);
+
+/* Control functions for MIPS IRQ0 to IRQ7 */
+static INLINE void
+enable_brcm_irq(unsigned int irq)
+{
+	set_c0_status(SR_IM(irq));
+	irq_enable_hazard();
+}
+
+static INLINE void
+disable_brcm_irq(unsigned int irq)
+{
+	clear_c0_status(SR_IM(irq));
+	irq_disable_hazard();
+}
+
+static void
+ack_brcm_irq(unsigned int irq)
+{
+	/* Done in plat_irq_dispatch()! */
+}
+
+static void
+end_brcm_irq(unsigned int irq)
+{
+	/* Done in plat_irq_dispatch()! */
+}
+
+/* Control functions for linux IRQ8 and above */
+static INLINE void
+enable_brcm_irq2(unsigned int irq)
+{
+	ASSERT(irq2en >= 0);
+	if (irq2en++)
+		return;
+	enable_brcm_irq(2);
+}
+
+static INLINE void
+disable_brcm_irq2(unsigned int irq)
+{
+	ASSERT(irq2en > 0);
+	if (--irq2en)
+		return;
+	disable_brcm_irq(2);
+}
+
+static void
+ack_brcm_irq2(unsigned int irq)
+{
+	/* Already done in plat_irq_dispatch()! */
+}
+
+static void
+end_brcm_irq2(unsigned int irq)
+{
+	/* Already done in plat_irq_dispatch()! */
+}
+
+/*
+ * Route interrupts to ISR(s).
+ *
+ * This function is entered with the IE disabled. It can be
+ * re-entered as soon as the IE is re-enabled in function
+ * handle_IRQ_envet().
+ */
+void
+plat_irq_dispatch(struct pt_regs *regs)
+{
+	u32 pending, ipvec;
+	uint32 flags = 0;
+	int irq;
+
+	/* Disable MIPS IRQs with pending interrupts */
+	pending = read_c0_cause() & CAUSEF_IP;
+	pending &= read_c0_status();
+	clear_c0_status(pending);
+	irq_disable_hazard();
+
+	/*
+	 * Handle MIPS timer interrupt. Re-enable MIPS IRQ7
+	 * immediately after servicing the interrupt so that
+	 * we can take this kind of interrupt again later
+	 * while servicing other interrupts.
+	 */
+	if (pending & CAUSEF_IP7) {
+		do_IRQ(7);
+		pending &= ~CAUSEF_IP7;
+		set_c0_status(STATUSF_IP7);
+		irq_enable_hazard();
+	}
+
+	/*
+	 * Build bitvec for pending interrupts. Start with
+	 * MIPS IRQ2 and add linux IRQs to higher bits to
+	 * make the interrupt processing uniform.
+	 */
+	ipvec = pending >> CAUSEB_IP2;
+	if (pending & CAUSEF_IP2) {
+		if (ccsbr)
+			flags = R_REG(NULL, &ccsbr->sbflagst);
+
+		/* Read intstatus */
+		if (mips_corereg)
+			flags = R_REG(NULL, &((mips74kregs_t *)mips_corereg)->intstatus);
+
+		flags &= shints;
+		ipvec |= flags << SBMIPS_VIRTIRQ_BASE;
+	}
+
+#ifdef CONFIG_HND_BMIPS3300_PROF
+	/*
+	 * Handle MIPS core interrupt. Re-enable the MIPS IRQ that
+	 * MIPS core is assigned to immediately after servicing the
+	 * interrupt so that we can take this kind of interrupt again
+	 * later while servicing other interrupts.
+	 *
+	 * mipsirq < 0 indicates MIPS core IRQ # is unknown.
+	 */
+	if (mipsirq >= 0 && (ipvec & (1 << mipsirq))) {
+		/*
+		 * MIPS core raised the interrupt on the shared MIPS IRQ2.
+		 * Make sure MIPS core is the only interrupt source before
+		 * re-enabling the IRQ.
+		 */
+		if (mipsirq >= SBMIPS_VIRTIRQ_BASE) {
+			if (flags == (1 << (mipsirq-SBMIPS_VIRTIRQ_BASE))) {
+				irq = mipsirq + 2;
+				do_IRQ(irq);
+				ipvec &= ~(1 << mipsirq);
+				pending &= ~CAUSEF_IP2;
+				set_c0_status(STATUSF_IP2);
+				irq_enable_hazard();
+			}
+		}
+		/*
+		 * MIPS core raised the interrupt on a dedicated MIPS IRQ.
+		 * Re-enable the IRQ immediately.
+		 */
+		else {
+			irq = mipsirq + 2;
+			do_IRQ(irq);
+			ipvec &= ~(1 << mipsirq);
+			pending &= ~CR_IP(irq);
+			set_c0_status(SR_IM(irq));
+			irq_enable_hazard();
+		}
+	}
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+
+        /* Shared interrupt bits are shifted to respective bit positions in
+	 * ipvec above. IP2 (bit 0) is of no significance, hence shifting the
+	 * bit map by 1 to the right.
+	 */
+	ipvec >>= 1;
+
+	/*
+	 * Handle all other interrupts. Re-enable disabled MIPS IRQs
+	 * after processing all pending interrupts.
+	 */
+	for (irq = 3; ipvec != 0; irq++) {
+		if (ipvec & 1)
+			do_IRQ(irq);
+		ipvec >>= 1;
+	}
+	set_c0_status(pending);
+	irq_enable_hazard();
+}
+
+/* MIPS IRQ0 to IRQ7 interrupt controller */
+static struct irq_chip brcm_irq_type = {
+	.name = "MIPS",
+	.ack = ack_brcm_irq,
+	.mask = disable_brcm_irq,
+	.mask_ack = disable_brcm_irq,
+	.unmask = enable_brcm_irq,
+	.end = end_brcm_irq
+};
+
+/* linux IRQ8 and above interrupt controller */
+static struct irq_chip brcm_irq2_type = {
+	.name = "IRQ2",
+	.ack = ack_brcm_irq2,
+	.mask = disable_brcm_irq2,
+	.mask_ack = disable_brcm_irq2,
+	.unmask = enable_brcm_irq2,
+	.end = end_brcm_irq2
+};
+
+/*
+ * We utilize chipcommon configuration register SBFlagSt to implement a
+ * smart shared IRQ handling machenism through which only ISRs registered
+ * for the SB cores that raised the interrupt are invoked. This machenism
+ * relies on the SBFlagSt register's reliable recording of the SB cores
+ * that raised the interrupt.
+ */
+void __init
+arch_init_irq(void)
+{
+	int i;
+	uint32 coreidx, mips_core_id;
+	void *regs;
+
+	if (BCM330X(current_cpu_data.processor_id))
+		mips_core_id = MIPS33_CORE_ID;
+	else if (MIPS74K(current_cpu_data.processor_id))
+		mips_core_id = MIPS74K_CORE_ID;
+	else {
+		printk(KERN_ERR "MIPS CPU type %x unknown", current_cpu_data.processor_id);
+		return;
+	}
+
+	/* Cache chipc and mips33 config registers */
+	ASSERT(bcm947xx_sih);
+	coreidx = si_coreidx(bcm947xx_sih);
+	regs = si_setcore(bcm947xx_sih, mips_core_id, 0);
+	mipsirq = si_irq(bcm947xx_sih);
+	if (bcm947xx_sih->socitype == SOCI_SB) {
+		if (regs)
+			mipssbr = (sbconfig_t *)((ulong)regs + SBCONFIGOFF);
+
+		if ((regs = si_setcore(bcm947xx_sih, CC_CORE_ID, 0)))
+			ccsbr = (sbconfig_t *)((ulong)regs + SBCONFIGOFF);
+	}
+	si_setcoreidx(bcm947xx_sih, coreidx);
+
+	if (BCM330X(current_cpu_data.processor_id)) {
+		/* Cache mips33 sbintvec register */
+		if (mipssbr)
+			shints = R_REG(NULL, &mipssbr->sbintvec);
+	} else {
+		uint32 *intmask;
+
+		/* Use intmask5 register to route the timer interrupt */
+		intmask = (uint32 *) &((mips74kregs_t *)regs)->intmask[5];
+		W_REG(NULL, intmask, 1 << 31);
+
+		intmask = (uint32 *) &((mips74kregs_t *)regs)->intmask[0];
+		shints = R_REG(NULL, intmask);
+
+		/* Save the pointer to mips core registers */
+		mips_corereg = regs;
+	}
+
+	/* Install interrupt controllers */
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, (i < SBMIPS_NUMIRQS ? &brcm_irq_type : &brcm_irq2_type));
+	}
+}
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/Makefile linux-2.6/arch/mips/brcm-boards/bcm947xx/Makefile
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/Makefile	2009-06-23 12:25:32.000000000 +0400
@@ -0,0 +1,34 @@
+#
+# Makefile for Broadcom BCM947XX boards
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.3 2008/05/02 22:49:54 Exp $
+#
+#
+
+ifeq ($(CONFIG_USB),m)
+ EXTRA_CFLAGS += -DNLS_XFR
+endif
+
+
+SHARED := ../../../../../../shared
+
+BCM947XX_OBJS = $(addprefix $(SHARED)/, hndmips.o hndchipc.o linux_gpio.o sflash.o)
+BCM947XX_OBJS += $(addprefix $(SHARED)/nvram/, nvram.o)
+
+EXTRA_CFLAGS += -DLINUX_HYBRID_POSTPROCESSING_REMOVAL
+ifeq ($(CONFIG_PCI),y)
+BCM947XX_OBJS += $(addprefix $(SHARED)/, hndpci.o) pcibios.o
+endif
+
+BCM947XX_OBJS += setup.o prom.o time.o irq.o perfcntr.o
+
+bcm947xx-objs += $(BCM947XX_OBJS)
+obj-y += bcm947xx.o
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/nvram_linux.c linux-2.6/arch/mips/brcm-boards/bcm947xx/nvram_linux.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/nvram_linux.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/nvram_linux.c	2009-06-23 12:25:26.000000000 +0400
@@ -0,0 +1,1652 @@
+/*
+ * NVRAM variable manipulation (Linux kernel half)
+ *
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: nvram_linux.c,v 1.8 2008/07/04 01:15:09 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/bootmem.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/mtd/mtd.h>
+//#include <mtd/mtd-user.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+
+#include <typedefs.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <bcmutils.h>
+#include <bcmdefs.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <hndmips.h>
+#include <sflash.h>
+
+/* In BSS to minimize text size and page aligned so it can be mmap()-ed */
+static char nvram_buf[NVRAM_SPACE] __attribute__((aligned(PAGE_SIZE)));
+
+#define CFE_UPDATE 1 // added by Chen-I for mac/regulation update
+#ifdef CFE_UPDATE
+//#include <sbextif.h>
+
+extern void bcm947xx_watchdog_disable(void);
+
+#define CFE_SPACE       256*1024
+#define CFE_NVRAM_START 0x00000
+#define CFE_NVRAM_END   0x01fff
+#define CFE_NVRAM_SPACE 64*1024
+static struct mtd_info *cfe_mtd = NULL;
+static char *CFE_NVRAM_PREFIX="asuscfe";
+static char *CFE_NVRAM_COMMIT="asuscfecommit";
+static char *CFE_NVRAM_WATCHDOG="asuscfewatchdog";
+char *cfe_buf;// = NULL;
+struct nvram_header *cfe_nvram_header; // = NULL;
+
+static u_int32_t cfe_offset;
+static u_int32_t cfe_embedded_size;
+static int get_embedded_block(struct mtd_info *mtd, char *buf, size_t erasesize,
+                       u_int32_t *offset, struct nvram_header **header, u_int32_t *emb_size);
+
+static int cfe_init(void);
+static int cfe_update(const char *keyword, const char *value);
+static int cfe_dump(void);
+static int cfe_commit(void);
+#endif
+
+
+#define WPS	1
+
+#ifdef MODULE
+
+#define early_nvram_get(name) nvram_get(name)
+
+#else /* !MODULE */
+
+/* Global SB handle */
+extern void *bcm947xx_sih;
+extern spinlock_t bcm947xx_sih_lock;
+
+/* Convenience */
+#define sih bcm947xx_sih
+#define sih_lock bcm947xx_sih_lock
+#define KB * 1024
+#define MB * 1024 * 1024
+
+//#define NLS_XFR 1              /* added by Jiahao for WL500gP */
+#ifdef NLS_XFR
+
+#include <linux/nls.h>
+
+static char *NLS_NVRAM_U2C="asusnlsu2c";
+static char *NLS_NVRAM_C2U="asusnlsc2u";
+__u16 unibuf[1024];
+char codebuf[1024];
+char tmpbuf[1024];
+
+void
+asusnls_u2c(char *name)
+{
+	char *codepage;
+	char *xfrstr;
+	struct nls_table *nls;
+	int ret, len;
+
+	strcpy(codebuf, name);
+	codepage=codebuf+strlen(NLS_NVRAM_U2C);
+	if((xfrstr=strchr(codepage, '_')))
+	{
+		*xfrstr=NULL;
+		xfrstr++;
+		/* debug message, start */
+/*
+		printk("%s, xfr from utf8 to %s\n", xfrstr, codepage);
+		int j;
+		printk("utf8:    %d, ", strlen(xfrstr));
+		for(j=0;j<strlen(xfrstr);j++)
+			printk("%X ", (unsigned char)xfrstr[j]);
+		printk("\n");
+*/
+		/* debug message, end */
+
+		nls=load_nls(codepage);
+		if(!nls)
+		{
+			printk("NLS table is null!!\n");
+		}
+		else {
+			len = 0;
+			if (ret=utf8_mbstowcs(unibuf, xfrstr, strlen(xfrstr)))
+			{
+				int i;
+				for (i = 0; (i < ret) && unibuf[i]; i++) {
+					int charlen;
+					charlen = nls->uni2char(unibuf[i], &name[len], NLS_MAX_CHARSET_SIZE);
+					if (charlen > 0) {
+						len += charlen;
+					}
+					else {
+						//name[len++] = '?';
+						strcpy(name, "");
+						unload_nls(nls);
+						return;
+					}
+				}
+				name[len] = 0;
+			}
+			unload_nls(nls);
+			/* debug message, start */
+/*
+			int i;
+			printk("unicode: %d, ", ret);
+			for (i=0;i<ret;i++)
+				printk("%X ", unibuf[i]);
+			printk("\n");
+			printk("local:   %d, ", strlen(name));
+			for (i=0;i<strlen(name);i++)
+				printk("%X ", (unsigned char)name[i]);
+			printk("\n");
+			printk("local:   %s\n", name);
+*/
+			/* debug message, end */
+
+			if(!len)
+			{
+				printk("can not xfr from utf8 to %s\n", codepage);
+				strcpy(name, "");
+			}
+		}
+	}
+	else
+	{
+		strcpy(name, "");
+	}
+}
+
+void                                                                                                                         
+asusnls_c2u(char *name)
+{
+	char *codepage;
+	char *xfrstr;
+	struct nls_table *nls;
+	int ret;
+
+	strcpy(codebuf, name);
+	codepage=codebuf+strlen(NLS_NVRAM_C2U);
+	if((xfrstr=strchr(codepage, '_')))
+	{
+		*xfrstr=NULL;
+		xfrstr++;
+
+		/* debug message, start */
+/*
+		printk("%s, xfr from %s to utf8\n", xfrstr, codepage);
+		printk("local:   %d, ", strlen(xfrstr));
+		int j;
+		for (j=0;j<strlen(xfrstr);j++)
+			printk("%X ", (unsigned char)xfrstr[j]);
+		printk("\n");
+		printk("local:   %s\n", xfrstr);
+*/
+		/* debug message, end */
+
+		strcpy(name, "");
+		nls=load_nls(codepage);
+		if(!nls)
+		{
+			printk("NLS table is null!!\n");
+		}
+		else
+		{
+			int charlen;
+			int i;
+			int len = strlen(xfrstr);
+			for (i = 0; len && *xfrstr; i++, xfrstr += charlen, len -= charlen) {   /* string to unicode */
+				charlen = nls->char2uni(xfrstr, len, &unibuf[i]);
+				if (charlen < 1) {
+					//unibuf[i] = 0x003f;     /* a question mark */
+					//charlen = 1;
+					strcpy(name ,"");
+					unload_nls(nls);
+					return;
+				}
+			}
+			unibuf[i] = 0;
+			ret=utf8_wcstombs(name, unibuf, 1024);  /* unicode to utf-8, 1024 is size of array unibuf */
+			name[ret]=0;
+			unload_nls(nls);
+			/* debug message, start */
+/*
+			int k;
+			printk("unicode: %d, ", i);
+			for(k=0;k<i;k++)
+				printk("%X ", unibuf[k]);
+			printk("\n");
+			printk("utf-8:    %s, %d, ", name, strlen(name));
+			for (i=0;i<strlen(name);i++)
+				printk("%X ", (unsigned char)name[i]);
+			printk("\n");
+*/
+			/* debug message, end */
+			if(!ret)
+			{
+				printk("can not xfr from %s to utf8\n", codepage);
+				strcpy(name, "");
+			}
+		}
+	}
+	else
+	{
+		strcpy(name, "");
+	}
+}
+
+/* Jiahao */
+static int
+nvram_xfr(char *buf)
+{
+	char *name = tmpbuf;
+	ssize_t ret=0;
+
+	printk("nvram xfr 1: %s\n", buf);
+	if (copy_from_user(name, buf, strlen(buf)+1)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (strncmp(tmpbuf, NLS_NVRAM_U2C, strlen(NLS_NVRAM_U2C))==0)
+	{
+		asusnls_u2c(tmpbuf);
+	}
+	else if (strncmp(buf, NLS_NVRAM_C2U, strlen(NLS_NVRAM_C2U))==0)
+	{
+		asusnls_c2u(tmpbuf);
+	}
+	else
+	{
+		strcpy(tmpbuf, "");
+		printk("nvram xfr 2: %s\n", tmpbuf);
+	}
+
+	if (copy_to_user(buf, tmpbuf, strlen(tmpbuf)+1))
+	{
+		ret = -EFAULT;
+		goto done;
+	}
+	printk("nvram xfr 3: %s\n", tmpbuf);
+
+done:
+	return ret;
+}
+
+#endif
+
+/* Probe for NVRAM header */
+static int
+early_nvram_init(void)
+{
+	struct nvram_header *header;
+	chipcregs_t *cc;
+	struct sflash *info = NULL;
+	int i;
+	uint32 base, off, lim;
+	u32 *src, *dst;
+
+	if ((cc = si_setcore(sih, CC_CORE_ID, 0)) != NULL) {
+		base = KSEG1ADDR(SI_FLASH2);
+		switch (readl(&cc->capabilities) & CC_CAP_FLASH_MASK) {
+		case PFLASH:
+			lim = SI_FLASH2_SZ;
+			break;
+
+		case SFLASH_ST:
+		case SFLASH_AT:
+			if ((info = sflash_init(sih, cc)) == NULL)
+				return -1;
+			lim = info->size;
+			break;
+
+		case FLASH_NONE:
+		default:
+			return -1;
+		}
+	} else {
+		/* extif assumed, Stop at 4 MB */
+		base = KSEG1ADDR(SI_FLASH1);
+		lim = SI_FLASH1_SZ;
+	}
+
+	off = FLASH_MIN;
+	while (off <= lim) {
+		/* Windowed flash access */
+		header = (struct nvram_header *) KSEG1ADDR(base + off - NVRAM_SPACE);
+		if (header->magic == NVRAM_MAGIC)
+			if (nvram_calc_crc(header) == (uint8) header->crc_ver_init) {
+				goto found;
+			}
+		off <<= 1;
+	}
+
+	/* Try embedded NVRAM at 4 KB and 1 KB as last resorts */
+	header = (struct nvram_header *) KSEG1ADDR(base + 4 KB);
+	if (header->magic == NVRAM_MAGIC)
+		if (nvram_calc_crc(header) == (uint8) header->crc_ver_init) {
+			goto found;
+		}
+
+	header = (struct nvram_header *) KSEG1ADDR(base + 1 KB);
+	if (header->magic == NVRAM_MAGIC)
+		if (nvram_calc_crc(header) == (uint8) header->crc_ver_init) {
+			goto found;
+		}
+
+	return -1;
+
+found:
+	src = (u32 *) header;
+	dst = (u32 *) nvram_buf;
+	for (i = 0; i < sizeof(struct nvram_header); i += 4)
+		*dst++ = *src++;
+	for (; i < header->len && i < NVRAM_SPACE; i += 4)
+		*dst++ = ltoh32(*src++);
+
+	return 0;
+}
+
+/* Early (before mm or mtd) read-only access to NVRAM */
+static char *
+early_nvram_get(const char *name)
+{
+	char *var, *value, *end, *eq;
+
+	if (!name)
+		return NULL;
+
+	/* Too early? */
+	if (sih == NULL)
+		return NULL;
+
+	if (!nvram_buf[0])
+		if (early_nvram_init() != 0) {
+			printk("early_nvram_get: Failed reading nvram var %s\n", name);
+			return NULL;
+		}
+
+	/* Look for name=value and return value */
+	var = &nvram_buf[sizeof(struct nvram_header)];
+	end = nvram_buf + sizeof(nvram_buf) - 2;
+	end[0] = end[1] = '\0';
+	for (; *var; var = value + strlen(value) + 1) {
+		if (!(eq = strchr(var, '=')))
+			break;
+		value = eq + 1;
+		if ((eq - var) == strlen(name) && strncmp(var, name, (eq - var)) == 0)
+			return value;
+	}
+
+	return NULL;
+}
+
+static int
+early_nvram_getall(char *buf, int count)
+{
+	char *var, *end;
+	int len = 0;
+
+	/* Too early? */
+	if (sih == NULL)
+		return -1;
+
+	if (!nvram_buf[0])
+		if (early_nvram_init() != 0) {
+			printk("early_nvram_getall: Failed reading nvram var\n");
+			return -1;
+		}
+
+	bzero(buf, count);
+
+	/* Write name=value\0 ... \0\0 */
+	var = &nvram_buf[sizeof(struct nvram_header)];
+	end = nvram_buf + sizeof(nvram_buf) - 2;
+	end[0] = end[1] = '\0';
+	for (; *var; var += strlen(var) + 1) {
+		if ((count - len) <= (strlen(var) + 1))
+			break;
+		len += sprintf(buf + len, "%s", var) + 1;
+	}
+
+	return 0;
+}
+#endif /* !MODULE */
+
+extern char * _nvram_get(const char *name);
+extern int _nvram_set(const char *name, const char *value);
+extern int _nvram_unset(const char *name);
+extern int _nvram_getall(char *buf, int count);
+extern int _nvram_commit(struct nvram_header *header);
+extern int _nvram_init(void *sih);
+extern void _nvram_exit(void);
+
+/* Globals */
+static spinlock_t nvram_lock = SPIN_LOCK_UNLOCKED;
+static struct semaphore nvram_sem;
+static unsigned long nvram_offset = 0;
+static int nvram_major = -1;
+static struct class *nvram_class = NULL;
+static struct mtd_info *nvram_mtd = NULL;
+
+int
+_nvram_read(char *buf)
+{
+	struct nvram_header *header = (struct nvram_header *) buf;
+	size_t len;
+
+	if (!nvram_mtd ||
+	    nvram_mtd->read(nvram_mtd, nvram_mtd->size - NVRAM_SPACE, NVRAM_SPACE, &len, buf) ||
+	    len != NVRAM_SPACE ||
+	    header->magic != NVRAM_MAGIC) {
+		/* Maybe we can recover some data from early initialization */
+		memcpy(buf, nvram_buf, NVRAM_SPACE);
+	}
+
+	return 0;
+}
+
+struct nvram_tuple *
+_nvram_realloc(struct nvram_tuple *t, const char *name, const char *value)
+{
+	if ((nvram_offset + strlen(value) + 1) > NVRAM_SPACE)
+		return NULL;
+
+	if (!t) {
+		if (!(t = kmalloc(sizeof(struct nvram_tuple) + strlen(name) + 1, GFP_ATOMIC)))
+			return NULL;
+
+		/* Copy name */
+		t->name = (char *) &t[1];
+		strcpy(t->name, name);
+
+		t->value = NULL;
+	}
+
+	/* Copy value */
+	if (!t->value || strcmp(t->value, value)) {
+		t->value = &nvram_buf[nvram_offset];
+		strcpy(t->value, value);
+		nvram_offset += strlen(value) + 1;
+	}
+
+	return t;
+}
+
+void
+_nvram_free(struct nvram_tuple *t)
+{
+	if (!t)
+		nvram_offset = 0;
+	else
+		kfree(t);
+}
+
+int
+nvram_init(void *sih)
+{
+	return 0;
+}
+
+int
+nvram_set(const char *name, const char *value)
+{
+	unsigned long flags;
+	int ret;
+	struct nvram_header *header;
+	char wps_name[32];
+	int wep_len;
+
+	spin_lock_irqsave(&nvram_lock, flags);
+
+	//printk("nvram_set: name = %s, value = %s!\n", name, value);
+#ifdef CFE_UPDATE //write back to default sector as well, Chen-I
+        if(strncmp(name, CFE_NVRAM_PREFIX, strlen(CFE_NVRAM_PREFIX))==0)
+        {
+                if(strcmp(name, CFE_NVRAM_COMMIT)==0)
+                        cfe_commit();
+                else if(strcmp(name, "asuscfe_dump") == 0)
+                        ret = cfe_dump();
+                else if(strcmp(name, CFE_NVRAM_WATCHDOG)==0)
+                {
+                        bcm947xx_watchdog_disable();
+                }
+                else
+                {
+                        cfe_update(name+strlen(CFE_NVRAM_PREFIX), value);
+                        _nvram_set(name+strlen(CFE_NVRAM_PREFIX), value);
+                }
+        }
+        else
+#endif
+
+#if WPS
+	if (strncmp(name, "wlx_", 4) == 0) {
+		memset(wps_name, 0, sizeof(wps_name));
+		sprintf(wps_name, "wl0_%s", name+4);
+		ret = _nvram_set(wps_name, value);
+		spin_unlock_irqrestore(&nvram_lock, flags);
+                return ret;
+	}
+
+	if (strncmp(name, "wl0_", 4) == 0) 
+	{
+		/* Authentication mode */
+		if (strncmp(name, "wl0_akm", 7) == 0) {
+			if (strncmp(value, "psk2", 4) == 0) { 		// WPA2-Personal
+        	                _nvram_set("wl_auth_mode", "psk");
+	                        _nvram_set("wl_wpa_mode", "2");
+			}
+		        else if (strncmp(value, "psk ", 4) == 0) { 	// WPA-Auto-Personal
+        	                _nvram_set("wl_auth_mode", "psk");
+                	        _nvram_set("wl_wpa_mode", "0");
+	                }
+                	else if (strncmp(value, "psk", 3) == 0) { 	// WPA-Personal
+        	                _nvram_set("wl_auth_mode", "psk");
+                	        _nvram_set("wl_wpa_mode", "1");
+	                }
+        	        else if (strncmp(value, "wpa2", 4) == 0) {	// WPA2-Enterprise
+                	        _nvram_set("wl_auth_mode", "wpa2");
+        	        }
+		        else if (strncmp(value, "wpa ", 4) == 0) {	// WPA-Auto-Enterprise
+	                       	_nvram_set("wl_wpa_mode", "4");
+        	                _nvram_set("wl_auth_mode", "wpa");
+                	}
+                	else if (strncmp(value, "wpa", 3) == 0) {	// WPA-Enterprise
+	                       	_nvram_set("wl_wpa_mode", "3");
+        	                _nvram_set("wl_auth_mode", "wpa");
+                	}
+			_nvram_set("wl_akm", value);
+		}
+		/* WPS KEY*/
+		else if (strcmp(name, "wl0_wpa_psk") == 0) {
+			_nvram_set("wl_wpa_psk", value);
+		}
+		/* WEP type */
+#if 1
+		else if ((strncmp(name, "wl0_key", 7) == 0 )) {
+
+			wep_len = strlen (value);
+			memset(wps_name, 0, sizeof(wps_name));
+
+			if ((wep_len == 5) || (wep_len == 10)) { /* wl0_key1~4*/
+//				_nvram_set ("wl0_wep_x", "1");
+				_nvram_set ("wl_wep_x", "1");
+				sprintf(wps_name, "wl_%s", name+4);
+			}
+			else if ((wep_len == 13) || (wep_len == 26)) { 
+//				_nvram_set ("wl0_wep_x", "2");
+				_nvram_set ("wl_wep_x", "2");
+				sprintf(wps_name, "wl_%s", name+4);
+			}
+			else { /* wl0_key index */
+				sprintf(wps_name, "wl_%s", name+4);
+			}
+			_nvram_set(wps_name, value);
+		}
+#endif
+		else if (strcmp(name, "wl0_ssid") == 0) {
+	//		_nvram_set("wl0_ssid2", value);
+	//		_nvram_set("wl_ssid2", value);
+			_nvram_set("wl_ssid", value);
+		}	
+		else if (strcmp(name, "wl0_crypto") == 0) {
+			_nvram_set("wl_crypto", value);
+		}
+		else if (strncmp(name, "wl0_wps", 7) == 0) {
+			memset(wps_name, 0, sizeof(wps_name));
+			sprintf(wps_name, "wl_%s", name+4);
+			_nvram_set(wps_name, value);
+		}
+
+	}
+	else if (strncmp(name, "wps_random_ssid_prefix", 22) == 0) {
+		memset(wps_name, 0, sizeof(wps_name));
+		sprintf(wps_name, "ASUS_");
+		ret = _nvram_set("wps_random_ssid_prefix", wps_name);
+		spin_unlock_irqrestore(&nvram_lock, flags);
+		return ret;
+	}
+
+	if ((strcmp(name, "wl_wps_config_state") == 0) || (strcmp(name, "wl0_wps_config_state") == 0))
+		_nvram_set("wps_config_state", value);
+//	else if ((strncmp(name, "wps_proc_status", 15) == 0 ) && (strcmp(value, "4"))) /* WPS success*/
+//		_nvram_set("wps_config_state", "1");
+
+#if 0
+	if(!strcmp(name, "wl0_ssid"))
+		_nvram_set("wl_ssid", value);
+	if(!strcmp(name, "wl0_ssid"))
+		_nvram_set("wl_ssid", value);
+        /* Set Wireless encryption */
+        if (!strcmp(name, "wl0_akm")) {
+		_nvram_set("wl_auth_mode", "psk");
+                _nvram_set("wl_wpa_mode", "1");
+	}
+	else if (!strcmp("wl0_akm", "psk2")) {
+                _nvram_set("wl_auth_mode", "psk");
+                _nvram_set("wl_wpa_mode", "2");
+        }
+        else if (nvram_match("wl0_akm", "wpa")) {
+                _nvram_set("wl_auth_mode", "wpa");
+                _nvram_set("wl_wpa_mode", "3");
+        }
+        else if (nvram_match("wl0_akm", "wpa2")) {
+                _nvram_set("wl_auth_mode", "wpa2");
+        }
+        else
+                _nvram_set("wl_auth_mode", nvram_get("wl0_auth_mode"));
+#endif
+#endif
+
+	if ((ret = _nvram_set(name, value))) {
+		/* Consolidate space and try again */
+		if ((header = kmalloc(NVRAM_SPACE, GFP_ATOMIC))) {
+			if (_nvram_commit(header) == 0)
+				ret = _nvram_set(name, value);
+			kfree(header);
+		}
+	}
+	spin_unlock_irqrestore(&nvram_lock, flags);
+
+	return ret;
+}
+
+char *
+real_nvram_get(const char *name)
+{
+	unsigned long flags;
+	char *value;
+
+	spin_lock_irqsave(&nvram_lock, flags);
+	value = _nvram_get(name);
+	spin_unlock_irqrestore(&nvram_lock, flags);
+
+	return value;
+}
+
+char *
+nvram_get(const char *name)
+{
+	if (nvram_major >= 0)
+		return real_nvram_get(name);
+	else
+		return early_nvram_get(name);
+}
+
+int
+nvram_unset(const char *name)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&nvram_lock, flags);
+#ifdef CFE_UPDATE //unset variable in embedded nvram
+        if(strncmp(name, CFE_NVRAM_PREFIX, strlen(CFE_NVRAM_PREFIX))==0)
+        {
+                if((ret = cfe_update(name+strlen(CFE_NVRAM_PREFIX), NULL)) == 0)
+                {
+                        ret = _nvram_unset(name+strlen(CFE_NVRAM_PREFIX));
+                }
+        }
+        else
+#endif
+	ret = _nvram_unset(name);
+	spin_unlock_irqrestore(&nvram_lock, flags);
+
+	return ret;
+}
+
+static void
+erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *) done->priv;
+	wake_up(wait_q);
+}
+
+int
+nvram_commit(void)
+{
+	char *buf;
+	size_t erasesize, len, magic_len;
+	unsigned int i;
+	int ret;
+	struct nvram_header *header;
+	unsigned long flags;
+	u_int32_t offset;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	struct erase_info erase;
+	u_int32_t magic_offset = 0; /* Offset for writing MAGIC # */
+
+	if (!nvram_mtd) {
+		printk("nvram_commit: NVRAM not found\n");
+		return -ENODEV;
+	}
+
+	if (in_interrupt()) {
+		printk("nvram_commit: not committing in interrupt\n");
+		return -EINVAL;
+	}
+
+	/* Backup sector blocks to be erased */
+	erasesize = ROUNDUP(NVRAM_SPACE, nvram_mtd->erasesize);
+	if (!(buf = kmalloc(erasesize, GFP_KERNEL))) {
+		printk("nvram_commit: out of memory\n");
+		return -ENOMEM;
+	}
+
+	down(&nvram_sem);
+
+	if ((i = erasesize - NVRAM_SPACE) > 0) {
+		offset = nvram_mtd->size - erasesize;
+		len = 0;
+		ret = nvram_mtd->read(nvram_mtd, offset, i, &len, buf);
+		if (ret || len != i) {
+			printk("nvram_commit: read error ret = %d, len = %d/%d\n", ret, len, i);
+			ret = -EIO;
+			goto done;
+		}
+		header = (struct nvram_header *)(buf + i);
+		magic_offset = i + ((void *)&header->magic - (void *)header);
+	} else {
+		offset = nvram_mtd->size - NVRAM_SPACE;
+		magic_offset = ((void *)&header->magic - (void *)header);
+		header = (struct nvram_header *)buf;
+	}
+
+	/* clear the existing magic # to mark the NVRAM as unusable 
+	 * we can pull MAGIC bits low without erase
+	 */
+	header->magic = NVRAM_CLEAR_MAGIC; /* All zeros magic */
+	/* Unlock sector blocks */
+	if (nvram_mtd->unlock)
+		nvram_mtd->unlock(nvram_mtd, offset, nvram_mtd->erasesize);
+	ret = nvram_mtd->write(nvram_mtd, offset + magic_offset, sizeof(header->magic),
+		&magic_len, (char *)&header->magic);
+	if (ret || magic_len != sizeof(header->magic)) {
+		printk("nvram_commit: clear MAGIC error\n");
+		ret = -EIO;
+		goto done;
+	}
+
+	header->magic = NVRAM_MAGIC;
+	/* reset MAGIC before we regenerate the NVRAM,
+	 * otherwise we'll have an incorrect CRC
+	 */
+	/* Regenerate NVRAM */
+	spin_lock_irqsave(&nvram_lock, flags);
+	ret = _nvram_commit(header);
+	spin_unlock_irqrestore(&nvram_lock, flags);
+	if (ret)
+		goto done;
+
+	/* Erase sector blocks */
+	init_waitqueue_head(&wait_q);
+	for (; offset < nvram_mtd->size - NVRAM_SPACE + header->len;
+		offset += nvram_mtd->erasesize) {
+
+		erase.mtd = nvram_mtd;
+		erase.addr = offset;
+		erase.len = nvram_mtd->erasesize;
+		erase.callback = erase_callback;
+		erase.priv = (u_long) &wait_q;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&wait_q, &wait);
+
+		/* Unlock sector blocks */
+		if (nvram_mtd->unlock)
+			nvram_mtd->unlock(nvram_mtd, offset, nvram_mtd->erasesize);
+
+		if ((ret = nvram_mtd->erase(nvram_mtd, &erase))) {
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			printk("nvram_commit: erase error\n");
+			goto done;
+		}
+
+		/* Wait for erase to finish */
+		schedule();
+		remove_wait_queue(&wait_q, &wait);
+	}
+
+	/* Write partition up to end of data area */
+	header->magic = NVRAM_INVALID_MAGIC; /* All ones magic */
+	offset = nvram_mtd->size - erasesize;
+	i = erasesize - NVRAM_SPACE + header->len;
+	ret = nvram_mtd->write(nvram_mtd, offset, i, &len, buf);
+	if (ret || len != i) {
+		printk("nvram_commit: write error\n");
+		ret = -EIO;
+		goto done;
+	}
+
+	/* Now mark the NVRAM in flash as "valid" by setting the correct
+	 * MAGIC #
+	 */
+	header->magic = NVRAM_MAGIC;
+	ret = nvram_mtd->write(nvram_mtd, offset + magic_offset, sizeof(header->magic),
+		&magic_len, (char *)&header->magic);
+	if (ret || magic_len != sizeof(header->magic)) {
+		printk("nvram_commit: write MAGIC error\n");
+		ret = -EIO;
+		goto done;
+	}
+
+	offset = nvram_mtd->size - erasesize;
+	ret = nvram_mtd->read(nvram_mtd, offset, 4, &len, buf);
+
+done:
+	up(&nvram_sem);
+	kfree(buf);
+	return ret;
+}
+
+int
+nvram_getall(char *buf, int count)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&nvram_lock, flags);
+	if (nvram_major >= 0)
+		ret = _nvram_getall(buf, count);
+	else
+		ret = early_nvram_getall(buf, count);
+	spin_unlock_irqrestore(&nvram_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(nvram_init);
+EXPORT_SYMBOL(nvram_get);
+EXPORT_SYMBOL(nvram_getall);
+EXPORT_SYMBOL(nvram_set);
+EXPORT_SYMBOL(nvram_unset);
+EXPORT_SYMBOL(nvram_commit);
+
+/* User mode interface below */
+
+static ssize_t
+dev_nvram_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	char tmp[100], *name = tmp, *value;
+	ssize_t ret;
+	unsigned long off;
+
+	if (count > sizeof(tmp)) {
+		if (!(name = kmalloc(count, GFP_KERNEL)))
+			return -ENOMEM;
+	}
+
+	if (copy_from_user(name, buf, count)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (*name == '\0') {
+		/* Get all variables */
+		ret = nvram_getall(name, count);
+		if (ret == 0) {
+			if (copy_to_user(buf, name, count)) {
+				ret = -EFAULT;
+				goto done;
+			}
+			ret = count;
+		}
+	} else {
+		if (!(value = nvram_get(name))) {
+			ret = 0;
+			goto done;
+		}
+
+		/* Provide the offset into mmap() space */
+		off = (unsigned long) value - (unsigned long) nvram_buf;
+
+		if (put_user(off, (unsigned long *) buf)) {
+			ret = -EFAULT;
+			goto done;
+		}
+
+		ret = sizeof(unsigned long);
+	}
+
+	flush_cache_all();
+
+done:
+	if (name != tmp)
+		kfree(name);
+
+	return ret;
+}
+
+static ssize_t
+dev_nvram_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	char tmp[100], *name = tmp, *value;
+	ssize_t ret;
+
+	if (count > sizeof(tmp)) {
+		if (!(name = kmalloc(count, GFP_KERNEL)))
+			return -ENOMEM;
+	}
+
+	if (copy_from_user(name, buf, count)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	value = name;
+	name = strsep(&value, "=");
+	if (value)
+		ret = nvram_set(name, value) ? : count;
+	else
+		ret = nvram_unset(name) ? : count;
+
+done:
+	if (name != tmp)
+		kfree(name);
+
+	return ret;
+}
+
+static int
+dev_nvram_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	if (cmd != NVRAM_MAGIC)
+		return -EINVAL;
+
+#ifndef NLS_XFR
+	return nvram_commit();
+#else
+	if(arg == 0)
+		return nvram_commit();
+	else
+		return nvram_xfr((char *)arg);
+#endif	// NLS_XFR
+}
+
+static int
+dev_nvram_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long offset = __pa(nvram_buf) >> PAGE_SHIFT;
+
+	if (remap_pfn_range(vma, vma->vm_start, offset,
+	                    vma->vm_end - vma->vm_start,
+	                    vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int
+dev_nvram_open(struct inode *inode, struct file * file)
+{
+	return 0;
+}
+
+static int
+dev_nvram_release(struct inode *inode, struct file * file)
+{
+	return 0;
+}
+
+static struct file_operations dev_nvram_fops = {
+	owner:		THIS_MODULE,
+	open:		dev_nvram_open,
+	release:	dev_nvram_release,
+	read:		dev_nvram_read,
+	write:		dev_nvram_write,
+	ioctl:		dev_nvram_ioctl,
+	mmap:		dev_nvram_mmap
+};
+
+static void
+dev_nvram_exit(void)
+{
+	int order = 0;
+	struct page *page, *end;
+
+	if (nvram_class) {
+		class_device_destroy(nvram_class, MKDEV(nvram_major, 0));
+		class_destroy(nvram_class);
+	}
+
+	if (nvram_major >= 0)
+		unregister_chrdev(nvram_major, "nvram");
+
+	if (nvram_mtd)
+		put_mtd_device(nvram_mtd);
+
+	while ((PAGE_SIZE << order) < NVRAM_SPACE)
+		order++;
+	end = virt_to_page(nvram_buf + (PAGE_SIZE << order) - 1);
+	for (page = virt_to_page(nvram_buf); page <= end; page++)
+		ClearPageReserved(page);
+
+	_nvram_exit();
+}
+
+static int
+dev_nvram_init(void)
+{
+	int order = 0, ret = 0;
+	struct page *page, *end;
+	unsigned int i;
+	osl_t *osh;
+
+	/* Allocate and reserve memory to mmap() */
+	while ((PAGE_SIZE << order) < NVRAM_SPACE)
+		order++;
+	end = virt_to_page(nvram_buf + (PAGE_SIZE << order) - 1);
+	for (page = virt_to_page(nvram_buf); page <= end; page++) {
+		SetPageReserved(page);
+	}
+
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+	/* Find associated MTD device */
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		nvram_mtd = get_mtd_device(NULL, i);
+		if (!IS_ERR(nvram_mtd)) {
+			if (!strcmp(nvram_mtd->name, "nvram") &&
+			    nvram_mtd->size >= NVRAM_SPACE) {
+				break;
+			}
+			put_mtd_device(nvram_mtd);
+		}
+	}
+	if (i >= MAX_MTD_DEVICES)
+		nvram_mtd = NULL;
+#endif
+
+	/* Initialize hash table lock */
+	spin_lock_init(&nvram_lock);
+
+	/* Initialize commit semaphore */
+	init_MUTEX(&nvram_sem);
+
+	/* Register char device */
+	if ((nvram_major = register_chrdev(0, "nvram", &dev_nvram_fops)) < 0) {
+		ret = nvram_major;
+		goto err;
+	}
+
+	if (si_osh(sih) == NULL) {
+		osh = osl_attach(NULL, SI_BUS, FALSE);
+		if (osh == NULL) {
+			printk("Error allocating osh\n");
+			unregister_chrdev(nvram_major, "nvram");
+			goto err;
+		}
+		si_setosh(sih, osh);
+	}
+
+	/* Initialize hash table */
+	_nvram_init(sih);
+
+	/* Create /dev/nvram handle */
+	nvram_class = class_create(THIS_MODULE, "nvram");
+	if (IS_ERR(nvram_class)) {
+		printk("Error creating nvram class\n");
+		goto err;
+	}
+
+	/* Add the device nvram0 */
+	class_device_create(nvram_class, NULL, MKDEV(nvram_major, 0), NULL, "nvram");
+
+	/* Set the SDRAM NCDL value into NVRAM if not already done */
+	if (getintvar(NULL, "sdram_ncdl") == 0) {
+		unsigned int ncdl;
+		char buf[] = "0x00000000";
+
+		if ((ncdl = si_memc_get_ncdl(sih))) {
+			sprintf(buf, "0x%08x", ncdl);
+			nvram_set("sdram_ncdl", buf);
+			nvram_commit();
+		}
+	}
+
+	return 0;
+
+err:
+	dev_nvram_exit();
+	return ret;
+}
+
+#ifdef CFE_UPDATE
+int get_embedded_block(struct mtd_info *mtd, char *buf, size_t erasesize,
+                       u_int32_t *offset, struct nvram_header **header, u_int32_t *emb_size)
+{
+        size_t len;
+        struct nvram_header *nvh;
+
+#ifdef CONFIG_RTAN23 /*for AMCC RTAN23 */
+        *offset = mtd->size - erasesize; /*/at the end of mtd */
+        *emb_size = 8*1024 - 16; /*/8K - 16 byte */
+        printk("get_embedded_block: mtd->size(%08x) erasesize(%08x) offset(%08x) emb_size(%08x)\n", mtd->size, erasesize, *offset, *emb_size);
+        cfe_mtd->read(mtd, *offset, erasesize, &len, buf);
+        if(len != erasesize)
+                return -EIO;
+
+        /* find nvram header */
+        nvh = (struct nvram_header *)(buf + erasesize - 8*1024);
+        if (nvh->magic == NVRAM_MAGIC)
+        {
+                *header = nvh;
+                return 0;
+        }
+
+#else /* for Broadcom WL500 serials */
+        *offset = 0; /* from the mtd start */
+        *emb_size = 4096; /* 1K byte */
+        printk("get_embedded_block: mtd->size(%08x) erasesize(%08x) offset(%08x) emb_size(%08x)\n", mtd->size, erasesize, *offset, *emb_size);
+        cfe_mtd->read(mtd, *offset, erasesize, &len, buf);
+        if(len != erasesize)
+                return -EIO;
+
+        /* find nvram header */
+        nvh = (struct nvram_header *)(buf + (4 * 1024));
+        if (nvh->magic == NVRAM_MAGIC)
+        {
+                *header = nvh;
+                return 0;
+        }
+        nvh = (struct nvram_header *)(buf + (1 * 1024));
+        if (nvh->magic == NVRAM_MAGIC)
+        {
+                *header = nvh;
+                return 0;
+        }
+#endif
+        printk("get_embedded_block: no nvram magic found\n");
+        return -ENXIO;
+}
+static int cfe_init(void)
+{
+        size_t erasesize;
+        int i;
+        int ret = 0;
+
+        /* Find associated MTD device */
+        for (i = 0; i < MAX_MTD_DEVICES; i++) {
+                cfe_mtd = get_mtd_device(NULL, i);
+                if (cfe_mtd != NULL) {
+                        printk("cfe_init: CFE MTD %x %s %x\n", i, cfe_mtd->name, cfe_mtd->size);
+                        if (!strcmp(cfe_mtd->name, "boot"))
+                                break;
+                        put_mtd_device(cfe_mtd);
+                }
+        }
+        if (i >= MAX_MTD_DEVICES)
+        {
+                printk("cfe_init: No CFE MTD\n");
+                cfe_mtd = NULL;
+                ret = -ENODEV;
+        }
+
+        if(cfe_mtd == NULL) goto fail;
+
+        /* sector blocks to be erased and backup */
+        erasesize = ROUNDUP(CFE_NVRAM_SPACE, cfe_mtd->erasesize);
+
+	//printk("cfe_init: block size %d\n", erasesize);
+        cfe_buf = kmalloc(erasesize, GFP_KERNEL);
+
+        if(cfe_buf == NULL)
+        {
+                //printk("cfe_init: No CFE Memory\n");
+                ret = -ENOMEM;
+                goto fail;
+        }
+        if((ret = get_embedded_block(cfe_mtd, cfe_buf, erasesize, &cfe_offset, &cfe_nvram_header, &cfe_embedded_size)))
+                goto fail;
+
+        printk("cfe_init: cfe_nvram_header(%08x)\n", (unsigned int) cfe_nvram_header);
+	bcm947xx_watchdog_disable();
+
+        return 0;
+
+fail:
+        if (cfe_mtd != NULL)
+        {
+                put_mtd_device(cfe_mtd);
+                cfe_mtd=NULL;
+        }
+        if(cfe_buf != NULL)
+        {
+                kfree(cfe_buf);
+                cfe_buf=NULL;
+        }
+        return ret;
+}
+static int cfe_update(const char *keyword, const char *value)
+{
+        struct nvram_header *header;
+        uint8 crc;
+        int ret;
+        int found = 0;
+        char *str, *end, *mv_target = NULL, *mv_start = NULL;
+
+        if(keyword == NULL || *keyword == 0)
+                return 0;
+
+        if(cfe_buf == NULL||cfe_mtd == NULL)
+                if((ret = cfe_init()))
+                        return ret;
+
+        header = cfe_nvram_header;
+
+	//printk("cfe_update: before %x %x\n", header->len,  cfe_nvram_header->crc_ver_init&0xff);
+        str = (char *) &header[1];
+        end = (char *) header + cfe_embedded_size - 2;
+        end[0] = end[1] = '\0';
+        for (; *str; str += strlen(str) + 1)
+        {
+                if(!found)
+                {
+                        if(strncmp(str, keyword, strlen(keyword)) == 0 && str[strlen(keyword)] == '=')
+                        {
+                                printk("cfe_update: !!!! found !!!!\n");
+                                found = 1;
+                                if(value != NULL && strlen(str) == strlen(keyword) + 1 + strlen(value))
+                                {//string length is the same
+                                        strcpy(str+strlen(keyword)+1, value);
+                                }
+                                else
+                                {
+                                        mv_target = str;
+                                        mv_start = str + strlen(str) + 1;
+                                }
+                        }
+                }
+        }
+        /* str point to the end of all embedded nvram settings */
+
+        if(mv_target != NULL)
+        { /* need to move string */
+                int str_len = strlen(mv_target);
+                printk("cfe_update: mv_target(%08x) mv_start(%08x) str(%08x) str_len(%d)\n", (unsigned int)mv_target, (unsigned int)mv_start, (unsigned int)str, str_len);
+                if(value != NULL && (str + strlen(keyword) + 1 + strlen(value) + 1 - (str_len + 1)) > end)
+                        return -ENOSPC;
+                memmove(mv_target, mv_start, str - mv_start);
+                printk("cfe_update: memmove done\n");
+                str -= (str_len + 1); /* /set str to the end for placing incoming keyword and value there */
+        }
+
+        if(value == NULL)
+        {
+                printk("cfe_update: do unset\n");
+        }
+        else if(!found || mv_target != NULL) /*new or movement */
+        { /* append the keyword and value here */
+                printk("cfe_update: str(%08x)\n", (unsigned int) str);
+                if((str + strlen(keyword) + 1 + strlen(value) + 1) > end)
+                        return -ENOSPC;
+                str += sprintf(str, "%s=%s", keyword, value) + 1;
+                printk("cfe_update: append string\n");
+        }
+/* calc length */
+        memset(str, 0, cfe_embedded_size+(char *)header - str);
+        str += 2;
+        header->len = ROUNDUP(str - (char *) header, 4);
+        printk("cfe_update: header len: %x\n", header->len);
+/*/calc crc */
+        crc = nvram_calc_crc(header);
+        printk("cfe_update: nvram_calc_crc(header) = 0x%02x\n", crc);
+        header->crc_ver_init = (header->crc_ver_init & NVRAM_CRC_VER_MASK)|crc;
+        /*/printk("cfe_update: after %x %x\n", header->crc_ver_init&0xFF, crc); */
+        return 0;
+}
+static int cfe_dump(void)
+{
+        unsigned int i;
+        int ret;
+        unsigned char *ptr;
+
+        if(cfe_buf == NULL||cfe_mtd == NULL)
+                if((ret = cfe_init()))
+                        return ret;
+
+        printk("cfe_dump: cfe_buf(%08x), dump 1024 byte\n", (unsigned int)cfe_buf);
+        for(i=0, ptr=(unsigned char *)cfe_nvram_header - 1024; ptr < (unsigned char *)cfe_nvram_header; i++, ptr++)
+        {
+                if(i%16==0) printk("%04x: %02x ", i, *ptr);
+                else if(i%16==15) printk("%02x\n", *ptr);
+                else if(i%16==7) printk("%02x - ", *ptr);
+                else printk("%02x ", *ptr);
+        }
+
+        printk("\ncfe_dump: cfe_nvram_header(%08x)\n", (unsigned int)cfe_nvram_header);
+        printk("cfe_dump: cfe_nvram_header->len(0x%08x)\n", cfe_nvram_header->len);
+
+        printk("\n####################\n");
+        for(i=0, ptr=(unsigned char *)cfe_nvram_header; i< cfe_embedded_size; i++, ptr++)
+        {
+                if(i%16==0) printk("%04x: %02x ", i, *ptr);
+                else if(i%16==15) printk("%02x\n", *ptr);
+                else if(i%16==7) printk("%02x - ", *ptr);
+                else printk("%02x ", *ptr);
+        }
+        printk("\n####################\n");
+        ptr = (unsigned char *)&cfe_nvram_header[1];
+        while(*ptr)
+        {
+                printk("%s\n", ptr);
+                ptr += strlen(ptr) + 1;
+        }
+        printk("\n####################\n");
+        for(i=0, ptr=((unsigned char *)cfe_nvram_header) + cfe_embedded_size; i<16; i++, ptr++)
+        {
+                if(i%16==0) printk("%04x: %02x ", i, *ptr);
+                else if(i%16==15) printk("%02x\n", *ptr);
+                else if(i%16==7) printk("%02x - ", *ptr);
+                else printk("%02x ", *ptr);
+        }
+        return 0;
+}
+
+static int cfe_commit(void)
+{
+        DECLARE_WAITQUEUE(wait, current);
+        wait_queue_head_t wait_q;
+        struct erase_info erase;
+        int ret = 0;
+        size_t erasesize, len=0;
+        u_int32_t offset;
+
+        if(cfe_mtd == NULL||cfe_buf == NULL)
+        {
+                printk("cfe_commit: do nothing\n");
+                return 0;
+        }
+
+#if 0
+        ret = cfe_dump();
+        return ret;
+#endif
+#if 1
+        /* Backup sector blocks to be erased */
+        erasesize = ROUNDUP(CFE_NVRAM_SPACE, cfe_mtd->erasesize);
+        printk("cfe_commit: erasesize(%08x) cfe_offset(%08x)\n", erasesize, cfe_offset);
+
+        /* Erase sector blocks */
+        init_waitqueue_head(&wait_q);
+        for (offset=cfe_offset;offset < cfe_offset+erasesize;offset += cfe_mtd->erasesize) {
+           printk("cfe_commit: ERASE sector block offset(%08x) cfe_mtd->erasesize(%08x)\n", offset, cfe_mtd->erasesize);
+           erase.mtd = cfe_mtd;
+           erase.addr = offset;
+           erase.len = cfe_mtd->erasesize;
+           erase.callback = erase_callback;
+           erase.priv = (u_long) &wait_q;
+
+           set_current_state(TASK_INTERRUPTIBLE);
+           add_wait_queue(&wait_q, &wait);
+           /* Unlock sector blocks */
+           if (cfe_mtd->unlock)
+                   cfe_mtd->unlock(cfe_mtd, offset, cfe_mtd->erasesize);
+
+           if ((ret = cfe_mtd->erase(cfe_mtd, &erase))) {
+                set_current_state(TASK_RUNNING);
+                remove_wait_queue(&wait_q, &wait);
+                printk("cfe_commit: erase error\n");
+                ret = -EIO;
+                goto done;
+           }
+
+           /* Wait for erase to finish */
+           schedule();
+           remove_wait_queue(&wait_q, &wait);
+        }
+
+        ret = cfe_mtd->write(cfe_mtd, cfe_offset, erasesize, &len, cfe_buf);
+        printk("cfe_commit: MTD_WRITE cfe_offset(%08x) erasesize(%08x) len(%08x) ret(%08x)\n", cfe_offset, erasesize, len, ret);
+
+        if (ret || len != erasesize) {
+           printk("cfe_commit: write error\n");
+           ret = -EIO;
+        }
+
+done:
+        if (cfe_mtd != NULL)
+        {
+                put_mtd_device(cfe_mtd);
+                cfe_mtd=NULL;
+        }
+        if(cfe_buf != NULL)
+        {
+                kfree(cfe_buf);
+                cfe_buf=NULL;
+        }
+        //printk("commit: %d\n", ret);
+        return ret;
+#endif
+}
+#endif
+
+
+//#ifdef CFE_UPDATE
+#if 0
+void cfe_init(void)
+{
+        size_t erasesize, len;
+        int i;
+
+        /* Find associated MTD device */
+        for (i = 0; i < MAX_MTD_DEVICES; i++) {
+                cfe_mtd = get_mtd_device(NULL, i);
+                if (cfe_mtd) {
+                        printk("CFE MTD: %x %s %x\n", i, cfe_mtd->name, cfe_mtd->size);
+                        if (!strcmp(cfe_mtd->name, "boot"))
+                                break;
+                        put_mtd_device(cfe_mtd);
+                }
+        }
+        if (i >= MAX_MTD_DEVICES)
+        {
+                printk("No CFE MTD\n");
+                cfe_mtd = NULL;
+        }
+
+        if(!cfe_mtd) goto fail;
+
+        /* sector blocks to be erased and backup */
+        erasesize = ROUNDUP(CFE_NVRAM_SPACE, cfe_mtd->erasesize);
+
+        /* printk("block size %d\n", erasesize); */
+
+        cfe_buf = kmalloc(erasesize, GFP_KERNEL);
+
+        if(!cfe_buf)
+        {
+                /* printk("No CFE Memory\n"); */
+                goto fail;
+        }
+        cfe_mtd->read(cfe_mtd, CFE_NVRAM_START, erasesize, &len, cfe_buf);
+
+        /* find nvram header */
+        for(i=0;i<len;i+=4)
+        {
+                cfe_nvram_header=(struct nvram_header *)&cfe_buf[i];
+                if (cfe_nvram_header->magic==NVRAM_MAGIC) break;
+        }
+
+        bcm947xx_watchdog_disable(); /*disable watchdog as well */
+
+#if 0                                                           
+        printf("read from nvram %d %s\n", i, cfe_buf);
+        for(i=0;i<CFE_SPACE;i++)
+        {
+              if(i%16) printk("\n");
+              printk("%02x ", (unsigned char)cfe_buf[i]);
+        }
+#endif
+        return;
+fail:
+        if (cfe_mtd)
+        {
+                put_mtd_device(cfe_mtd);
+                cfe_mtd=NULL;
+        }
+        if(cfe_buf)
+        {
+                kfree(cfe_buf);
+                cfe_buf=NULL;
+        }
+        return;
+}
+
+void cfe_update(const char *keyword, const char *value)
+{
+        unsigned long i, offset;
+        struct nvram_header tmp, *header;
+        uint8 crc;
+//        int ret;
+        int found = 0;
+
+        if(!cfe_buf||!cfe_mtd)
+                cfe_init();
+
+        if (!cfe_buf||!cfe_mtd) return;
+
+        header = cfe_nvram_header;
+
+        printk("before: %x %x\n", header->len,  cfe_nvram_header->crc_ver_init&0xff); 
+
+        for(i=CFE_NVRAM_START;i<=CFE_NVRAM_END;i++)
+        {
+                if(strncmp(&cfe_buf[i], keyword, strlen(keyword))==0)
+                {
+                        printk("before: %s\n", cfe_buf+i); 
+                        offset=strlen(keyword);
+                        memcpy(cfe_buf+i+offset+1, value, strlen(value));
+                        printk("after: %s\n", cfe_buf+i); 
+                        found = 1;
+                }
+        }
+
+        if(!found)
+        {
+                char *tmp_buf = (char *)cfe_nvram_header;
+
+                /* printk("header len: %x\n", header->len); */
+                sprintf(tmp_buf+header->len, "%s=%s", keyword, value);
+                header->len = header->len + strlen(keyword) + strlen(value) + 2;
+                /* printk("header len: %x\n", header->len); */
+        }
+
+        tmp.crc_ver_init = htol32(header->crc_ver_init);
+        tmp.config_refresh = htol32(header->config_refresh);
+        tmp.config_ncdl = htol32(header->config_ncdl);
+        crc = hndcrc8((char *) &tmp + 9, sizeof(struct nvram_header) - 9, CRC8_INIT_VALUE);
+
+        /* Continue CRC8 over data bytes */
+        crc = hndcrc8((char *) &header[1], header->len - sizeof(struct nvram_header), crc);
+        header->crc_ver_init = (header->crc_ver_init&0xFFFFFF00)|crc;
+        printk("after: %x %x\n", header->crc_ver_init&0xFF, crc); 
+}
+
+int cfe_commit(void)
+{
+        DECLARE_WAITQUEUE(wait, current);
+        wait_queue_head_t wait_q;
+        struct erase_info erase;
+//        unsigned int i;
+        int ret;
+        size_t erasesize, len;
+        u_int32_t offset;
+//        char *buf;
+
+        if(!cfe_buf||!cfe_mtd) cfe_init();
+
+        if(!cfe_mtd||!cfe_buf)
+        {
+                ret = - ENOMEM;
+                goto done;
+        }
+
+        /* Backup sector blocks to be erased */
+        erasesize = ROUNDUP(CFE_NVRAM_SPACE, cfe_mtd->erasesize);
+
+	down(&nvram_sem);
+
+        /* Erase sector blocks */
+        init_waitqueue_head(&wait_q);
+
+
+        for (offset=CFE_NVRAM_START;offset <= CFE_NVRAM_END;offset += cfe_mtd->erasesize) {
+           erase.mtd = cfe_mtd;
+           erase.addr = offset;
+           erase.len = cfe_mtd->erasesize;
+           erase.callback = erase_callback;
+           erase.priv = (u_long) &wait_q;
+
+           set_current_state(TASK_INTERRUPTIBLE);
+           add_wait_queue(&wait_q, &wait);
+           /* Unlock sector blocks */
+           if (cfe_mtd->unlock)
+                   cfe_mtd->unlock(cfe_mtd, offset, cfe_mtd->erasesize);
+
+           if ((ret = cfe_mtd->erase(cfe_mtd, &erase))) {
+                set_current_state(TASK_RUNNING);
+                remove_wait_queue(&wait_q, &wait);
+                printk("cfe_commit: erase error\n");
+                goto done;
+           }
+
+           /* Wait for erase to finish */
+           schedule();
+           remove_wait_queue(&wait_q, &wait);
+        }
+
+        ret = cfe_mtd->write(cfe_mtd, CFE_NVRAM_START, erasesize, &len, cfe_buf);
+        /* printk("Write offset: %x %x %x\n", ret, len, erasesize); */
+
+        if (ret || len != erasesize) {
+           printk("cfe_commit: write error\n");
+           ret = -EIO;
+        }
+
+done:
+	up(&nvram_sem);
+        if (cfe_mtd)
+        {
+                put_mtd_device(cfe_mtd);
+                cfe_mtd=NULL;
+        }
+        if(cfe_buf)
+        {
+                kfree(cfe_buf);
+                cfe_buf=NULL;
+        }
+        /* printk("commit: %d\n", ret); */
+        return ret;
+
+}
+#endif
+
+
+module_init(dev_nvram_init);
+module_exit(dev_nvram_exit);
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/pcibios.c linux-2.6/arch/mips/brcm-boards/bcm947xx/pcibios.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/pcibios.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/pcibios.c	2009-05-27 12:34:44.000000000 +0400
@@ -0,0 +1,363 @@
+/*
+ * Low-Level PCI and SB support for BCM47xx (Linux support code)
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: pcibios.c,v 1.8 2008/07/04 01:09:57 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/paccess.h>
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <hndcpu.h>
+#include <hndpci.h>
+#include <pcicfg.h>
+#include <bcmdevs.h>
+#include <bcmnvram.h>
+
+/* Global SB handle */
+extern si_t *bcm947xx_sih;
+extern spinlock_t bcm947xx_sih_lock;
+
+/* Convenience */
+#define sih bcm947xx_sih
+#define sih_lock bcm947xx_sih_lock
+
+static int
+sbpci_read_config_reg(struct pci_bus *bus, unsigned int devfn, int where,
+                      int size, u32 *value)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&sih_lock, flags);
+	ret = hndpci_read_config(sih, bus->number, PCI_SLOT(devfn),
+	                        PCI_FUNC(devfn), where, value, size);
+	spin_unlock_irqrestore(&sih_lock, flags);
+	return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static int
+sbpci_write_config_reg(struct pci_bus *bus, unsigned int devfn, int where,
+                       int size, u32 value)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&sih_lock, flags);
+	ret = hndpci_write_config(sih, bus->number, PCI_SLOT(devfn),
+	                         PCI_FUNC(devfn), where, &value, size);
+	spin_unlock_irqrestore(&sih_lock, flags);
+	return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops pcibios_ops = {
+	sbpci_read_config_reg,
+	sbpci_write_config_reg
+};
+
+static u32 pci_iobase = 0x100;
+static u32 pci_membase = SI_PCI_DMA;
+
+void __init
+pcibios_init(void)
+{
+	ulong flags;
+
+	/* For 4716, use sbtopcie0 to access the device. We
+	 * can't use address match 2 (1 GB window) region as MIPS
+	 * can not generate 64-bit address on the backplane.
+	 */
+	if (sih->chip == BCM4716_CHIP_ID) {
+		printk("PCI: Using membase %x\n", SI_PCI_MEM);
+		pci_membase = SI_PCI_MEM;
+	}
+
+	if (!(sih = si_kattach(SI_OSH)))
+		panic("si_kattach failed");
+	spin_lock_init(&sih_lock);
+
+	spin_lock_irqsave(&sih_lock, flags);
+	hndpci_init(sih);
+	spin_unlock_irqrestore(&sih_lock, flags);
+
+	set_io_port_base((unsigned long) ioremap_nocache(SI_PCI_MEM, 0x04000000));
+
+	/* Scan the SB bus */
+	pci_scan_bus(0, &pcibios_ops, NULL);
+}
+
+char * __init
+pcibios_setup(char *str)
+{
+	if (!strncmp(str, "ban=", 4)) {
+		hndpci_ban(simple_strtoul(str + 4, NULL, 0));
+		return NULL;
+	}
+
+	return (str);
+}
+
+void __init
+pcibios_fixup_bus(struct pci_bus *b)
+{
+	struct list_head *ln;
+	struct pci_dev *d, *dev;
+	struct resource *res;
+	int pos, size;
+	u32 *base;
+	u8 irq;
+
+	printk("PCI: Fixing up bus %d\n", b->number);
+
+	/* Fix up SB */
+	if (b->number == 0) {
+		for (ln = b->devices.next; ln != &b->devices; ln = ln->next) {
+			d = pci_dev_b(ln);
+			/* Fix up interrupt lines */
+			pci_read_config_byte(d, PCI_INTERRUPT_LINE, &irq);
+			d->irq = irq + 2;
+			pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+		}
+	} else {
+		/* Fix up external PCI */
+		for (ln = b->devices.next; ln != &b->devices; ln = ln->next) {
+			d = pci_dev_b(ln);
+			/* Fix up resource bases */
+			for (pos = 0; pos < 6; pos++) {
+				res = &d->resource[pos];
+				base = (res->flags & IORESOURCE_IO) ? &pci_iobase : &pci_membase;
+				if (res->end) {
+					size = res->end - res->start + 1;
+					if (*base & (size - 1))
+						*base = (*base + size) & ~(size - 1);
+					res->start = *base;
+					res->end = res->start + size - 1;
+					*base += size;
+					pci_write_config_dword(d,
+						PCI_BASE_ADDRESS_0 + (pos << 2), res->start);
+				}
+				/* Fix up PCI bridge BAR0 only */
+				if (b->number == 1 && PCI_SLOT(d->devfn) == 0)
+					break;
+			}
+			/* Fix up interrupt lines */
+			list_for_each_entry(dev, &((pci_find_bus(0, 0))->devices), bus_list) {
+				if ((dev != NULL) &&
+				    ((dev->device == PCI_CORE_ID) ||
+				    (dev->device == PCIE_CORE_ID)))
+					d->irq = dev->irq;
+			}
+			pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+		}
+		hndpci_arb_park(sih, PCI_PARK_NVRAM);
+	}
+}
+
+int
+pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return (dev->irq);
+}
+
+int
+pcibios_enable_resources(struct pci_dev *dev)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	/* External PCI only */
+	if (dev->bus->number == 0)
+		return 0;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for (idx = 0; idx < 6; idx++) {
+		r = &dev->resource[idx];
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (dev->resource[PCI_ROM_RESOURCE].start)
+		cmd |= PCI_COMMAND_MEMORY;
+	if (cmd != old_cmd) {
+		printk("PCI: Enabling device %s (%04x -> %04x)\n", pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+int
+pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	ulong flags;
+	uint coreidx;
+	void *regs;
+
+	/* External PCI device enable */
+	if (dev->bus->number != 0)
+		return pcibios_enable_resources(dev);
+
+	/* These cores come out of reset enabled */
+	if (dev->device == MIPS_CORE_ID ||
+	    dev->device == MIPS33_CORE_ID ||
+	    dev->device == CC_CORE_ID)
+		return 0;
+
+	spin_lock_irqsave(&sih_lock, flags);
+	coreidx = si_coreidx(sih);
+	regs = si_setcoreidx(sih, PCI_SLOT(dev->devfn));
+	if (!regs)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* 
+	 * The USB core requires a special bit to be set during core
+	 * reset to enable host (OHCI) mode. Resetting the SB core in
+	 * pcibios_enable_device() is a hack for compatibility with
+	 * vanilla usb-ohci so that it does not have to know about
+	 * SB. A driver that wants to use the USB core in device mode
+	 * should know about SB and should reset the bit back to 0
+	 * after calling pcibios_enable_device().
+	 */
+	if (si_coreid(sih) == USB_CORE_ID) {
+		si_core_disable(sih, si_core_cflags(sih, 0, 0));
+		si_core_reset(sih, 1 << 29, 0);
+	}
+	/*
+	 * USB 2.0 special considerations:
+	 *
+	 * 1. Since the core supports both OHCI and EHCI functions, it must
+	 *    only be reset once.
+	 *
+	 * 2. In addition to the standard SB reset sequence, the Host Control
+	 *    Register must be programmed to bring the USB core and various
+	 *    phy components out of reset.
+	 */
+	else if (si_coreid(sih) == USB20H_CORE_ID) {
+		if (!si_iscoreup(sih)) {
+			si_core_reset(sih, 0, 0);
+			// USB hungup issue from broadcom 2009.6.24
+			mdelay(10);
+			writel(0x7ff, regs + 0x200);
+			udelay(1);
+		}
+
+		/* PRxxxx: War for 5354 failures. */
+		if (sih->chip == BCM5354_CHIP_ID && (si_corerev(sih) == 1 || si_corerev(sih) == 2)) {
+			uint32 tmp;
+
+			/* Change Flush control reg */
+			tmp = readl(regs + 0x400);
+			tmp &= ~8;
+			writel(tmp, regs + 0x400);
+
+			/* Change Shim control reg */
+			tmp = readl(regs + 0x304);
+			tmp &= ~0x100;
+			writel(tmp, regs + 0x304);
+
+			/* Change Syn01 reg */
+			tmp = 0x00fe00fe;
+			writel(tmp, regs + 0x894);
+
+			/* Change Syn03 reg */
+			tmp = 0x1;
+			writel(tmp, regs + 0x89c);
+		}
+
+                                /* War for 4716 failures. */
+                if (sih->chip == BCM4716_CHIP_ID) {
+                        uint32 tmp;
+                        uint32 delay = 500;
+                        uint32 val = 0;
+                        uint32 clk_freq;
+
+                        clk_freq = si_cpu_clock(sih);
+                        if(clk_freq == 480000000)
+                                val = 0x1846b;
+                        else if (clk_freq == 453000000)
+//                        else if (clk_freq == 452000000)
+                                val = 0x1046b;
+
+                        /* Change Shim mdio control reg to fix host not acking at high frequencies
+ *                         */
+                        if (val) {
+                                writel(val, regs + 0x524);
+                                udelay(delay);
+                                writel(0x4ab, regs + 0x524);
+                                udelay(delay);
+                                tmp = readl(regs + 0x528);
+                                udelay(delay);
+                                writel(val, regs + 0x524);
+                                udelay(delay);
+                                writel(0x4ab, regs + 0x524);
+                                udelay(delay);
+                                tmp = readl(regs + 0x528);
+                                printk("USB20H mdio control register : 0x%x\n", tmp);
+                        }
+                }
+
+	} else
+		si_core_reset(sih, 0, 0);
+
+	si_setcoreidx(sih, coreidx);
+	spin_unlock_irqrestore(&sih_lock, flags);
+
+	return 0;
+}
+
+void
+pcibios_update_resource(struct pci_dev *dev, struct resource *root,
+	struct resource *res, int resource)
+{
+	unsigned long where, size;
+	u32 reg;
+
+	/* External PCI only */
+	if (dev->bus->number == 0)
+		return;
+
+	where = PCI_BASE_ADDRESS_0 + (resource * 4);
+	size = res->end - res->start;
+	pci_read_config_dword(dev, where, &reg);
+	reg = (reg & size) | (((u32)(res->start - root->start)) & ~size);
+	pci_write_config_dword(dev, where, reg);
+}
+
+static void __init
+quirk_sbpci_bridge(struct pci_dev *dev)
+{
+	if (dev->bus->number != 1 || PCI_SLOT(dev->devfn) != 0)
+		return;
+
+	printk("PCI: Fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and memory space */
+	pci_set_master(dev);
+	pcibios_enable_resources(dev);
+
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, PCI_BAR1_CONTROL, 3);
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, quirk_sbpci_bridge);
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/perfcntr.c linux-2.6/arch/mips/brcm-boards/bcm947xx/perfcntr.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/perfcntr.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/perfcntr.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,340 @@
+/*
+ * Broadcom BCM47xx Performance Counters
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: perfcntr.c,v 1.1 2007/09/04 04:45:20 Exp $
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <typedefs.h>
+#include <osl.h>
+#include <mipsinc.h>
+
+/* 
+ * BCM4710 performance counter register select values
+ * No even-odd control-counter mapping, just counters
+ */
+#define PERF_DCACHE_HIT		0
+#define PERF_DCACHE_MISS	1
+#define PERF_ICACHE_HIT		2
+#define PERF_ICACHE_MISS	3
+#define PERF_ICOUNT		4
+
+asmlinkage uint read_perf_cntr(uint counter)
+{
+	uint32 prid = MFC0(C0_PRID, 0);
+	if (BCM330X(prid)) {
+#ifdef CONFIG_HND_BMIPS3300_PROF
+		switch (counter) {
+		case PERF_DCACHE_HIT:	return -MFC0(C0_PERFORMANCE, 0);
+		case PERF_DCACHE_MISS:	return -MFC0(C0_PERFORMANCE, 1);
+		case PERF_ICACHE_HIT:	return -MFC0(C0_PERFORMANCE, 2);
+		case PERF_ICACHE_MISS:	return -MFC0(C0_PERFORMANCE, 3);
+		}
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+		return 0;
+	}
+	else {
+		switch (counter) {
+		case PERF_DCACHE_HIT:	return MFC0(C0_PERFORMANCE, 0);
+		case PERF_DCACHE_MISS:	return MFC0(C0_PERFORMANCE, 1);
+		case PERF_ICACHE_HIT:	return MFC0(C0_PERFORMANCE, 2);
+		case PERF_ICACHE_MISS:	return MFC0(C0_PERFORMANCE, 3);
+		case PERF_ICOUNT:	return MFC0(C0_PERFORMANCE, 4);
+		}
+	}
+	return 0;
+}
+
+/*
+ * 'data' passed to proc entry callback is formatted as:
+ *	(reg << 16) + sel
+ */
+#define REGSHIFT	16	/* register # is at high 16 bit */
+#define SELMASK		0xffff	/* select # is at low 16 bit */
+
+/*
+ * Template to read/write cp0 register. Caller will modify
+ * the mfc0 and mtc0 instructions before calling.
+ */
+static void tmfc0(void)
+{
+	__asm__ __volatile__(
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t$1,$0\n\t"
+		"move\t$2,$1\n\t"
+		".set\tat\n\t"
+		".set\treorder");
+}
+
+static void tmtc0(uint val)
+{
+	__asm__ __volatile__(
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		"move\t$1,$4\n\t"
+		"mtc0\t$1,$0\n\t"
+		".set\tat\n\t"
+		".set\treorder");
+}
+
+/*
+ * Read/write cp0 register. Assuming code space is writeable
+ * so modify the mfc0 and mtc0 instructions before calling the
+ * function tmfc0() and tmtc0() to build the correct mfc0 and
+ * mtc0 instructions.
+ */
+static int cp0_read(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+	uint reg, sel;
+	uint (*cp0i)(void);
+	size_t len;
+
+	/* we have done once so stop */
+	if (off) {
+		len = 0;
+		goto done;
+	}
+
+	/* change the mfc0 instr with the right reg/sel */
+	reg = (uintptr)data >> REGSHIFT;
+	sel = (uintptr)data & SELMASK;
+	cp0i = (uint (*)(void))KSEG1ADDR(tmfc0);
+	*(uint *)cp0i = 0x40010000 | (reg << 11) | sel;
+	__asm__ __volatile__("nop; nop; nop; nop;");
+
+	/* return the value in hex string */
+	len = sprintf(page, "0x%08x\n", cp0i());
+	*start = page;
+done:	return len;
+}
+
+static int cp0_write(struct file *file, const char *buf,
+                     unsigned long count, void *data)
+{
+	uint reg, sel, val;
+	void (*cp0i)(uint);
+
+	/* change the mtc0 instr with the right reg/sel */
+	reg = (uintptr)data >> REGSHIFT;
+	sel = (uintptr)data & SELMASK;
+	val = simple_strtoul(buf, NULL, 0);
+	cp0i = (void (*)(uint))KSEG1ADDR(tmtc0);
+	*((uint *)cp0i + 1) = 0x40810000 | (reg << 11) | sel;
+	__asm__ __volatile__("nop; nop; nop; nop;");
+
+	/* set the value and we are all done */
+	cp0i(val);
+	return count;
+}
+
+#ifdef CONFIG_HND_BMIPS3300_PROF
+/*
+ * Enable/disable cache hits/misses countings - counters are 
+ * hard wired as:
+ *	d$ - cntr 0 and 1
+ *	i$ - cntr 2 and 3
+ * They can't be enabled at the same time according to the BMIPS
+ * 3300 documentations, although they are displayed togather.
+ */
+static void bmips3300_dccntenab(bool enable)
+{
+	if (enable) {
+		MTC0(C0_PERFORMANCE, 6, 0x80000211);	/* enable D$ counting */
+		MTC0(C0_PERFORMANCE, 4, 0x80248028);	/* enable cntr 0 and 1 */
+		MTC0(C0_PERFORMANCE, 0, 0);		/* zero cntr 0 - # hits */
+		MTC0(C0_PERFORMANCE, 1, 0);		/* zero cntr 1 - # misses */
+		printk("enabled performance counter 0 for D$ hits\n");
+		printk("enabled performance counter 1 for D$ misses\n");
+	}
+	else {
+		MTC0(C0_PERFORMANCE, 4, 0);		/* disable cntr 0 and 1 */
+		MTC0(C0_PERFORMANCE, 6, 0);		/* disable D$ counting */
+		printk("disabled performance counters\n");
+	}
+}
+
+static void bmips3300_iccntenab(bool enable)
+{
+	if (enable) {
+		MTC0(C0_PERFORMANCE, 6, 0x80000218);	/* enable I$ counting */
+		MTC0(C0_PERFORMANCE, 5, 0x80148018);	/* enable cntr 2 and 3 */
+		MTC0(C0_PERFORMANCE, 2, 0);		/* zero cntr 0 - # hits */
+		MTC0(C0_PERFORMANCE, 3, 0);		/* zero cntr 1 - # misses */
+		printk("enabled performance counter 2 for I$ hits\n");
+		printk("enabled performance counter 3 for I$ misses\n");
+	}
+	else {
+		MTC0(C0_PERFORMANCE, 5, 0);		/* disable cntr 2 and 3 */
+		MTC0(C0_PERFORMANCE, 6, 0);		/* disable I$ counting */
+		printk("disabled performance counters\n");
+	}
+}
+
+/* cache counting enable/disable proc entry callback */
+#define DCACHE_CNTENAB	0
+#define ICACHE_CNTENAB	1
+
+static int bmips3300_ccntenab(struct file *file, const char *buf,
+                         unsigned long count, void *data)
+{
+	uint val = simple_strtoul(buf, NULL, 0);
+	switch ((uint)data) {
+	case DCACHE_CNTENAB:
+		bmips3300_dccntenab(val != 0);
+		break;
+	case ICACHE_CNTENAB:
+		bmips3300_iccntenab(val != 0);
+		break;
+	}
+	return count;
+}
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+
+/* cp0 registers/selects map */
+#define MAXREGS		32	/* max # registers */
+#define MAXSELS		32	/* max # selects */
+#define CP0REG(r)	(1<<(r))
+#define CP0SEL(s)	(1<<(s))
+typedef struct
+{
+	uint32 reg_map;		/* registers map */
+	uint8 sel_map[MAXSELS];	/* selects map */
+} cp0_reg_map_t;
+
+#ifdef CONFIG_HND_BMIPS3300_PROF
+static cp0_reg_map_t bmips3300_cp0regmap =
+{
+	CP0REG(0)|CP0REG(1)|CP0REG(2)|CP0REG(3)|CP0REG(4)|CP0REG(5)|
+		CP0REG(6)|CP0REG(7)|CP0REG(8)|CP0REG(9)|CP0REG(10)|
+		CP0REG(11)|CP0REG(12)|CP0REG(13)|CP0REG(14)|CP0REG(15)|
+		CP0REG(16)|CP0REG(22)|CP0REG(23)|CP0REG(24)|CP0REG(25)|
+		CP0REG(28)|CP0REG(30)|CP0REG(31),
+	{
+		/* 0 */	CP0SEL(0),
+		/* 1 */	CP0SEL(0),
+		/* 2 */	CP0SEL(0),
+		/* 3 */	CP0SEL(0),
+		/* 4 */	CP0SEL(0),
+		/* 5 */	CP0SEL(0),
+		/* 6 */	CP0SEL(0),
+		/* 7 */	CP0SEL(0),
+		/* 8 */	CP0SEL(0),
+		/* 9 */	CP0SEL(0),
+		/* 10 */ CP0SEL(0),
+		/* 11 */ CP0SEL(0),
+		/* 12 */ CP0SEL(0),
+		/* 13 */ CP0SEL(0),
+		/* 14 */ CP0SEL(0),
+		/* 15 */ CP0SEL(0),
+		/* 16 */ CP0SEL(0)|CP0SEL(1),
+		0,
+		0,
+		0,
+		0,
+		0,
+		/* 22 */ CP0SEL(0)|CP0SEL(4)|CP0SEL(5),
+		/* 23 */ CP0SEL(0),
+		/* 24 */ CP0SEL(0),
+		/* 25 */ CP0SEL(0)|CP0SEL(1)|CP0SEL(2)|CP0SEL(3)|CP0SEL(4)|
+			CP0SEL(5)|CP0SEL(6),
+		0,
+		0,
+		/* 28 */ CP0SEL(0)|CP0SEL(1),
+		0,
+		/* 30 */ CP0SEL(0),
+		/* 31 */ CP0SEL(0),
+	}
+};
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+
+/* create/remove proc entries - no worry about error handling;-( */
+static int __init cp0_init(void)
+{
+	struct proc_dir_entry *cp0_proc;
+#ifdef CONFIG_HND_BMIPS3300_PROF
+	struct proc_dir_entry *cache_proc;
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+	struct proc_dir_entry *reg_proc, *sel_proc;
+	cp0_reg_map_t *reg_map = NULL;
+	uint32 prid;
+	char name[16];
+	int i, j;
+
+	/* create proc entry cp0 in root */
+	cp0_proc = create_proc_entry("cp0", 0444 | S_IFDIR, &proc_root);
+	if (!cp0_proc)
+		return 0;
+
+	/* create proc entries for enabling cache hit/miss counting */
+	prid = MFC0(C0_PRID, 0);
+	if (BCM330X(prid)) {
+#ifdef CONFIG_HND_BMIPS3300_PROF
+		/* D$ */
+		cache_proc = create_proc_entry("dccnt", 0644, cp0_proc);
+		if (!cache_proc)
+			return 0;
+		cache_proc->write_proc = bmips3300_ccntenab;
+		cache_proc->data = (void *)DCACHE_CNTENAB;
+		/* I$ */
+		cache_proc = create_proc_entry("iccnt", 0644, cp0_proc);
+		if (!cache_proc)
+			return 0;
+		cache_proc->write_proc = bmips3300_ccntenab;
+		cache_proc->data = (void *)ICACHE_CNTENAB;
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+	}
+
+	/* select cp0 registers/selects map table */
+	if (BCM330X(prid)) {
+#ifdef CONFIG_HND_BMIPS3300_PROF
+		reg_map = &bmips3300_cp0regmap;
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+	}
+	if (!reg_map)
+		return 0;
+	/* create proc entry for each register select */
+	for (i = 0; i < MAXREGS; i ++) {
+		if (!(reg_map->reg_map & (1 << i)))
+			continue;
+		sprintf(name, "%u", i);
+		reg_proc = create_proc_entry(name, 0444 | S_IFDIR, cp0_proc);
+		if (!reg_proc)
+			break;
+		for (j = 0; j < MAXSELS; j ++) {
+			if (!(reg_map->sel_map[i] & (1 << j)))
+				continue;
+			sprintf(name, "%u", j);
+			sel_proc = create_proc_entry(name, 0644, reg_proc);
+			if (!sel_proc)
+				break;
+			sel_proc->read_proc = cp0_read;
+			sel_proc->write_proc = cp0_write;
+			sel_proc->data = (void *)((i << REGSHIFT) + j);
+		}
+	}
+	return 0;
+}
+
+static void __exit cp0_cleanup(void)
+{
+	remove_proc_entry("cp0", &proc_root);
+}
+
+/* hook it up with system at boot time */
+module_init(cp0_init);
+module_exit(cp0_cleanup);
+
+#endif	/* CONFIG_PROC_FS */
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/prom.c linux-2.6/arch/mips/brcm-boards/bcm947xx/prom.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/prom.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/prom.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,68 @@
+/*
+ * Early initialization code for BCM94710 boards
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: prom.c,v 1.3 2009/04/23 07:43:09 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <hndcpu.h>
+#include <mipsinc.h>
+#include <mips74k_core.h>
+
+void __init
+prom_init(void)
+{
+	unsigned long mem;
+
+	mips_machgroup = MACH_GROUP_BRCM;
+	mips_machtype = MACH_BCM947XX;
+
+	/* Figure out memory size by finding aliases */
+	for (mem = (1 << 20); mem < (128 << 20); mem <<= 1) {
+		if (*(unsigned long *)((unsigned long)(prom_init) + mem) == 
+		    *(unsigned long *)(prom_init))
+			break;
+	} 
+
+#if CONFIG_RAM_SIZE
+       {
+               unsigned long config_mem;
+               config_mem = CONFIG_RAM_SIZE * 0x100000;
+               if (config_mem < mem)
+                       mem = config_mem;
+       }
+#endif
+
+	/* Ignoring the last page when ddr size is 128M. Cached
+	 * accesses to last page is causing the processor to prefetch
+	 * using address above 128M stepping out of the ddr address
+	 * space.
+	 */
+	if (MIPS74K(current_cpu_data.processor_id) && (mem == 0x8000000))
+		mem -= 0x1000;
+
+	add_memory_region(0, mem, BOOT_MEM_RAM);
+}
+
+void __init
+prom_free_prom_memory(void)
+{
+}
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/setup.c linux-2.6/arch/mips/brcm-boards/bcm947xx/setup.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/setup.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/setup.c	2009-02-23 17:14:55.000000000 +0300
@@ -0,0 +1,347 @@
+/*
+ * HND MIPS boards setup routines
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: setup.c,v 1.6 2008/04/03 03:49:45 Exp $
+ */
+
+#include <linux/types.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_core.h>
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+#include <linux/blkdev.h>
+#include <linux/ide.h>
+#endif
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/minix_fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/romfs_fs.h>
+#include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
+#endif
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmnvram.h>
+#include <siutils.h>
+#include <hndsoc.h>
+#include <hndcpu.h>
+#include <mips33_core.h>
+#include <mips74k_core.h>
+#include <sbchipc.h>
+#include <hndchipc.h>
+#include <trxhdr.h>
+#include "bcm947xx.h"
+
+extern void bcm947xx_time_init(void);
+extern void bcm947xx_timer_setup(struct irqaction *irq);
+
+#ifdef CONFIG_KGDB
+extern void set_debug_traps(void);
+extern void rs_kgdb_hook(struct uart_port *);
+extern void breakpoint(void);
+#endif
+
+/* Global SB handle */
+si_t *bcm947xx_sih = NULL;
+spinlock_t bcm947xx_sih_lock = SPIN_LOCK_UNLOCKED;
+EXPORT_SYMBOL(bcm947xx_sih);
+EXPORT_SYMBOL(bcm947xx_sih_lock);
+
+/* Convenience */
+#define sih bcm947xx_sih
+#define sih_lock bcm947xx_sih_lock
+
+/* Kernel command line */
+extern char arcs_cmdline[CL_SIZE];
+
+void
+bcm947xx_machine_restart(char *command)
+{
+	printk("Please stand by while rebooting the system...\n");
+
+	/* Set the watchdog timer to reset immediately */
+	local_irq_disable();
+	hnd_cpu_reset(sih);
+}
+
+void
+bcm947xx_machine_halt(void)
+{
+	printk("System halted\n");
+
+	/* Disable interrupts and watchdog and spin forever */
+	local_irq_disable();
+	si_watchdog(sih, 0);
+	while (1);
+}
+
+#ifdef CONFIG_SERIAL_CORE
+
+static struct uart_port rs = {
+	line: 0,
+	flags: ASYNC_BOOT_AUTOCONF,
+	iotype: SERIAL_IO_MEM,
+};
+
+static void __init
+serial_add(void *regs, uint irq, uint baud_base, uint reg_shift)
+{
+	rs.membase = regs;
+	rs.irq = irq + 2;
+	rs.uartclk = baud_base;
+	rs.regshift = reg_shift;
+
+	early_serial_setup(&rs);
+
+	rs.line++;
+}
+
+static void __init
+serial_setup(si_t *sih)
+{
+	si_serial_init(sih, serial_add);
+
+#ifdef CONFIG_KGDB
+	/* Use the last port for kernel debugging */
+	if (rs.membase)
+		rs_kgdb_hook(&rs);
+#endif
+}
+
+#endif /* CONFIG_SERIAL_CORE */
+
+void __init
+brcm_setup(void)
+{
+	char *value;
+
+	/* Get global SB handle */
+	sih = si_kattach(SI_OSH);
+
+	/* Initialize clocks and interrupts */
+	si_mips_init(sih, SBMIPS_VIRTIRQ_BASE);
+
+	if (BCM330X(current_cpu_data.processor_id) &&
+		(read_c0_diag() & BRCM_PFC_AVAIL)) {
+		/* 
+		 * Now that the sih is inited set the  proper PFC value 
+		 */	
+		printk("Setting the PFC to its default value\n");
+		enable_pfc(PFC_AUTO);
+	}
+
+
+#ifdef CONFIG_SERIAL_CORE
+	/* Initialize UARTs */
+	serial_setup(sih);
+#endif /* CONFIG_SERIAL_CORE */
+
+	/* Override default command line arguments */
+	value = nvram_get("kernel_args");
+	if (value && strlen(value) && strncmp(value, "empty", 5))
+		strncpy(arcs_cmdline, value, sizeof(arcs_cmdline));
+
+
+	/* Generic setup */
+	_machine_restart = bcm947xx_machine_restart;
+	_machine_halt = bcm947xx_machine_halt;
+	pm_power_off = bcm947xx_machine_halt;
+
+	board_time_init = bcm947xx_time_init;
+}
+
+const char *
+get_system_type(void)
+{
+	static char s[32];
+
+	if (bcm947xx_sih) {
+		sprintf(s, "Broadcom BCM%X chip rev %d pkg %d", bcm947xx_sih->chip,
+			bcm947xx_sih->chiprev, bcm947xx_sih->chippkg);
+		return s;
+	}
+	else
+		return "Broadcom BCM947XX";
+}
+
+void __init
+bus_error_init(void)
+{
+}
+
+void __init
+plat_mem_setup(void)
+{
+	brcm_setup();
+	return;
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition bcm947xx_parts[] =
+{
+	{
+		.name = "boot",
+		.size = 0,
+		.offset = 0,
+//		.mask_flags = MTD_WRITEABLE
+	},
+	{
+		.name = "linux",
+		.size = 0,
+		.offset = 0
+	},
+	{
+		.name = "rootfs",
+		.size = 0,
+		.offset = 0,
+		.mask_flags = MTD_WRITEABLE
+	},
+	{
+		.name = "nvram",
+		.size = 0,
+		.offset = 0
+	}
+};
+
+struct mtd_partition *
+init_mtd_partitions(struct mtd_info *mtd, size_t size)
+{
+	struct minix_super_block *minixsb;
+	struct ext2_super_block *ext2sb;
+	struct romfs_super_block *romfsb;
+	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
+	struct trx_header *trx;
+	unsigned char buf[512];
+	int off;
+	size_t len;
+
+	minixsb = (struct minix_super_block *) buf;
+	ext2sb = (struct ext2_super_block *) buf;
+	romfsb = (struct romfs_super_block *) buf;
+	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
+	trx = (struct trx_header *) buf;
+
+	/* Look at every 64 KB boundary */
+	for (off = 0; off < size; off += (64 * 1024)) {
+		memset(buf, 0xe5, sizeof(buf));
+
+		/*
+		 * Read block 0 to test for romfs and cramfs superblock
+		 */
+		if (mtd->read(mtd, off, sizeof(buf), &len, buf) ||
+		    len != sizeof(buf))
+			continue;
+
+		/* Try looking at TRX header for rootfs offset */
+		if (le32_to_cpu(trx->magic) == TRX_MAGIC) {
+			bcm947xx_parts[1].offset = off;
+//			if (le32_to_cpu(trx->offsets[1]) > off)
+	                if (le32_to_cpu(trx->offsets[2]) > off)
+	                        off = le32_to_cpu(trx->offsets[2]);
+	                else if (le32_to_cpu(trx->offsets[1]) > off)
+				off = le32_to_cpu(trx->offsets[1]);
+			continue;
+		}
+
+		/* romfs is at block zero too */
+		if (romfsb->word0 == ROMSB_WORD0 &&
+		    romfsb->word1 == ROMSB_WORD1) {
+			printk(KERN_NOTICE
+			       "%s: romfs filesystem found at block %d\n",
+			       mtd->name, off / BLOCK_SIZE);
+			goto done;
+		}
+
+		/* squashfs is at block zero too */
+                if (squashfsb->s_magic == SQUASHFS_MAGIC
+			|| squashfsb->s_magic == SQUASHFS_MAGIC_LZMA) {
+                        printk(KERN_NOTICE
+                               "%s: squashfs filesystem found at block %d\n",
+                               mtd->name, off / BLOCK_SIZE);
+                        goto done;
+                }
+
+
+		/* so is cramfs */
+		if (cramfsb->magic == CRAMFS_MAGIC) {
+			printk(KERN_NOTICE
+			       "%s: cramfs filesystem found at block %d\n",
+			       mtd->name, off / BLOCK_SIZE);
+			goto done;
+		}
+
+		/*
+		 * Read block 1 to test for minix and ext2 superblock
+		 */
+		if (mtd->read(mtd, off + BLOCK_SIZE, sizeof(buf), &len, buf) ||
+		    len != sizeof(buf))
+			continue;
+
+		/* Try minix */
+		if (minixsb->s_magic == MINIX_SUPER_MAGIC ||
+		    minixsb->s_magic == MINIX_SUPER_MAGIC2) {
+			printk(KERN_NOTICE
+			       "%s: Minix filesystem found at block %d\n",
+			       mtd->name, off / BLOCK_SIZE);
+			goto done;
+		}
+
+		/* Try ext2 */
+		if (ext2sb->s_magic == cpu_to_le16(EXT2_SUPER_MAGIC)) {
+			printk(KERN_NOTICE
+			       "%s: ext2 filesystem found at block %d\n",
+			       mtd->name, off / BLOCK_SIZE);
+			goto done;
+		}
+	}
+
+	printk(KERN_NOTICE
+	       "%s: Couldn't find valid ROM disk image\n",
+	       mtd->name);
+
+ done:
+	/* Find and size nvram */
+	bcm947xx_parts[3].offset = size - ROUNDUP(NVRAM_SPACE, mtd->erasesize);
+	bcm947xx_parts[3].size = size - bcm947xx_parts[3].offset;
+
+	/* Find and size rootfs */
+	if (off < size) {
+		bcm947xx_parts[2].offset = off;
+		bcm947xx_parts[2].size = bcm947xx_parts[3].offset - bcm947xx_parts[2].offset;
+	}
+
+	/* Size linux (kernel and rootfs) */
+	bcm947xx_parts[1].size = bcm947xx_parts[3].offset - bcm947xx_parts[1].offset;
+
+	/* Size pmon */
+	bcm947xx_parts[0].size = bcm947xx_parts[1].offset - bcm947xx_parts[0].offset;
+
+	return bcm947xx_parts;
+}
+
+EXPORT_SYMBOL(init_mtd_partitions);
+
+#endif
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/bcm947xx/time.c linux-2.6/arch/mips/brcm-boards/bcm947xx/time.c
--- linux-2.6.22/arch/mips/brcm-boards/bcm947xx/time.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/time.c	2009-03-13 12:11:27.000000000 +0300
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: time.c,v 1.8 2008/07/04 01:06:30 Exp $
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/serial_reg.h>
+#include <linux/interrupt.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmnvram.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <siutils.h>
+#include <hndmips.h>
+#include <mipsinc.h>
+#include <hndcpu.h>
+#include <bcmdevs.h>
+
+/* Global SB handle */
+extern si_t *bcm947xx_sih;
+extern spinlock_t bcm947xx_sih_lock;
+
+/* Convenience */
+#define sih bcm947xx_sih
+#define sih_lock bcm947xx_sih_lock
+
+#define WATCHDOG_MIN	3000	/* milliseconds */
+extern int panic_timeout;
+static int watchdog = 0;
+
+#ifndef	CONFIG_HWSIM
+static u8 *mcr = NULL;
+#endif /* CONFIG_HWSIM */
+
+void __init
+bcm947xx_time_init(void)
+{
+	unsigned int hz;
+
+	/*
+	 * Use deterministic values for initial counter interrupt
+	 * so that calibrate delay avoids encountering a counter wrap.
+	 */
+	write_c0_count(0);
+	write_c0_compare(0xffff);
+
+	if (!(hz = si_cpu_clock(sih)))
+		hz = 100000000;
+
+	printk("CPU: BCM%04x rev %d at %d MHz\n", ((si_t *)sih)->chip, ((si_t *)sih)->chiprev,
+	       (hz + 500000) / 1000000);
+
+	/* Set MIPS counter frequency for fixed_rate_gettimeoffset() */
+	mips_hpt_frequency = hz / 2;
+
+	/* Set watchdog interval in ms */
+	watchdog = simple_strtoul(nvram_safe_get("watchdog"), NULL, 0);
+
+	/* Please set the watchdog to 3 sec if it is less than 3 but not equal to 0 */
+	if ((watchdog > 0) && (watchdog < WATCHDOG_MIN))
+		watchdog = WATCHDOG_MIN;
+
+	/* Set panic timeout in seconds */
+	panic_timeout = watchdog / 1000;
+}
+
+#ifdef CONFIG_HND_BMIPS3300_PROF
+extern bool hndprofiling;
+#ifdef CONFIG_MIPS64
+typedef u_int64_t sbprof_pc;
+#else
+typedef u_int32_t sbprof_pc;
+#endif
+extern void sbprof_cpu_intr(sbprof_pc restartpc);
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+
+static irqreturn_t
+bcm947xx_timer_interrupt(int irq, void *dev_id)
+{
+#ifdef CONFIG_HND_BMIPS3300_PROF
+	/*
+	 * Are there any ExcCode or other mean(s) to determine what has caused
+	 * the timer interrupt? For now simply stop the normal timer proc if
+	 * count register is less than compare register.
+	 */
+	if (hndprofiling) {
+		sbprof_cpu_intr(read_c0_epc() +
+		                ((read_c0_cause() >> (CAUSEB_BD - 2)) & 4));
+		if (read_c0_count() < read_c0_compare())
+			return (IRQ_HANDLED);
+	}
+#endif	/* CONFIG_HND_BMIPS3300_PROF */
+
+	/* Generic MIPS timer code */
+	timer_interrupt(irq, dev_id);
+
+	/* Set the watchdog timer to reset after the specified number of ms */
+	if (watchdog > 0) {
+		if (((si_t *)sih)->chip == BCM5354_CHIP_ID)
+			si_watchdog(sih, WATCHDOG_CLOCK_5354 / 1000 * watchdog);
+		else
+			si_watchdog_ms(sih, watchdog);
+	}
+
+#ifdef	CONFIG_HWSIM
+	(*((int *)0xa0000f1c))++;
+#else
+	/* Blink one of the LEDs in the external UART */
+	if (mcr && !(jiffies % (HZ/2)))
+		writeb(readb(mcr) ^ UART_MCR_OUT2, mcr);
+#endif
+
+	return (IRQ_HANDLED);
+}
+
+static struct irqaction bcm947xx_timer_irqaction = {
+	bcm947xx_timer_interrupt,
+	IRQF_DISABLED,
+	{ { 0 } },
+	"timer",
+	NULL,
+	NULL,
+	0,
+	NULL
+};
+
+void __init
+plat_timer_setup(struct irqaction *irq)
+{
+	/* Enable the timer interrupt */
+	setup_irq(7, &bcm947xx_timer_irqaction);
+}
+
+#define CFE_UPDATE 1            // added by Chen-I for mac/regulation update
+
+#ifdef CFE_UPDATE
+void bcm947xx_watchdog_disable(void)
+{
+        watchdog=0;
+        si_watchdog(sih, 0);
+}
+#endif
+
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/generic/gdb_hook.c linux-2.6/arch/mips/brcm-boards/generic/gdb_hook.c
--- linux-2.6.22/arch/mips/brcm-boards/generic/gdb_hook.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/generic/gdb_hook.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2008, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * This is the interface to the remote debugger stub.
+ *
+ */
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+
+#include <asm/serial.h>
+#include <asm/io.h>
+
+static struct async_struct kdb_port_info = {0};
+
+static __inline__ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return readb(info->iomem_base + (offset<<info->iomem_reg_shift));
+}
+
+static __inline__ void serial_out(struct async_struct *info, int offset,
+				  int value)
+{
+	writeb(value, info->iomem_base + (offset<<info->iomem_reg_shift));
+}
+
+void rs_kgdb_hook(struct uart_port *ser) {
+	int t;
+
+	kdb_port_info.state = (struct serial_state *)ser;
+	kdb_port_info.magic = SERIAL_MAGIC;
+	kdb_port_info.port = ser->line;
+	kdb_port_info.flags = ser->flags;
+	kdb_port_info.iomem_base = ser->membase;
+	kdb_port_info.iomem_reg_shift = ser->regshift;
+	kdb_port_info.MCR = UART_MCR_DTR | UART_MCR_RTS;
+
+	/*
+	 * Clear all interrupts
+	 */
+	serial_in(&kdb_port_info, UART_LSR);
+	serial_in(&kdb_port_info, UART_RX);
+	serial_in(&kdb_port_info, UART_IIR);
+	serial_in(&kdb_port_info, UART_MSR);
+
+	/*
+	 * Now, initialize the UART 
+	 */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
+	serial_out(&kdb_port_info, UART_MCR, kdb_port_info.MCR);
+	
+	/*
+	 * and set the speed of the serial port
+	 * (currently hardwired to 115200 8N1
+	 */
+
+	/* baud rate is fixed to 115200 (is this sufficient?)*/
+	t = ser->uartclk / 115200;	
+	/* set DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+	serial_out(&kdb_port_info, UART_DLL, t & 0xff);/* LS of divisor */
+	serial_out(&kdb_port_info, UART_DLM, t >> 8);  /* MS of divisor */
+	/* reset DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);
+}
+
+int putDebugChar(char c)
+{
+
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while ((serial_in(&kdb_port_info, UART_LSR) & UART_LSR_THRE) == 0)
+		;
+
+	serial_out(&kdb_port_info, UART_TX, c);
+
+	return 1;
+}
+
+char getDebugChar(void) 
+{
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while (!(serial_in(&kdb_port_info, UART_LSR) & 1))
+		;
+
+	return(serial_in(&kdb_port_info, UART_RX));
+}
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/generic/int-handler.S linux-2.6/arch/mips/brcm-boards/generic/int-handler.S
--- linux-2.6.22/arch/mips/brcm-boards/generic/int-handler.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/generic/int-handler.S	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,51 @@
+/*
+ * Generic interrupt handler for Broadcom MIPS boards
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: int-handler.S,v 1.1 2007/09/04 04:41:12 Exp $
+ */
+
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware
+ *             4        Hardware
+ *             5        Hardware
+ *             6        Hardware
+ *             7        R4k timer
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(brcmIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+	.set    noreorder
+
+	jal	plat_irq_dispatch
+	move	a0, sp
+
+	j	ret_from_irq
+	nop
+
+	END(brcmIRQ)
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/generic/irq.c linux-2.6/arch/mips/brcm-boards/generic/irq.c
--- linux-2.6.22/arch/mips/brcm-boards/generic/irq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/generic/irq.c	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,129 @@
+/*
+ * Generic interrupt control functions for Broadcom MIPS boards
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: irq.c,v 1.1 2007/09/04 04:41:12 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
+
+extern asmlinkage void brcmIRQ(void);
+extern asmlinkage unsigned int do_IRQ(int irq, struct pt_regs *regs);
+
+void
+plat_irq_dispatch(struct pt_regs *regs)
+{
+	u32 cause;
+
+	cause = read_c0_cause() &
+		read_c0_status() &
+		CAUSEF_IP;
+
+#ifdef CONFIG_KERNPROF
+	change_c0_status(cause | 1, 1);
+#else
+	clear_c0_status(cause);
+#endif
+
+	if (cause & CAUSEF_IP7)
+		do_IRQ(7, regs);
+	if (cause & CAUSEF_IP2)
+		do_IRQ(2, regs);
+	if (cause & CAUSEF_IP3)
+		do_IRQ(3, regs);
+	if (cause & CAUSEF_IP4)
+		do_IRQ(4, regs);
+	if (cause & CAUSEF_IP5)
+		do_IRQ(5, regs);
+	if (cause & CAUSEF_IP6)
+		do_IRQ(6, regs);
+}
+
+static void
+enable_brcm_irq(unsigned int irq)
+{
+	if (irq < 8)
+		set_c0_status(1 << (irq + 8));
+	else
+		set_c0_status(IE_IRQ0);
+}
+
+static void
+disable_brcm_irq(unsigned int irq)
+{
+	if (irq < 8)
+		clear_c0_status(1 << (irq + 8));
+	else
+		clear_c0_status(IE_IRQ0);
+}
+
+static void
+ack_brcm_irq(unsigned int irq)
+{
+	/* Already done in plat_irq_dispatch */
+}
+
+static unsigned int
+startup_brcm_irq(unsigned int irq)
+{ 
+	enable_brcm_irq(irq);
+
+	return 0; /* never anything pending */
+}
+
+static void
+end_brcm_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_brcm_irq(irq);
+}
+
+static struct hw_interrupt_type brcm_irq_type = {
+	typename: "MIPS",
+	startup: startup_brcm_irq,
+	shutdown: disable_brcm_irq,
+	enable: enable_brcm_irq,
+	disable: disable_brcm_irq,
+	ack: ack_brcm_irq,
+	end: end_brcm_irq,
+	NULL
+};
+
+void __init
+init_IRQ(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &brcm_irq_type;
+	}
+
+	change_c0_status(ST0_IM, ALLINTS);
+
+#ifdef CONFIG_KGDB
+	printk("Breaking into debugger...\n");
+	set_debug_traps();
+	breakpoint(); 
+#endif
+}
diff -urBwNp linux-2.6.22/arch/mips/brcm-boards/generic/Makefile linux-2.6/arch/mips/brcm-boards/generic/Makefile
--- linux-2.6.22/arch/mips/brcm-boards/generic/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/generic/Makefile	2008-12-12 06:25:41.000000000 +0300
@@ -0,0 +1,22 @@
+#
+# Makefile for generic Broadcom MIPS boards
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.1 2007/09/04 04:41:12 Exp $
+#
+
+USE_STANDARD_AS_RULE := TRUE
+
+obj-y += int-handler.o
+ifneq ($(strip $(CONFIG_BCM47XX)),y)
+obj-y += irq.o
+endif
+
+obj-$(CONFIG_KGDB) += gdb_hook.o
diff -urBwNp linux-2.6.22/arch/mips/defconfig linux-2.6/arch/mips/defconfig
--- linux-2.6.22/arch/mips/defconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/defconfig	2008-12-12 06:25:39.000000000 +0300
@@ -465,6 +465,7 @@ CONFIG_NF_NAT_TFTP=m
 CONFIG_NF_NAT_AMANDA=m
 CONFIG_NF_NAT_PPTP=m
 CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_AUTOFW=m
 CONFIG_NF_NAT_SIP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
diff -urBwNp linux-2.6.22/arch/mips/defconfig-bcm947xx-slimrtr linux-2.6/arch/mips/defconfig-bcm947xx-slimrtr
--- linux-2.6.22/arch/mips/defconfig-bcm947xx-slimrtr	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/arch/mips/defconfig-bcm947xx-slimrtr	2008-12-12 06:25:54.000000000 +0300
@@ -0,0 +1,1048 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.22
+# Wed May  7 18:15:28 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+CONFIG_MIPS_BRCM=y
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_WR_PPMC is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+
+#
+# Support for Broadcom MIPS based boards
+#
+CONFIG_BCM947XX=y
+CONFIG_BCM47XX=y
+CONFIG_BCMIPDSCP=y
+# CONFIG_HND_BMIPS3300_PROF is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_TIME=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+# CONFIG_MIPS_VPE_LOADER is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_HZ_48 is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+CONFIG_HZ_1000=y
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=1000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_KEXEC is not set
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+CONFIG_NF_CONNTRACK_ENABLED=y
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CT_ACCT is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CT_PROTO_GRE=y
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+# CONFIG_IP_NF_MATCH_TOS is not set
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_FTP=y
+# CONFIG_NF_NAT_IRC is not set
+CONFIG_NF_NAT_TFTP=y
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_AUTOFW=y
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=y
+# CONFIG_BRIDGE_EBT_BROUTE is not set
+# CONFIG_BRIDGE_EBT_T_FILTER is not set
+# CONFIG_BRIDGE_EBT_T_NAT is not set
+# CONFIG_BRIDGE_EBT_802_3 is not set
+# CONFIG_BRIDGE_EBT_AMONG is not set
+# CONFIG_BRIDGE_EBT_ARP is not set
+# CONFIG_BRIDGE_EBT_IP is not set
+# CONFIG_BRIDGE_EBT_LIMIT is not set
+# CONFIG_BRIDGE_EBT_MARK is not set
+# CONFIG_BRIDGE_EBT_PKTTYPE is not set
+# CONFIG_BRIDGE_EBT_STP is not set
+# CONFIG_BRIDGE_EBT_VLAN is not set
+# CONFIG_BRIDGE_EBT_ARPREPLY is not set
+# CONFIG_BRIDGE_EBT_DNAT is not set
+# CONFIG_BRIDGE_EBT_MARK_T is not set
+# CONFIG_BRIDGE_EBT_REDIRECT is not set
+# CONFIG_BRIDGE_EBT_SNAT is not set
+# CONFIG_BRIDGE_EBT_LOG is not set
+# CONFIG_BRIDGE_EBT_ULOG is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_BCM947XX=y
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_SFLASH=y
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# Misc devices
+#
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# Broadcom HND network devices
+#
+CONFIG_HND=y
+CONFIG_ET=m
+CONFIG_ET_47XX=y
+# CONFIG_WL_EMULATOR is not set
+CONFIG_BCM57XX=m
+CONFIG_WL=m
+CONFIG_WL_USE_AP=y
+# CONFIG_WL_USE_STA is not set
+# CONFIG_WL_USE_APSTA is not set
+# CONFIG_WL_USE_AP_SDSTD is not set
+# CONFIG_WL_USE_AP_ONCHIP_G is not set
+# CONFIG_WL_USE_STA_ONCHIP_G is not set
+# CONFIG_WL_USE_APSTA_ONCHIP_G is not set
+# CONFIG_WL_USE_HIGH is not set
+CONFIG_WL_AP="wlconfig_lx_router_ap"
+CONFIG_WL_STA="wlconfig_lx_router_sta"
+CONFIG_WL_APSTA="wlconfig_lx_router_apsta"
+CONFIG_WL_AP_SDSTD="wlconfig_lx_router_ap_sdstd"
+CONFIG_WL_AP_ONCHIP_G="wlconfig_lx_router_ap_1chipG"
+CONFIG_WL_STA_ONCHIP_G="wlconfig_lx_router_sta_1chipG"
+CONFIG_WL_HIGH="wlconfig_lx_router_high"
+CONFIG_EMF=m
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_DM9000 is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+# CONFIG_HWMON is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# Real Time Clock
+#
+# CONFIG_RTC_CLASS is not set
+
+#
+# DMA Engine support
+#
+# CONFIG_DMA_ENGINE is not set
+
+#
+# DMA Clients
+#
+
+#
+# DMA Devices
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+CONFIG_CONFIGFS_FS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HWSIM is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="root=/dev/mtdblock2 console=ttyS0,115200 init=/sbin/preinit"
+CONFIG_SYS_SUPPORTS_KGDB=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -urBwNp linux-2.6.22/arch/mips/Kconfig linux-2.6/arch/mips/Kconfig
--- linux-2.6.22/arch/mips/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/Kconfig	2008-12-12 06:25:39.000000000 +0300
@@ -4,16 +4,27 @@ config MIPS
 	# Horrible source of confusion.  Die, die, die ...
 	select EMBEDDED
 
+config ZONE_DMA
+	bool
+
 mainmenu "Linux/MIPS Kernel Configuration"
 
 menu "Machine selection"
 
-config ZONE_DMA
-	bool
-
 choice
 	prompt "System type"
-	default SGI_IP22
+	default MIPS_BRCM
+
+config MIPS_BRCM
+	bool "Broadcom MIPS based platforms"
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_KGDB
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
 
 config MACH_ALCHEMY
 	bool "Alchemy processor based machines"
@@ -673,6 +684,31 @@ source "arch/mips/philips/pnx8550/common
 
 endmenu
 
+menu "Support for Broadcom MIPS based boards"
+
+config BCM947XX
+	bool "Support for Broadcom BCM947XX"
+	depends on MIPS_BRCM
+
+config BCM47XX
+	bool "Support for Broadcom BCM47XX processors"
+	depends on BCM947XX
+
+config BCMIPDSCP
+	bool "Support for Using DSCP based IP forwarding"
+	depends on BCM947XX
+
+config HND_BMIPS3300_PROF
+	bool "Support for performance profiling"
+	depends on BCM947XX
+
+config RAM_SIZE
+	int "Memory size (in megabytes)"
+	depends on BCM947XX
+
+endmenu
+
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
@@ -942,7 +962,7 @@ menu "CPU selection"
 
 choice
 	prompt "CPU type"
-	default CPU_R4X00
+	default CPU_MIPS32_R1
 
 config CPU_MIPS32_R1
 	bool "MIPS32 Release 1"
diff -urBwNp linux-2.6.22/arch/mips/kernel/cpu-probe.c linux-2.6/arch/mips/kernel/cpu-probe.c
--- linux-2.6.22/arch/mips/kernel/cpu-probe.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/cpu-probe.c	2008-12-12 06:25:45.000000000 +0300
@@ -150,9 +150,6 @@ static inline void check_wait(void)
 		break;
 
 	case CPU_74K:
-		cpu_wait = r4k_wait;
-		if ((c->processor_id & 0xff) >= PRID_REV_ENCODE_332(2, 1, 0))
-			cpu_wait = r4k_wait_irqoff;
 		break;
 
 	case CPU_TX49XX:
@@ -646,6 +643,14 @@ static inline void cpu_probe_mips(struct
 		break;
 	case PRID_IMP_74K:
 		c->cputype = CPU_74K;
+		c->options &= ~MIPS_CPU_DIVEC;
+
+		/* Kernel already has hazard barrier instructions in
+		 * place so we clear the IHB bit. CFE sets the IHB bit
+		 * of config7 to enable automatic prevention of hazards.
+		 */
+		if (read_c0_config7() & (1 << 29))
+			clear_c0_config7(1 << 29);
 		break;
 	}
 }
@@ -731,6 +736,51 @@ static inline void cpu_probe_philips(str
 	}
 }
 
+static inline void cpu_probe_broadcom(struct cpuinfo_mips *c)
+{
+	unsigned long config0 = read_c0_config(), config1;
+
+	if ((config0 & CONF_BE) != 
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+	    0
+#else
+	    CONF_BE
+#endif
+	) {
+		panic("Kernel compiled little-endian, but running on a big-endian cpu");
+	}
+
+	decode_configs(c);
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_BCM4710:
+		c->cputype = CPU_BCM4710;
+		c->isa_level = MIPS_CPU_ISA_M32R1;
+		break;
+	case PRID_IMP_4KC:
+	case PRID_IMP_BCM3302:
+		c->cputype = CPU_BCM3302;
+		c->isa_level = MIPS_CPU_ISA_M32R1;
+		break;
+	default:
+		panic("Unknown Broadcom Core!");
+		c->cputype = CPU_UNKNOWN;
+		return;
+	}
+	
+	c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX | MIPS_CPU_4K_CACHE |
+	             MIPS_CPU_COUNTER;
+	config1 = read_c0_config1();
+	if (config1 & (1 << 3))
+		c->options |= MIPS_CPU_WATCH;
+	if (config1 & (1 << 2))
+		c->options |= MIPS_ASE_MIPS16;
+	if (config1 & 1)
+		c->options |= MIPS_CPU_FPU;
+	c->scache.flags = MIPS_CACHE_NOT_PRESENT;
+
+	return;
+}
+
 
 __cpuinit void cpu_probe(void)
 {
@@ -760,6 +810,9 @@ __init void cpu_probe(void)
  	case PRID_COMP_PHILIPS:
 		cpu_probe_philips(c);
 		break;
+ 	case PRID_COMP_BROADCOM:
+		cpu_probe_broadcom(c);
+		break;
 	default:
 		c->cputype = CPU_UNKNOWN;
 	}
diff -urBwNp linux-2.6.22/arch/mips/kernel/genex.S linux-2.6/arch/mips/kernel/genex.S
--- linux-2.6.22/arch/mips/kernel/genex.S	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/genex.S	2008-12-12 06:25:45.000000000 +0300
@@ -54,6 +54,10 @@ NESTED(except_vec3_generic, 0, sp)
 #if R5432_CP0_INTERRUPT_WAR
 	mfc0	k0, CP0_INDEX
 #endif
+#ifdef CONFIG_BCM47XX
+	nop
+	nop
+#endif          
 	mfc0	k1, CP0_CAUSE
 	andi	k1, k1, 0x7c
 #ifdef CONFIG_64BIT
diff -urBwNp linux-2.6.22/arch/mips/kernel/head.S linux-2.6/arch/mips/kernel/head.S
--- linux-2.6.22/arch/mips/kernel/head.S	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/head.S	2008-12-12 06:25:45.000000000 +0300
@@ -129,11 +129,19 @@
 #endif
 	.endm
 
+#ifdef CONFIG_BCM47XX
+#undef eret
+#define eret nop; nop; eret
+#endif
+
+	j	kernel_entry
+	nop
+
 	/*
 	 * Reserved space for exception handlers.
 	 * Necessary for machines which link their kernels at KSEG0.
 	 */
-	.fill	0x400
+	.fill	0x3f4
 
 EXPORT(stext)					# used for profiling
 EXPORT(_stext)
@@ -174,6 +182,7 @@ NESTED(kernel_entry, 16, sp)			# kernel
 	mtc0	t0, CP0_STATUS
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+#if !defined(CONFIG_HWSIM) || defined(CONFIG_HWSIM_ZMEM)
 	PTR_LA		t0, __bss_start		# clear .bss
 	LONG_S		zero, (t0)
 	PTR_LA		t1, __bss_stop - LONGSIZE
@@ -181,6 +190,7 @@ NESTED(kernel_entry, 16, sp)			# kernel
 	PTR_ADDIU	t0, LONGSIZE
 	LONG_S		zero, (t0)
 	bne		t0, t1, 1b
+#endif
 
 	LONG_S		a0, fw_arg0		# firmware arguments
 	LONG_S		a1, fw_arg1
diff -urBwNp linux-2.6.22/arch/mips/kernel/proc.c linux-2.6/arch/mips/kernel/proc.c
--- linux-2.6.22/arch/mips/kernel/proc.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/proc.c	2008-12-12 06:25:46.000000000 +0300
@@ -84,6 +84,8 @@ static const char *cpu_name[] = {
 	[CPU_VR4181A]	= "NEC VR4181A",
 	[CPU_SR71000]	= "Sandcraft SR71000",
 	[CPU_PR4450]	= "Philips PR4450",
+	[CPU_BCM4710]	= "Broadcom BCM4710",
+	[CPU_BCM3302]	= "Broadcom BCM3302",
 };
 
 
@@ -93,6 +95,7 @@ static int show_cpuinfo(struct seq_file
 	unsigned int version = cpu_data[n].processor_id;
 	unsigned int fp_vers = cpu_data[n].fpu_id;
 	char fmt [64];
+	extern unsigned long unaligned_instructions;
 
 #ifdef CONFIG_SMP
 	if (!cpu_isset(n, cpu_online_map))
@@ -138,6 +141,16 @@ static int show_cpuinfo(struct seq_file
 	seq_printf(m, fmt, 'I', vcei_count);
 	seq_printf(m, "\n");
 
+	seq_printf(m, "unaligned_instructions\t: %lu\n", unaligned_instructions);
+
+#ifdef CONFIG_HND_BMIPS3300_PROF
+	seq_printf(m, "dcache hits\t\t: %u\n", read_perf_cntr(0));
+	seq_printf(m, "dcache misses\t\t: %u\n", read_perf_cntr(1));
+	seq_printf(m, "icache hits\t\t: %u\n", read_perf_cntr(2));
+	seq_printf(m, "icache misses\t\t: %u\n", read_perf_cntr(3));
+	seq_printf(m, "instructions\t\t: %u\n", read_perf_cntr(4));
+#endif
+
 	return 0;
 }
 
diff -urBwNp linux-2.6.22/arch/mips/kernel/scall32-o32.S linux-2.6/arch/mips/kernel/scall32-o32.S
--- linux-2.6.22/arch/mips/kernel/scall32-o32.S	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/scall32-o32.S	2009-03-30 07:09:00.000000000 +0400
@@ -55,6 +55,21 @@ NESTED(handle_sys, PT_SIZE, sp)
 	bgez	t3, stackargs
 
 stack_done:
+#ifdef CONFIG_PRINT_SYSCALLS
+	SAVE_STATIC
+	sw	t2, PT_R1(sp)
+	move	a0, sp			# pass pointer to saved regs
+	
+	jal	strace
+
+	RESTORE_STATIC
+	lw	t2, PT_R1(sp)
+
+	lw	a0, PT_R4(sp)		# Restore argument registers
+	lw	a1, PT_R5(sp)
+	lw	a2, PT_R6(sp)
+	lw	a3, PT_R7(sp)
+#endif
 	lw	t0, TI_FLAGS($28)	# syscall tracing enabled?
 	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
 	and	t0, t1
diff '-x.*' -urNBp a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
--- a/arch/mips/kernel/Makefile	2011-09-30 16:24:37.000000000 +0400
+++ b/arch/mips/kernel/Makefile	2011-10-02 20:03:33.000000000 +0400
@@ -69,3 +69,16 @@ obj-$(CONFIG_KEXEC)		+= machine_kexec.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 
 CFLAGS_cpu-bugs64.o	= $(shell if $(CC) $(CFLAGS) -Wa,-mdaddi -c -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-DHAVE_AS_SET_DADDI"; fi)
+
+ifneq ($(CONFIG_PRINT_SYSCALLS),)
+$(src)/syscall.o: $(src)/syscalls.h
+
+clean-files := syscalls.h
+
+quiet_cmd_syscall_names = GEN     $@
+      cmd_syscall_names = awk -f $(src)/syscalls.awk $< >$@
+
+# Only O32 ABI supported for now
+$(src)/syscalls.h: $(src)/scall32-o32.S $(src)/syscalls.awk
+	$(call cmd,syscall_names)
+endif
diff '-x.*' -urNBp a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
--- a/arch/mips/kernel/syscall.c	2007-07-09 03:32:17.000000000 +0400
+++ b/arch/mips/kernel/syscall.c	2011-10-02 20:04:19.000000000 +0400
@@ -443,3 +443,57 @@ int kernel_execve(const char *filename,
 
 	return -__v0;
 }
+
+/*
+ * Build the string table for the builtin "poor man's strace".
+ */
+#ifdef CONFIG_PRINT_SYSCALLS
+static const char *syscall_names[] = {
+# include "syscalls.h"
+};
+
+#ifdef	CONFIG_HWSIM
+int do_strace = 1;
+#else
+int do_strace = 0;
+#endif
+
+asmlinkage void strace(struct pt_regs *regs)
+{
+	int i, narg;
+	unsigned long scn, *pa0, addr;
+	extern asmlinkage unsigned long sys_call_table[];
+
+	if (do_strace == 0)
+		return;
+
+	scn = regs->regs[2];
+	pa0 = &regs->regs[4];
+
+	if ((scn >= __NR_Linux)  && (scn < (__NR_Linux + __NR_Linux_syscalls))) {
+		addr = sys_call_table[(scn - __NR_Linux) << 1];
+		narg = (sys_call_table[((scn - __NR_Linux) << 1) + 1] + (5 << 2)) >> 2;
+	} else {
+		addr = 0;
+		narg = 0;
+	}
+
+	printk("%lu[%s:%d]@0x%08lx: ", jiffies, current->comm, current->pid, regs->cp0_epc);
+	if (addr)
+		printk("%s(", syscall_names[scn - __NR_Linux]);
+	else
+		printk("sc%lu(", scn);
+
+	if (narg > 6) narg = 6;
+
+	for (i = 0; i < narg; i++) {
+		if (i) printk(", ");
+		if (i < 4)
+			printk("0x%08lx", pa0[i]);
+		else
+			printk("0x%08lx", regs->pad0[i]);
+	}
+
+	printk(")\n");
+}
+#endif /* CONFIG_PRINT_SYSCALLS */
diff '-x.*' -urNBp a/arch/mips/kernel/syscalls.awk b/arch/mips/kernel/syscalls.awk
--- a/arch/mips/kernel/syscalls.awk	1970-01-01 03:00:00.000000000 +0300
+++ b/arch/mips/kernel/syscalls.awk	2011-10-02 19:36:30.000000000 +0400
@@ -0,0 +1,18 @@
+BEGIN { is_syscalltable = 0 }
+{
+	if ( $1 == ".macro" && $2 == "syscalltable" ) {
+		is_syscalltable = 1;
+	} else if ( is_syscalltable == 1 ) {
+		if ( $1 == ".endm" ) {
+			is_syscalltable = 0;
+		} else {
+			if ( $1 == "sys" ) {
+				print "\"" $2 "\",";
+			} else if ( $1 == "mille" ) {
+				print "\"" $2 "\", /* mille loop? */";
+			} else {
+				print $0;
+			}
+		}
+	}
+}
diff -urBwNp linux-2.6.22/arch/mips/kernel/time.c linux-2.6/arch/mips/kernel/time.c
--- linux-2.6.22/arch/mips/kernel/time.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/time.c	2008-12-12 06:25:46.000000000 +0300
@@ -23,6 +23,9 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#ifdef CONFIG_KERNPROF
+#include <linux/kernprof.h>
+#endif
 
 #include <asm/bootinfo.h>
 #include <asm/cache.h>
@@ -125,7 +128,38 @@ int (*mips_timer_state)(void);
 void (*mips_timer_ack)(void);
 
 /* last time when xtime and rtc are sync'ed up */
-static long last_rtc_update;
+static long last_rtc_update = 0;
+
+#if defined(CONFIG_KERNPROF)
+int prof_freq[NR_CPUS] = { [0 ... NR_CPUS - 1] = HZ };
+int prof_counter[NR_CPUS] = { [0 ... NR_CPUS - 1] = 1 };
+
+/*
+ * Change the frequency of the profiling timer.  The multiplier is specified
+ * by an appropriate ioctl() on /dev/kernprof.
+ */
+int setup_profiling_timer(unsigned int freq)
+{
+	int i;
+
+	/*
+	 * Sanity check.
+	 */
+	if (!freq)
+		return -EINVAL;
+
+	/* 
+	 * Set the new multiplier for each CPU. CPUs don't start using the
+	 * new values until the next timer interrupt in which they do process
+	 * accounting. At that time they also adjust their APIC timers
+	 * accordingly.
+	 */
+	for (i = 0; i < NR_CPUS; ++i)
+		prof_freq[i] = freq;
+
+	return 0;
+}
+#endif
 
 /*
  * local_timer_interrupt() does profiling and process accounting
@@ -149,10 +183,23 @@ void local_timer_interrupt(int irq, void
  */
 irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
+#if defined(CONFIG_KERNPROF)
+	unsigned int cpu = smp_processor_id();
+#endif
+
 	write_seqlock(&xtime_lock);
 
 	mips_timer_ack();
 
+#if defined(CONFIG_KERNPROF)
+	if (prof_freq[cpu] <= HZ) {
+		if (--prof_counter[cpu] == 0) {
+			if (prof_timer_hook)
+				prof_timer_hook(regs);
+			prof_counter[cpu] = HZ / prof_freq[cpu];
+		}
+	}
+#endif
 	/*
 	 * call the generic timer interrupt handling
 	 */
diff -urBwNp linux-2.6.22/arch/mips/Makefile linux-2.6/arch/mips/Makefile
--- linux-2.6.22/arch/mips/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/Makefile	2008-12-12 06:25:39.000000000 +0300
@@ -81,7 +81,13 @@ endif
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= -msoft-float
 LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
-MODFLAGS			+= -mlong-calls
+MODFLAGS			+= -mlong-calls -fno-common
+
+# Always compile with debug symbols. They will be stripped by the router
+# makefile to produce the final kernel. Debug versions of kernel and brcm
+# kernel modules will be kept with the extension dbgsym attached to their
+# names.
+cflags-y += -ggdb
 
 cflags-y += -ffreestanding
 
@@ -147,6 +153,8 @@ MODFLAGS	+= -msb1-pass1-workarounds
 endif
 endif
 
+cflags-y += $(call check_gcc, -m4710a0kern, )
+
 #
 # Firmware support
 #
@@ -592,6 +600,15 @@ load-$(CONFIG_TOSHIBA_RBTX4938) += 0xfff
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
+#
+# Broadcom BCM947XX variants
+#
+ifdef CONFIG_BCM947XX
+core-$(CONFIG_BCM947XX) += arch/mips/brcm-boards/generic/ arch/mips/brcm-boards/bcm947xx/
+load-$(CONFIG_BCM947XX) := 0xffffffff80001000
+zImage: vmlinux
+endif
+
 ifdef CONFIG_32BIT
 ifdef CONFIG_CPU_LITTLE_ENDIAN
 JIFFIES			= jiffies_64
@@ -603,6 +620,7 @@ JIFFIES			= jiffies_64
 endif
 
 AFLAGS		+= $(cflags-y)
+ASFLAGS		+= $(cflags-y)
 CFLAGS		+= $(cflags-y)
 
 LDFLAGS			+= -m $(ld-emul)
@@ -737,6 +737,7 @@
 archclean:
 	@$(MAKE) $(clean)=arch/mips/boot
 	@$(MAKE) $(clean)=arch/mips/lasat
+	$(Q)$(MAKE) -C arch/mips/brcm-boards/bcm947xx/compressed clean
 
 CLEAN_FILES += vmlinux.32 \
 	       vmlinux.64 \
diff -urBwNp linux-2.6.22/arch/mips/mm/c-r4k.c linux-2.6/arch/mips/mm/c-r4k.c
--- linux-2.6.22/arch/mips/mm/c-r4k.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/mm/c-r4k.c	2008-12-12 06:25:49.000000000 +0300
@@ -559,6 +559,7 @@ static void r4k_dma_cache_wback_inv(unsi
 	BUG_ON(size == 0);
 
 	if (cpu_has_inclusive_pcaches) {
+		printk("r4k_dma_cache_wback_inv: cpu_has_inclusive_pcaches set!!!!\n");
 		if (size >= scache_size)
 			r4k_blast_scache();
 		else
@@ -573,7 +574,7 @@ static void r4k_dma_cache_wback_inv(unsi
 	 */
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
-	} else {
+	} else if (size) {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
 	}
@@ -587,6 +588,7 @@ static void r4k_dma_cache_inv(unsigned l
 	BUG_ON(size == 0);
 
 	if (cpu_has_inclusive_pcaches) {
+		printk("r4k_dma_cache_wback_inv: cpu_has_inclusive_pcaches set!!!!\n");
 		if (size >= scache_size)
 			r4k_blast_scache();
 		else
@@ -596,7 +598,7 @@ static void r4k_dma_cache_inv(unsigned l
 
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
-	} else {
+	} else if (size) {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
 	}
@@ -788,7 +790,6 @@ static void __init probe_pcache(void)
 	case CPU_VR4133:
 		write_c0_config(config & ~VR41_CONF_P4K);
 	case CPU_VR4131:
-		/* Workaround for cache instruction bug of VR4131 */
 		if (c->processor_id == 0x0c80U || c->processor_id == 0x0c81U ||
 		    c->processor_id == 0x0c82U) {
 			config |= 0x00400000U;
@@ -1145,6 +1146,22 @@ void au1x00_fixup_config_od(void)
 	}
 }
 
+#if defined(CONFIG_BCM47XX) || defined(CONFIG_BCM5365)
+static void __cpuinit _change_cachability(u32 cm)
+{
+	change_c0_config(CONF_CM_CMASK, cm);
+
+	if (BCM330X(current_cpu_data.processor_id)) {
+		cm = read_c0_diag();
+		/* Enable icache */
+		cm |= (1 << 31);
+		/* Enable dcache */
+		cm |= (1 << 30);
+		write_c0_diag(cm);
+	}
+}	
+static void (*change_cachability)(u32);
+#else
 static void __cpuinit coherency_setup(void)
 {
 	change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
@@ -1176,6 +1193,7 @@ static void __init coherency_setup(void)
 		break;
 	}
 }
+#endif
 
 void __cpuinit r4k_cache_init(void)
 {
@@ -1232,5 +1250,11 @@ void __init r4k_cache_init(void)
 	build_clear_page();
 	build_copy_page();
 	local_r4k___flush_cache_all(NULL);
+
+#if defined(CONFIG_BCM47XX) || defined(CONFIG_BCM5365)
+	change_cachability = (void (*)(u32)) KSEG1ADDR((unsigned long)(_change_cachability));
+	_change_cachability(CONF_CM_DEFAULT);
+#else
 	coherency_setup();
+#endif
 }
diff -urBwNp linux-2.6.22/arch/mips/mm/tlbex.c linux-2.6/arch/mips/mm/tlbex.c
--- linux-2.6.22/arch/mips/mm/tlbex.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/mm/tlbex.c	2008-12-12 06:25:50.000000000 +0300
@@ -893,6 +891,8 @@ static __init void build_tlb_write_entry
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
+	case CPU_BCM4710:
+	case CPU_BCM3302:
 		if (m4kc_tlbp_war())
 			i_nop(p);
 		tlbw(p);
diff -urBwNp linux-2.6.22/arch/mips/pci/pci.c linux-2.6/arch/mips/pci/pci.c
--- linux-2.6.22/arch/mips/pci/pci.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/pci/pci.c	2010-01-26 15:52:34.000000000 +0300
@@ -108,95 +108,9 @@ static inline u8 bridge_swizzle(u8 pin, 
 	return (((pin - 1) + slot) % 4) + 1;
 }
 
-static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
-{
-	u8 pin = *pinp;
-
-	while (dev->bus->parent) {
-		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
-		/* Move up the chain of bridges. */
-		dev = dev->bus->self;
-        }
-	*pinp = pin;
-
-	/* The slot is the slot of the last bridge. */
-	return PCI_SLOT(dev->devfn);
-}
-
-static int __init pcibios_init(void)
-{
-	struct pci_controller *hose;
-	struct pci_bus *bus;
-	int next_busno;
-	int need_domain_info = 0;
-
-	/* Scan all of the recorded PCI controllers.  */
-	for (next_busno = 0, hose = hose_head; hose; hose = hose->next) {
-
-		if (!hose->iommu)
-			PCI_DMA_BUS_IS_PHYS = 1;
-
-		if (hose->get_busno && pci_probe_only)
-			next_busno = (*hose->get_busno)();
-
-		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
-		hose->bus = bus;
-		hose->need_domain_info = need_domain_info;
-		if (bus) {
-			next_busno = bus->subordinate + 1;
-			/* Don't allow 8-bit bus number overflow inside the hose -
-			   reserve some space for bridges. */
-			if (next_busno > 224) {
-				next_busno = 0;
-				need_domain_info = 1;
-			}
-		}
-	}
-
-	if (!pci_probe_only)
-		pci_assign_unassigned_resources();
-	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
-
-	return 0;
-}
-
+extern int __init pcibios_init(void);
 subsys_initcall(pcibios_init);
 
-static int pcibios_enable_resources(struct pci_dev *dev, int mask)
-{
-	u16 cmd, old_cmd;
-	int idx;
-	struct resource *r;
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	old_cmd = cmd;
-	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
-		/* Only set up the requested stuff */
-		if (!(mask & (1<<idx)))
-			continue;
-
-		r = &dev->resource[idx];
-		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
-			continue;
-		if ((idx == PCI_ROM_RESOURCE) &&
-				(!(r->flags & IORESOURCE_ROM_ENABLE)))
-			continue;
-		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available because of resource collisions\n", pci_name(dev));
-			return -EINVAL;
-		}
-		if (r->flags & IORESOURCE_IO)
-			cmd |= PCI_COMMAND_IO;
-		if (r->flags & IORESOURCE_MEM)
-			cmd |= PCI_COMMAND_MEMORY;
-	}
-	if (cmd != old_cmd) {
-		printk("PCI: Enabling device %s (%04x -> %04x)\n", pci_name(dev), old_cmd, cmd);
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
-	return 0;
-}
-
 /*
  *  If we set up a device for bus mastering, we need to check the latency
  *  timer as certain crappy BIOSes forget to set it properly.
@@ -223,61 +137,6 @@ unsigned int pcibios_assign_all_busses(v
 	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
 }
 
-int pcibios_enable_device(struct pci_dev *dev, int mask)
-{
-	int err;
-
-	if ((err = pcibios_enable_resources(dev, mask)) < 0)
-		return err;
-
-	return pcibios_plat_dev_init(dev);
-}
-
-static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev,
-	struct pci_bus *bus)
-{
-	/* Update device resources.  */
-	struct pci_controller *hose = (struct pci_controller *)bus->sysdata;
-	unsigned long offset = 0;
-	int i;
-
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		if (!dev->resource[i].start)
-			continue;
-		if (dev->resource[i].flags & IORESOURCE_IO)
-			offset = hose->io_offset;
-		else if (dev->resource[i].flags & IORESOURCE_MEM)
-			offset = hose->mem_offset;
-
-		dev->resource[i].start += offset;
-		dev->resource[i].end += offset;
-	}
-}
-
-void __devinit pcibios_fixup_bus(struct pci_bus *bus)
-{
-	/* Propagate hose info into the subordinate devices.  */
-
-	struct pci_controller *hose = bus->sysdata;
-	struct list_head *ln;
-	struct pci_dev *dev = bus->self;
-
-	if (!dev) {
-		bus->resource[0] = hose->io_resource;
-		bus->resource[1] = hose->mem_resource;
-	} else if (pci_probe_only &&
-		   (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
-		pci_read_bridge_bases(bus);
-		pcibios_fixup_device_resources(dev, bus);
-	}
-
-	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-		struct pci_dev *dev = pci_dev_b(ln);
-
-		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
-			pcibios_fixup_device_resources(dev, bus);
-	}
-}
 
 void __init
 pcibios_update_irq(struct pci_dev *dev, int irq)
@@ -323,8 +182,3 @@ EXPORT_SYMBOL(pcibios_bus_to_resource);
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif
-
-char *pcibios_setup(char *str)
-{
-	return str;
-}
diff -uBp a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug
--- a/arch/mips/Kconfig.debug	2008-02-26 02:59:40.000000000 +0300
+++ b/arch/mips/Kconfig.debug	2011-10-02 16:06:14.000000000 +0400
@@ -95,4 +95,9 @@
 	  hardware debugging with a logic analyzer and need to see all traffic
 	  on the bus.
 
+config PRINT_SYSCALLS
+	bool "Syscalls trace"
+	help
+	  Enables poor man's strace.
+
 endmenu
diff -urBwNp linux-2.6.22/drivers/Makefile linux-2.6/drivers/Makefile
--- linux-2.6.22/drivers/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/Makefile	2008-12-12 06:27:04.000000000 +0300
@@ -41,6 +41,8 @@ obj-$(CONFIG_IEEE1394)		+= ieee1394/
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
 obj-$(CONFIG_MTD)		+= mtd/
+obj-y				+= nvram_linux.o
+nvram_linux-objs := ../arch/mips/brcm-boards/bcm947xx/nvram_linux.o
 obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
diff -urBwNp linux-2.6.22/drivers/mtd/chips/cfi_probe.c linux-2.6/drivers/mtd/chips/cfi_probe.c
--- linux-2.6.22/drivers/mtd/chips/cfi_probe.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/mtd/chips/cfi_probe.c	2008-12-12 06:28:48.000000000 +0300
@@ -120,6 +120,7 @@ static int __xipram cfi_probe_chip(struc
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
+	udelay(1);
 
 	if (!qry_present(map,base,cfi)) {
 		xip_enable(base, map, cfi);
diff -uB linux-2.6/drivers/mtd/devices/Kconfig linux-2.6/drivers/mtd/devices/Kconfig
--- linux-2.6/drivers/mtd/devices/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/mtd/devices/Kconfig	2008-12-12 06:28:48.000000000 +0300
@@ -1,6 +1,9 @@
 menu "Self-contained MTD device drivers"
 	depends on MTD!=n
 
+config MTD_SFLASH
+	bool "Broadcom Chipcommon Serial Flash support"
+
 config MTD_PMC551
 	tristate "Ramix PMC551 PCI Mezzanine RAM card support"
 	depends on PCI
diff -urBwNp linux-2.6.22/drivers/mtd/devices/Makefile linux-2.6/drivers/mtd/devices/Makefile
--- linux-2.6.22/drivers/mtd/devices/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/mtd/devices/Makefile	2008-12-12 06:28:48.000000000 +0300
@@ -18,3 +18,4 @@ obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_DATAFLASH26)	+= at91_dataflash26.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_SFLASH)	+= sflash.o
diff -urBwNp linux-2.6.22/drivers/mtd/devices/sflash.c linux-2.6/drivers/mtd/devices/sflash.c
--- linux-2.6.22/drivers/mtd/devices/sflash.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/mtd/devices/sflash.c	2008-12-12 06:28:49.000000000 +0300
@@ -0,0 +1,282 @@
+/*
+ * Broadcom SiliconBackplane chipcommon serial flash interface
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: sflash.c,v 1.1 2008/07/09 09:56:22 Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <bcmnvram.h>
+#include <siutils.h>
+#include <hndpci.h>
+#include <pcicfg.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <sflash.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+extern struct mtd_partition * init_mtd_partitions(struct mtd_info *mtd, size_t size);
+#endif
+
+
+struct sflash_mtd {
+	si_t *sih;
+	chipcregs_t *cc;
+	struct mtd_info mtd;
+	struct mtd_erase_region_info region;
+};
+
+/* Private global state */
+static struct sflash_mtd sflash;
+
+static int
+sflash_mtd_poll(struct sflash_mtd *sflash, unsigned int offset, int timeout)
+{
+	int now = jiffies;
+	int ret = 0;
+
+	for (;;) {
+		if (!sflash_poll(sflash->sih, sflash->cc, offset)) {
+			ret = 0;
+			break;
+		}
+		if (time_after((unsigned long)jiffies, (unsigned long)now + timeout)) {
+			printk(KERN_ERR "sflash: timeout\n");
+			ret = -ETIMEDOUT;
+			break;
+		}
+		udelay(1);
+	}
+
+	return ret;
+}
+
+static int
+sflash_mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct sflash_mtd *sflash = (struct sflash_mtd *) mtd->priv;
+	int bytes, ret = 0;
+
+	/* Check address range */
+	if (!len)
+		return 0;
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+
+	*retlen = 0;
+	while (len) {
+		if ((bytes = sflash_read(sflash->sih, sflash->cc, (uint) from, len, buf)) < 0) {
+			ret = bytes;
+			break;
+		}
+		from += (loff_t) bytes;
+		len -= bytes;
+		buf += bytes;
+		*retlen += bytes;
+	}
+
+	return ret;
+}
+
+static int
+sflash_mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct sflash_mtd *sflash = (struct sflash_mtd *) mtd->priv;
+	int bytes, ret = 0;
+
+	/* Check address range */
+	if (!len)
+		return 0;
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+
+	*retlen = 0;
+	while (len) {
+		if ((bytes = sflash_write(sflash->sih, sflash->cc, (uint) to, len, buf)) < 0) {
+			ret = bytes;
+			break;
+		}
+		if ((ret = sflash_mtd_poll(sflash, (unsigned int) to, HZ / 10)))
+			break;
+		to += (loff_t) bytes;
+		len -= bytes;
+		buf += bytes;
+		*retlen += bytes;
+	}
+
+	return ret;
+}
+
+static int
+sflash_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
+{
+	struct sflash_mtd *sflash = (struct sflash_mtd *) mtd->priv;
+	int i, j, ret = 0;
+	unsigned int addr, len;
+
+	/* Check address range */
+	if (!erase->len)
+		return 0;
+	if ((erase->addr + erase->len) > mtd->size)
+		return -EINVAL;
+
+	addr = erase->addr;
+	len = erase->len;
+
+	/* Ensure that requested region is aligned */
+	for (i = 0; i < mtd->numeraseregions; i++) {
+		for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
+			if (addr == mtd->eraseregions[i].offset +
+			    mtd->eraseregions[i].erasesize * j &&
+			    len >= mtd->eraseregions[i].erasesize) {
+				if ((ret = sflash_erase(sflash->sih, sflash->cc, addr)) < 0)
+					break;
+				if ((ret = sflash_mtd_poll(sflash, addr, 10 * HZ)))
+					break;
+				addr += mtd->eraseregions[i].erasesize;
+				len -= mtd->eraseregions[i].erasesize;
+			}
+		}
+		if (ret)
+			break;
+	}
+
+	/* Set erase status */
+	if (ret)
+		erase->state = MTD_ERASE_FAILED;
+	else
+		erase->state = MTD_ERASE_DONE;
+
+	/* Call erase callback */
+	if (erase->callback)
+		erase->callback(erase);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define sflash_mtd_init init_module
+#define sflash_mtd_exit cleanup_module
+#endif
+
+static int __init
+sflash_mtd_init(void)
+{
+	int ret = 0;
+	struct sflash *info;
+	struct pci_dev *dev = NULL;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+#endif
+
+	list_for_each_entry(dev, &((pci_find_bus(0, 0))->devices), bus_list) {
+		if ((dev != NULL) && (dev->device == CC_CORE_ID))
+			break;
+	}
+
+	if (dev == NULL) {
+		printk(KERN_ERR "sflash: chipcommon not found\n");
+		return -ENODEV;
+	}
+
+	memset(&sflash, 0, sizeof(struct sflash_mtd));
+
+	/* attach to the backplane */
+	if (!(sflash.sih = si_kattach(SI_OSH))) {
+		printk(KERN_ERR "sflash: error attaching to backplane\n");
+		ret = -EIO;
+		goto fail;
+	}
+
+	/* Map registers and flash base */
+	if (!(sflash.cc = ioremap_nocache(
+		pci_resource_start(dev, 0),
+		pci_resource_len(dev, 0)))) {
+		printk(KERN_ERR "sflash: error mapping registers\n");
+		ret = -EIO;
+		goto fail;
+	}
+
+	/* Initialize serial flash access */
+	if (!(info = sflash_init(sflash.sih, sflash.cc))) {
+		printk(KERN_ERR "sflash: found no supported devices\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	/* Setup region info */
+	sflash.region.offset = 0;
+	sflash.region.erasesize = info->blocksize;
+	sflash.region.numblocks = info->numblocks;
+	if (sflash.region.erasesize > sflash.mtd.erasesize)
+		sflash.mtd.erasesize = sflash.region.erasesize;
+	sflash.mtd.size = info->size;
+	sflash.mtd.numeraseregions = 1;
+
+	/* Register with MTD */
+	sflash.mtd.name = "sflash";
+	sflash.mtd.type = MTD_NORFLASH;
+	sflash.mtd.flags = MTD_CAP_NORFLASH;
+	sflash.mtd.eraseregions = &sflash.region;
+	sflash.mtd.erase = sflash_mtd_erase;
+	sflash.mtd.read = sflash_mtd_read;
+	sflash.mtd.write = sflash_mtd_write;
+	sflash.mtd.writesize = 1;
+	sflash.mtd.priv = &sflash;
+	sflash.mtd.owner = THIS_MODULE;
+
+
+#ifdef CONFIG_MTD_PARTITIONS
+	parts = init_mtd_partitions(&sflash.mtd, sflash.mtd.size);
+	ret = add_mtd_partitions(&sflash.mtd, parts, 4);
+	if (ret) {
+		printk(KERN_ERR "sflash: add_mtd failed\n");
+		goto fail;
+	}
+#endif
+	return 0;
+
+fail:
+	if (sflash.cc)
+		iounmap((void *) sflash.cc);
+	if (sflash.sih)
+		si_detach(sflash.sih);
+	return ret;
+}
+
+static void __exit
+sflash_mtd_exit(void)
+{
+#ifdef CONFIG_MTD_PARTITIONS
+	del_mtd_partitions(&sflash.mtd);
+#else
+	del_mtd_device(&sflash.mtd);
+#endif
+	iounmap((void *) sflash.cc);
+	si_detach(sflash.sih);
+}
+
+module_init(sflash_mtd_init);
+module_exit(sflash_mtd_exit);
diff -uB linux-2.6/drivers/mtd/maps/Kconfig linux-2.6/drivers/mtd/maps/Kconfig
--- linux-2.6/drivers/mtd/maps/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/mtd/maps/Kconfig	2008-12-12 06:28:49.000000000 +0300
@@ -620,5 +620,8 @@
 
 	  This selection automatically selects the map_ram driver.
 
-endmenu
+config MTD_BCM947XX
+	tristate "CFI Flash device mapped on Broadcom BCM947XX boards"
+	depends on MTD_CFI
 
+endmenu
diff -urBwNp linux-2.6.22/drivers/mtd/maps/bcm947xx-flash.c linux-2.6/drivers/mtd/maps/bcm947xx-flash.c
--- linux-2.6.22/drivers/mtd/maps/bcm947xx-flash.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/mtd/maps/bcm947xx-flash.c	2008-12-12 06:28:49.000000000 +0300
@@ -0,0 +1,169 @@
+/*
+ * Flash mapping for BCM947XX boards
+ *
+ * Copyright (C) 2008, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: bcm947xx-flash.c,v 1.5 2008/03/25 01:27:49 Exp $
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+
+#include <typedefs.h>
+#include <bcmnvram.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <siutils.h>
+#include <trxhdr.h>
+
+/* Global SB handle */
+extern void *bcm947xx_sih;
+extern spinlock_t bcm947xx_sih_lock;
+
+/* Convenience */
+#define sih bcm947xx_sih
+#define sih_lock bcm947xx_sih_lock
+
+#ifdef CONFIG_MTD_PARTITIONS
+extern struct mtd_partition * init_mtd_partitions(struct mtd_info *mtd, size_t size);
+#endif
+
+#define WINDOW_ADDR 0x1fc00000
+#define WINDOW_SIZE 0x400000
+#define BUSWIDTH 2
+
+/* e.g., flash=2M or flash=4M */
+static int flash = 0;
+module_param(flash, int, 0);
+static int __init
+bcm947xx_setup(char *str)
+{
+	flash = memparse(str, &str);
+	return 1;
+}
+__setup("flash=", bcm947xx_setup);
+
+static struct mtd_info *bcm947xx_mtd;
+
+
+#if LINUX_VERSION_CODE < 0x20212 && defined(MODULE)
+#define init_bcm947xx_map init_module
+#define cleanup_bcm947xx_map cleanup_module
+#endif
+
+struct map_info bcm947xx_map = {
+	.name = "Physically mapped flash",
+	.size = WINDOW_SIZE,
+	.bankwidth = BUSWIDTH
+};
+
+static int __init
+init_bcm947xx_map(void)
+{
+	ulong flags;
+ 	uint coreidx;
+	chipcregs_t *cc;
+	uint32 fltype;
+	uint window_addr = 0, window_size = 0;
+	size_t size;
+	int ret = 0;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+#endif
+
+	spin_lock_irqsave(&sih_lock, flags);
+	coreidx = si_coreidx(sih);
+
+	/* Check strapping option if chipcommon exists */
+	if ((cc = si_setcore(sih, CC_CORE_ID, 0))) {
+		fltype = readl(&cc->capabilities) & CC_CAP_FLASH_MASK;
+		if (fltype == PFLASH) {
+			bcm947xx_map.map_priv_2 = 1;
+			window_addr = 0x1c000000;
+			bcm947xx_map.size = window_size = 32 * 1024 * 1024;
+			if ((readl(&cc->flash_config) & CC_CFG_DS) == 0)
+				bcm947xx_map.bankwidth = 1;
+		}
+	} else {
+		fltype = PFLASH;
+		bcm947xx_map.map_priv_2 = 0;
+		window_addr = WINDOW_ADDR;
+		bcm947xx_map.size = window_size = WINDOW_SIZE;
+	}
+
+	si_setcoreidx(sih, coreidx);
+	spin_unlock_irqrestore(&sih_lock, flags);
+
+	if (fltype != PFLASH) {
+		printk(KERN_ERR "pflash: found no supported devices\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	bcm947xx_map.virt = ioremap(window_addr, window_size);
+	if (bcm947xx_map.virt == NULL) {
+		printk(KERN_ERR "pflash: ioremap failed\n");
+		ret = -EIO;
+		goto fail;
+	}
+
+	if ((bcm947xx_mtd = do_map_probe("cfi_probe", &bcm947xx_map)) == NULL) {
+		printk(KERN_ERR "pflash: cfi_probe failed\n");
+		ret = -ENXIO;
+		goto fail;
+	}
+
+	bcm947xx_mtd->owner = THIS_MODULE;
+
+	/* Allow size override for testing */
+	size = flash ? : bcm947xx_mtd->size;
+
+	printk(KERN_NOTICE "Flash device: 0x%x at 0x%x\n", size, window_addr);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	parts = init_mtd_partitions(bcm947xx_mtd, size);
+	ret = add_mtd_partitions(bcm947xx_mtd, parts, 4);
+	if (ret) {
+		printk(KERN_ERR "pflash: add_mtd_partitions failed\n");
+		goto fail;
+	}
+#endif
+
+	return 0;
+
+ fail:
+	if (bcm947xx_mtd)
+		map_destroy(bcm947xx_mtd);
+	if (bcm947xx_map.map_priv_1)
+		iounmap((void *) bcm947xx_map.map_priv_1);
+	bcm947xx_map.map_priv_1 = 0;
+	return ret;
+}
+
+static void __exit
+cleanup_bcm947xx_map(void)
+{
+#ifdef CONFIG_MTD_PARTITIONS
+	del_mtd_partitions(bcm947xx_mtd);
+#endif
+	map_destroy(bcm947xx_mtd);
+	iounmap((void *) bcm947xx_map.map_priv_1);
+	bcm947xx_map.map_priv_1 = 0;
+}
+
+module_init(init_bcm947xx_map);
+module_exit(cleanup_bcm947xx_map);
diff -urBwNp linux-2.6.22/drivers/mtd/maps/Makefile linux-2.6/drivers/mtd/maps/Makefile
--- linux-2.6.22/drivers/mtd/maps/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/mtd/maps/Makefile	2008-12-12 06:28:49.000000000 +0300
@@ -72,3 +72,4 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_BCM947XX)	+= bcm947xx-flash.o
diff -urBwNp linux-2.6.22/drivers/net/bcm57xx/Makefile linux-2.6/drivers/net/bcm57xx/Makefile
--- linux-2.6.22/drivers/net/bcm57xx/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/bcm57xx/Makefile	2008-12-12 06:29:15.000000000 +0300
@@ -0,0 +1,48 @@
+#
+# Broadcom BCM57XX Gigabit Ethernet driver make file.
+#
+# $Id: Makefile,v 1.3 2008/05/02 22:49:54 Exp $
+#
+
+B57SRCDIR := ../../../../../bcm57xx
+SHAREDSRCDIR := ../../../../../shared
+
+obj-$(CONFIG_BCM57XX) := bcm57xx.o
+
+bcm57xx-objs := $(B57SRCDIR)/linux/b57um.o $(B57SRCDIR)/linux/b57proc.o \
+		$(B57SRCDIR)/linux/b57diag.o \
+		$(B57SRCDIR)/sys/tigon3.o $(B57SRCDIR)/sys/autoneg.o \
+                $(B57SRCDIR)/sys/5701rls.o $(B57SRCDIR)/sys/tcp_seg.o \
+		$(SHAREDSRCDIR)/hndgige.o
+
+# If source directory src/bcm57xx exists, build objects from there
+ifneq ($(wildcard $(src)/$(B57SRCDIR)/sys),)
+
+EXTRA_CFLAGS += -DDBG=0 -DT3_JUMBO_RCV_RCB_ENTRY_COUNT=256 -DNICE_SUPPORT -DBCM_SMALL_DRV
+EXTRA_CFLAGS += -DPCIX_TARGET_WORKAROUND=1 -DINCLUDE_TBI_SUPPORT -DINCLUDE_5701_AX_FIX=1
+EXTRA_CFLAGS += -I$(src)/$(B57SRCDIR)/linux -I$(src)/$(B57SRCDIR)/sys \
+		-I$(src)/$(B57SRCDIR)/include
+
+EXTRA_CFLAGS += -DLINUX_HYBRID_POSTPROCESSING_REMOVAL
+# Otherwise, use object module(s) in this directory
+else
+
+bcm57xx-objs := $(B57SRCDIR)/linux/bcm57xx.o
+
+endif
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+else
+# Normal makefile
+KERNELDIR := ../../../../../linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+endif
+
+clean-files += $(B57SRCDIR)/sys/*.o $(B57SRCDIR)/sys/.*.o.cmd \
+	       $(B57SRCDIR)/linux/*.o $(B57SRCDIR)/linux/.*.o.cmd \
+	       $(SHAREDSRCDIR)/hndgige.o $(SHAREDSRCDIR)/.hndgige.o.cmd
diff -urBwNp linux-2.6.22/drivers/net/emf/Makefile linux-2.6/drivers/net/emf/Makefile
--- linux-2.6.22/drivers/net/emf/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/emf/Makefile	2008-12-12 06:29:20.000000000 +0300
@@ -0,0 +1,43 @@
+#
+# Makefile for the Broadcom EMF Layer
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.3 2008/08/13 20:20:16 Exp $
+#
+
+EMFSRCDIR := ../../../../../router/emf/emf
+EMFCSRCDIR := ../../../../../emf/emf
+EMFDIR := ../../../../../router/emf
+
+EMF_OBJS := $(EMFCSRCDIR)/emfc.o $(EMFSRCDIR)/emf_linux.o
+
+# Search for sources under src/router/emf/emf
+ifneq ($(wildcard $(src)/$(EMFSRCDIR)),)
+	EXTRA_CFLAGS += -I../../router/emf/emf -I../../router/emf/igs
+	EXTRA_CFLAGS += -I../../include/emf/emf -I../../include/emf/igs
+	emf-objs := $(EMF_OBJS)
+else
+	emf-objs := $(EMFDIR)/emf.o
+endif
+
+obj-$(CONFIG_EMF) := emf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+else
+# Normal makefile
+KERNELDIR := ../../../../../linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+endif
+
+clean-files += $(EMFCSRCDIR)/*.o $(EMFSRCDIR)/*.o $(EMFSRCDIR)/.*.o.cmd
diff -urBwNp linux-2.6.22/drivers/net/et/Makefile linux-2.6/drivers/net/et/Makefile
--- linux-2.6.22/drivers/net/et/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/et/Makefile	2008-12-12 06:29:20.000000000 +0300
@@ -0,0 +1,48 @@
+#
+# Makefile for the Broadcom et driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.4 2008/12/12 02:00:40 Exp $
+#
+
+ETSRCDIR := ../../../../../et
+
+et-objs := $(ETSRCDIR)/sys/et_linux.o $(ETSRCDIR)/sys/etc.o
+
+ifeq ($(CONFIG_ET_47XX),y)
+et-objs		+= $(ETSRCDIR)/sys/etc47xx.o $(ETSRCDIR)/sys/etc_adm.o
+et-objs		+= $(ETSRCDIR)/sys/etcgmac.o
+EXTRA_CFLAGS	+= -DCFG_GMAC -DBCM47XX_CHOPS -DETROBO -DETADM -DBCMDMA64 -DBCMDMA32
+endif
+
+obj-$(CONFIG_ET) := et.o
+
+EXTRA_CFLAGS	+= -DDMA -Werror
+
+# Search for sources under src/et/sys or objects under src/et/linux
+ifneq ($(wildcard $(src)/$(ETSRCDIR)/sys),)
+EXTRA_CFLAGS	+= -I$(src)/$(ETSRCDIR)/sys
+else
+et-objs := $(ETSRCDIR)/linux/et.o
+endif
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+else
+# Normal makefile
+KERNELDIR := ../../../../../linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+endif
+
+clean-files += $(ETSRCDIR)/sys/*.o $(ETSRCDIR)/sys/.*.o.cmd
diff -urBwNp linux-2.6.22/drivers/net/hnd/Kconfig linux-2.6/drivers/net/hnd/Kconfig
--- linux-2.6.22/drivers/net/hnd/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/hnd/Kconfig	2008-12-12 06:29:21.000000000 +0300
@@ -0,0 +1,86 @@
+#
+# Broadcom Home Networking Division (HND) driver configuration
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Kconfig,v 1.3 2008/08/11 23:05:54 Exp $
+#
+
+menu "Broadcom HND network devices"
+	depends on PCI
+config HND
+	bool "Broadcom HND network device support"
+config ET
+	tristate "10/100 Ethernet support"
+	depends on HND
+config ET_47XX
+	bool "BCM47xx support"
+	depends on ET
+config WL_EMULATOR
+	bool "WL emulation using Gigabit ethernet"
+	depends on HND
+config BCM57XX
+	tristate "BCM57xx support is ON"
+	depends on WL_EMULATOR
+config WL
+	tristate "Wireless feature variant is set to AP"
+	depends on WL_EMULATOR
+	select WL_USE_AP
+config BCM57XX
+	tristate "BCM57xx Gigabit Ethernet support"
+	depends on HND && !WL_EMULATOR
+config WL
+	tristate "BCM43xx 802.11 Wireless support"
+	depends on HND && !WL_EMULATOR
+#	select WIRELESS_EXT
+choice
+	prompt "Wireless feature variant"
+	depends on HND && !WL_EMULATOR && WL
+config WL_USE_AP
+	bool "Config file for basic AP variant"
+config WL_USE_AP_SDSTD
+	bool "Config file for basic AP sdstd variant"
+config WL_USE_STA
+	bool "Config file for basic STA variant"
+config WL_USE_APSTA
+	bool "Config file for basic APSTA variant"
+config WL_USE_AP_ONCHIP_G
+	bool "Config file for AP 1chipG variant"
+config WL_USE_STA_ONCHIP_G
+	bool "Config file for STA 1chipG variant"
+config WL_USE_APSTA_ONCHIP_G
+	bool "Config file for APSTA 1chipG variant"
+config WL_USE_HIGH
+	bool "Config file for high/bmac split variant"
+endchoice
+config WL_AP
+	string "Config file for basic AP variant"
+	default "wlconfig_lx_router_ap"
+config WL_AP_SDSTD
+	string "Config file for basic AP sdstd variant"
+	default "wlconfig_lx_router_ap_sdstd"
+config WL_STA
+	string "Config file for basic STA variant"
+	default "wlconfig_lx_router_sta"
+config WL_APSTA
+	string "Config file for basic APSTA variant"
+	default "wlconfig_lx_router_apsta"
+config WL_AP_ONCHIP_G
+	string "Config file for AP 1chipG variant"
+	default "wlconfig_lx_router_ap_1chipG"
+config WL_STA_ONCHIP_G
+	string "Config file for STA 1chipG variant"
+	default "wlconfig_lx_router_sta_1chipG"
+config WL_HIGH
+	string "Config file for high/bmac split variant"
+	default "wlconfig_lx_router_high"
+config EMF
+	tristate "Efficient Multicast Forwarding & IGMP Snooping Layers"
+	depends on NETFILTER
+endmenu
diff -urBwNp linux-2.6.22/drivers/net/hnd/Makefile linux-2.6/drivers/net/hnd/Makefile
--- linux-2.6.22/drivers/net/hnd/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/hnd/Makefile	2008-12-12 06:29:21.000000000 +0300
@@ -0,0 +1,115 @@
+#
+# Makefile for Broadcom Home Networking Division (HND) shared driver code
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.5 2008/05/02 22:49:54 Exp $
+#
+
+SHARED   := ../../../../../shared
+ROUTER   := ../../../../../router
+SRC      := ../../../../../../src
+WLSHARED := wlconfig_lx_shared
+WLCFGDIR := $(src)/../../../../../wl/config
+WLSYSDIR := $(src)/../../../../../wl/sys
+
+ifneq ($(wildcard $(WLCFGDIR)),)
+include $(WLCFGDIR)/$(WLSHARED)
+include $(WLCFGDIR)/wl.mk
+endif
+
+hnd-objs := $(addprefix $(SHARED)/, $(sort $(WLFILES:.c=.o)))
+HND_OBJS := $(addprefix $(src)/$(SHARED)/, $(sort $(WLFILES:.c=.o)))
+
+EXTRA_CFLAGS += $(WLFLAGS) -DBCM5354 -DLINUX_HYBRID_POSTPROCESSING_REMOVAL
+
+ifneq ($(CONFIG_BCM947XX),y)
+HND_OBJS += $(src)/$(SHARED)/nvramstubs.o
+hnd-objs += $(SHARED)/nvramstubs.o
+endif
+
+ifeq ($(CONFIG_ET_47XX),y)
+HND_OBJS += $(src)/$(SHARED)/bcmrobo.o
+hnd-objs += $(SHARED)/bcmrobo.o
+else
+ifeq ($(CONFIG_BCM57XX),y)
+HND_OBJS += $(src)/$(SHARED)/bcmrobo.o
+hnd-objs += $(SHARED)/bcmrobo.o
+endif
+endif
+
+ifdef CONFIG_USB_RNDIS
+EXTRA_CFLAGS += -DCONFIG_USBRNDIS_RETAIL
+endif
+
+ifeq ($(BCMDBG_MEM),1)
+EXTRA_CFLAGS += -DBCMDBG_MEM
+endif
+
+obj-$(CONFIG_HND) := hnd.o shared_ksyms.o
+
+clean-files := shared_ksyms.c
+
+ifeq ($(wildcard $(src)/$(SHARED)/bcmutils.c),)
+$(src)/$(SHARED)/bcmutils.o: $(src)/$(SHARED)/linux/bcmutils.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/bcmrobo.c),)
+$(src)/$(SHARED)/bcmrobo.o: $(src)/$(SHARED)/linux/bcmrobo.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/hnddma.c),)
+$(src)/$(SHARED)/hnddma.o: $(src)/$(SHARED)/linux/hnddma.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/linux_osl.c),)
+$(src)/$(SHARED)/linux_osl.o: $(src)/$(SHARED)/linux/linux_osl.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/sbutils.c),)
+$(src)/$(SHARED)/sbutils.o: $(src)/$(SHARED)/linux/sbutils.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/hndpmu.c),)
+$(src)/$(SHARED)/hndpmu.o: $(src)/$(SHARED)/linux/hndpmu.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/bcmsrom.c),)
+$(src)/$(SHARED)/bcmsrom.o: $(src)/$(SHARED)/linux/bcmsrom.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/nvramstubs.c),)
+$(src)/$(SHARED)/nvramstubs.o: $(src)/$(SHARED)/linux/nvramstubs.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/bcmwpa.c),)
+$(src)/$(SHARED)/bcmwpa.o: $(src)/$(SHARED)/linux/bcmwpa.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/bcmotp.c),)
+$(src)/$(SHARED)/bcmotp.o: $(src)/$(SHARED)/linux/bcmotp.o
+	cp $< $@
+endif
+
+ifeq ($(wildcard $(src)/$(SHARED)/nicpci.c),)
+$(src)/$(SHARED)/nicpci.o: $(src)/$(SHARED)/linux/nicpci.o
+	cp $< $@
+endif
+
+$(src)/shared_ksyms.c: $(src)/shared_ksyms.sh $(HND_OBJS)
+	sh -e $< $(HND_OBJS) > $@
diff -urBwNp linux-2.6.22/drivers/net/hnd/shared_ksyms.sh linux-2.6/drivers/net/hnd/shared_ksyms.sh
--- linux-2.6.22/drivers/net/hnd/shared_ksyms.sh	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/hnd/shared_ksyms.sh	2008-12-12 06:29:21.000000000 +0300
@@ -0,0 +1,21 @@
+#!/bin/sh
+#
+# Copyright (C) 2008, Broadcom Corporation      
+# All Rights Reserved.      
+#       
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+#
+# $Id: shared_ksyms.sh,v 1.2 2008/12/05 20:10:41 Exp $
+#
+
+cat <<EOF
+#include <linux/config.h>
+#include <linux/module.h>
+EOF
+
+for file in $* ; do
+    ${NM} $file | sed -ne 's/[0-9A-Fa-f]* [BDRT] \([^ ]*\)/extern void \1; EXPORT_SYMBOL(\1);/p'
+done
diff -urBwNp linux-2.6.22/drivers/net/igs/Makefile linux-2.6/drivers/net/igs/Makefile
--- linux-2.6.22/drivers/net/igs/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/igs/Makefile	2008-12-12 06:29:22.000000000 +0300
@@ -0,0 +1,44 @@
+#
+# Makefile for the Broadcom IGS Layer
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.3 2008/08/13 20:20:16 Exp $
+#
+
+IGSSRCDIR := ../../../../../router/emf/igs
+IGSCSRCDIR := ../../../../../emf/igs
+EMFDIR := ../../../../../router/emf
+
+IGS_OBJS := $(IGSCSRCDIR)/igsc.o $(IGSCSRCDIR)/igsc_sdb.o $(IGSSRCDIR)/igs_linux.o \
+	    $(IGSCSRCDIR)/osl_linux.o
+
+# Search for sources under src/router/emf/igs
+ifneq ($(wildcard $(src)/$(IGSSRCDIR)),)
+	EXTRA_CFLAGS += -I../../router/emf/igs -I../../router/emf/emf
+	EXTRA_CFLAGS += -I../../include/emf/igs -I../../include/emf/emf
+	igs-objs := $(IGS_OBJS)
+else
+	igs-objs := $(EMFDIR)/igs.o
+endif
+
+obj-$(CONFIG_EMF) := igs.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+else
+# Normal makefile
+KERNELDIR := ../../../../../linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+endif
+
+clean-files += $(IGSCSRCDIR)/*.o $(IGSSRCDIR)/*.o $(IGSSRCDIR)/.*.o.cmd
diff -urBwNp linux-2.6.22/drivers/net/Kconfig linux-2.6/drivers/net/Kconfig
--- linux-2.6.22/drivers/net/Kconfig	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/net/Kconfig	2009-05-05 05:50:39.000000000 +0400
@@ -28,6 +28,8 @@ config NETDEVICES
 # that for each of the symbols.
 if NETDEVICES
 
+source "drivers/net/hnd/Kconfig"
+
 config IFB
 	tristate "Intermediate Functional Block support"
 	depends on NET_CLS_ACT
diff -urBwNp linux-2.6.22/drivers/net/Makefile linux-2.6/drivers/net/Makefile
--- linux-2.6.22/drivers/net/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/drivers/net/Makefile	2009-05-05 05:58:26.000000000 +0400
@@ -215,6 +222,16 @@ obj-$(CONFIG_USB_RTL8150)       += usb/
 obj-$(CONFIG_USB_USBNET)        += usb/
 obj-$(CONFIG_USB_ZD1201)        += usb/
 
+#
+# Broadcom HND devices
+#
+obj-$(CONFIG_HND) += hnd/
+obj-$(CONFIG_ET) += et/
+obj-$(CONFIG_BCM57XX) += bcm57xx/
+obj-$(CONFIG_WL) += wl/
+obj-$(CONFIG_EMF) += emf/ igs/
+
+
 obj-y += wireless/
 obj-$(CONFIG_NET_TULIP) += tulip/
 obj-$(CONFIG_HAMRADIO) += hamradio/
diff -urBwNp linux-2.6.22/drivers/net/wl/Makefile linux-2.6/drivers/net/wl/Makefile
--- linux-2.6.22/drivers/net/wl/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/Makefile	2008-12-12 06:29:47.000000000 +0300
@@ -0,0 +1,65 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.9.2 2011/09/14 21:46:00 Exp $
+#
+
+SRCBASE := ../../../../..
+
+TARGET := wl
+WLCONF_H := wlconf.h
+WLCONF_O := wlconf.o
+
+ifneq ($(wildcard $(src)/$(SRCBASE)/wl/linux/wl_*_prebuilt.o),)
+  WL_PARTIAL_REBUILD := 1
+endif
+
+# Generate list of supported variants
+#VLIST_BASE := AP STA APSTA
+VLIST_BASE := APSTA
+
+ifeq ($(CONFIG_WL_USE_AP_SDSTD),y)
+  VLIST_BASE   += AP_SDSTD
+endif
+
+VLIST          += $(VLIST_BASE)
+
+ifeq ($(CONFIG_WL_USBAP),y)
+# Do variants because we need two drivers for dual band operation
+WL_VARIANTS	:= 1
+VLIST		+= HIGH
+# Note that we don't use CONFIG_WL_USE_HIGH because we need to leave WL_SUFFIX for
+# the other driver. HIGH driver is always called wl_high and loaded upon hotplut
+# event.
+endif
+
+ifeq ($(BUILD_WL_ONCHIP_G),true)
+  VLIST        += $(foreach base,$(VLIST_BASE),$(base)_ONCHIP_G)
+endif # BUILD_WL_ONCHIP_G
+
+
+# Set suffix and config based on the selected variant
+WL_SUFFIX := $(strip $(foreach v,$(VLIST),$(if $(CONFIG_WL_USE_$(v)),$(v))))
+CONFIG_WL_CONF := $(CONFIG_WL_$(WL_SUFFIX))
+
+# Module file names use lowercase of the suffix
+wl_suffix := $(shell echo "$(WL_SUFFIX)" | tr A-Z a-z)
+
+
+# For PREBUILD and postbuild w/WLSRC, compile variants in subdirs
+# Subdir names use lowercase versions of the variant suffixes
+wlsubdirs := $(addprefix wl_,$(foreach v,$(VLIST),$(shell echo "$(v)/" | tr A-Z a-z)))
+
+
+#subdir-$(CONFIG_WL) += $(wlsubdirs)
+
+
+include $(src)/wl_generic.mk
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_ap/Makefile linux-2.6/drivers/net/wl/wl_ap/Makefile
--- linux-2.6.22/drivers/net/wl/wl_ap/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_ap/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:35 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_AP),)
+CONFIG_WL_AP := "wlconfig_lx_router_ap"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_AP)
+
+wl_suffix := ap
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_ap_onchip_g/Makefile linux-2.6/drivers/net/wl/wl_ap_onchip_g/Makefile
--- linux-2.6.22/drivers/net/wl/wl_ap_onchip_g/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_ap_onchip_g/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:37 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_AP_ONCHIP_G),)
+CONFIG_WL_AP_ONCHIP_G := "wlconfig_lx_router_ap_1chipG"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_AP_ONCHIP_G)
+
+wl_suffix := ap_onchip_g
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_ap_sdstd/Makefile linux-2.6/drivers/net/wl/wl_ap_sdstd/Makefile
--- linux-2.6.22/drivers/net/wl/wl_ap_sdstd/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_ap_sdstd/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2008/08/11 23:05:54 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_AP_SDSTD),)
+CONFIG_WL_AP_SDSTD := "wlconfig_lx_router_ap_sdstd"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_AP_SDSTD)
+
+wl_suffix := ap_sdstd
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_apsta/Makefile linux-2.6/drivers/net/wl/wl_apsta/Makefile
--- linux-2.6.22/drivers/net/wl/wl_apsta/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_apsta/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:38 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_APSTA),)
+CONFIG_WL_APSTA := "wlconfig_lx_router_apsta"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_APSTA)
+
+wl_suffix := apsta
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_apsta_onchip_g/Makefile linux-2.6/drivers/net/wl/wl_apsta_onchip_g/Makefile
--- linux-2.6.22/drivers/net/wl/wl_apsta_onchip_g/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_apsta_onchip_g/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:39 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_APSTA_ONCHIP_G),)
+CONFIG_WL_APSTA_ONCHIP_G := "wlconfig_lx_router_apsta_1chipG"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_APSTA_ONCHIP_G)
+
+wl_suffix := apsta_onchip_g
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wlconf.c linux-2.6/drivers/net/wl/wlconf.c
--- linux-2.6.22/drivers/net/wl/wlconf.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wlconf.c	2008-12-12 06:29:47.000000000 +0300
@@ -0,0 +1 @@
+#include <wlconf.h>
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_dngl/Makefile linux-2.6/drivers/net/wl/wl_dngl/Makefile
--- linux-2.6.22/drivers/net/wl/wl_dngl/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_dngl/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2008/08/11 23:05:54 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_DNGL),)
+CONFIG_WL_DNGL := "wlconfig_lx_router_dngl"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_DNGL)
+
+wl_suffix := dngl
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_dngl_onchip_g/Makefile linux-2.6/drivers/net/wl/wl_dngl_onchip_g/Makefile
--- linux-2.6.22/drivers/net/wl/wl_dngl_onchip_g/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_dngl_onchip_g/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright 2007, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2008/08/11 23:05:54 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_DNGL_MIMO),)
+CONFIG_WL_DNGL_MIMO := "wlconfig_lx_router_dngl_mimo"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_DNGL_MIMO)
+
+wl_suffix := dngl_mimo
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_generic.mk linux-2.6/drivers/net/wl/wl_generic.mk
--- linux-2.6.22/drivers/net/wl/wl_generic.mk	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_generic.mk	2011-05-12 06:29:47.000000000 +0300
@@ -0,0 +1,115 @@
+#
+# Generic portion of the Broadcom wl driver makefile
+#
+# input: O_TARGET, CONFIG_WL_CONF and wl_suffix
+# output: obj-m, obj-y
+#
+# $Id: wl_generic.mk,v 1.3.2 2011/09/14 21:46:00 Exp $
+#
+
+REBUILD_WL_MODULE=$(shell if [ -d "$(src)/$(SRCBASE)/wl/sys" -a "$(REUSE_PREBUILT_WL)" != "1" ]; then echo 1; else echo 0; fi)
+
+# If source directory (src/wl/sys) exists and REUSE_PREBUILT_WL is undefined, 
+# then build inside $(SRCBASE)/wl/sys, otherwise use pre-builts
+ifeq ($(REBUILD_WL_MODULE),1)
+
+    # Get the source files and flags from the specified config file
+    # (Remove config's string quotes before trying to use the file)
+    ifeq ($(CONFIG_WL_CONF),)
+         $(error var_vlist($(VLIST)) var_config_wl_use($(shell env|grep CONFIG_WL_USE)))
+         $(error CONFIG_WL_CONF is undefined)
+    endif
+    
+    WLCONFFILE := $(strip $(subst ",,$(CONFIG_WL_CONF))) 
+    WLCFGDIR   := $(src)/$(SRCBASE)/wl/config
+    
+    # define OS flag to pick up wl osl file from wl.mk
+    WLLX=1
+    include $(WLCFGDIR)/$(WLCONFFILE)
+    include $(WLCFGDIR)/wl.mk
+    
+    ifeq ($(WLFILES),)
+         $(error WLFILES is undefined in $(WLCFGDIR)/$(WLCONFFILE))
+    endif
+    
+    ifeq ("$(CONFIG_WL_EMULATOR)","y") 
+         WLFILES += wl_bcm57emu.c
+    endif
+    
+ifeq ($(WL_PARTIAL_REBUILD),1)
+    WL_SOURCE   := wl_linux.c
+    ifeq ($(WLLXIW),1)
+    	WL_SOURCE += wl_iw.c
+    endif
+else
+    WL_SOURCE := $(WLFILES)
+endif
+
+    WL_DFLAGS := $(WLFLAGS)
+    # If source directory (src/wl/sys) exists, use sources to build objects
+    WL_OBJS   := $(foreach file, $(WL_SOURCE), \
+		 $(if $(wildcard $(src)/$(SRCBASE)/wl/sys/$(file)), \
+		 $(addprefix $(SRCBASE)/wl/sys/, $(patsubst %.c,%.o,$(file)))))
+    WL_OBJS   += $(foreach file, $(WL_SOURCE), \
+		 $(if $(wildcard $(src)/$(SRCBASE)/bcmcrypto/$(file)), \
+		 $(addprefix $(SRCBASE)/bcmcrypto/, $(patsubst %.c,%.o,$(file)))))
+    WL_OBJS   += $(foreach file, $(WL_SOURCE), \
+		 $(if $(wildcard $(src)/$(SRCBASE)/shared/$(file)), \
+		 $(addprefix $(SRCBASE)/shared/, $(patsubst %.c,%.o,$(file)))))
+    WL_OBJS   += $(foreach file, $(WL_SOURCE), \
+		 $(if $(wildcard $(src)/$(SRCBASE)/bcmsdio/sys/$(file)), \
+		 $(addprefix $(SRCBASE)/bcmsdio/sys/, $(patsubst %.c,%.o,$(file)))))
+    
+    # need -I. to pick up wlconf.h in build directory
+    
+    EXTRA_CFLAGS += -DDMA $(WL_DFLAGS) -I$(src) -I$(src)/.. -I$(src)/$(SRCBASE)/wl/linux \
+		    -I$(src)/$(SRCBASE)/wl/sys -finline-limit=2048 -Werror
+    
+    # If the PHY_HAL flag is defined we look in directory wl/phy for the
+    # phy source files.
+    ifneq ($(findstring PHY_HAL,$(WL_DFLAGS)),)
+        WL_OBJS   += $(foreach file, $(WL_SOURCE), \
+		     $(if $(wildcard $(src)/$(SRCBASE)/wl/phy/$(file)), \
+		     $(addprefix $(SRCBASE)/wl/phy/, $(patsubst %.c,%.o,$(file)))))
+        EXTRA_CFLAGS += -I$(src)/$(SRCBASE)/wl/phy
+    endif
+
+	UPDATESH   := $(WLCFGDIR)/diffupdate.sh
+
+	WLTUNEFILE ?= wltunable_lx_router.h
+
+    # wl-objs is for linking to wl.o
+ifeq ($(WL_PARTIAL_REBUILD),1)
+    $(TARGET)-objs := $(SRCBASE)/wl/linux/wl_$(wl_suffix)_prebuilt.o
+else
+    $(TARGET)-objs := $(WLCONF_O)
+
+$(obj)/$(WLCONF_O): $(obj)/$(WLCONF_H)
+
+$(obj)/$(WLCONF_H): $(WLCFGDIR)/$(WLTUNEFILE) FORCE
+	[ ! -f $@ ] || chmod +w $@
+	@echo "check and update config file"
+	@echo $(if $(VLIST),"VLIST          = $(VLIST)")
+	@echo "CONFIG_WL_CONF = $(CONFIG_WL_CONF)"
+	@echo "WLTUNEFILE     = $(WLTUNEFILE)"
+	cp $< wltemp
+	$(UPDATESH) wltemp $@
+
+endif # partial rebuild
+
+    $(TARGET)-objs += $(WL_OBJS)
+
+else # SRCBASE/wl/sys doesn't exist
+
+    # Otherwise, assume prebuilt object module(s) in src/wl/linux directory
+    prebuilt := wl_$(wl_suffix).o
+    $(TARGET)-objs := $(SRCBASE)/wl/linux/$(prebuilt)
+
+endif
+
+obj-$(CONFIG_WL) := $(TARGET).o
+
+
+FORCE:
+
+clean-files += $(SRCBASE)/wl/sys/*.o $(SRCBASE)/wl/phy/*.o $(SRCBASE)/wl/sys/.*.*.cmd $(SRCBASE)/wl/phy/.*.*.cmd $(WLCONF_H) $(WLCONF_O)
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_high/Makefile linux-2.6/drivers/net/wl/wl_high/Makefile
--- linux-2.6.22/drivers/net/wl/wl_high/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_high/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.1 2008/05/14 01:24:11 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_HIGH),)
+CONFIG_WL_HIGH := "wlconfig_lx_router_high"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_HIGH)
+
+wl_suffix := high
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_sta/Makefile linux-2.6/drivers/net/wl/wl_sta/Makefile
--- linux-2.6.22/drivers/net/wl/wl_sta/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_sta/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:40 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_STA),)
+CONFIG_WL_STA := "wlconfig_lx_router_sta"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_STA)
+
+wl_suffix := sta
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/drivers/net/wl/wl_sta_onchip_g/Makefile linux-2.6/drivers/net/wl/wl_sta_onchip_g/Makefile
--- linux-2.6.22/drivers/net/wl/wl_sta_onchip_g/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.6/drivers/net/wl/wl_sta_onchip_g/Makefile	2008-12-12 06:29:48.000000000 +0300
@@ -0,0 +1,39 @@
+#
+# Makefile for the Broadcom wl driver
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.2 2007/11/17 01:37:41 Exp $
+#
+
+SRCBASE := ../../../../../..
+
+ifeq ($(CONFIG_WL_STA_ONCHIP_G),)
+CONFIG_WL_STA_ONCHIP_G := "wlconfig_lx_router_sta_1chipG"
+endif
+CONFIG_WL_CONF = $(CONFIG_WL_STA_ONCHIP_G)
+
+wl_suffix := sta_onchip_g
+
+TARGET := wl_$(wl_suffix)
+WLCONF_H := ../wlconf.h
+WLCONF_O := ../wlconf.o
+
+ifneq ($(KERNELVERSION),)
+# kbuild part of makefile
+include $(src)/../wl_generic.mk
+else
+# Normal makefile
+KERNELDIR := $(SRCBASE)/linux/linux-2.6
+all:
+	$(MAKE) -C $(KERNELDIR) M=`pwd`
+clean:
+	$(MAKE) -C $(KERNELDIR) M=`pwd` clean
+include ../wl_generic.mk
+endif
diff -urBwNp linux-2.6.22/include/asm-mips/bootinfo.h linux-2.6/include/asm-mips/bootinfo.h
--- linux-2.6.22/include/asm-mips/bootinfo.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/asm-mips/bootinfo.h	2008-12-12 06:33:23.000000000 +0300
@@ -213,6 +205,16 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+/*
+ * Valid machtype for group BRCM
+ */
+#define MACH_GROUP_BRCM        26       /* Broadcom */
+#define  MACH_BCM93725          0
+#define  MACH_BCM93725_VJ       1
+#define  MACH_BCM93730          2
+#define  MACH_BCM947XX          3
+#define  MACH_BCM933XX          4
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -urBwNp linux-2.6.22/include/asm-mips/cpu.h linux-2.6/include/asm-mips/cpu.h
--- linux-2.6.22/include/asm-mips/cpu.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/asm-mips/cpu.h	2008-12-12 06:33:24.000000000 +0300
@@ -89,6 +89,19 @@
 #define PRID_IMP_34K		0x9500
 #define PRID_IMP_24KE		0x9600
 #define PRID_IMP_74K		0x9700
+#define PRID_IMP_BCM4710	0x4000
+#define PRID_IMP_BCM3302        0x9000
+#define PRID_IMP_BCM3303        0x9100
+
+#define PRID_COPT_MASK          0xff000000
+#define PRID_COMP_MASK          0x00ff0000
+#define PRID_IMP_MASK           0x0000ff00
+#define PRID_REV_MASK           0x000000ff
+
+#define BCM330X(id) \
+	(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) \
+	|| ((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
+
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_SIBYTE
@@ -211,7 +224,9 @@
 #define CPU_SB1A		62
 #define CPU_74K			63
 #define CPU_R14000		64
-#define CPU_LAST		64
+#define CPU_BCM4710		65
+#define CPU_BCM3302		66
+#define CPU_LAST		66
 
 /*
  * ISA Level encodings
diff -urBwNp linux-2.6.22/include/asm-mips/fixmap.h linux-2.6/include/asm-mips/fixmap.h
--- linux-2.6.22/include/asm-mips/fixmap.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/asm-mips/fixmap.h	2008-12-12 06:33:24.000000000 +0300
@@ -79,6 +79,8 @@ extern void __set_fixmap (enum fixed_add
  */
 #if defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TX49XX)
 #define FIXADDR_TOP	((unsigned long)(long)(int)(0xff000000 - 0x20000))
+#elif defined(CONFIG_BCM47XX)
+#define FIXADDR_TOP	((unsigned long)(long)(int)0xf0000000)
 #else
 #define FIXADDR_TOP	((unsigned long)(long)(int)0xfffe0000)
 #endif
diff -urBwNp linux-2.6.22/include/asm-mips/mipsregs.h linux-2.6/include/asm-mips/mipsregs.h
--- linux-2.6.22/include/asm-mips/mipsregs.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/asm-mips/mipsregs.h	2008-12-12 06:33:25.000000000 +0300
@@ -1477,10 +1454,19 @@ change_c0_##name(unsigned int change, un
 __BUILD_SET_C0(status)
 __BUILD_SET_C0(cause)
 __BUILD_SET_C0(config)
+__BUILD_SET_C0(config7)
 __BUILD_SET_C0(intcontrol)
 __BUILD_SET_C0(intctl)
 __BUILD_SET_C0(srsmap)
 
+/*
+ * Functions to access the performance counter and control registers
+ */
+extern asmlinkage unsigned int read_perf_cntr(unsigned int counter);
+extern asmlinkage void write_perf_cntr(unsigned int counter, unsigned int val);
+extern asmlinkage unsigned int read_perf_cntl(unsigned int counter);
+extern asmlinkage void write_perf_cntl(unsigned int counter, unsigned int val);
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* _ASM_MIPSREGS_H */
diff -urBwNp linux-2.6.22/include/asm-mips/stackframe.h linux-2.6/include/asm-mips/stackframe.h
--- linux-2.6.22/include/asm-mips/stackframe.h	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/include/asm-mips/stackframe.h	2008-12-12 06:33:26.000000000 +0300
@@ -350,6 +350,10 @@
 		.macro	RESTORE_SP_AND_RET
 		LONG_L	sp, PT_R29(sp)
 		.set	mips3
+#ifdef CONFIG_BCM47XX
+		nop
+		nop
+#endif /* CONFIG_BCM47XX */
 		eret
 		.set	mips0
 		.endm
diff -urBwNp linux-2.6.22/init/calibrate.c linux-2.6/init/calibrate.c
--- linux-2.6.22/init/calibrate.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/init/calibrate.c	2008-12-12 06:34:41.000000000 +0300
@@ -105,6 +105,10 @@ static unsigned long __devinit calibrate
 static unsigned long __devinit calibrate_delay_direct(void) {return 0;}
 #endif
 
+#if defined(CONFIG_BCM947XX) && defined(CONFIG_HWSIM)
+#include <asm/time.h>
+#endif
+
 /*
  * This is the number of bits of precision for the loops_per_jiffy.  Each
  * bit takes on average 1.5/HZ seconds.  This (like the original) is a little
@@ -117,6 +121,9 @@ void __devinit calibrate_delay(void)
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
 
+#if defined(CONFIG_BCM947XX) && defined(CONFIG_HWSIM)
+	preset_lpj = 10 * (mips_hpt_frequency / 1000);
+#endif
 	if (preset_lpj) {
 		loops_per_jiffy = preset_lpj;
 		printk("Calibrating delay loop (skipped)... "
diff -urBwNp linux-2.6.22/kernel/extable.c linux-2.6/kernel/extable.c
--- linux-2.6.22/kernel/extable.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/kernel/extable.c	2008-12-12 06:34:43.000000000 +0300
@@ -22,11 +22,14 @@
 
 extern struct exception_table_entry __start___ex_table[];
 extern struct exception_table_entry __stop___ex_table[];
+extern struct exception_table_entry __start___dbe_table[];
+extern struct exception_table_entry __stop___dbe_table[];
 
 /* Sort the kernel's built-in exception table */
 void __init sort_main_extable(void)
 {
 	sort_extable(__start___ex_table, __stop___ex_table);
+	sort_extable(__start___dbe_table, __stop___dbe_table);
 }
 
 /* Given an address, look for it in the exception tables. */
diff -urBwNp linux-2.6.22/kernel/irq/spurious.c linux-2.6/kernel/irq/spurious.c
--- linux-2.6.22/kernel/irq/spurious.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/kernel/irq/spurious.c	2009-05-27 12:36:44.000000000 +0400
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 #include <linux/interrupt.h>
+#include <linux/reboot.h>
 
 static int irqfixup __read_mostly;
 
@@ -192,6 +193,9 @@ void note_interrupt(unsigned int irq, st
 		/*
 		 * The interrupt is stuck
 		 */
+		/* reboot it */
+		printk("IRQ error and try to reboot!\n");
+		machine_restart(NULL);
 		__report_bad_irq(irq, desc, action_ret);
 		/*
 		 * Now kill the IRQ
diff -urBwNp linux-2.6.22/kernel/printk.c linux-2.6/kernel/printk.c
--- linux-2.6.22/kernel/printk.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/kernel/printk.c	2008-12-12 06:34:44.000000000 +0300
@@ -469,11 +469,13 @@ __attribute__((weak)) unsigned long long
 /* Check if we have any console registered that can be called early in boot. */
 static int have_callable_console(void)
 {
+#if !defined(CONFIG_HWSIM)
 	struct console *con;
 
 	for (con = console_drivers; con; con = con->next)
 		if (con->flags & CON_ANYTIME)
 			return 1;
+#endif
 
 	return 0;
 }
@@ -521,6 +523,11 @@ asmlinkage int vprintk(const char *fmt,
 	static char printk_buf[1024];
 	static int log_level_unknown = 1;
 
+#if defined(CONFIG_HWSIM) && defined(mips)
+	if (log_buf == __log_buf)
+		log_buf = KSEG1ADDR((char *) __log_buf);
+#endif
+
 	preempt_disable();
 	if (unlikely(oops_in_progress) && printk_cpu == smp_processor_id())
 		/* If a crash is occurring during printk() on this CPU,
diff -urBwNp linux-2.6.22/lib/Kconfig.debug linux-2.6/lib/Kconfig.debug
--- linux-2.6.22/lib/Kconfig.debug	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/lib/Kconfig.debug	2008-12-12 06:34:46.000000000 +0300
@@ -445,3 +445,10 @@ config FAULT_INJECTION_STACKTRACE_FILTER
 	select FRAME_POINTER
 	help
 	  Provide stacktrace filter for fault-injection capabilities
+
+config HWSIM
+	bool "Running on a hardware simulator"
+
+config HWSIM_ZMEM
+	bool "Do clear memory"
+	depends on HWSIM
diff -urBwNp linux-2.6.22/mm/bootmem.c linux-2.6/mm/bootmem.c
--- linux-2.6.22/mm/bootmem.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/mm/bootmem.c	2008-12-12 06:34:49.000000000 +0300
@@ -101,7 +101,9 @@ static unsigned long __init init_bootmem
 	 * register free RAM areas explicitly.
 	 */
 	mapsize = get_mapsize(bdata);
+#if     !defined(CONFIG_HWSIM) || defined(CONFIG_HWSIM_ZMEM)
 	memset(bdata->node_bootmem_map, 0xff, mapsize);
+#endif
 
 	return mapsize;
 }
@@ -296,7 +298,9 @@ found:
 	for (i = start; i < start + areasize; i++)
 		if (unlikely(test_and_set_bit(i, bdata->node_bootmem_map)))
 			BUG();
+#ifndef CONFIG_HWSIM
 	memset(ret, 0, size);
+#endif
 	return ret;
 }
 
diff -urBwNp linux-2.6.22/Makefile linux-2.6/Makefile
--- linux-2.6.22/Makefile	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/Makefile	2009-03-02 10:34:48.000000000 +0300
@@ -316,6 +313,35 @@ CFLAGS          := -Wall -Wundef -Wstric
                    -fno-strict-aliasing -fno-common
 AFLAGS          := -D__ASSEMBLY__
 
+
+# Broadcom source tree
+export SRCBASE := ../..
+CFLAGS += -I$(SRCBASE)/include
+AFLAGS += -I$(SRCBASE)/include
+ASFLAGS += -I$(SRCBASE)/include
+
+ifeq ("$(CONFIG_WL_EMULATOR)","y")
+CFLAGS += -DBCM_WL_EMULATOR -DBCMPERFSTATS
+endif #CONFIG_WL_EMULATOR
+
+#ifdef BCMINTERNAL
+##BCMINTERNAL := y
+ifeq ("$(strip $(BCMINTERNAL))","y")
+AFLAGS += -DBCMINTERNAL
+ASFLAGS += -DBCMINTERNAL
+CFLAGS += -DBCMINTERNAL
+#ifdef BCMDBG
+##BCMDBG := y
+ifeq ("$(strip $(BCMDBG))","y")
+AFLAGS += -DBCMDBG
+ASFLAGS += -DBCMDBG
+CFLAGS += -DBCMDBG
+endif #BCMDBG
+#endif
+endif #BCMINTERNAL
+#endif
+CFLAGS += -DBCMDRIVER -Dlinux
+
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
 KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
 KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
@@ -540,6 +566,8 @@ export MODLIB
 #  the default option --strip-debug will be used.  Otherwise,
 #  INSTALL_MOD_STRIP will used as the options to the strip command.
 
+INSTALL_MOD_STRIP = 1
+
 ifdef INSTALL_MOD_STRIP
 ifeq ($(INSTALL_MOD_STRIP),1)
 mod_strip_cmd = $(STRIP) --strip-debug
@@ -810,9 +838,12 @@ endif
 
 localver-full = $(localver)$(localver-auto)
 
+include/linux/config.h:
+	$(Q)ln -sfn $(srctree)/include/linux/autoconf.h include/linux/config.h
+
 # Store (new) KERNELRELASE string in include/config/kernel.release
 kernelrelease = $(KERNELVERSION)$(localver-full)
-include/config/kernel.release: include/config/auto.conf FORCE
+include/config/kernel.release: include/config/auto.conf include/linux/config.h FORCE
 	$(Q)rm -f $@
 	$(Q)echo $(kernelrelease) > $@
 
--- /dev/null	2008-12-03 13:29:15.000000000 +0300
+++ linux-2.6/arch/mips/brcm-boards/bcm947xx/compressed/Makefile	2008-12-12 06:22:48.000000000 +0300
@@ -0,0 +1,100 @@
+#
+# Makefile for Broadcom BCM947XX boards
+#
+# Copyright (C) 2008, Broadcom Corporation
+# All Rights Reserved.
+# 
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+# KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+# SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+# FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+#
+# $Id: Makefile,v 1.6 2008/04/03 03:48:38 Exp $
+#
+
+
+# Link at 3 MB offset in RAM
+TEXT_START	?= 0x80300000
+
+LOADADDR	:= 0x80001000
+CROSS_COMPILE	?= mipsel-linux-
+
+OBJCOPY		:= $(CROSS_COMPILE)objcopy -O binary -R .reginfo -R .note -R .comment -R .mdebug -S
+OBJCOPYSREC	:= $(CROSS_COMPILE)objcopy -O srec -R .reginfo -R .note -R .comment -R .mdebug -S
+
+vpath %.c $(SRCBASE)/shared
+vpath %.S $(SRCBASE)/shared
+vpath %.lds.in $(SRCBASE)/shared
+
+ASFLAGS		+= -D__ASSEMBLY__ -DLOADADDR=$(LOADADDR) -march=mips32 -Wa,-mips32 -Wa,--trap
+CFLAGS		+= -DLOADADDR=$(LOADADDR) -march=mips32 -Wa,-mips32 -Wa,--trap
+# The self-decompresor is standalone, get rid of the linux flags
+CFLAGS		:= $(subst -Dlinux,,$(CFLAGS))
+CFLAGS		+= -Ulinux -D_MINOSL_ -ffreestanding
+ifdef CONFIG_MCOUNT
+CFLAGS		:= $(subst -pg,,$(CFLAGS))
+endif
+CFLAGS		+= -ffunction-sections $(call check_gcc, -fvtable-gc, )
+
+SYSTEM		?= $(LINUXDIR)/vmlinux
+OBJECTS		:= boot.o sisdram.o sbsdram.o aisdram.o load.o sflash.o \
+		hndmips.o hndchipc.o \
+		sbutils.o aiutils.o siutils.o hndpmu.o nicpci.o \
+		min_osl.o bcmutils.o sromstubs.o nvramstubs.o bcmstdlib.o
+
+CFLAGS		+= -G 0 -mno-abicalls -fno-pic -pipe -msoft-float
+ASFLAGS		+= -G 0 -mno-abicalls -fno-pic -pipe
+
+# Default to bzip2
+COMPRESS	?= bzip2 -c
+
+ifneq ($(findstring gzip,$(COMPRESS)),)
+CFLAGS		+= -DUSE_GZIP
+else
+ifneq ($(findstring bzip2,$(COMPRESS)),)
+CFLAGS		+= -DUSE_BZIP2
+else
+COMPRESS	:= cat
+endif
+endif
+
+CFLAGS		+= -I$(SRCBASE)/include -DBCMDRIVER
+ASFLAGS		+= -I$(SRCBASE)/include
+
+all: zImage vmlinuz
+
+# Don't build dependencies, this may die if $(CC) isn't gcc
+dep:
+
+zImage: vmlinux
+	$(OBJCOPY) $< $@
+
+# Link the loader and the kernel binary together
+vmlinux: vmlinux.lds $(OBJECTS) piggy.o
+	$(LD) -static --gc-sections -no-warn-mismatch -T vmlinux.lds -o $@ $(OBJECTS) piggy.o
+
+vmlinux.lds: hndrte.lds.in Makefile
+	@sed -e s/TEXT_START/$(TEXT_START)/ \
+	     -e s/TARGET_ARCH/mips/ < $< > $@
+
+# Create a linkable version of the (possibly compressed) kernel binary
+piggy.o: piggz piggy.lds
+	$(LD) -no-warn-mismatch -T piggy.lds -r -o $@ -b binary piggz -b elf32-tradlittlemips
+
+piggy.lds:
+	@echo "SECTIONS { .data : { input_len = .; LONG(input_data_end - input_data) input_data = .; *(.data) input_data_end = .; }}" > $@
+
+# Always create a gzipped version named vmlinuz for compatibility
+vmlinuz: piggy
+	gzip -c9 $< > $@
+
+piggz: piggy
+	$(COMPRESS) $< > $@
+
+piggy: $(SYSTEM)
+	$(OBJCOPY) $< $@
+
+mrproper: clean
+
+clean:
+	$(Q)rm -f vmlinux vmlinuz zImage piggz piggy *.lds *.o
diff -urBwNp linux-2.6.22/arch/mips/kernel/gdb-stub.c linux-2.6/arch/mips/kernel/gdb-stub.c
--- linux-2.6.22/arch/mips/kernel/gdb-stub.c	2007-07-09 03:32:17.000000000 +0400
+++ linux-2.6/arch/mips/kernel/gdb-stub.c	2008-12-12 06:25:45.000000000 +0300
@@ -377,7 +377,7 @@ static struct hard_trap_info {
 	unsigned char signo;		/* Signal that we map this trap into */
 } hard_trap_info[] = {
 	{ 6, SIGBUS },			/* instruction bus error */
-	{ 7, SIGBUS },			/* data bus error */
+/*	{ 7, SIGBUS },		*/	/* data bus error */
 	{ 9, SIGTRAP },			/* break */
 	{ 10, SIGILL },			/* reserved instruction */
 /*	{ 11, SIGILL },		*/	/* CPU unusable */
