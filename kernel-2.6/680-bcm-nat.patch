--- a/include/linux/netfilter.h	2011-07-12 08:14:14.988095000 +0000
+++ b/include/linux/netfilter.h	2011-03-14 12:49:47.000000000 +0000
@@ -21,7 +21,12 @@
 #define NF_STOLEN 2
 #define NF_QUEUE 3
 #define NF_REPEAT 4
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+#define NF_FAST_NAT 5
+#define NF_STOP 6
+#else
 #define NF_STOP 5
+#endif
 #define NF_MAX_VERDICT NF_STOP
 
 /* we overload the higher bits for encoding auxiliary data such as the queue
--- a/include/linux/sysctl.h	2011-07-12 08:14:14.998095000 +0000
+++ b/include/linux/sysctl.h	2011-03-14 12:49:09.000000000 +0000
@@ -530,6 +530,9 @@ enum
  	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
 	NET_IPV4_NF_CONNTRACK_COUNT=27,
 	NET_IPV4_NF_CONNTRACK_CHECKSUM=28,
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	NET_IPV4_CONNTRACK_FASTNAT=29,
+#endif
 };
  
 /* /proc/sys/net/ipv6 */
--- a/include/net/netfilter/nf_nat.h	2011-07-12 08:14:15.018095000 +0000
+++ b/include/net/netfilter/nf_nat.h	2011-03-14 14:07:25.000000000 +0000
@@ -56,6 +56,9 @@ struct nf_nat_multi_range_compat
 struct nf_nat_info
 {
 	struct list_head bysource;
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	u_int32_t nat_type;
+#endif
 	struct nf_nat_seq seq[IP_CT_DIR_MAX];
 };
 
--- a/net/ipv4/ip_input.c	2011-07-11 17:06:59.598095000 +0000
+++ b/net/ipv4/ip_input.c	2011-07-11 19:47:06.438095000 +0000
@@ -146,6 +146,10 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+extern int ipv4_conntrack_fastnat;
+#endif
+
 /*
  *	SNMP management statistics
  */
@@ -437,6 +441,9 @@ int ip_rcv(struct sk_buff *skb, struct n
 	}
 
 	/* Remove any debris in the socket control block */
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	if (!ipv4_conntrack_fastnat)
+#endif
 	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
 	return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL,
--- a/net/ipv4/netfilter/bcm_nat.c	1970-01-01 00:00:00.000000000 +0000
+++ b/net/ipv4/netfilter/bcm_nat.c	2011-07-11 19:44:07.418095000 +0000
@@ -0,0 +1,199 @@
+/*
+ * Packet matching code.
+ *
+ * Copyright (C) 1999 Paul `Rusty' Russell & Michael J. Neuling
+ * Copyright (C) 2009-2002 Netfilter core team <coreteam@netfilter.org>
+ *
+ * 19 Jan 2002 Harald Welte <laforge@gnumonks.org>
+ * 	- increase module usage count as soon as we have rules inside
+ * 	  a table
+ */
+#include <linux/config.h>
+#include <linux/cache.h>
+#include <linux/skbuff.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/ip.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <net/netfilter/nf_nat_core.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+#define DEBUGP(format, args...)
+
+typedef int (*bcmNatHitHook)(struct sk_buff *skb);
+typedef int (*bcmNatBindHook)(struct nf_conn *ct,
+	enum ip_conntrack_info ctinfo,
+	struct sk_buff *skb,
+	struct nf_conntrack_l3proto *l3proto,
+	struct nf_conntrack_l4proto *l4proto);
+
+extern bcmNatHitHook bcm_nat_hit_hook;
+extern bcmNatBindHook bcm_nat_bind_hook;
+
+static inline int
+bcm_nat_hit_hook_func(bcmNatHitHook hook_func) {
+	bcm_nat_hit_hook = hook_func;
+	return 1;
+};
+
+static inline int
+bcm_nat_bind_hook_func(bcmNatBindHook hook_func) {
+	bcm_nat_bind_hook = hook_func;
+	return 1;
+};
+
+extern int
+bcm_manip_pkt(u_int16_t proto,
+	struct sk_buff *skb,
+	unsigned int iphdroff,
+	const struct nf_conntrack_tuple *target,
+	enum nf_nat_manip_type maniptype);
+
+extern int
+bcm_nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
+	const struct nf_conntrack_tuple *orig,
+	const struct nf_conntrack_l3proto *l3proto,
+	const struct nf_conntrack_l4proto *l4proto);
+
+/* 
+ * Send packets to output.
+ */
+static inline int
+bcm_fast_path_output(struct sk_buff *skb)
+{
+	int ret = 0;
+	struct dst_entry *dst = skb->dst;
+	struct hh_cache *hh = dst->hh;
+
+	if (hh) {
+		unsigned seq;
+		int hh_len;
+
+		do {
+			int hh_alen;
+			seq = read_seqbegin(&hh->hh_lock);
+			hh_len = hh->hh_len;
+			hh_alen = HH_DATA_ALIGN(hh_len);
+			memcpy(skb->data - hh_alen, hh->hh_data, hh_alen);
+		} while (read_seqretry(&hh->hh_lock, seq));
+
+		skb_push(skb, hh_len);
+		ret = hh->hh_output(skb);
+	} else if (dst->neighbour)
+		ret = dst->neighbour->output(skb);
+
+	/* Don't return 1 */
+	if (ret == 1)
+		return 0;
+	return ret;
+}
+
+static inline int
+ip_skb_dst_mtu(struct sk_buff *skb)
+{
+	struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
+
+	return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ?
+	       skb->dst->dev->mtu : dst_mtu(skb->dst);
+}
+
+static int
+bcm_fast_path(struct sk_buff *skb)
+{
+	if (skb->dst == NULL) {
+		struct iphdr *iph = ip_hdr(skb);
+		struct net_device *dev = skb->dev;
+
+		if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev)) {
+			return NF_DROP;
+		}
+		/*  Change skb owner to output device */
+		skb->dev = skb->dst->dev;
+	}
+
+	if (skb->dst) {
+		if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
+			return ip_fragment(skb, bcm_fast_path_output);
+		else
+			return bcm_fast_path_output(skb);
+	}
+
+	kfree_skb(skb);
+	return -EINVAL;
+}
+
+static int
+bcm_do_bindings(struct nf_conn *ct,
+	enum ip_conntrack_info ctinfo,
+	struct sk_buff *skb,
+	struct nf_conntrack_l3proto *l3proto,
+	struct nf_conntrack_l4proto *l4proto)
+{
+	struct iphdr *iph = ip_hdr(skb);
+	unsigned int i;
+	static int hn[2] = {NF_IP_PRE_ROUTING, NF_IP_POST_ROUTING};
+	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
+
+	for (i = 0; i < 2; i++) {
+		enum nf_nat_manip_type mtype = HOOK2MANIP(hn[i]);
+		unsigned long statusbit;
+
+		if (mtype == IP_NAT_MANIP_SRC)
+			statusbit = IPS_SRC_NAT;
+		else
+			statusbit = IPS_DST_NAT;
+
+		/* Invert if this is reply dir. */
+		if (dir == IP_CT_DIR_REPLY)
+			statusbit ^= IPS_NAT_MASK;
+
+		if (ct->status & statusbit) {
+			struct nf_conntrack_tuple target;
+
+			if (!skb_make_writable(skb, 0))
+					return NF_DROP;
+
+			if (skb->dst == NULL && mtype == IP_NAT_MANIP_SRC) {
+				struct net_device *dev = skb->dev;
+				if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))
+					return NF_DROP;
+				/* Change skb owner */
+				skb->dev = skb->dst->dev;
+			}
+
+			/* We are aiming to look like inverse of other direction. */
+			bcm_nf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple, l3proto, l4proto);
+
+			if (!bcm_manip_pkt(target.dst.protonum, skb, 0, &target, mtype))
+				return NF_DROP;
+		}
+	}
+
+	return NF_FAST_NAT;
+}
+
+static int __init bcm_nat_init(void)
+{
+	bcm_nat_hit_hook_func (bcm_fast_path);
+	bcm_nat_bind_hook_func (bcm_do_bindings);
+	printk("BCM fast NAT: INIT\n");
+	return 0;
+}
+
+static void __exit bcm_nat_fini(void)
+{
+	bcm_nat_hit_hook_func (NULL);
+	bcm_nat_bind_hook_func (NULL);
+}
+
+module_init(bcm_nat_init);
+module_exit(bcm_nat_fini);
+MODULE_LICENSE("Proprietary");
--- a/net/ipv4/netfilter/Kconfig	2011-07-12 08:14:15.018095000 +0000
+++ b/net/ipv4/netfilter/Kconfig	2011-03-14 12:43:42.000000000 +0000
@@ -174,6 +174,14 @@ config NF_NAT_NEEDED
 	depends on NF_NAT
 	default y
 
+config BCM_NAT
+	tristate "Broadcom fast NAT support"
+	depends on NF_CONNTRACK && NF_NAT
+	default y
+	help
+	  This helps packets pass through netfilter faster when a packet
+	  is an established or reply traffic.
+
 config IP_NF_TARGET_MASQUERADE
 	tristate "MASQUERADE target support"
 	depends on NF_NAT
--- a/net/ipv4/netfilter/Makefile	2011-07-12 08:14:15.018095000 +0000
+++ b/net/ipv4/netfilter/Makefile	2011-03-14 12:58:38.000000000 +0000
@@ -18,6 +18,9 @@ obj-$(CONFIG_NF_CONNTRACK_IPV4) += nf_co
 
 obj-$(CONFIG_NF_NAT) += nf_nat.o
 
+# Broadcom NAT
+obj-$(CONFIG_BCM_NAT) += bcm_nat.o
+
 # NAT helpers (nf_conntrack)
 obj-$(CONFIG_NF_NAT_AMANDA) += nf_nat_amanda.o
 obj-$(CONFIG_NF_NAT_FTP) += nf_nat_ftp.o
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2011-07-12 08:14:15.028095000 +0000
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2011-07-11 19:45:04.548095000 +0000
@@ -30,6 +30,11 @@
 #define DEBUGP(format, args...)
 #endif
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+int ipv4_conntrack_fastnat __read_mostly = 1;
+EXPORT_SYMBOL_GPL(ipv4_conntrack_fastnat);
+#endif
+
 static int ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,
 			     struct nf_conntrack_tuple *tuple)
 {
@@ -63,7 +68,11 @@ static int ipv4_print_tuple(struct seq_f
 }
 
 /* Returns new sk_buff, or NULL */
-static int nf_ct_ipv4_gather_frags(struct sk_buff *skb, u_int32_t user)
+#if !defined(CONFIG_BCM_NAT) && !defined(CONFIG_BCM_NAT_MODULE)
+static
+#endif
+int
+nf_ct_ipv4_gather_frags(struct sk_buff *skb, u_int32_t user)
 {
 	int err;
 
@@ -302,6 +311,16 @@ static ctl_table ip_ct_sysctl_table[] =
 		.extra1		= &log_invalid_proto_min,
 		.extra2		= &log_invalid_proto_max,
 	},
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	{
+		.ctl_name	= NET_IPV4_CONNTRACK_FASTNAT,
+		.procname	= "ip_conntrack_fastnat",
+		.data		= &ipv4_conntrack_fastnat,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 	{
 		.ctl_name	= 0
 	}
--- a/net/ipv4/netfilter/nf_nat_core.c	2011-07-12 08:14:15.028095000 +0000
+++ b/net/ipv4/netfilter/nf_nat_core.c	2011-07-11 19:41:27.758095000 +0000
@@ -392,6 +392,24 @@ manip_pkt(u_int16_t proto,
 	return 1;
 }
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+#ifndef CONFIG_BCM_NAT_MODULE
+inline
+#endif
+int
+bcm_manip_pkt(u_int16_t proto,
+	struct sk_buff *skb,
+	unsigned int iphdroff,
+	const struct nf_conntrack_tuple *target,
+	enum nf_nat_manip_type maniptype)
+{
+	return manip_pkt(proto, skb, iphdroff, target, maniptype);
+}
+#ifdef CONFIG_BCM_NAT_MODULE
+EXPORT_SYMBOL(bcm_manip_pkt);
+#endif
+#endif
+
 /* Do packet manipulations according to nf_nat_setup_info. */
 unsigned int nf_nat_packet(struct nf_conn *ct,
 			   enum ip_conntrack_info ctinfo,
--- a/net/netfilter/core.c	2011-07-12 08:14:15.028095000 +0000
+++ b/net/netfilter/core.c	2011-03-14 12:48:17.000000000 +0000
@@ -23,6 +23,11 @@
 
 #include "nf_internals.h"
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+typedef int (*bcmNatHitHook)(struct sk_buff *skb);
+extern bcmNatHitHook bcm_nat_hit_hook;
+#endif
+
 static DEFINE_MUTEX(afinfo_mutex);
 
 struct nf_afinfo *nf_afinfo[NPROTO] __read_mostly;
@@ -133,6 +138,13 @@ unsigned int nf_iterate(struct list_head
 	list_for_each_continue_rcu(*i, head) {
 		struct nf_hook_ops *elem = (struct nf_hook_ops *)*i;
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+		if (!elem->hook) {
+			NFDEBUG("nf_hook_slow: elem is empty return NF_DROP\n");
+			return NF_DROP;
+		}
+#endif
+
 		if (hook_thresh > elem->priority)
 			continue;
 
@@ -140,6 +152,12 @@ unsigned int nf_iterate(struct list_head
 		   reference here, since function can't sleep. --RR */
 repeat:
 		verdict = elem->hook(hook, skb, indev, outdev, okfn);
+
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+		if (verdict == NF_FAST_NAT)
+			return NF_FAST_NAT;
+#endif
+
 		if (verdict != NF_ACCEPT) {
 #ifdef CONFIG_NETFILTER_DEBUG
 			if (unlikely((verdict & NF_VERDICT_MASK)
@@ -189,6 +207,17 @@ next_hook:
 			      verdict >> NF_VERDICT_BITS))
 			goto next_hook;
 	}
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	else if (verdict == NF_FAST_NAT) {
+		if (bcm_nat_hit_hook) {
+			ret = bcm_nat_hit_hook(skb);
+		}
+		else {
+			kfree_skb(skb);
+			ret = -EPERM;
+		}
+	}
+#endif
 unlock:
 	rcu_read_unlock();
 	return ret;
--- a/net/netfilter/nf_conntrack_core.c	2011-07-12 08:14:15.028095000 +0000
+++ b/net/netfilter/nf_conntrack_core.c	2011-07-11 19:52:44.668095000 +0000
@@ -30,6 +30,11 @@
 #include <linux/socket.h>
 #include <linux/mm.h>
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+#include <net/ip.h>
+#include <linux/tcp.h>
+#endif
+
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
@@ -76,6 +81,25 @@ static unsigned int nf_conntrack_next_id
 DEFINE_PER_CPU(struct ip_conntrack_stat, nf_conntrack_stat);
 EXPORT_PER_CPU_SYMBOL(nf_conntrack_stat);
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+#define BCM_FASTNAT_DENY 1
+extern int ipv4_conntrack_fastnat;
+
+typedef int (*bcmNatHitHook)(struct sk_buff *skb);
+typedef int (*bcmNatBindHook)(struct nf_conn *ct,
+	enum ip_conntrack_info ctinfo,
+	struct sk_buff *skb,
+	struct nf_conntrack_l3proto *l3proto,
+	struct nf_conntrack_l4proto *l4proto);
+
+bcmNatHitHook bcm_nat_hit_hook __read_mostly = NULL;
+bcmNatBindHook bcm_nat_bind_hook __read_mostly = NULL;
+#ifdef CONFIG_BCM_NAT_MODULE
+EXPORT_SYMBOL(bcm_nat_hit_hook);
+EXPORT_SYMBOL(bcm_nat_bind_hook);
+#endif
+#endif
+
 /*
  * This scheme offers various size of "struct nf_conn" dependent on
  * features(helper, nat, ...)
@@ -287,6 +311,23 @@ nf_ct_invert_tuple(struct nf_conntrack_t
 }
 EXPORT_SYMBOL_GPL(nf_ct_invert_tuple);
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+#ifndef CONFIG_BCM_NAT_MODULE
+inline
+#endif
+int
+bcm_nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
+	const struct nf_conntrack_tuple *orig,
+	const struct nf_conntrack_l3proto *l3proto,
+	const struct nf_conntrack_l4proto *l4proto)
+{
+	return nf_ct_invert_tuple(inverse, orig, l3proto,l4proto);
+}
+#ifdef CONFIG_BCM_NAT_MODULE
+EXPORT_SYMBOL(bcm_nf_ct_invert_tuple);
+#endif
+#endif
+
 static void
 clean_from_lists(struct nf_conn *ct)
 {
@@ -837,6 +878,11 @@ resolve_normal_ct(struct sk_buff *skb,
 	return ct;
 }
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+extern int
+nf_ct_ipv4_gather_frags(struct sk_buff *skb, u_int32_t user);
+#endif
+
 unsigned int
 nf_conntrack_in(int pf, unsigned int hooknum, struct sk_buff *skb)
 {
@@ -848,6 +894,9 @@ nf_conntrack_in(int pf, unsigned int hoo
 	u_int8_t protonum;
 	int set_reply = 0;
 	int ret;
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	struct nf_conn_nat *nat = NULL;
+#endif
 
 	/* Previously seen (loopback or untracked)?  Ignore. */
 	if (skb->nfct) {
@@ -863,6 +912,19 @@ nf_conntrack_in(int pf, unsigned int hoo
 		return -ret;
 	}
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	if (pf == PF_INET && ipv4_conntrack_fastnat) {
+		/* Gather fragments. */
+		if (ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET)) {
+			if (nf_ct_ipv4_gather_frags(skb,
+						hooknum == NF_IP_PRE_ROUTING ?
+						IP_DEFRAG_CONNTRACK_IN :
+						IP_DEFRAG_CONNTRACK_OUT))
+				return NF_STOLEN;
+		}
+	}
+#endif
+
 	l4proto = __nf_ct_l4proto_find((u_int16_t)pf, protonum);
 
 	/* It may be an special packet, error, unclean...
@@ -902,8 +964,57 @@ nf_conntrack_in(int pf, unsigned int hoo
 		return -ret;
 	}
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	if (pf == PF_INET)
+		nat = nfct_nat(ct);
+
+	if (nat &&
+	    ipv4_conntrack_fastnat && bcm_nat_bind_hook &&
+	    (hooknum == NF_IP_PRE_ROUTING /*|| hooknum == NF_IP_FORWARD*/) &&
+	    (ctinfo == IP_CT_ESTABLISHED || ctinfo == IP_CT_ESTABLISHED + IP_CT_IS_REPLY) &&
+	    (protonum == IPPROTO_TCP || protonum == IPPROTO_UDP)) {
+		struct nf_conn_help *help = nfct_help(ct);
+		struct nf_conntrack_tuple *t1, *t2;
+
+		if ((nat->info.nat_type & BCM_FASTNAT_DENY) || help->helper)
+			goto pass;
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_WEBSTR) || defined(CONFIG_NETFILTER_XT_MATCH_WEBSTR_MODULE)
+		if (ipv4_conntrack_fastnat > 1 && protonum == IPPROTO_TCP ) {
+			struct tcphdr _tcph, *tcph;
+			unsigned char _data[2], *data;
+
+			/* For URL filter; RFC-HTTP: GET, POST, HEAD */
+			if ((tcph = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph)) &&
+			    (data = skb_header_pointer(skb, dataoff + tcph->doff*4, sizeof(_data), &_data)) &&
+			    ((data[0] == 'G' && data[1] == 'E') ||
+			     (data[0] == 'P' && data[1] == 'O') ||
+			     (data[0] == 'H' && data[1] == 'E'))) {
+				nat->info.nat_type |= BCM_FASTNAT_DENY;
+				goto pass;
+			}
+		}
+#endif
+		t1 = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
+		t2 = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
+		if (!(t1->dst.u3.ip == t2->src.u3.ip &&
+			t1->src.u3.ip == t2->dst.u3.ip &&
+			t1->dst.u.all == t2->src.u.all &&
+			t1->src.u.all == t2->dst.u.all)) {
+			ret = bcm_nat_bind_hook(ct, ctinfo, skb, l3proto, l4proto);
+		}
+	}
+	pass:
+#endif
+
 	if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
+	{
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+		if (nat && hooknum == NF_IP_LOCAL_OUT)
+			nat->info.nat_type |= BCM_FASTNAT_DENY;
+#endif
 		nf_conntrack_event_cache(IPCT_STATUS, skb);
+	}
 
 	return ret;
 }
--- a/net/netfilter/nf_conntrack_proto_tcp.c	2011-07-12 08:14:15.038095000 +0000
+++ b/net/netfilter/nf_conntrack_proto_tcp.c	2011-03-14 12:46:34.000000000 +0000
@@ -33,6 +33,10 @@
 #define DEBUGP(format, args...)
 #endif
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+extern int ipv4_conntrack_fastnat;
+#endif
+
 /* Protects conntrack->proto.tcp */
 static DEFINE_RWLOCK(tcp_lock);
 
@@ -776,6 +780,11 @@ static int tcp_error(struct sk_buff *skb
 		return -NF_ACCEPT;
 	}
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	if (ipv4_conntrack_fastnat)
+		return NF_ACCEPT;
+#endif
+
 	/* Checksum invalid? Ignore.
 	 * We skip checking packets on the outgoing path
 	 * because the checksum is assumed to be correct.
--- a/net/netfilter/nf_conntrack_proto_udp.c	2011-07-12 08:14:15.038095000 +0000
+++ b/net/netfilter/nf_conntrack_proto_udp.c	2011-03-14 12:45:59.000000000 +0000
@@ -23,6 +23,10 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_ecache.h>
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+extern int ipv4_conntrack_fastnat;
+#endif
+
 static unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
 static unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
 
@@ -114,6 +118,11 @@ static int udp_error(struct sk_buff *skb
 		return -NF_ACCEPT;
 	}
 
+#if defined(CONFIG_BCM_NAT) || defined(CONFIG_BCM_NAT_MODULE)
+	if (ipv4_conntrack_fastnat)
+		return NF_ACCEPT;
+#endif
+
 	/* Packet with no checksum */
 	if (!hdr->check)
 		return NF_ACCEPT;
