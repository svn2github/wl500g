diff -BurpN -x'*.o' router/rc/bigpond.c gateway/rc/bigpond.c
--- router/rc/bigpond.c	2004-11-11 10:32:06.000000000 +0300
+++ gateway/rc/bigpond.c	2008-03-19 20:07:24.000000000 +0300
@@ -38,7 +38,7 @@ start_bpalogin(void)
 	}
 	else if(nvram_invmatch("wan0_domain", " ") && nvram_invmatch("wan0_domain", ""))
 	{	
-		snprintf(authserver, sizeof(authserver), "sm-server.%s", nvram_safe_get("wan0_domain"));
+		snprintf(authserver, sizeof(authserver), "%s", "sm-server");
 		snprintf(authdomain, sizeof(authdomain), "%s", nvram_safe_get("wan0_domain"));
 	}
 #ifdef REMOVE
@@ -68,7 +68,7 @@ start_bpalogin(void)
 		snprintf(authdomain, sizeof(authdomain), "%s", "");
 	}
 
-	snprintf(buf, sizeof(buf), "%s%c%s", authserver, !strcmp(authdomain,"") ? '\0' : '.', authdomain);
+	snprintf(buf, sizeof(buf), "%s%s%s", authserver, !strcmp(authdomain,"") ? "" : ".", authdomain);
 
 	nvram_set("hb_server_name", buf);
 	
@@ -79,7 +79,9 @@ start_bpalogin(void)
 	fprintf(fp, "username %s\n", nvram_safe_get("wan_pppoe_username"));
 	fprintf(fp, "password %s\n", nvram_safe_get("wan_pppoe_passwd"));
 	fprintf(fp, "authserver %s\n", authserver);
-	fprintf(fp, "%cauthdomain %s\n", strcmp(authdomain,"") ? '\0' : '#', authdomain);
+	if (strcmp(authdomain,"")) {
+	  fprintf(fp, "authdomain %s\n", authdomain);
+	}
 	fprintf(fp, "localport 5050\n");
 	fprintf(fp, "logging syslog\n");
 	fprintf(fp, "debuglevel 0\n");
@@ -115,7 +117,6 @@ stop_bpalogin(void)
 int
 bpa_connect_main(int argc, char **argv)
 {
-	FILE *fp;
 	char buf[254];
 	
 	nvram_set("wan_auth_t", "OK");
@@ -133,6 +134,12 @@ bpa_connect_main(int argc, char **argv)
 int
 bpa_disconnect_main(int argc, char **argv)
 {
+#if 1
+	/* never play with dhcp leases, they're working
+	 idependently of authentication and you could 
+	 erroneously release lease, which was just aquired */
+	nvram_set("wan_auth_t", "FAIL");
+#else
 	char tmp[100], *str;
 	int pid;
 
@@ -144,6 +151,6 @@ bpa_disconnect_main(int argc, char **arg
 		free(str);	
 		kill(pid, SIGUSR2);
 	}
-
+#endif
 	return TRUE;
 }
diff -BurpN -x'*.o' router/rc/common_ex.c gateway/rc/common_ex.c
--- router/rc/common_ex.c	2004-12-10 04:03:12.000000000 +0300
+++ gateway/rc/common_ex.c	2008-12-28 11:27:07.000000000 +0300
@@ -13,6 +13,7 @@
 
 #include<stdlib.h>
 #include<stdio.h>
+#include <string.h>
 #include<time.h>
 #include<signal.h>
 #include<bcmnvram.h>
@@ -22,6 +23,9 @@
 #include<sys/time.h>
 #include<syslog.h>
 #include <stdarg.h>
+#include <errno.h>
+
+#include "rc.h"
 
 #define XSTR(s) STR(s)
 #define STR(s) #s
@@ -56,13 +60,9 @@ char *mac_conv(char *mac_name, int idx, 
 
 	mac = nvram_safe_get(name);
 
-	if (strlen(mac)==0) 
-	{
-		buf[0] = 0;
-	}
-	else
+	j=0;
+	if (strlen(mac)!=0) 
 	{
-		j=0;	
 		for(i=0; i<12; i++)
 		{		
 			if (i!=0&&i%2==0) buf[j++] = ':';
@@ -117,55 +117,6 @@ write_ver:
 	nvram_set("firmver", trim_r(fwver));
 }
 
-void wan_netmask_check(void)
-{
-	unsigned int ip, gw, nm, lip, lnm;
-
-	if (nvram_match("wan0_proto", "static") ||
-	    nvram_match("wan0_proto", "pptp"))
-	{
-		ip = inet_addr(nvram_safe_get("wan_ipaddr"));
-		gw = inet_addr(nvram_safe_get("wan_gateway"));
-		nm = inet_addr(nvram_safe_get("wan_netmask"));
-
-		lip = inet_addr(nvram_safe_get("lan_ipaddr"));
-		lnm = inet_addr(nvram_safe_get("lan_netmask"));
-
-		dprintf("ip : %x %x %x\n", ip, gw, nm);
-
-		if (ip==0x0 || (ip&lnm)==(lip&lnm))
-		{
-			nvram_set("wan_ipaddr", "1.1.1.1");
-			nvram_set("wan_netmask", "255.0.0.0");	
-		}
-
-		// check netmask here
-		if (gw==0 || gw==0xffffffff || (ip&nm)==(gw&nm))
-		{
-			nvram_set("wan0_netmask", nvram_safe_get("wan_netmask"));
-		}
-		else
-		{		
-			for(nm=0xffffffff;nm!=0;nm=(nm>>8))
-			{
-				if ((ip&nm)==(gw&nm)) break;
-			}
-
-			dprintf("nm: %x\n", nm);
-
-			if (nm==0xffffffff) nvram_set("wan0_netmask", "255.255.255.255");
-			else if (nm==0xffffff) nvram_set("wan0_netmask", "255.255.255.0");
-			else if (nm==0xffff) nvram_set("wan0_netmask", "255.255.0.0");
-			else if (nm==0xff) nvram_set("wan0_netmask", "255.0.0.0");
-			else nvram_set("wan0_netmask", "0.0.0.0");
-		}
-
-		nvram_set("wanx_ipaddr", nvram_safe_get("wan0_ipaddr"));
-		nvram_set("wanx_netmask", nvram_safe_get("wan0_netmask"));
-		nvram_set("wanx_gateway", nvram_safe_get("wan0_gateway"));
-	}
-}
-
 /* This function is used to map nvram value from asus to Broadcom */
 void convert_asus_values()
 {	
@@ -198,23 +149,33 @@ void convert_asus_values()
 	cprintf("read from nvram\n");
 
 	/* Wireless Section */
+	nvram_set("wl0_bss_enabled", "1");
+	
+	/* No wsc support yet -- this also fixes nas WPA/WPA-PSK problems */
+	nvram_set("wl0_wsc_mode", "disabled");
+
 	/* Country Code */
 	nvram_set("wl0_country_code", nvram_safe_get("wl_country_code"));
 
 	/* GMODE */
 	nvram_set("wl0_gmode", nvram_safe_get("wl_gmode"));
+	nvram_set("wl0_nmode", nvram_safe_get("wl_gmode"));
 
 	if (nvram_match("wl_gmode_protection_x", "1"))
 	{
 		//cprintf("set to auto\n");
 		nvram_set("wl_gmode_protection", "auto");
 		nvram_set("wl0_gmode_protection", "auto");
+		nvram_set("wl_nmode_protection", "auto");
+		nvram_set("wl0_nmode_protection", "auto");
 	}
 	else
 	{
 		//cprintf("set to off");
 		nvram_set("wl_gmode_protection", "off");
 		nvram_set("wl0_gmode_protection", "off");
+		nvram_set("wl_nmode_protection", "off");
+		nvram_set("wl0_nmode_protection", "off");
 	}	
 
 	if (nvram_match("wl_wep_x", "0"))
@@ -229,21 +190,54 @@ void convert_asus_values()
 #ifdef WPA2_WMM
 	if (nvram_match("wl_auth_mode", "wpa"))
 	{
-		nvram_set("wl_akm", "wpa wpa2");
-		nvram_set("wl0_akm", "wpa wpa2");
+                nvram_set("wl_akm", "wpa");
+                nvram_set("wl0_akm", "wpa");
 	}
+        else if (nvram_match("wl_auth_mode", "wpa2"))
+        {
+                nvram_set("wl_akm", "wpa2");
+                nvram_set("wl0_akm", "wpa2");
+        }
 	else if (nvram_match("wl_auth_mode", "psk"))
 	{
-		nvram_set("wl_akm", "psk psk2");
-		nvram_set("wl0_akm", "psk psk2");
+                if (nvram_match("wl_wpa_mode", "0"))
+                {
+                        if (nvram_match("wl_crypto", "tkip") || nvram_match("wl_crypto", "0"))
+                        {
+                                nvram_set("wl_akm", "psk");
+                                nvram_set("wl0_akm", "psk");
+                        }
+                        else if (nvram_match("wl_crypto", "aes"))
+                        {
+                                nvram_set("wl_akm", "psk2");
+                                nvram_set("wl0_akm", "psk2");
+                        }
+                        else
+                        {
+                                nvram_set("wl_akm", "psk psk2");
+                                nvram_set("wl0_akm", "psk psk2");
+                        }
+                }
+                else if (nvram_match("wl_wpa_mode", "1"))
+                {
+                        nvram_set("wl_akm", "psk");
+                        nvram_set("wl0_akm", "psk");
+                }
+                else if (nvram_match("wl_wpa_mode", "2"))
+                {
+                        nvram_set("wl_akm", "psk2");
+                        nvram_set("wl0_akm", "psk2");
+                }
+
 	}	
 	else 
 	{
 		nvram_set("wl_akm", "");
 		nvram_set("wl0_akm", "");
 	}
-	
-	nvram_set("wl0_auth_mode", "none");
+
+	nvram_set("wl0_auth_mode", 
+		nvram_match("wl_auth_mode", "radius") ? "radius" : "none");
 	nvram_set("wl0_preauth", nvram_safe_get("wl_preauth"));
 	nvram_set("wl0_net_reauth", nvram_safe_get("wl_net_reauth"));
 	nvram_set("wl0_wme", nvram_safe_get("wl_wme"));
@@ -258,12 +252,47 @@ void convert_asus_values()
 	nvram_set("wl0_wme_ap_vo", nvram_safe_get("wl_wme_ap_vo"));
 #else
 	nvram_set("wl0_auth_mode", nvram_safe_get("wl_auth_mode"));
+	nvram_set("wl_akm", "");
+	nvram_set("wl0_akm", "");
+	nvram_set("wl0_wme", "off");
 #endif
 
+	nvram_set("wl0_rate", nvram_safe_get("wl_rate"));
+	nvram_set("wl0_gmode", nvram_get("wl_gmode"));
+	nvram_set("wl0_nreqd", "0");	/* off */
+
+	/* BUGBUG: nmcsidx == -1 causes wlconf to ignore wl_rate */
+	/* setting completely (resets to auto), so we use something < 0 */
+	nvram_set("wl0_nmcsidx", nvram_match("wl_nmcsidx", "-1") ? 
+		"-2" : nvram_get("wl_nmcsidx"));
+	
+	/* override settings for 11n */
+	if (nvram_match("wl_gmode", "6"))	/* 11n */
+	{
+		nvram_set("wl0_rate", "0");
+		nvram_set("wl0_nmode", "1");	/* on */
+		nvram_set("wl0_gmode", "1");	/* auto */
+		nvram_set("wl0_nreqd", "1");	/* on */
+	}
+	else if (nvram_match("wl_gmode","1"))	/* auto */
+	{	
+		nvram_set("wl0_nmode", "-1");	/* auto */
+	} else {
+		nvram_set("wl0_nmode", "0");	/* off */
+	}
+
+	nvram_set("wl0_nbw", nvram_safe_get("wl_nbw"));
+	/* 0 - 20Mhz, 1 - 40 Mhz, 2 - 20Mhz in 2.4G/40Mhz in 5G */
+	nvram_set("wl0_nbw_cap", nvram_match("wl_nbw", "20") ? "0" : "1");
+	nvram_set("wl0_nctrlsb", nvram_safe_get("wl_nctrlsb"));
+	nvram_set("wl0_nband", nvram_safe_get("wl_nband"));
+	nvram_set("wl0_reg_mode", nvram_safe_get("wl_reg_mode"));
+
 	nvram_set("wl0_ssid", nvram_safe_get("wl_ssid"));
 	nvram_set("wl0_channel", nvram_safe_get("wl_channel"));
 	nvram_set("wl0_country_code", nvram_safe_get("wl_country_code"));
 	nvram_set("wl0_rate", nvram_safe_get("wl_rate"));
+	nvram_set("wl0_mrate", nvram_safe_get("wl_mrate"));
 	nvram_set("wl0_rateset", nvram_safe_get("wl_rateset"));
 	nvram_set("wl0_frag", nvram_safe_get("wl_frag"));
 	nvram_set("wl0_rts", nvram_safe_get("wl_rts"));
@@ -293,7 +322,7 @@ void convert_asus_values()
 		int wepidx=atoi(nvram_safe_get("wl0_key"));
 		char wepkey[64], wepname[16];
 
-		sprintf(sbuf, "wl join %s", nvram_safe_get("wl0_ssid"));
+		sprintf(sbuf, "wl join \"%s\"", nvram_safe_get("wl0_ssid"));
 
 		// key ??
 		if (nvram_match("wl0_auth_mode", "psk"))
@@ -308,7 +337,9 @@ void convert_asus_values()
 		
 		sprintf(sbuf, "%s imode bss", sbuf);
 		
-		if (nvram_match("wl0_auth_mode", "shared"))
+		if (nvram_match("wl_auth_mode", "psk"))
+			sprintf(sbuf, "%s amode wpapsk", sbuf);
+		else if (nvram_match("wl_auth_mode", "shared"))
 			sprintf(sbuf, "%s amode shared", sbuf);
 		else sprintf(sbuf, "%s amode open", sbuf);
 
@@ -398,6 +429,7 @@ void convert_asus_values()
 
 	nvram_set("wan0_proto", nvram_safe_get("wan_proto"));
 	nvram_set("wan0_ipaddr", nvram_safe_get("wan_ipaddr"));
+	nvram_set("wan0_netmask", nvram_safe_get("wan_netmask"));
 	nvram_set("wan0_gateway", nvram_safe_get("wan_gateway"));
 
 	nvram_set("wan_ipaddr_t", "");
@@ -406,30 +438,46 @@ void convert_asus_values()
 	nvram_set("wan_dns_t", "");
 	nvram_set("wan_status_t", "Disconnected");
 
-	wan_netmask_check();
-
-
-	if (nvram_match("wan_proto", "pppoe") || nvram_match("wan_proto", "pptp"))
+	if (nvram_match("wan_proto", "pppoe") || nvram_match("wan_proto", "pptp") ||
+		nvram_match("wan_proto", "l2tp"))
 	{
 		nvram_set("wan0_pppoe_ifname", "ppp0");
 		nvram_set("upnp_wan_proto", "pppoe");
 		nvram_set("wan0_pppoe_username", nvram_safe_get("wan_pppoe_username"));
 		nvram_set("wan0_pppoe_passwd", nvram_safe_get("wan_pppoe_passwd"));
 		nvram_set("wan0_pppoe_idletime", nvram_safe_get("wan_pppoe_idletime"));
+		nvram_set("wan0_pppoe_txonly_x", nvram_safe_get("wan_pppoe_txonly_x"));
 		nvram_set("wan0_pppoe_mtu", nvram_safe_get("wan_pppoe_mtu"));
 		nvram_set("wan0_pppoe_mru", nvram_safe_get("wan_pppoe_mru"));
 		nvram_set("wan0_pppoe_service", nvram_safe_get("wan_pppoe_service"));
 		nvram_set("wan0_pppoe_ac", nvram_safe_get("wan_pppoe_ac"));
+		nvram_set("wan0_pppoe_options_x", nvram_safe_get("wan_pppoe_options_x"));
+		nvram_set("wan0_pptp_options_x", nvram_safe_get("wan_pptp_options_x"));
 #ifdef REMOVE
 		nvram_set("wan0_pppoe_demand", "1");
 		nvram_set("wan0_pppoe_keepalive", "1");
 #endif
 		nvram_set("wan0_pppoe_ipaddr", nvram_safe_get("wan_ipaddr"));
-		nvram_set("wan0_pppoe_netmask", nvram_safe_get("wan_netmask"));
-		nvram_set("wan0_pppoe_gateway", nvram_safe_get("wan_gateway"));
+		nvram_set("wan0_pppoe_netmask", 
+			inet_addr_(nvram_safe_get("wan_ipaddr")) && 
+			inet_addr_(nvram_safe_get("wan_netmask")) ? 
+				nvram_get("wan_netmask") : NULL);
+		nvram_set("wan0_pppoe_gateway", nvram_get("wan_gateway"));
+		
+		/* current interface address (dhcp + firewall) */
+		nvram_set("wanx_ipaddr", nvram_safe_get("wan_ipaddr"));
 	}
 	nvram_set("wan0_hostname", nvram_safe_get("wan_hostname"));
-	nvram_set("wan0_hwaddr", mac_conv("wan_hwaddr_x", -1, macbuf));
+
+	if (nvram_invmatch("wan_hwaddr_x", ""))
+	{
+		nvram_set("wan_hwaddr", mac_conv("wan_hwaddr_x", -1, macbuf));
+		nvram_set("wan0_hwaddr", mac_conv("wan_hwaddr_x", -1, macbuf));
+	}
+
+	nvram_set("wan0_dnsenable_x", nvram_safe_get("wan_dnsenable_x"));
+	nvram_unset("wan0_dns");
+	nvram_unset("wanx_dns");
 
 	convert_routes();
 
@@ -445,22 +493,40 @@ void convert_asus_values()
 	if (nvram_match("wan_nat_x", "0") && nvram_match("wan_route_x", "IP_Bridged"))
 	{
 		sprintf(ifnames, "%s", nvram_safe_get("lan_ifnames"));
-		sprintf(ifnames, "%s %s", ifnames, nvram_safe_get("wan_ifnames"));
-		nvram_set("lan_ifnames_t", ifnames);
+		sprintf(ifnames, "%s %s", ifnames, nvram_safe_get("wan_ifname"));
 		nvram_set("router_disable", "1");
 		nvram_set("vlan_enable", "0");
 	}
+	else if (nvram_invmatch("wl_mode_ex", "ap")) 
+	{
+		char name[80], *next;
+		char *wl_ifname = nvram_safe_get("wl0_ifname");
+
+		strcpy(ifnames, nvram_safe_get("wan_ifname"));
+		/* remove wl_ifname from the ifnames */
+		foreach(name, nvram_safe_get("lan_ifnames"), next) {
+			if (strcmp(name, wl_ifname)) {
+				sprintf(ifnames, "%s %s", ifnames, name);
+			}
+		}
+
+		nvram_set("router_disable", "0");
+		nvram_set("vlan_enable", "0");
+	}
 	else 
 	{ 
-		nvram_set("lan_ifnames_t", nvram_safe_get("lan_ifnames"));
+		strcpy(ifnames, nvram_safe_get("lan_ifnames"));
 		nvram_set("router_disable", "0");
 		nvram_set("vlan_enable", "1");
 	}
+	
+	nvram_set("lan_ifnames_t", ifnames);
 
 	// clean some temp variables
 	nvram_set("usb_device", "");
 	nvram_set("usb_ftp_device", "");
-	nvram_set("usb_storage_device", "");
+	/* force mounting (boot_local and wl-hdd) */
+	nvram_set("usb_storage_device", "ide");
 	nvram_set("usb_web_device", "");
 	nvram_set("usb_audio_device", "");
 	nvram_set("usb_webdriver_x", "");
@@ -473,6 +539,21 @@ void convert_asus_values()
 		eval("insmod", "ipt_NETMAP.o");
 	}
 
+        //2005/09/22 insmod FTP module
+        if (nvram_match("usb_ftpenable_x", "1") && atoi(nvram_get("usb_ftpport_x"))!=21)
+        {
+                char ports[32];
+
+                sprintf(ports, "ports=21,%d", atoi(nvram_get("usb_ftpport_x")));
+                eval("insmod", "ip_conntrack_ftp.o", ports);
+                eval("insmod", "ip_nat_ftp.o", ports);
+        }
+        else
+        {
+                eval("insmod", "ip_conntrack_ftp.o");
+                eval("insmod", "ip_nat_ftp.o");
+        }
+
 	update_lan_status(1);
 
 	dprintf("end map\n");
@@ -536,6 +617,7 @@ void update_wan_status(int isup)
 	else if (!strcmp(proto, "dhcp")) nvram_set("wan_proto_t", "Automatic IP");
 	else if (!strcmp(proto, "pppoe")) nvram_set("wan_proto_t", "PPPoE");	
 	else if (!strcmp(proto, "pptp")) nvram_set("wan_proto_t", "PPTP");
+	else if (!strcmp(proto, "l2tp")) nvram_set("wan_proto_t", "L2TP");
 	else if (!strcmp(proto, "bigpond")) nvram_set("wan_proto_t", "BigPond");
 
 
@@ -559,8 +641,8 @@ void update_wan_status(int isup)
 		{		
 			if (nvram_invmatch("wan_dns1_x",""))
 				sprintf(dns_str, "%s", nvram_safe_get("wan_dns1_x"));		
-			if (nvram_invmatch("wan_dns1_x",""))
-				sprintf(dns_str, " %s", nvram_safe_get("wan_dns1_x"));		
+			if (nvram_invmatch("wan_dns2_x",""))
+				sprintf(dns_str, " %s", nvram_safe_get("wan_dns2_x"));		
 			nvram_set("wan_dns_t", dns_str);
 		}
 		else nvram_set("wan_dns_t", nvram_safe_get("wan0_dns"));
@@ -620,6 +702,7 @@ char *pppstatus(char *buf)
    {
 	strcpy(buf, "unknown reason");
    }	
+   return buf;
 }
 
 
@@ -633,7 +716,6 @@ kill_pidfile_s(char *pidfile, int sig)
 {
 	FILE *fp = fopen(pidfile, "r");
 	char buf[256];
-	extern errno;
 
 	if (fp && fgets(buf, sizeof(buf), fp)) {
 		pid_t pid = strtoul(buf, NULL, 0);
diff -BurpN -x'*.o' router/rc/dns.c gateway/rc/dns.c
--- router/rc/dns.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/dns.c	2008-12-28 11:56:00.000000000 +0300
@@ -16,10 +16,13 @@
 #include <sys/ioctl.h>
 
 #include "dns.h"
+#include "dns_decode.h"
 
 #define DNS_PORT 53
 #define SVR_PORT 4567
 
+int dns_construct_name(char *name, char *encoded_name);
+
 static int 
 waitsock(int sockfd, int sec, int usec)
 {
diff -BurpN -x'*.o' router/rc/dns_decode.c gateway/rc/dns_decode.c
--- router/rc/dns_decode.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/dns_decode.c	2008-12-28 12:01:27.000000000 +0300
@@ -3,6 +3,7 @@
 #include <arpa/inet.h>
 #include <string.h>
 
+#include "dns.h"
 #include "dns_decode.h"
 
 /*
diff -BurpN -x'*.o' router/rc/dns_decode.h gateway/rc/dns_decode.h
--- router/rc/dns_decode.h	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/dns_decode.h	2008-12-28 12:01:17.000000000 +0300
@@ -1,4 +1,3 @@
-#include "dns.h"
 
 /*
  * Queries are encoded such that there is and integer specifying how long 
diff -BurpN -x'*.o' router/rc/firewall.c gateway/rc/firewall.c
--- router/rc/firewall.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/firewall.c	2008-12-28 11:57:52.000000000 +0300
@@ -28,6 +28,8 @@
 #include <netconf.h>
 #include <nvparse.h>
 
+extern void g_buf_init();
+
 /* Add filter to specified table */
 static void
 add_filter(netconf_filter_t *filter, int dir)
diff -BurpN -x'*.o' router/rc/firewall_ex.c gateway/rc/firewall_ex.c
--- router/rc/firewall_ex.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/firewall_ex.c	2008-12-28 11:56:49.000000000 +0300
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2004, ASUSTek Inc.
  * All Rights Reserved.
@@ -117,7 +116,7 @@ char *portrange_ex_conv(char *port_name,
 	else if(!strncmp(port, "<", 1)) {
 		sprintf(g_buf, "1-%d", atoi(port+1) - 1);
 	}
-	else if(strptr=strchr(port, ':'))
+	else if ((strptr=strchr(port, ':')) != NULL)
 	{		
 		strcpy(itemname_arr, port);
 		strptr = strchr(itemname_arr, ':');
@@ -129,7 +128,7 @@ char *portrange_ex_conv(char *port_name,
 	}
 	else
 	{
-		sprintf(g_buf, "");
+		g_buf[0] = 0;
 	}
 	
 	return(g_buf_alloc(g_buf));
@@ -162,7 +161,7 @@ char *portrange_ex2_conv(char *port_name
 		*start=1;
 		*end=atoi(port+1);
 	}
-	else if(strptr=strchr(port, ':'))
+	else if( (strptr=strchr(port, ':')) != NULL)
 	{		
 		strcpy(itemname_arr, port);
 		strptr = strchr(itemname_arr, ':');
@@ -178,7 +177,7 @@ char *portrange_ex2_conv(char *port_name
 	}
 	else
 	{
-		sprintf(g_buf, "");
+		g_buf[0] = 0;
 		*start=0;
 		*end=0;
 	}
@@ -408,7 +407,7 @@ void timematch_conv(char *mstr, char *nv
 	return;
 	
 no_match:
-	sprintf(mstr, "");
+	mstr[0] = 0;
 	return;
 }
 
@@ -425,18 +424,19 @@ ip2class(char *lan_ip, char *netmask, ch
 	struct in_addr in;
 	int i=0;
 
-	// only handle class A,B,C	
 	val = (unsigned int)inet_addr(netmask);
 	ip = (unsigned int)inet_addr(lan_ip);
-	in.s_addr = ip & val;
-	if (val==0xff00000) sprintf(buf, "%s/8", inet_ntoa(in));
-	else if (val==0xffff0000) sprintf(buf, "%s/16", inet_ntoa(in));
-	else sprintf(buf, "%s/24", inet_ntoa(in));
-	dprintf(buf);	
+	in.s_addr = ip & val;
+
+        for (val = ntohl(val); val; i++) 
+        	val <<= 1;
+       
+        sprintf(buf, "%s/%d", inet_ntoa(in), i);
+	dprintf("%s", buf);	
 }
 
 void
-write_upnp_forward(FILE *fp, FILE *fp1, char *wan_if, char *wan_ip, char *lan_if, char *lan_ip, char *lan_class, char *logaccept, char *logdrop)
+write_upnp_forward(FILE *fp, char *wan_if, char *wan_ip, char *lan_if, char *lan_ip, char *lan_class, char *logaccept, char *logdrop)
 {
 	char name[] = "forward_portXXXXXXXXXX", value[512];
         char *wan_port0, *wan_port1, *lan_ipaddr, *lan_port0, *lan_port1, *proto;
@@ -499,21 +499,14 @@ write_upnp_forward(FILE *fp, FILE *fp1, 
 		                 --to-destination 192.168.1.88:23  */
 		if( !strcmp(proto,"tcp") || !strcmp(proto,"both") )
 		{
-	   		fprintf(fp, "-A PREROUTING -p tcp -m tcp -d %s --dport %s "
+	   		fprintf(fp, "-A VSERVER -p tcp -m tcp --dport %s "
 				  "-j DNAT --to-destination %s:%s\n"
-					, wan_ip, wan_port0, lan_ipaddr, lan_port0);
-
-			fprintf(fp1, "-A FORWARD -p tcp "
-				 "-m tcp -d %s --dport %s -j %s\n"
-				 , lan_ipaddr, lan_port0, logaccept);
+					, wan_port0, lan_ipaddr, lan_port0);
 		}
 		if( !strcmp(proto,"udp") || !strcmp(proto,"both") ){
-	   		fprintf(fp, "-A PREROUTING -p udp -m udp -d %s --dport %s "
+	   		fprintf(fp, "-A VSERVER -p udp -m udp --dport %s "
 				  "-j DNAT --to-destination %s:%s\n"
-				  	, wan_ip, wan_port0, lan_ipaddr, lan_port0);
-
-			fprintf(fp1, "-A FORWARD -p udp -m udp -d %s --dport %s -j %s\n"
-				 , lan_ipaddr, lan_port0, logaccept);
+				  	, wan_port0, lan_ipaddr, lan_port0);
 		}
 	}
 }
@@ -528,43 +521,49 @@ char *ipoffset(char *ip, int offset, cha
 	dprintf("ip : %s\n", tmp);
 	return(tmp);
 }
+
 
-nat_setting(char *wan_if, char *wan_ip, char *lan_if, char *lan_ip, char *logaccept, char *logdrop)
+void nat_setting(char *wan_if, char *wan_ip, char *lan_if, char *lan_ip, char *logaccept, char *logdrop)
 {
-	FILE *fp, *fp1;
-        char *proto, *flag, *srcip, *srcport, *dstip, *dstport;
-        char *setting, lan_class[32];
+	FILE *fp;
+        char lan_class[32];
 	int i;
 	int wan_port;
-	char *internal_ip, *internal_num;
-	int num;
 	char dstips[32], dstports[12];
      				
 	
-	if ((fp=fopen("/tmp/nat_rules", "w"))==NULL) return -1;
-	if ((fp1=fopen("/tmp/nat_forward_rules", "w"))==NULL) return -1;
+	if ((fp=fopen("/tmp/nat_rules", "w"))==NULL) return;
 
 	fprintf(fp, "*nat\n"
 	       	":PREROUTING ACCEPT [0:0]\n"
 	       	":POSTROUTING ACCEPT [0:0]\n"
-	  	":OUTPUT ACCEPT [0:0]\n");
+	  	":OUTPUT ACCEPT [0:0]\n"
+	  	":VSERVER - [0:0]\n");
 
 	//Log	
    	//if(nvram_match("misc_natlog_x", "1"))
    	// 	fprintf(fp, "-A PREROUTING -i %s -j LOG --log-prefix ALERT --log-level 4\n", wan_if);
 
+	/* VSERVER chain */
+	if (inet_addr_(wan_ip))
+		fprintf(fp, "-A PREROUTING -d %s -j VSERVER\n", wan_ip);
+
+	if (nvram_invmatch("wan0_ifname", wan_if) && inet_addr_(nvram_safe_get("wanx_ipaddr")))
+   		fprintf(fp, "-A PREROUTING -d %s -j VSERVER\n", nvram_get("wanx_ipaddr"));
+      
    	if (nvram_match("misc_http_x", "1"))
 	{
 		wan_port=8080;
    		if (nvram_invmatch("misc_httpport_x", ""))
       			wan_port=atoi(nvram_safe_get("misc_httpport_x")); 	
-   		fprintf(fp, "-A PREROUTING -p tcp -m tcp -d %s --dport %d -j DNAT --to-destination %s:80\n", wan_ip, wan_port, lan_ip);
+   		fprintf(fp, "-A VSERVER -p tcp -m tcp --dport %d -j DNAT --to-destination %s:%s\n",
+			wan_port, lan_ip, nvram_safe_get("http_lanport"));
 	}
 
-   	if (nvram_match("wan_nat_x", "1"))
+   	if (nvram_match("wan_nat_x", "1") && nvram_invmatch("upnp_enable", "0"))
    	{     		
 		// upnp port forward
-        	write_upnp_forward(fp, fp1, wan_if, wan_ip, lan_if, lan_ip, lan_class, logaccept, logdrop);
+        	write_upnp_forward(fp, wan_if, wan_ip, lan_if, lan_ip, lan_class, logaccept, logdrop);
 	}
 
 	// Port forwarding or Virtual Server
@@ -601,45 +600,37 @@ nat_setting(char *wan_if, char *wan_ip, 
 			{
 				if (lport!=NULL && strlen(lport)!=0) 
 				{
-					fprintf(fp, "-A PREROUTING -p tcp -m tcp -d %s --dport %s -j DNAT --to-destination %s\n", 
-					wan_ip, port, dstips);
+					fprintf(fp, "-A VSERVER -p tcp -m tcp --dport %s -j DNAT --to-destination %s\n", 
+					port, dstips);
 				}
 				else
 				{
-					fprintf(fp, "-A PREROUTING -p tcp -m tcp -d %s --dport %s -j DNAT --to %s\n", 
-					wan_ip, port, dstip);
+					fprintf(fp, "-A VSERVER -p tcp -m tcp --dport %s -j DNAT --to %s\n", 
+					port, dstip);
 				}
-
-				fprintf(fp1, "-A FORWARD -p tcp -m tcp -d %s --dport %s -j %s\n", 
-					dstip, dstports, logaccept);
 			}     				
 				
 			if (strcmp(proto, "udp")==0 || strcmp(proto, "both")==0)
 			{
 				if (lport!=NULL && strlen(lport)!=0) 
 				{
-					fprintf(fp, "-A PREROUTING -p udp -m udp -d %s --dport %s -j DNAT --to-destination %s\n", 
-					wan_ip, port, dstips);
+					fprintf(fp, "-A VSERVER -p udp -m udp --dport %s -j DNAT --to-destination %s\n", 
+					port, dstips);
 				}
 				else
 				{
-					fprintf(fp, "-A PREROUTING -p udp -m udp -d %s --dport %s -j DNAT --to %s\n", 
-					wan_ip, port, dstip);
+					fprintf(fp, "-A VSERVER -p udp -m udp --dport %s -j DNAT --to %s\n", 
+					port, dstip);
 				}
-				fprintf(fp1, "-A FORWARD -p udp -m udp -d %s --dport %s -j %s\n", 
-					dstip, dstports, logaccept);
 			}     				        			
 			if (strcmp(proto, "other")==0)
 			{
-				fprintf(fp, "-A PREROUTING -p %s -d %s -j DNAT --to %s\n",
-					protono, wan_ip, dstip);
-
-				fprintf(fp1, "-A FORWARD -p %s -d %s -j %s\n",
-					protono, dstip, logaccept);
+				fprintf(fp, "-A VSERVER -p %s -j DNAT --to %s\n",
+					protono, dstip);
 			}     				        				}	
 	}	
 
-   	if (nvram_match("wan_nat_x", "1") && nvram_invmatch("sp_battle_ips", "0"))
+   	if (nvram_match("wan_nat_x", "1") && nvram_invmatch("sp_battle_ips", "0") && inet_addr_(wan_ip))
 	{
 		#define BASEPORT 6112
 		#define BASEPORT_NEW 10000
@@ -650,34 +641,35 @@ nat_setting(char *wan_if, char *wan_ip, 
 		fprintf(fp, "-A PREROUTING -p udp -d %s --sport %d -j NETMAP --to %s\n", wan_ip, BASEPORT, lan_class);
 
 		fprintf(fp, "-A POSTROUTING -p udp -s %s --dport %d -j NETMAP --to %s\n", lan_class, BASEPORT, wan_ip);
-
-		fprintf(fp1, "-A FORWARD -p udp --dport %d -j %s\n",
-					BASEPORT, logaccept);
 	}
 
    	// Exposed station	
    	if (nvram_match("wan_nat_x", "1") && nvram_invmatch("dmz_ip", ""))
    	{   		
-      		fprintf(fp, "-A PREROUTING -d %s -j DNAT --to %s\n", 
-			wan_ip, nvram_safe_get("dmz_ip"));      
-
-      		fprintf(fp1, "-A FORWARD -d %s -j %s\n", 
-			nvram_safe_get("dmz_ip"), logaccept);      
+      		fprintf(fp, "-A VSERVER -j DNAT --to %s\n", nvram_safe_get("dmz_ip"));
       	}
 
 	if (nvram_match("wan_nat_x", "1"))
-	{
-   		fprintf(fp, "-A POSTROUTING -o %s -j MASQUERADE\n", wan_if);
+	{
+		if (inet_addr_(wan_ip))
+   			fprintf(fp, "-A POSTROUTING -o %s ! -s %s -j MASQUERADE\n", wan_if, wan_ip);
+
+   		/* masquerade physical WAN port connection */
+		if (nvram_invmatch("wan0_ifname", wan_if) && inet_addr_(nvram_safe_get("wanx_ipaddr")))
+			fprintf(fp, "-A POSTROUTING -o %s ! -s %s -j MASQUERADE\n", 
+	   			nvram_get("wan0_ifname"), nvram_get("wanx_ipaddr"));
 
 		// masquerade lan to lan
 		ip2class(lan_ip, nvram_safe_get("lan_netmask"), lan_class);
 		fprintf(fp, "-A POSTROUTING -o %s -s %s -d %s -j MASQUERADE\n", lan_if, lan_class, lan_class);
 	}
+
+	/* Trigger port setting */
+	porttrigger_setting(fp, lan_if);
 
 	fprintf(fp, "COMMIT\n");
 	
 	fclose(fp);
-	fclose(fp1);
 
 	eval("iptables-restore", "/tmp/nat_rules");
 }
@@ -703,156 +695,149 @@ int
 filter_setting(char *wan_if, char *wan_ip, char *lan_if, char *lan_ip, char *logaccept, char *logdrop)
 {
 
-	FILE *fp, *fp1;
+	FILE *fp;
         char *proto, *flag, *srcip, *srcport, *dstip, *dstport;
         char *setting, line[256];
-	char macaccept[32], chain[3];
-	char *ftype, *dtype, *fftype;
-	int num;
 	int i;
-	int wan_port;
 	
 	if ((fp=fopen("/tmp/filter_rules", "w"))==NULL) return -1;
 
-	fprintf(fp, "*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:MACS - [0:0]\n:logaccept - [0:0]\n:logdrop - [0:0]\n");
-
-	strcpy(macaccept, "");
+	fprintf(fp, "*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:MACS - [0:0]\n:SECURITY - [0:0]\n:logaccept - [0:0]\n:logdrop - [0:0]\n");
 
 	// FILTER from LAN to WAN Source MAC
-	if(nvram_invmatch("macfilter_enable_x", "0"))
+	if(nvram_invmatch("macfilter_enable_x", "0") && 
+		nvram_invmatch("macfilter_enable_x", "disabled"))
 	{   		
+		int blacklist = nvram_invmatch("macfilter_enable_x", "1");
 		// LAN/WAN filter		
-		g_buf_init();
-
-		if (nvram_match("macfilter_enable_x", "2"))
-		{
-			dtype = logaccept;
-			ftype = logdrop;
-			fftype = logdrop;
-		}
-		else
-		{
-			dtype = logdrop;
-			ftype = logaccept;
-
-			strcpy(macaccept, "MACS");
-			fftype = macaccept;
-		}
-	
-		num = atoi(nvram_safe_get("macfilter_num_x"));
-
-		for(i=0;i<num;i++)
+		foreach_x("macfilter_num_x")
 		{	
-         		fprintf(fp, "-A INPUT -i %s -m mac --mac-source %s -j %s\n", lan_if, mac_conv("macfilter_list_x", i, line), ftype);
-         		fprintf(fp, "-A FORWARD -i %s -m mac --mac-source %s -j %s\n", lan_if, mac_conv("macfilter_list_x", i, line), fftype);
+			g_buf_init();
+         		fprintf(fp, "-A MACS -m mac --mac-source %s -j %s\n", 
+				mac_conv("macfilter_list_x", i, line), 
+				(blacklist ? logdrop : "RETURN"));
 		} 
+		if (!blacklist)
+			fprintf(fp, "-A MACS -j %s\n", logdrop);
+		fprintf(fp, "-A INPUT -i %s -j MACS\n", lan_if);
+		fprintf(fp, "-A FORWARD -i %s -j MACS\n", lan_if);
 	} 
 
-	if (nvram_invmatch("fw_enable_x", "1"))
-	{
-		if (nvram_match("macfilter_enable_x", "1"))
-		{
-			/* Filter known SPI state */
-			fprintf(fp, "-A INPUT -i %s -m state --state NEW -j %s\n"
-			,lan_if, logdrop);
-		}
-	}
-	else
+	// Security checks
+	// sync-flood protection	
+	fprintf(fp, "-A SECURITY -p tcp --syn -m limit --limit 1/s -j RETURN\n");
+	// furtive port scanner
+	fprintf(fp, "-A SECURITY -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j RETURN\n");
+	// udp flooding
+	fprintf(fp, "-A SECURITY -p udp -m limit --limit 5/s -j RETURN\n");
+	// ping of death
+	fprintf(fp, "-A SECURITY -p icmp -m limit --limit 5/s -j RETURN\n");
+	// drop attacks!!!
+	fprintf(fp, "-A SECURITY -j %s\n", logdrop);
+
+	/* Drop the wrong state, INVALID, packets */
+	fprintf(fp, "-A INPUT -m state --state INVALID -j %s\n", logdrop);
+	/* Accept related connections, skip rest of checks */
+	fprintf(fp, "-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n");
+	/* From localhost and intranet, all traffic is accepted */
+	fprintf(fp, "-A INPUT -i lo -m state --state NEW -j %s\n", logaccept);
+	fprintf(fp, "-A INPUT -i %s -m state --state NEW -j %s\n", lan_if, logaccept);
+	/* Pass multicast */
+	if (nvram_match("mr_enable_x", "1") || nvram_invmatch("udpxy_enable_x", "0")) {
+		fprintf(fp, "-A INPUT -p igmp -d 224.0.0.0/4 -j %s\n", logaccept);
+		fprintf(fp, "-A INPUT -p udp -d 224.0.0.0/4 ! --dport 1900 -j %s\n", logaccept);
+	}
+	/* Check internet traffic */
+	if (nvram_match("fw_dos_x", "1"))
+		fprintf(fp, "-A INPUT -i %s -m state --state NEW -j SECURITY\n", wan_if);
+
+	if (nvram_match("fw_enable_x", "1"))
 	{	
-		if (nvram_match("macfilter_enable_x", "1"))
+		/* enable incoming packets from broken dhcp servers, which are sending replies
+		 * from addresses other than used for query, this could lead to lower level
+		 * of security, but it does not work otherwise (conntrack does not work) :-( 
+		 */
+		if (nvram_match("wan0_proto", "dhcp") || nvram_match("wan0_proto", "bigpond") ||
+		    nvram_match("wan_ipaddr", "0.0.0.0"))
 		{
-			/* Filter known SPI state */
-			fprintf(fp, "-A INPUT -m state --state INVALID -j %s\n"
-		          "-A INPUT -m state --state RELATED,ESTABLISHED -j %s\n"
-	        	  "-A INPUT -i lo -m state --state NEW -j %s\n"
-		          "-A INPUT -i %s -m state --state NEW -j %s\n"
-			,logdrop, logaccept, "ACCEPT", lan_if, logdrop);
+			fprintf(fp, "-A INPUT -p udp --sport 67 --dport 68 -j %s\n", logaccept);
 		}
-		else
+
+		// Firewall between WAN and Local
+		if (nvram_invmatch("http_lanport", "80"))
+			fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport 80 -j %s\n", nvram_safe_get("lan_ipaddr"), logaccept);
+		if (nvram_match("misc_http_x", "1"))
 		{
-			/* Filter known SPI state */
-			fprintf(fp, "-A INPUT -m state --state INVALID -j %s\n"
-		          "-A INPUT -m state --state RELATED,ESTABLISHED -j %s\n"
-	        	  "-A INPUT -i lo -m state --state NEW -j %s\n"
-		          "-A INPUT -i %s -m state --state NEW -j %s\n"
-			,logdrop, logaccept, "ACCEPT", lan_if, "ACCEPT");
+            		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %s -j %s\n", nvram_safe_get("lan_ipaddr"), nvram_safe_get("http_lanport"), logaccept);  
 		}
 
+		if (nvram_match("usb_webenable_x", "2"))
+		{
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %s -j %s\n", nvram_safe_get("usb_webhttpport_x"), logaccept);
 
-	// Firewall between WAN and Local
-	if (nvram_match("misc_http_x", "1"))
-	{
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport 80 -j %s\n", nvram_safe_get("lan_ipaddr"), logaccept);
-		//fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %s -j %s\n", wan_ip, nvram_safe_get("misc_httpport_x"), logaccept);
-	}
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %s -j %s\n", nvram_safe_get("usb_webactivex_x"), logaccept);
+		}
 
-	if (nvram_match("usb_webenable_x", "2"))
-	{
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %s -j %s\n", wan_ip, nvram_safe_get("usb_webhttpport_x"), logaccept);
+		if (nvram_match("usb_ftpenable_x", "1"))
+		{	
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %s -j %s\n", nvram_safe_get("usb_ftpport_x"), logaccept);
+		}
 
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %s -j %s\n", wan_ip, nvram_safe_get("usb_webactivex_x"), logaccept);
-	}
+		if (nvram_invmatch("misc_ping_x", "0"))
+		{
+			fprintf(fp, "-A INPUT -p icmp -j %s\n", logaccept);
+		}
 
-	if (nvram_invmatch("usb_ftpenable_x", "0"))
-	{	
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %s -j %s\n", wan_ip, nvram_safe_get("usb_ftpport_x"), logaccept);
-	}
+	#ifdef CONFIG_IPV6
+		if (nvram_match("ipv6_sit_enable", "1"))
+		{
+			fprintf(fp, "-A INPUT -p 41 -j %s\n", logaccept);
+		}
+	#endif
 
-	if (nvram_invmatch("misc_ping_x", "0"))
-	{
-		fprintf(fp, "-A INPUT -p icmp -d %s -j %s\n", wan_ip, logaccept);
-	}
+		if (nvram_invmatch("misc_lpr_x", "0"))
+		{
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %d -j %s\n", 515, logaccept);
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %d -j %s\n", 9100, logaccept);
+	#ifdef PARPORT_SUPPORT	
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %d -j %s\n", 9101, logaccept);
+	#endif
 
-	if (nvram_invmatch("misc_lpr_x", "0"))
-	{
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %d -j %s\n", wan_ip, 515, logaccept);
+			fprintf(fp, "-A INPUT -p tcp -m tcp --dport %d -j %s\n", 3838, logaccept);
+		}
 
-		fprintf(fp, "-A INPUT -p tcp -m tcp -d %s --dport %d -j %s\n", wan_ip, 3838, logaccept);
+		fprintf(fp, "-A INPUT -j %s\n", logdrop);
 	}
 
-	fprintf(fp, "-A INPUT -j %s\n", logdrop);
-	}
 
+	/* Accept the redirect, might be seen as INVALID, packets */
+	fprintf(fp, "-A FORWARD -i %s -o %s -j %s\n", lan_if, lan_if, logaccept);	
 	/* Drop the wrong state, INVALID, packets */
 	fprintf(fp, "-A FORWARD -m state --state INVALID -j %s\n", logdrop);
-	if (strlen(macaccept)>0)
-		fprintf(fp, "-A MACS -m state --state INVALID -j %s\n", logdrop);
-
+	/* Pass multicast */
+	if (nvram_match("mr_enable_x", "1"))
+		fprintf(fp, "-A FORWARD -p udp -d 224.0.0.0/4 -j ACCEPT\n");
 
-	/* Accept the redirect, might be seen as INVALID, packets */
-	fprintf(fp, "-A FORWARD -i %s -o %s -j %s\n", lan_if, lan_if, logaccept);	
-	if (strlen(macaccept)>0)
-		fprintf(fp, "-A MACS -i %s -o %s -j %s\n", lan_if, lan_if, logaccept);	
 	/* Clamp TCP MSS to PMTU of WAN interface */
-	if( nvram_match("wan_proto", "pppoe"))
-	{
-		fprintf(fp, "-A FORWARD -p tcp --tcp-flags SYN,RST SYN -m tcpmss --mss %d: -j TCPMSS "
-			  "--set-mss %d\n", atoi(nvram_safe_get("wan_pppoe_mtu"))-39, atoi(nvram_safe_get("wan_pppoe_mtu"))-40);
-		
-		if (strlen(macaccept)>0)
-			fprintf(fp, "-A MACS -p tcp --tcp-flags SYN,RST SYN -m tcpmss --mss %d: -j TCPMSS "
-			  "--set-mss %d\n", atoi(nvram_safe_get("wan_pppoe_mtu"))-39, atoi(nvram_safe_get("wan_pppoe_mtu"))-40);
-	}
-	
-	if (nvram_match("fw_enable_x", "1"))
+	if (nvram_match("wan_proto", "pppoe") ||
+		nvram_match("wan_proto", "pptp") || nvram_match("wan_proto", "l2tp"))
 	{
-   		// DoS attacks   
-   		// sync-flood protection	
-   		fprintf(fp, "-A FORWARD -i %s -p tcp --syn -m limit --limit 1/s -j %s\n", wan_if, logaccept);
-   		// furtive port scanner
-   		fprintf(fp, "-A FORWARD -i %s -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j %s\n", wan_if, logaccept);
-   		// ping of death
-   		fprintf(fp, "-A FORWARD -i %s -p icmp --icmp-type echo-request -m limit --limit 1/s -j %s\n", wan_if, logaccept);
+		fprintf(fp, "-A FORWARD -p tcp --syn -j TCPMSS --clamp-mss-to-pmtu\n");
 	}
 
+	/* Accept related connections, skip rest of checks */
+	fprintf(fp, "-A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT\n");
+
+	/* Filter out invalid WAN->WAN connections */
+	fprintf(fp, "-A FORWARD -o %s ! -i %s -j %s\n", wan_if, lan_if, logdrop);
+	if (nvram_invmatch("wan0_ifname", wan_if))
+		fprintf(fp, "-A FORWARD -o %s ! -i %s -j %s\n", nvram_get("wan0_ifname"), lan_if, logdrop);
+
+	/* Check internet traffic */
+	if (nvram_match("fw_dos_x", "1"))
+		fprintf(fp, "-A FORWARD ! -i %s -m state --state NEW -j SECURITY\n", lan_if);
 
 	// FILTER from LAN to WAN
-        // Rules for MAC Filter and LAN to WAN Filter
-        // Drop rules always before Accept
-	if(nvram_match("macfilter_enable_x", "1"))
-		strcpy(chain, "MACS");
-	else strcpy(chain, "FORWARD");
-		
 	if(nvram_match("fw_lw_enable_x", "1"))
 	{   		
 		char lanwan_timematch[128];
@@ -865,7 +850,6 @@ filter_setting(char *wan_if, char *wan_i
 		{
 			dtype = logdrop;
 			ftype = logaccept;
-
 		}
 		else
 		{
@@ -874,10 +858,9 @@ filter_setting(char *wan_if, char *wan_i
 		}
 			
 		// LAN/WAN filter		
-		g_buf_init();
-
        		foreach_x("filter_lw_num_x")
        		{	               			
+			g_buf_init();
             		proto = protoflag_conv("filter_lw_proto_x", i, 0);
             		flag = protoflag_conv("filter_lw_proto_x", i, 1);
 			srcip = iprange_ex_conv("filter_lw_srcip_x", i);
@@ -885,22 +868,17 @@ filter_setting(char *wan_if, char *wan_i
 			dstip = iprange_ex_conv("filter_lw_dstip_x", i);
 			dstport = portrange_conv("filter_lw_dstport_x", i);	
 			setting=filter_conv(proto, flag, srcip, srcport, dstip, dstport); 
-         		fprintf(fp, "-A %s %s -i %s -o %s %s -j %s\n", chain, lanwan_timematch, lan_if, wan_if, setting, ftype);
+         		fprintf(fp, "-A FORWARD %s -i %s %s -j %s\n", lanwan_timematch, lan_if, setting, ftype);
 		}            
 
        		// ICMP       	       			       			
        		foreach(ptr, nvram_safe_get("filter_lw_icmp_x"), icmplist)
 		{	   	 		
-	        	fprintf(fp, "-A %s %s -i %s -o %s -p icmp --icmp-type %s -j %s\n", chain, lanwan_timematch, lan_if, wan_if, ptr, ftype);
+	        	fprintf(fp, "-A FORWARD %s -i %s -p icmp --icmp-type %s -j %s\n", lanwan_timematch, lan_if, ptr, ftype);
 	        }	
 
 		// Default
-	        fprintf(fp, "-A %s -i %s -o %s -j %s\n", chain, lan_if, wan_if, dtype);
-	} 
-	else if (nvram_match("macfilter_enable_x", "1"))
-	{
-         	fprintf(fp, "-A FORWARD -i %s -o %s -j %s\n", lan_if, wan_if, logdrop);
-         	fprintf(fp, "-A MACS -i %s -o %s -j %s\n", lan_if, wan_if, logaccept);
+	        fprintf(fp, "-A FORWARD -i %s -j %s\n", lan_if, dtype);
 	}
 
 	// Filter from WAN to LAN
@@ -911,7 +889,6 @@ filter_setting(char *wan_if, char *wan_i
 		char *dtype, *ftype;
 
 		timematch_conv(wanlan_timematch, "filter_wl_date_x", "filter_wl_time_x");
-		g_buf_init();
 	
 		if (nvram_match("filter_wl_default_x", "DROP"))
 		{
@@ -926,6 +903,7 @@ filter_setting(char *wan_if, char *wan_i
 			
        		foreach_x("filter_wl_num_x")
        		{	               			
+			g_buf_init();
             		proto = protoflag_conv("filter_wl_proto_x", i, 0);
             		flag = protoflag_conv("filter_wl_proto_x", i, 1);
 			srcip = iprange_ex_conv("filter_wl_srcip_x", i);
@@ -934,39 +912,35 @@ filter_setting(char *wan_if, char *wan_i
 			dstport = portrange_conv("filter_wl_dstport_x", i);	
 			setting=filter_conv(proto, flag, srcip, srcport, dstip, dstport);
 
-         		fprintf(fp, "-A FORWARD %s -i %s -o %s %s -j %s\n", wanlan_timematch, wan_if, lan_if, setting, ftype);
+         		fprintf(fp, "-A FORWARD %s -o %s %s -j %s\n", wanlan_timematch, lan_if, setting, ftype);
 		}            
        			 
        		// ICMP       	       			       			
        		foreach(ptr, nvram_safe_get("filter_wl_icmp_x"), icmplist)
 		{	   	 		
-	        	fprintf(fp, "-A FORWARD %s -i %s -o %s -p icmp --icmp-type %s -j %s\n", wanlan_timematch, wan_if, lan_if, ptr, ftype);
-	        }	
-         	
-		// Default
-		fprintf(fp, "-A FORWARD -i %s -o %s -j %s\n", wan_if, lan_if, dtype);
+	        	fprintf(fp, "-A FORWARD %s -o %s -p icmp --icmp-type %s -j %s\n", wanlan_timematch, lan_if, ptr, ftype);
+	        }
        	}
 
+	/* Enable Virtual Servers */
+	fprintf(fp, "-A FORWARD -m conntrack --ctstate DNAT -j %s\n", 
+		nvram_match("filter_vs_default_x", "DROP") ? logdrop : logaccept);
 
-	/* Write forward chain rules of NAT */
-	if ((fp1 = fopen("/tmp/nat_forward_rules", "r"))!=NULL)
-	{
-		while(fgets(line, sizeof(line), fp1))
-		{
-			fprintf(fp, "%s", line);
-		}
-
-		fclose(fp1);
-	}
-
-
+	if(nvram_match("fw_wl_enable_x", "1"))
+	{   		
+		// Default
+		fprintf(fp, "-A FORWARD -o %s -j %s\n", lan_if, 
+			nvram_match("filter_wl_default_x", "DROP") ? logdrop : logaccept);
+	}
+
+
 	/* logaccept chain */
 	fprintf(fp, "-A logaccept -m state --state NEW -j LOG --log-prefix \"ACCEPT \" "
 		  "--log-tcp-sequence --log-tcp-options --log-ip-options\n"
 		  "-A logaccept -j ACCEPT\n");
 
 	/* logdrop chain */
-	fprintf(fp,"-A logdrop -m state --state NEW -j LOG --log-prefix \"DROP\" "
+	fprintf(fp,"-A logdrop -m state --state NEW -j LOG --log-prefix \"DROP \" "
 		  "--log-tcp-sequence --log-tcp-options --log-ip-options\n"
 		  "-A logdrop -j DROP\n");
 	
@@ -974,9 +948,11 @@ filter_setting(char *wan_if, char *wan_i
        	fclose(fp);
 
 	eval("iptables-restore", "/tmp/filter_rules");
+	
+	return 0;
 }
 
-int porttrigger_setting()
+int porttrigger_setting(FILE *fp, char *lan_if)
 {
 	netconf_app_t apptarget, *app;
 	int i;
@@ -1040,10 +1016,18 @@ int porttrigger_setting()
 		app->target = NETCONF_APP;
 
 		if (valid_autofw_port(app))
-		{	
-			netconf_add_fw((netconf_fw_t *)app);
+		{
+			fprintf(fp, "-A PREROUTING -p %s -i %s --dport %d:%d -j autofw"
+			    " --related-proto %s --related-dport %d-%d --related-to %d-%d\n",
+				(app->match.ipproto == IPPROTO_TCP) ? "tcp" : "udp", lan_if, 
+				ntohs(app->match.dst.ports[0]), ntohs(app->match.dst.ports[1]), 
+				(app->proto == IPPROTO_TCP) ? "tcp" : "udp", 
+				ntohs(app->dport[0]), ntohs(app->dport[1]), 
+				ntohs(app->to[0]), ntohs(app->to[1]));
+			/*netconf_add_fw((netconf_fw_t *)app); */
 		}
 	}
+	return 0;
 }
 
 int
@@ -1053,7 +1037,12 @@ start_firewall_ex(char *wan_if, char *wa
 	struct dirent *file;
 	FILE *fp;
 	char name[NAME_MAX];
-	char logaccept[32], logdrop[32];
+	char logaccept[32], logdrop[32];
+	char *mcast_ifname = nvram_get("wan0_ifname");
+	
+	/* mcast needs rp filter to be turned off only for non default iface */
+	if (!(nvram_match("mr_enable_x", "1") || nvram_invmatch("udpxy_enable_x", "0")) ||
+	 	strcmp(wan_if, mcast_ifname) == 0) mcast_ifname = NULL;
 	
 	/* Block obviously spoofed IP addresses */
 	if (!(dir = opendir("/proc/sys/net/ipv4/conf")))
@@ -1065,8 +1054,9 @@ start_firewall_ex(char *wan_if, char *wa
 			if (!(fp = fopen(name, "r+"))) {
 				perror(name);
 				break;
-			}
-			fputc('1', fp);
+			}
+			fputc(mcast_ifname && strncmp(file->d_name, 
+				mcast_ifname, NAME_MAX) == 0 ? '0' : '1', fp);
 			fclose(fp);
 		}
 	}
@@ -1088,9 +1078,13 @@ start_firewall_ex(char *wan_if, char *wa
 	/* Filter setting */
 	filter_setting(wan_if, wan_ip, lan_if, lan_ip, logaccept, logdrop);
 
-	/* Trigger port setting */
-	porttrigger_setting();
-
+	if (nvram_invmatch("misc_conntrack_x", "")) {
+		if( (fp=fopen("/proc/sys/net/ipv4/ip_conntrack_max", "r+")) ){
+			fputs(nvram_safe_get("misc_conntrack_x"), fp);
+			fclose(fp);
+		} else
+			perror("/proc/sys/net/ipv4/ip_conntrack_max");
+	}	
 #ifdef XBOX_SUPPORT
 	if( (fp=fopen("/proc/sys/net/ipv4/ip_conntrack_udp_timeouts", "r+")) ){
 		fprintf(fp, "%d %d", 65, 180);
@@ -1105,10 +1099,16 @@ start_firewall_ex(char *wan_if, char *wa
 	} else
 		perror("/proc/sys/net/ipv4/ip_forward");
 
-	return ;
-}
+	if (nvram_invmatch("wan0_ifname", wan_if))
+		eval("/usr/local/sbin/post-firewall", wan_if, wan_ip, lan_if, lan_ip, 
+			nvram_get("wan0_ifname"), nvram_get("wanx_ipaddr"));
+	else
+		eval("/usr/local/sbin/post-firewall", wan_if, wan_ip, lan_if, lan_ip);
 
+	return 0;
+}
 
+#if 0
 portmapping_main(int argc, char *argv[])
 {	
 	char actionname[32], portname[32], ipname[32];
@@ -1141,7 +1141,7 @@ portmapping_main(int argc, char *argv[])
 		start_firewall_ex("eth0", "", "br0", "");
 	}		
 }
-	
+#endif	
 
 void write_static_leases(char *file)
 {
@@ -1168,14 +1168,15 @@ void convert_routes(void)
 {
 	int i;
 	char *ip, *netmask, *gateway, *matric, *interface;
-	char wroutes[400], lroutes[400];
+	char wroutes[1024], lroutes[1024], mroutes[1024];
 
 	wroutes[0] = 0;
 	lroutes[0] = 0;	
+	mroutes[0] = 0;	
 
 	g_buf_init();
-			
-	foreach_x("sr_num_x")
+			
+	if (nvram_match("sr_enable_x", "1")) foreach_x("sr_num_x")
 	{
 		ip = general_conv("sr_ipaddr_x", i);
 		netmask = general_conv("sr_netmask_x", i);
@@ -1194,11 +1195,16 @@ void convert_routes(void)
 		{
 			sprintf(lroutes, "%s %s:%s:%s:%d", lroutes, ip, netmask, gateway, atoi(matric)+1);
 		}	
+		else if (!strcmp(interface, "MAN"))
+		{
+			sprintf(mroutes, "%s %s:%s:%s:%d", mroutes, ip, netmask, gateway, atoi(matric)+1);
+		}	
 	}
 
 	//printf("route: %s %s\n", lroutes, wroutes);
 	nvram_set("lan_route", lroutes);
 	nvram_set("wan0_route", wroutes);
+	nvram_set("wan_route", mroutes);
 }
 
 #ifdef USB_SUPPORT	
diff -BurpN -x'*.o' router/rc/init.c gateway/rc/init.c
--- router/rc/init.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/init.c	2008-03-19 20:07:24.000000000 +0300
@@ -31,6 +31,7 @@
 #include <sys/time.h>
 
 #include <shutils.h>
+#include <rc.h>
 
 #define loop_forever() do { sleep(1); } while (1)
 #define SHELL "/bin/sh"
@@ -77,6 +78,7 @@ int
 console_init()
 {
 	int fd;
+	int ret = 0;
 
 	/* Clean up */
 	ioctl(0, TIOCNOTTY, 0);
@@ -88,9 +90,12 @@ console_init()
 	/* Reopen console */
 	if ((fd = open(_PATH_CONSOLE, O_RDWR)) < 0) {
 		perror(_PATH_CONSOLE);
-		return errno;
+		if ((fd = open("/dev/null", O_RDWR)) < 0) {
+			perror("/dev/null");
+			return errno;
+		}
+		ret = -1;
 	}
-	dup2(fd, 0);
 	dup2(fd, 1);
 	dup2(fd, 2);
 
@@ -98,7 +103,7 @@ console_init()
 	tcsetpgrp(0, getpgrp());
 	set_term(0);
 
-	return 0;
+	return ret;
 }
 
 pid_t
@@ -109,7 +114,7 @@ run_shell(int timeout, int nowait)
 	char *envp[] = {
 		"TERM=vt100",
 		"HOME=/",
-		"PATH=/usr/bin:/bin:/usr/sbin:/sbin",
+		"PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin",
 		"SHELL=" SHELL,
 		"USER=root",
 		tz,
@@ -157,25 +162,41 @@ run_shell(int timeout, int nowait)
 static void
 shutdown_system(void)
 {
-	int sig;
+	int sig, fd;
 
 	/* Disable signal handlers */
 	for (sig = 0; sig < (_NSIG-1); sig++)
 		signal(sig, SIG_DFL);
 
+	/* Disconnect pppd - need this for PPTP/L2TP to finish gracefully */
+	eval("killall", "pppd");
+
+	eval("/usr/local/sbin/pre-shutdown");
+	sleep(2);
+	
+	if (exists("/dev/misc/rtc"))
+		eval("/sbin/hwclock", "-w");
+
 	cprintf("Sending SIGTERM to all processes\n");
 	kill(-1, SIGTERM);
-	sleep(1);
+	sleep(3);
 
 	cprintf("Sending SIGKILL to all processes\n");
 	kill(-1, SIGKILL);
 	sleep(1);
 
-	sync();
+	sync(), sync();
+
+	/* bring wifi interfaces down */
+#ifdef RT2400_SUPPORT
+	ifconfig("ra0", 0, NULL, NULL);
+#else
+	eval("wl", "radio", "off");
+#endif
 }
 
 static int fatal_signals[] = {
-	SIGQUIT,
+	SIGQUIT,	/* halt */
 	SIGILL,
 	SIGABRT,
 	SIGFPE,
@@ -186,14 +207,13 @@ static int fatal_signals[] = {
 	SIGTRAP,
 	SIGPWR,
 	SIGTERM,	/* reboot */
-	SIGUSR1,	/* halt */
 };
 
 void
 fatal_signal(int sig)
 {
 	char *message = NULL;
-
+	
 	switch (sig) {
 	case SIGQUIT: message = "Quit"; break;
 	case SIGILL: message = "Illegal instruction"; break;
@@ -217,8 +237,8 @@ fatal_signal(int sig)
 	shutdown_system();
 	sleep(2);
 
-	/* Halt on SIGUSR1 */
-	reboot(sig == SIGUSR1 ? RB_HALT_SYSTEM : RB_AUTOBOOT);
+	/* Halt on SIGQUIT */
+	reboot((sig == SIGQUIT) ? RB_HALT_SYSTEM : RB_AUTOBOOT);
 	loop_forever();
 }
 
diff -BurpN -x'*.o' router/rc/interface.c gateway/rc/interface.c
--- router/rc/interface.c	2004-12-01 21:53:30.000000000 +0300
+++ gateway/rc/interface.c	2008-03-19 20:07:24.000000000 +0300
@@ -34,6 +34,17 @@
 #include <bcmparams.h>
 #include <rc.h>
 
+in_addr_t
+inet_addr_(const char *cp)
+{
+	struct in_addr a;
+
+	if (!inet_aton(cp, &a))
+		return INADDR_ANY;
+	else
+		return a.s_addr;
+}
+
 int
 ifconfig(char *name, int flags, char *addr, char *netmask)
 {
@@ -153,14 +164,14 @@ config_loopback(void)
 	route_add("lo", 0, "127.0.0.0", "0.0.0.0", "255.0.0.0");
 }
 
-#ifndef WL500GX
+#ifndef CONFIG_SENTRY5
 /* configure/start vlan interface(s) based on nvram settings */
 int
 start_vlan(void)
 {
 	int s;
 	struct ifreq ifr;
-	int i, j;
+	int i, j, vlan0tag;
 	char ea[ETHER_ADDR_LEN];
 
 	/* set vlan i/f name to style "vlan<ID>" */
@@ -170,6 +181,8 @@ start_vlan(void)
 	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
 		return errno;
 
+	vlan0tag = strtoul(nvram_safe_get("vlan0tag"), NULL, 0);
+
 	for (i = 0; i <= VLAN_MAXVID; i ++) {
 		char nvvar_name[16];
 		char vlan_id[16];
@@ -202,10 +215,10 @@ start_vlan(void)
 		if (!(ifr.ifr_flags & IFF_UP))
 			ifconfig(ifr.ifr_name, IFUP, 0, 0);
 		/* create the VLAN interface */
-		snprintf(vlan_id, sizeof(vlan_id), "%d", i);
+		snprintf(vlan_id, sizeof(vlan_id), "%d", i | vlan0tag);
 		eval("vconfig", "add", ifr.ifr_name, vlan_id);
 		/* setup ingress map (vlan->priority => skb->priority) */
-		snprintf(vlan_id, sizeof(vlan_id), "vlan%d", i);
+		snprintf(vlan_id, sizeof(vlan_id), "vlan%d", i | vlan0tag);
 		for (j = 0; j < VLAN_NUMPRIS; j ++) {
 			snprintf(prio, sizeof(prio), "%d", j);
 			eval("vconfig", "set_ingress_map", vlan_id, prio, prio);
@@ -221,11 +234,13 @@ start_vlan(void)
 int
 stop_vlan(void)
 {
-	int i;
+	int i, vlan0tag;
 	char nvvar_name[16];
 	char vlan_id[16];
 	char *hwname;
 
+	vlan0tag = strtoul(nvram_safe_get("vlan0tag"), NULL, 0);
+
 	for (i = 0; i <= VLAN_MAXVID; i ++) {
 		/* get the address of the EMAC on which the VLAN sits */
 		snprintf(nvvar_name, sizeof(nvvar_name), "vlan%dhwname", i);
@@ -233,7 +248,7 @@ stop_vlan(void)
 			continue;
 
 		/* remove the VLAN interface */
-		snprintf(vlan_id, sizeof(vlan_id), "vlan%d", i);
+		snprintf(vlan_id, sizeof(vlan_id), "vlan%d", i | vlan0tag);
 		eval("vconfig", "rem", vlan_id);
 	}
 
diff -BurpN -x'*.o' router/rc/Makefile gateway/rc/Makefile
--- router/rc/Makefile	2004-12-02 08:39:03.000000000 +0300
+++ gateway/rc/Makefile	2008-12-27 20:07:24.000000000 +0300
@@ -16,8 +16,8 @@ include $(TOP)/.config
 
 CFLAGS	+= -I. -I$(TOP)/shared -I$(SRCBASE)/include -Wall -DASUS_EXT $(GLOBAL_OPTIONS)
 #CFLAGS	+= -g -DDEBUG
-CFLAGS	+= -s -O2
-LDFLAGS	+= -L$(TOP)/nvram -L$(INSTALLDIR)/nvram/usr/lib -lnvram -L$(TOP)/shared -L$(INSTALLDIR)/shared/usr/lib -lshared
+CFLAGS	+= -s -O2 $(EXTRACFLAGS)
+LDFLAGS	+= -L$(TOP)/nvram -L$(INSTALLDIR)/nvram/usr/lib -lnvram -L$(TOP)/shared -L$(INSTALLDIR)/shared/usr/lib -lshared -lcrypt
 
 OBJS := rc.o init.o interface.o network.o services.o udhcpc.o ppp.o http.o stats.o crc.o mtd.o common_ex.o network_ex.o firewall_ex.o services_ex.o manu_ex.o http_ex.o watchdog.o sendalarm.o dns.o dns_decode.o udhcpc_ex.o ntp.o bigpond.o qos.o rcamd.o waveserver.o
 
@@ -26,6 +26,9 @@ OBJS += firewall.o
 LDFLAGS += -L$(TOP)/netconf -L$(INSTALLDIR)/netconf/usr/lib -lnetconf
 endif
 
+ifeq ($(CONFIG_IPV6),y)
+CFLAGS += -DCONFIG_IPV6
+endif
 
 ifeq ($(CONFIG_SENTRY5),y)
 include $(TOP)/rc/Makefiles5.mk
@@ -45,8 +48,12 @@ install: all
 	cd $(INSTALLDIR)/sbin && ln -sf rc init
 	cd $(INSTALLDIR)/sbin && ln -sf rc erase
 	cd $(INSTALLDIR)/sbin && ln -sf rc write
+	cd $(INSTALLDIR)/sbin && ln -sf rc flash
 	cd $(INSTALLDIR)/sbin && ln -sf rc stats
 	cd $(INSTALLDIR)/sbin && ln -sf rc hotplug
+	cd $(INSTALLDIR)/sbin && ln -sf rc halt
+	cd $(INSTALLDIR)/sbin && ln -sf rc reboot
+	cd $(INSTALLDIR)/sbin && ln -sf rc poweron
 
 	# Added by ASUS
 	cd $(INSTALLDIR)/sbin && ln -sf rc stopservice
diff -BurpN -x'*.o' router/rc/manu_ex.c gateway/rc/manu_ex.c
--- router/rc/manu_ex.c	2004-12-07 16:02:14.000000000 +0300
+++ gateway/rc/manu_ex.c	2008-03-19 20:07:24.000000000 +0300
@@ -724,7 +724,7 @@ void sync_mac(char *devname, char *mac)
 	char buf[MAXBUF], macstr[32], s[3];
 	unsigned char t;	
 	srom_rw_t *srom;
-
+
 	if (strlen(mac)!=17) return;
 
 	//printf("dev: %s, mac : %s\n", devname, mac);
@@ -861,7 +861,9 @@ wlan_update()
 		val = rsrom_main("eth2", 104, 0);
 		if (val==0x003c) wsrom_main("eth2", 104, 0x004c);// ver 1.6
 		else if (val==0x0035) wsrom_main("eth2", 104, 0x0046);     // ver 2.2
-		else wsrom_main("eth2", 104, 0x0046);
+#if 0
+		else wsrom_main("eth2", 104, 0x0046);
+#endif
 		wsrom_main("eth2", 114, 0x0249);
 	}
 	else if(nvram_match("productid", "WL500g.Deluxe"))
diff -BurpN -x'*.o' router/rc/mtd.c gateway/rc/mtd.c
--- router/rc/mtd.c	2004-11-19 20:46:19.000000000 +0300
+++ gateway/rc/mtd.c	2008-03-19 20:07:24.000000000 +0300
@@ -102,6 +102,96 @@ mtd_erase(const char *mtd)
 	return 0;
 }
 
+
+/*
+ * Flash a file to an MTD device
+ * @param	path	file to write or a URL
+ * @param	mtd	path to or partition name of MTD device 
+ * @return	0 on success and errno on failure
+ */
+int
+mtd_flash(const char *path, const char *mtd)
+{
+	int mtd_fd = -1;
+	mtd_info_t mtd_info;
+	erase_info_t erase_info;
+
+	FILE *fp = NULL;
+	struct stat stats;
+	char *buf = NULL;
+	long count, len;
+	int ret = -1;
+
+	if (stat(path, &stats) || !(fp = fopen(path, "r"))) 
+	{
+		perror(path);
+		goto fail;
+	}
+
+	/* Open MTD device and get sector size */
+	if ((mtd_fd = mtd_open(mtd, O_RDWR)) < 0 ||
+	    ioctl(mtd_fd, MEMGETINFO, &mtd_info) != 0) 
+	{
+		perror(mtd);
+		goto fail;
+	}
+	
+	if (stats.st_size > mtd_info.size) {
+		fprintf(stderr, "%s: File is to big (%ld, max %ld)\n", path,
+				stats.st_size, mtd_info.size);
+		goto fail;
+	}
+
+	/* Allocate temporary buffer */
+	erase_info.length = mtd_info.erasesize;
+	
+	if (!(buf = malloc(erase_info.length))) {
+		perror("malloc");
+		goto fail;
+	}
+
+	/* Write file to MTD device */
+	for (erase_info.start = 0; erase_info.start < stats.st_size; erase_info.start += count) {
+		len = MIN(erase_info.length, stats.st_size - erase_info.start);
+		count = safe_fread(buf, 1, len, fp);
+
+		if (count < len) {
+			fprintf(stderr, "%s: Truncated file (actual %ld expect %ld)\n", path,
+				count, len);
+			goto fail;
+		}
+
+		/* Do it */
+		(void) ioctl(mtd_fd, MEMUNLOCK, &erase_info);
+		if (write(1, "-", 1) != 1 ||
+		    ioctl(mtd_fd, MEMERASE, &erase_info) != 0 ||
+		    write(1, "\b+", 2) != 2 ||
+		    write(mtd_fd, buf, count) != count) {
+			perror(mtd);
+			goto fail;
+		}
+		
+		write(1, "\b.", 2);
+	}
+
+	ret = 0;
+
+ fail:
+	printf("\n");
+
+	if (buf) {
+		/* Dummy read to ensure chip(s) are out of lock/suspend state */
+		(void) read(mtd_fd, buf, 2);
+		free(buf);
+	}
+
+	if (mtd_fd >= 0)
+		close(mtd_fd);
+	if (fp)
+		fclose(fp);
+	return ret;
+}
+
 extern int http_get(const char *server, char *buf, size_t count, off_t offset);
 
 /*
@@ -136,7 +226,7 @@ mtd_write(const char *path, const char *
 		goto fail;
 	}
 	if (trx.magic != TRX_MAGIC ||
-	    trx.len > TRX_MAX_LEN ||
+	    trx.len > 0x7a0000 /*TRX_MAX_LEN*/ ||
 	    trx.len < sizeof(struct trx_header)) {
 		fprintf(stderr, "%s: Bad trx header\n", path);
 		goto fail;
diff -BurpN -x'*.o' router/rc/mtd.h gateway/rc/mtd.h
--- router/rc/mtd.h	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/mtd.h	2008-03-19 20:07:24.000000000 +0300
@@ -38,4 +38,12 @@ extern int mtd_erase(const char *mtd);
  */
 extern int mtd_write(const char *path, const char *mtd);
 
+/*
+ * Flash a file to an MTD device
+ * @param	path	file to write or a URL
+ * @param	mtd	path to or partition name of MTD device 
+ * @return	0 on success and errno on failure
+ */
+extern int mtd_write(const char *path, const char *mtd);
+
 #endif /* _mtd_h_ */
diff -BurpN -x'*.o' router/rc/network.c gateway/rc/network.c
--- router/rc/network.c	2004-11-18 18:50:49.000000000 +0300
+++ gateway/rc/network.c	2008-12-28 11:12:51.000000000 +0300
@@ -15,7 +15,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-#include <syslog.h>															
+#include <syslog.h>
 #include <ctype.h>
 #include <string.h>
 #include <unistd.h>
@@ -41,9 +41,11 @@ typedef u_int8_t u8;
 #include <nvparse.h>
 #include <rc.h>
 #include <bcmutils.h>
-#include <etsockio.h>
+#include <etioctl.h>
 #include <bcmparams.h>
 
+void lan_up(char *lan_ifname);
+
 static int
 add_routes(char *prefix, char *var, char *ifname)
 {
@@ -65,6 +67,9 @@ add_routes(char *prefix, char *var, char
 		gateway = strsep(&metric, ":");
 		if (!gateway || !metric)
 			continue;
+			
+		if (inet_addr_(gateway) == INADDR_ANY) 
+			gateway = nvram_safe_get("wanx_gateway");
 
 		dprintf("\n\n\nadd %s %d %s %s %s\n\n\n", ifname, atoi(metric), ipaddr, gateway, netmask);
 		
@@ -74,6 +79,77 @@ add_routes(char *prefix, char *var, char
 	return 0;
 }
 
+static void
+add_wanx_routes(char *prefix, char *ifname, int metric)
+{
+	char *routes, *msroutes, *tmp;
+	char buf[30];
+
+	char ipaddr[] = "255.255.255.255";
+	char gateway[] = "255.255.255.255";
+	char netmask[] = "255.255.255.255";
+
+	if (!nvram_match("dr_enable_x", "1"))
+		return;
+
+	/* routes */
+	routes = strdup(nvram_safe_get(strcat_r(prefix, "routes", buf)));
+	for (tmp = routes; tmp && *tmp; )
+	{
+		char *ipaddr = strsep(&tmp, " ");
+		char *gateway = strsep(&tmp, " ");
+		if (gateway) {
+			route_add(ifname, metric + 1, ipaddr, gateway, netmask);
+		}
+	}
+	free(routes);
+	
+	/* ms routes */
+	for (msroutes = nvram_get(strcat_r(prefix, "msroutes", buf)); msroutes && isdigit(*msroutes); )
+	{
+		/* read net length */
+		int bit, bits = strtol(msroutes, &msroutes, 10);
+		struct in_addr ip, gw, mask;
+		
+		if (bits < 1 || bits > 32 || *msroutes != ' ')
+			break;
+
+		mask.s_addr = htonl(0xffffffff << (32 - bits));
+
+		/* read network address */
+		for (ip.s_addr = 0, bit = 24; bit > (24 - bits); bit -= 8)
+		{
+			if (*msroutes++ != ' ' || !isdigit(*msroutes))
+				goto bad_data;
+
+			ip.s_addr |= htonl(strtol(msroutes, &msroutes, 10) << bit);
+		}
+		
+		/* read gateway */
+		for (gw.s_addr = 0, bit = 24; bit >= 0 && *msroutes; bit -= 8)
+		{
+			if (*msroutes++ != ' ' || !isdigit(*msroutes))
+				goto bad_data;
+
+			gw.s_addr |= htonl(strtol(msroutes, &msroutes, 10) << bit);
+		}
+		
+		/* clear bits per RFC */
+		ip.s_addr &= mask.s_addr;
+		
+		strcpy(ipaddr, inet_ntoa(ip));
+		strcpy(gateway, inet_ntoa(gw));
+		strcpy(netmask, inet_ntoa(mask));
+		
+		route_add(ifname, metric + 1, ipaddr, gateway, netmask);
+		
+		if (*msroutes == ' ')
+			msroutes++;
+	}
+bad_data:
+	return;
+}
+
 static int
 del_routes(char *prefix, char *var, char *ifname)
 {
@@ -96,6 +172,9 @@ del_routes(char *prefix, char *var, char
 		gateway = strsep(&metric, ":");
 		if (!gateway || !metric)
 			continue;
+			
+		if (inet_addr_(gateway) == INADDR_ANY) 
+			gateway = nvram_safe_get("wanx_gateway");
 		
 		dprintf("add %s\n", ifname);
 		
@@ -117,6 +196,42 @@ del_lan_routes(char *lan_ifname)
 	return del_routes("lan_", "route", lan_ifname);
 }
 
+static void
+start_igmpproxy(char *wan_ifname)
+{
+	static char *igmpproxy_conf = "/etc/igmpproxy.conf";
+	struct stat	st_buf;
+	FILE 		*fp;
+
+	if (atoi(nvram_safe_get("udpxy_enable_x")))
+		eval("/usr/sbin/udpxy", "-a", nvram_get("lan_ifname") ? : "br0",
+			"-m", wan_ifname, "-p", nvram_get("udpxy_enable_x"));
+	
+	if (!nvram_match("mr_enable_x", "1"))
+		return;
+	
+	if (stat(igmpproxy_conf, &st_buf) != 0) 
+	{
+		if ((fp = fopen(igmpproxy_conf, "w")) == NULL) {
+			perror(igmpproxy_conf);
+			return;
+		}
+		
+		fprintf(fp, "# automagically generated from web settings\n"
+			"quickleave\n\n"
+			"phyint %s upstream\n"
+			"\taltnet %s\n\n"
+			"phyint %s downstream\n\n", 
+			wan_ifname, 
+			nvram_get("mr_altnet_x") ? : "0.0.0.0/0", 
+			nvram_get("lan_ifname") ? : "br0");
+			
+		fclose(fp);
+	}
+	
+	eval("/usr/sbin/igmpproxy", "-c", igmpproxy_conf);
+}
+
 void
 start_lan(void)
 {
@@ -175,7 +290,8 @@ start_lan(void)
 					j = atoi(nvram_safe_get("wl_wdsnum_x"));
 					for(i=1;i<=j;i++)
 					{
-						sprintf(tmpstr, "ra%d", i);							ifconfig(tmpstr, IFUP, NULL, NULL);
+						sprintf(tmpstr, "ra%d", i);
+						ifconfig(tmpstr, IFUP, NULL, NULL);
 						eval("brctl","addif",lan_ifname,tmpstr);
 					}
 				}
@@ -190,7 +306,9 @@ start_lan(void)
 				char wl_name[] = "wlXXXXXXXXXX_mode";
 				int unit;
 #ifdef ASUS_EXT
-				sync_mac(name, nvram_safe_get("et0macaddr"));
+				/* do not play srom games, let asus firmware do everything */
+				/* mac offset == 72 for sroms 1, 2, == 76 for srom 3 */
+				/* sync_mac(name, nvram_safe_get("et0macaddr")); */
 #endif
 				wl_ioctl(name, WLC_GET_INSTANCE, &unit, sizeof(unit));
 				snprintf(wl_name, sizeof(wl_name), "wl%d_mode", unit);
@@ -264,6 +382,7 @@ start_lan(void)
 			}
 		}
 	}
+	close(s);
 #endif
 
 #ifdef ASUS_EXT
@@ -354,6 +473,26 @@ start_lan(void)
 	dprintf("%s %s\n",
 		nvram_safe_get("lan_ipaddr"),
 		nvram_safe_get("lan_netmask"));
+
+#ifdef CONFIG_IPV6
+	/* IPv6 address config */
+	{
+		char *ip6_addr = nvram_safe_get("ipv6_lan_addr");
+		char *ip6_size = nvram_safe_get("ipv6_lan_netsize");
+		if( ip6_addr && *ip6_addr && ip6_size && *ip6_size )
+		{
+			char *ip6_net = (char*) malloc(45);
+			strcpy( ip6_net, ip6_addr );
+			strcat( ip6_net, "/" );
+			strcat( ip6_net, ip6_size );
+
+			eval( "ip", "-6", "addr", "add", ip6_net, "dev", nvram_safe_get("lan_ifname") );
+		
+			free( ip6_net );
+		}
+	}
+#endif
+
 }
 
 void
@@ -437,6 +576,11 @@ wan_valid(char *ifname)
 	foreach(name, nvram_safe_get("wan_ifnames"), next)
 		if (ifname && !strcmp(ifname, name))
 			return 1;
+	
+	if (nvram_invmatch("wl_mode_ex", "ap")) {
+		return nvram_match("wl0_ifname", ifname);
+	}
+
 	return 0;
 }
 
@@ -459,7 +603,7 @@ start_wan(void)
 #ifdef ASUS_EXT
 	update_wan_status(0);
 	/* start connection independent firewall */
-	start_firewall();
+	/* start_firewall(); */
 #else
 	/* start connection independent firewall */
 	start_firewall();
@@ -546,7 +690,11 @@ start_wan(void)
 			ifconfig(wan_ifname, IFUP, NULL, NULL);
 
 			/* do wireless specific config */
-			eval("wlconf", wan_ifname, "up");
+			if (!eval("wlconf", wan_ifname, "up")) {
+				/* Kick wl to join network */
+				if (nvram_match("wl0_mode", "wet") || nvram_match("wl0_mode", "sta"))
+					system(nvram_safe_get("wl0_join"));
+			}
 		}
 	
 		close(s);
@@ -558,7 +706,7 @@ start_wan(void)
 			FILE *fp;
 
 			setup_ethernet(nvram_safe_get("wan_ifname"));
-			start_pppoe_relay(nvram_safe_get("wan_ifname"));
+			start_pppoe_relay(wan_ifname);
 
 
 			/* Enable Forwarding */
@@ -569,90 +717,78 @@ start_wan(void)
 			{	
 				perror("/proc/sys/net/ipv4/ip_forward");
 			}
-		}
 
-		if (strcmp(wan_proto, "pptp")==0) 
-		{
-			start_pptp(prefix);
-#ifdef ASUS_EXT
-			nvram_set("wan_ifname_t", "ppp0");
+#ifdef CONFIG_IPV6
+			/* Enable IPv6 Forwarding */
+			if ((fp = fopen("/proc/sys/net/ipv6/conf/all/forwarding", "r+"))) 			{
+				fputc('1', fp);
+				fclose(fp);
+			} else
+			{	
+				perror("/proc/sys/net/ipv6/conf/all/forwarding");
+			}
 #endif
 		}
-		else
+
 		/* 
 		* Configure PPPoE connection. The PPPoE client will run 
 		* ip-up/ip-down scripts upon link's connect/disconnect.
 		*/
-		if (strcmp(wan_proto, "pppoe") == 0) {
-			char *pppoe_argv[] = { "pppoecd",
-					       nvram_safe_get(strcat_r(prefix, "ifname", tmp)),
-					       "-u", nvram_safe_get(strcat_r(prefix, "pppoe_username", tmp)),
-					       "-p", nvram_safe_get(strcat_r(prefix, "pppoe_passwd", tmp)),
-					       "-r", nvram_safe_get(strcat_r(prefix, "pppoe_mru", tmp)),
-					       "-t", nvram_safe_get(strcat_r(prefix, "pppoe_mtu", tmp)),
-					       "-i", nvram_match(strcat_r(prefix, "pppoe_demand", tmp), "1") ?
-					       		nvram_safe_get(strcat_r(prefix, "pppoe_idletime", tmp)) : "0",
-#ifdef ASUS_EXT
-						NULL, NULL,
-						NULL, NULL,
-						NULL, NULL,
-#endif
-					       NULL, NULL,	/* pppoe_service */
-					       NULL, NULL,	/* pppoe_ac */
-					       NULL,		/* pppoe_keepalive */
-					       NULL, NULL,	/* ppp unit requested */
-					       NULL
-			}, **arg;
-			int timeout = 5;
-			char pppunit[] = "XXXXXXXXXXXX";
-
-			/* Add optional arguments */
-
-			for (arg = pppoe_argv; *arg; arg++);
-
-#ifdef ASUS_EXT
-			if (nvram_invmatch(strcat_r(prefix, "pppoe_idletime", tmp), "0"))
-			{
-				*arg++ = "-I";
-				*arg++ = "30";
-
-				*arg++ = "-T";
-				*arg++ = "9";
-
-				*arg++ = "-N";
-				*arg++ = "10";
-			}
+		if (strcmp(wan_proto, "pppoe") == 0 || strcmp(wan_proto, "pptp") == 0 ||
+		    strcmp(wan_proto, "l2tp") == 0) 
+		{
+			int demand = atoi(nvram_safe_get(strcat_r(prefix, "pppoe_idletime", tmp))) &&
+			    strcmp(wan_proto, "l2tp") /* L2TP does not support idling */;
+			
+			/* update demand option */
+			nvram_set(strcat_r(prefix, "pppoe_demand", tmp), demand ? "1" : "0");
 
-			if (nvram_invmatch(strcat_r(prefix, "pppoe_txonly_x", tmp), "0")) {
-				*arg++ = "-o";
-			}
-#endif
-			if (nvram_invmatch(strcat_r(prefix, "pppoe_service", tmp), "")) {
-				*arg++ = "-s";
-				*arg++ = nvram_safe_get(strcat_r(prefix, "pppoe_service", tmp));
-			}
-			if (nvram_invmatch(strcat_r(prefix, "pppoe_ac", tmp), "")) {
-				*arg++ = "-a";
-				*arg++ = nvram_safe_get(strcat_r(prefix, "pppoe_ac", tmp));
+			/* Bring up WAN interface */
+			ifconfig(wan_ifname, IFUP, 
+				nvram_get(strcat_r(prefix, "pppoe_ipaddr", tmp)),
+				nvram_get(strcat_r(prefix, "pppoe_netmask", tmp)));
+
+			/* start firewall */
+			start_firewall_ex(nvram_safe_get(strcat_r(prefix, "pppoe_ifname", tmp)),
+				"0.0.0.0", "br0", nvram_safe_get("lan_ipaddr"));
+
+		 	/* launch dhcp client and wait for lease forawhile */
+		 	if (nvram_match(strcat_r(prefix, "pppoe_ipaddr", tmp), "0.0.0.0")) 
+		 	{
+				char *wan_hostname = nvram_get(strcat_r(prefix, "hostname", tmp));
+				char *dhcp_argv[] = { "udhcpc",
+					      "-i", wan_ifname,
+					      "-p", (sprintf(tmp, "/var/run/udhcpc%d.pid", unit), tmp),
+					      "-s", "/tmp/udhcpc",
+					      "-b",
+					      wan_hostname && *wan_hostname ? "-H" : NULL,
+					      wan_hostname && *wan_hostname ? wan_hostname : NULL,
+					      NULL
+				};
+				/* Start dhcp daemon */
+				_eval(dhcp_argv, NULL, 0, NULL);
+		 	} else {
+			 	/* setup static wan routes via physical device */
+				add_routes("wan_", "route", wan_ifname);
+				/* and set default route if specified with metric 1 */
+				if (inet_addr_(nvram_safe_get(strcat_r(prefix, "pppoe_gateway", tmp))) &&
+				    !nvram_match("wan_heartbeat_x", ""))
+					route_add(wan_ifname, 2, "0.0.0.0", 
+						nvram_safe_get(strcat_r(prefix, "pppoe_gateway", tmp)), "0.0.0.0");
+				/* start multicast router */
+				start_igmpproxy(wan_ifname);
 			}
-
-#ifndef ASUS_EXT	// keep alive anyway
-			if (nvram_match(strcat_r(prefix, "pppoe_demand", tmp), "1") || 
-			    nvram_match(strcat_r(prefix, "pppoe_keepalive", tmp), "1"))
-#endif
-				*arg++ = "-k";
-			snprintf(pppunit, sizeof(pppunit), "%d", unit);
-			*arg++ = "-U";
-			*arg++ = pppunit;
-
+			
 			/* launch pppoe client daemon */
-			_eval(pppoe_argv, NULL, 0, &pid);
+			start_pppd(prefix);
 
 			/* ppp interface name is referenced from this point on */
 			wan_ifname = nvram_safe_get(strcat_r(prefix, "pppoe_ifname", tmp));
 			
 			/* Pretend that the WAN interface is up */
-			if (nvram_match(strcat_r(prefix, "pppoe_demand", tmp), "1")) {
+			if (demand) 
+			{
+				int timeout = 5;
 				/* Wait for pppx to be created */
 				while (ifconfig(wan_ifname, IFUP, NULL, NULL) && timeout--)
 					sleep(1);
@@ -703,6 +839,8 @@ start_wan(void)
 					      wan_hostname && *wan_hostname ? wan_hostname : NULL,
 					      NULL
 			};
+			/* start firewall */
+			start_firewall_ex(wan_ifname, "0.0.0.0", "br0", nvram_safe_get("lan_ipaddr"));
 			/* Start dhcp daemon */
 			_eval(dhcp_argv, NULL, 0, &pid);
 #ifdef ASUS_EXT
@@ -737,6 +875,103 @@ start_wan(void)
 		char *stats_argv[] = { "stats", nvram_get("stats_server"), NULL };
 		_eval(stats_argv, NULL, 5, NULL);
 	}
+
+#ifdef CONFIG_IPV6
+	/* IPv6 address config */
+	{
+		char *ip6_addr = nvram_safe_get("ipv6_wan_addr");
+		char *ip6_size = nvram_safe_get("ipv6_wan_netsize");
+		char *ip6_router = nvram_safe_get("ipv6_wan_router");
+		
+		if (ip6_addr && *ip6_addr && ip6_size && *ip6_size)
+		{
+			char ip6_net[64];
+			sprintf(ip6_net, "%s/%s", ip6_addr, ip6_size);
+
+			eval("ip", "-6", "addr", "add", ip6_net, "dev", nvram_safe_get("wan0_ifname"));
+		}
+
+		/* Configurate remote IPv6 address (default gateway) */
+		if (ip6_router && *ip6_router)
+			eval("ip", "-6", "ro", "add", "default", "via", ip6_router, "dev", nvram_safe_get("wan0_ifname"));
+
+	}
+
+	/* IPv6 tunnel config */
+	if (nvram_match("ipv6_sit_enable", "1"))
+	{
+		char *ip6_addrL = nvram_safe_get("ipv6_sit_localaddr");
+		char *ip6_sizeL = nvram_safe_get("ipv6_sit_netsize");
+		char *ip6_addrR = nvram_safe_get("ipv6_sit_remoteaddr");
+		
+		/* Instantiate tunnel */
+		eval("ip", "tunnel", "add", "sixtun", "mode", "sit",
+			"local", "0.0.0.0",
+			"remote", nvram_safe_get("ipv6_sit_remote"));
+
+		/* Enable tunnel */
+		eval("ip", "link", "set", "sixtun", "up");
+
+		/* Set MTU value */
+		eval("ip", "link", "set", "mtu", nvram_safe_get("ipv6_sit_mtu"), "dev", "sixtun");
+
+		/* Set TTL value */
+		eval("ip", "tunnel", "change", "sixtun", "ttl", nvram_safe_get("ipv6_sit_ttl"));
+
+		/* Configure local IPv6 address */
+		if (ip6_addrL && *ip6_addrL && ip6_sizeL && *ip6_sizeL)
+		{
+			char ip6_net[64];
+			sprintf(ip6_net, "%s/%s", ip6_addrL, ip6_sizeL);
+			
+			eval("ip", "-6", "addr", "add", ip6_net, "dev", "sixtun");
+
+		}
+
+		/* Configurate remote IPv6 address (default gateway) */
+		if (ip6_addrR && *ip6_addrR)
+			eval("ip", "-6", "ro", "add", "default", "via", ip6_addrR, "dev", "sixtun");
+	}
+
+	/* IPv6 router advertisement daemon */
+	if (nvram_match("ipv6_radvd_enable", "1"))
+	{
+		FILE *radvdconf = fopen( "/etc/radvd.conf", "w" );
+		if (radvdconf != NULL)
+		{
+			int netsize = atoi(nvram_safe_get("ipv6_lan_netsize")), i = 15, n = netsize;
+			struct in6_addr addr;
+			char final[INET6_ADDRSTRLEN];
+					
+			/* Convert for easy manipulation */
+			inet_pton(AF_INET6, nvram_safe_get("ipv6_lan_addr"), &addr);
+
+			/* Clean complete bytes, starting from the end */
+			while (n >= 8)
+			{
+				addr.s6_addr[i--] = 0;
+				n -= 8;
+			}
+
+			/* Clear remaining bits */
+			if (i > 0)
+				addr.s6_addr[i] &= (255 << n);
+
+			/* Convert back to string representation */
+			inet_ntop(AF_INET6, &addr, final, INET6_ADDRSTRLEN);
+	
+			/* And write out to config file */
+			fprintf( radvdconf,
+				"interface %s { AdvSendAdvert on; prefix %s/%d { AdvOnLink on; AdvAutonomous on; }; };",
+				nvram_safe_get("lan_ifname"), final, netsize);
+	
+			fclose(radvdconf);
+
+			/* Then start the radvd */
+			eval("radvd");
+		}
+	}
+#endif
 }
 
 void
@@ -750,14 +985,13 @@ stop_wan(void)
 	/* Shutdown and kill all possible tasks */
 	eval("killall", "ip-up");
 	eval("killall", "ip-down");
-	snprintf(signal, sizeof(signal), "-%d", SIGHUP);
-	eval("killall", signal, "pppoecd");
-	eval("killall", signal, "pppd");
-	eval("killall", "pppoecd");
+	eval("killall", "l2tpd");
 	eval("killall", "pppd");
 	snprintf(signal, sizeof(signal), "-%d", SIGUSR2);
 	eval("killall", signal, "udhcpc");
 	eval("killall", "udhcpc");
+	eval("killall", "igmpproxy");
+	eval("killall", "udpxy");
 
 	/* Bring down WAN interfaces */
 	foreach(name, nvram_safe_get("wan_ifnames"), next)
@@ -790,15 +1024,14 @@ stop_wan2(void)
 	/* Shutdown and kill all possible tasks */
 	eval("killall", "ip-up");
 	eval("killall", "ip-down");
-	snprintf(signal, sizeof(signal), "-%d", SIGHUP);
-	eval("killall", signal, "pppoecd");
-	eval("killall", signal, "pppd");
-	eval("killall", "pppoecd");
+	eval("killall", "l2tpd");
 	eval("killall", "pppd");
 
 	snprintf(signal, sizeof(signal), "-%d", SIGUSR2);
 	eval("killall", signal, "udhcpc");
 	eval("killall", "udhcpc");
+	eval("killall", "igmpproxy");
+	eval("killall", "udpxy");
 
 	/* Remove dynamically created links */
 	unlink("/tmp/udhcpc");
@@ -814,137 +1047,125 @@ stop_wan2(void)
 	dprintf("done\n");
 }
 
-static int
-add_ns(char *wan_ifname)
+static int 
+update_resolvconf(void)
 {
 	FILE *fp;
-	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
 	char word[100], *next;
-	char line[100];
 
-	/* Figure out nvram variable name prefix for this i/f */
-	if (wan_prefix(wan_ifname, prefix) < 0)
-		return -1;
+	/* check if auto dns enabled */	
+	if (!nvram_match("wan_dnsenable_x", "1"))
+		return 0;
 
-	/* Open resolv.conf to read */
-	if (!(fp = fopen("/tmp/resolv.conf", "r+"))) {
+	if (!(fp = fopen("/tmp/resolv.conf", "w+"))) {
 		perror("/tmp/resolv.conf");
 		return errno;
 	}
-
-	/* Append only those not in the original list */
-	foreach(word, nvram_safe_get(strcat_r(prefix, "dns", tmp)), next) 
+	
+	foreach(word, (nvram_get("wan0_dns") ? : 
+		nvram_safe_get("wanx_dns")), next) 
 	{
-		fseek(fp, 0, SEEK_SET);
-		while (fgets(line, sizeof(line), fp)) {
-			char *token = strtok(line, " \t\n");
-
-			if (!token || strcmp(token, "nameserver") != 0)
-				continue;
-			if (!(token = strtok(NULL, " \t\n")))
-				continue;
-
-			if (!strcmp(token, word))
-				break;
-		}
-		if (feof(fp))
-			fprintf(fp, "nameserver %s\n", word);
+		fprintf(fp, "nameserver %s\n", word);
 	}
+	
 	fclose(fp);
-
-#ifdef ASUS_EXT
-	stop_dns();
-	start_dns();
-#else
-	/* notify dnsmasq */
-	snprintf(tmp, sizeof(tmp), "-%d", SIGHUP);
-	eval("killall", tmp, "dnsmasq");
-#endif
 	
+	/* Notify dnsmasq of change */
+	eval("killall", "-1", "dnsmasq");
+
 	return 0;
 }
 
-static int
-del_ns(char *wan_ifname)
+void
+wan_up(char *wan_ifname)
 {
-	FILE *fp, *fp2;
 	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
-	char word[100], *next;
-	char line[100];
+	char *wan_proto, *gateway;
 
 	/* Figure out nvram variable name prefix for this i/f */
-	if (wan_prefix(wan_ifname, prefix) < 0)
-		return -1;
-
-	/* Open resolv.conf to read */
-	if (!(fp = fopen("/tmp/resolv.conf", "r"))) {
-		perror("fopen /tmp/resolv.conf");
-		return errno;
-	}
-	/* Open resolv.tmp to save updated name server list */
-	if (!(fp2 = fopen("/tmp/resolv.tmp", "w"))) {
-		perror("fopen /tmp/resolv.tmp");
-		fclose(fp);
-		return errno;
-	}
-	/* Copy updated name servers */
-	while (fgets(line, sizeof(line), fp)) {
-		char *token = strtok(line, " \t\n");
-
-		if (!token || strcmp(token, "nameserver") != 0)
-			continue;
-		if (!(token = strtok(NULL, " \t\n")))
-			continue;
+	if (wan_prefix(wan_ifname, prefix) < 0) 
+	{
+		/* called for dhcp+ppp */
+		if (!nvram_match("wan0_ifname", wan_ifname))
+			return;
+
+		/* re-start firewall with old ppp0 address or 0.0.0.0 */
+		start_firewall_ex("ppp0", nvram_safe_get("wan0_ipaddr"),
+			"br0", nvram_safe_get("lan_ipaddr"));
+
+	 	/* setup static wan routes via physical device */
+		add_routes("wan_", "route", wan_ifname);
+		/* and one supplied via DHCP */
+		add_wanx_routes("wanx_", wan_ifname, 0);
+		
+		gateway = inet_addr_(nvram_safe_get("wan_gateway")) != INADDR_ANY ?
+			nvram_get("wan_gateway") : nvram_safe_get("wanx_gateway");
 
-		foreach(word, nvram_safe_get(strcat_r(prefix, "dns", tmp)), next)
-			if (!strcmp(word, token))
-				break;
-		if (!next)
-			fprintf(fp2, "nameserver %s\n", token);
-	}
-	fclose(fp);
-	fclose(fp2);
-	/* Use updated file as resolv.conf */
-	unlink("/tmp/resolv.conf");
-	rename("/tmp/resolv.tmp", "/tmp/resolv.conf");
+		/* and default route with metric 1 */
+		if (inet_addr_(gateway) != INADDR_ANY)
+		{
+			char word[100], *next;
 
-#ifdef ASUS_EXT
-	stop_dns();
-	start_dns();
-#else	
-	/* notify dnsmasq */
-	snprintf(tmp, sizeof(tmp), "-%d", SIGHUP);
-	eval("killall", tmp, "dnsmasq");
-#endif
-	
-	return 0;
-}
+			route_add(wan_ifname, 2, "0.0.0.0", gateway, "0.0.0.0");
 
-void
-wan_up(char *wan_ifname)
-{
-	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
-	char *wan_proto;
+			/* ... and to dns servers as well for demand ppp to work */
+			if (nvram_match("wan_dnsenable_x", "1"))
+				foreach(word, nvram_safe_get("wanx_dns"), next) 
+			{
+				in_addr_t mask = inet_addr(nvram_safe_get("wanx_netmask"));
+				if ((inet_addr(word) & mask) != (inet_addr(nvram_safe_get("wanx_ipaddr")) & mask))
+					route_add(wan_ifname, 2, word, gateway, "255.255.255.255");
+			}
+		}
 
-	/* Figure out nvram variable name prefix for this i/f */
-	if (wan_prefix(wan_ifname, prefix) < 0)
+		/* start multicast router */
+		start_igmpproxy(wan_ifname);
+		
+		update_resolvconf();
+		
 		return;
+	}
 
 	wan_proto = nvram_safe_get(strcat_r(prefix, "proto", tmp));	
 
 	dprintf("%s %s\n", wan_ifname, wan_proto);
 
 	/* Set default route to gateway if specified */
-	if (nvram_match(strcat_r(prefix, "primary", tmp), "1"))
+	if (nvram_match(strcat_r(prefix, "primary", tmp), "1")) 
+	{
+		if (strcmp(wan_proto, "dhcp") == 0 || strcmp(wan_proto, "static") == 0) 
+		{
+			/* the gateway is in the local network */
+			route_add(wan_ifname, 0, nvram_safe_get(strcat_r(prefix, "gateway", tmp)),
+				NULL, "255.255.255.255");
+		}
+		/* default route via default gateway */
 		route_add(wan_ifname, 0, "0.0.0.0", 
-			nvram_safe_get(strcat_r(prefix, "gateway", tmp)),
-			"0.0.0.0");
+			nvram_safe_get(strcat_r(prefix, "gateway", tmp)), "0.0.0.0");
+		/* hack: avoid routing cycles, when both peer and server has the same IP */
+		if (strcmp(wan_proto, "pptp") == 0 || strcmp(wan_proto, "l2tp") == 0) {
+			/* delete gateway route as it's no longer needed */
+			route_del(wan_ifname, 0, nvram_safe_get(strcat_r(prefix, "gateway", tmp)),
+				"0.0.0.0", "255.255.255.255");
+		}
+	}
 
 	/* Install interface dependent static routes */
 	add_wan_routes(wan_ifname);
 
+ 	/* setup static wan routes via physical device */
+	if (strcmp(wan_proto, "dhcp") == 0 || strcmp(wan_proto, "static") == 0) 
+	{
+		nvram_set("wanx_gateway", nvram_safe_get(strcat_r(prefix, "gateway", tmp)));
+		add_routes("wan_", "route", wan_ifname);
+	}
+
+	/* and one supplied via DHCP */
+	if (strcmp(wan_proto, "dhcp") == 0)
+		add_wanx_routes(prefix, wan_ifname, 0);
+
 	/* Add dns servers to resolv.conf */
-	add_ns(wan_ifname);
+	update_resolvconf();
 
 	/* Sync time */
 	//start_ntpc();
@@ -955,7 +1176,10 @@ wan_up(char *wan_ifname)
 	start_ddns();
 	stop_upnp();
 	start_upnp();		
-	if (strcmp(wan_proto, "bigpond")==0)	start_bpalogin();
+	if (strcmp(wan_proto, "bigpond")==0) {
+		stop_bpalogin();
+		start_bpalogin();
+	}
 #endif
 	
 #ifdef QOS
@@ -963,6 +1187,14 @@ wan_up(char *wan_ifname)
 	start_qos(nvram_safe_get(strcat_r(prefix, "ipaddr", tmp)));
 #endif
 
+	/* start multicast router */
+	if (strcmp(wan_proto, "dhcp") == 0 || 
+		strcmp(wan_proto, "bigpond") == 0 || 
+		strcmp(wan_proto, "static") == 0) 
+	{
+		start_igmpproxy(wan_ifname);
+	}
+
 	dprintf("done\n");
 }
 
@@ -989,8 +1221,10 @@ wan_down(char *wan_ifname)
 	/* Remove interface dependent static routes */
 	del_wan_routes(wan_ifname);
 
-	/* Update resolv.conf */
-	del_ns(wan_ifname);
+	/* Update resolv.conf -- leave as is if no dns servers left for demand to work */
+	if (*nvram_safe_get("wanx_dns"))
+		nvram_unset(strcat_r(prefix, "dns", tmp));
+	update_resolvconf();
 
 #ifdef ASUS_EXT
 	update_wan_status(0);
@@ -1007,7 +1241,6 @@ lan_up(char *lan_ifname)
 {
 	FILE *fp;
 	char word[100], *next;
-	char line[100];
 
 	/* Set default route to gateway if specified */
 	route_add(lan_ifname, 0, "0.0.0.0", 
@@ -1017,11 +1250,11 @@ lan_up(char *lan_ifname)
 	/* Open resolv.conf to read */
 	if (!(fp = fopen("/tmp/resolv.conf", "w"))) {
 		perror("/tmp/resolv.conf");
-		return errno;
+		return;
 	}
 
-	if (nvram_invmatch("lan_gateway", ""))
-		fprintf(fp, "nameserver %s\n", nvram_safe_get("lan_gateway"));
+	/*if (nvram_invmatch("lan_gateway", ""))
+		fprintf(fp, "nameserver %s\n", nvram_safe_get("lan_gateway"));*/
 
 	foreach(word, nvram_safe_get("lan_dns"), next)
 	{
@@ -1029,6 +1262,9 @@ lan_up(char *lan_ifname)
 	}
 	fclose(fp);
 
+	/* Notify dnsmasq of change */
+	eval("killall", "-1", "dnsmasq");
+	
 	/* Sync time */
 	//start_ntpc();
 }
@@ -1051,7 +1287,6 @@ lan_up_ex(char *lan_ifname)
 {
 	FILE *fp;
 	char word[100], *next;
-	char line[100];
 
 	/* Set default route to gateway if specified */
 	route_add(lan_ifname, 0, "0.0.0.0", 
@@ -1061,11 +1296,11 @@ lan_up_ex(char *lan_ifname)
 	/* Open resolv.conf to read */
 	if (!(fp = fopen("/tmp/resolv.conf", "w"))) {
 		perror("/tmp/resolv.conf");
-		return errno;
+		return;
 	}
 
-	if (nvram_invmatch("lan_gateway_t", ""))
-		fprintf(fp, "nameserver %s\n", nvram_safe_get("lan_gateway_t"));
+	/*if (nvram_invmatch("lan_gateway_t", ""))
+		fprintf(fp, "nameserver %s\n", nvram_safe_get("lan_gateway_t"))*/;
 
 	foreach(word, nvram_safe_get("lan_dns_t"), next)
 	{
@@ -1073,6 +1308,9 @@ lan_up_ex(char *lan_ifname)
 	}
 	fclose(fp);
 
+	/* Notify dnsmasq of change */
+	eval("killall", "-1", "dnsmasq");
+	
 	/* Sync time */
 	//start_ntpc();
 	//update_lan_status(1);
@@ -1117,8 +1355,13 @@ notify_nas(char *type, char *ifname, cha
 	/* the wireless interface must be configured to run NAS */
 	wl_ioctl(ifname, WLC_GET_INSTANCE, &unit, sizeof(unit));
 	snprintf(prefix, sizeof(prefix), "wl%d_", unit);
+#ifdef WPA2_WMM
 	if (nvram_match(strcat_r(prefix, "akm", tmp), "") &&
 	    nvram_match(strcat_r(prefix, "auth_mode", tmp), "none"))
+#else
+	if (nvram_match(strcat_r(prefix, "auth_mode", tmp), "open") ||
+	    nvram_match(strcat_r(prefix, "auth_mode", tmp), "shared"))
+#endif
 		return 0;
 
 	/* find WDS link configuration */
@@ -1145,7 +1388,11 @@ notify_nas(char *type, char *ifname, cha
 		/* crypto */
 		argv[5] = nvram_safe_get(strcat_r(prefix, "crypto", tmp));
 		/* auth mode */
+#ifdef WPA2_WMM
 		argv[6] = nvram_safe_get(strcat_r(prefix, "akm", tmp));
+#else
+		argv[6] = nvram_safe_get(strcat_r(prefix, "auth_mode", tmp));
+#endif
 		/* passphrase */
 		argv[7] = nvram_safe_get(strcat_r(prefix, "wpa_psk", tmp));
 		/* ssid */
diff -BurpN -x'*.o' router/rc/network_ex.c gateway/rc/network_ex.c
--- router/rc/network_ex.c	2004-11-19 22:16:33.000000000 +0300
+++ gateway/rc/network_ex.c	2008-03-19 20:07:24.000000000 +0300
@@ -13,7 +13,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
-#include <syslog.h>															
+#include <syslog.h>
 #include <ctype.h>
 #include <string.h>
 #include <unistd.h>
@@ -35,7 +35,8 @@
 #include <rc.h>
 #include <bcmutils.h>
 
-#ifdef REMOVE
+
+#if 0
 int start_pppoe(void)
 {
 
@@ -97,106 +98,162 @@ int start_pppoe(void)
 }
 #endif
 
-int start_pptp(char *prefix)
+int start_pppd(char *prefix)
 {
 	int ret;
 	FILE *fp;
-	char *pptp_argv[] = { "pppd", NULL};
-	char username[32],passwd[32];
+	char options[80];
+	char *pppd_argv[] = { "pppd", "file", options, NULL};
 	char tmp[100];
+	mode_t mask;
+	
+	sprintf(options, "/tmp/ppp/options.wan%s", 
+		nvram_safe_get(strcat_r(prefix, "unit", tmp)));
 
-	strcpy(username, nvram_safe_get(strcat_r(prefix, "pppoe_username", tmp)));
-	strcpy(passwd, nvram_safe_get(strcat_r(prefix, "pppoe_passwd", tmp)));
-
+	mask = umask(066);
+	
 	/* Generate options file */
-	if (!(fp = fopen("/tmp/ppp/options", "w"))) {
-       	        perror("/tmp/ppp/options");
+	if (!(fp = fopen(options, "w"))) {
+       	        perror(options);
+		umask(mask);
        	        return -1;
 	}
 	
-	if (nvram_invmatch(strcat_r(prefix, "pppoe_idletime", tmp), ""))
-		fprintf(fp, "idle %s\n", nvram_safe_get(strcat_r(prefix, "pppoe_idletime", tmp)));
+	umask(mask);
 	
-       	fprintf(fp, "noauth\n");	
-       	fprintf(fp, "user '%s'\n",username); 
-	fprintf(fp, "demand\n");
-	fprintf(fp, "connect true\n");    
-
-	if(nvram_invmatch("wan_heartbeat_x", ""))
-	{	
-       		fprintf(fp, "pty '/usr/sbin/pptp %s --nolaunchpppd'\n",nvram_safe_get("wan_heartbeat_x")); 
+	/* do not authenticate peer and do not use eap */
+	fprintf(fp, "noauth refuse-eap\n");
+	fprintf(fp, "user '%s'\n", 
+       		nvram_safe_get(strcat_r(prefix, "pppoe_username", tmp))); 
+	fprintf(fp, "password '%s'\n", 
+		nvram_safe_get(strcat_r(prefix, "pppoe_passwd", tmp)));
+       	       	
+       	if (nvram_match(strcat_r(prefix, "proto", tmp), "pptp")) 
+       	{
+		fprintf(fp, "connect true\n");    
+		fprintf(fp, "sync pty '/usr/sbin/pptp --idle-wait 0 %s --nolaunchpppd --nobuffer --sync'\n", 
+   			nvram_invmatch("wan_heartbeat_x", "") ?
+   			nvram_safe_get("wan_heartbeat_x") : 
+   			nvram_safe_get(strcat_r(prefix, "pppoe_gateway", tmp))); 
+		fprintf(fp, "lock\n");
+		/* see KB Q189595 -- historyless & mtu */
+		fprintf(fp, "nomppe-stateful %s mtu 1400\n",
+			nvram_safe_get(strcat_r(prefix, "pptp_options_x", tmp)));
+	} else {
+		fprintf(fp, "nomppe nomppc\n");
 	}
-	else
+
+       	if (nvram_match(strcat_r(prefix, "proto", tmp), "pppoe")) 
+       	{
+		fprintf(fp, "plugin rp-pppoe.so");
+
+		if (nvram_invmatch(strcat_r(prefix, "pppoe_service", tmp), "")) {
+			fprintf(fp, " rp_pppoe_service '%s'", 
+				nvram_safe_get(strcat_r(prefix, "pppoe_service", tmp)));
+		}
+	
+		if (nvram_invmatch(strcat_r(prefix, "pppoe_ac", tmp), "")) {
+			fprintf(fp, " rp_pppoe_ac '%s'", 
+				nvram_safe_get(strcat_r(prefix, "pppoe_ac", tmp)));
+		}
+
+		fprintf(fp, " nic-%s\n", nvram_safe_get(strcat_r(prefix, "ifname", tmp)));
+		
+		fprintf(fp, "mru %s mtu %s\n", 
+			nvram_safe_get(strcat_r(prefix, "pppoe_mru", tmp)),
+			nvram_safe_get(strcat_r(prefix, "pppoe_mtu", tmp)));
+	}
+	
+	if (atoi(nvram_safe_get(strcat_r(prefix, "pppoe_idletime", tmp))) &&
+	     nvram_match(strcat_r(prefix, "pppoe_demand", tmp), "1")) 
 	{
-       		fprintf(fp, "pty '/usr/sbin/pptp %s --nolaunchpppd'\n",nvram_safe_get(strcat_r(prefix, "pppoe_gateway", tmp))); 
+		fprintf(fp, "idle %s ", nvram_safe_get(strcat_r(prefix, "pppoe_idletime", tmp)));
+		if (nvram_invmatch(strcat_r(prefix, "pppoe_txonly_x", tmp), "0")) {
+			fprintf(fp, "tx_only ");
+		}
+		fprintf(fp, "demand\n");
 	}
 
-	fprintf(fp, "defaultroute\n"); 
-
-	//if (nvram_invmatch(strcat_r(prefix, "pppoe_mtu", tmp), ""))	
-       	//	fprintf(fp, "mtu %s\n", nvram_safe_get(strcat_r(prefix, "pppoe_mtu", tmp)));
+	fprintf(fp, "maxfail 0\n");
 
       	if (nvram_invmatch(strcat_r(prefix, "dnsenable_x", tmp), "0"))
 		fprintf(fp, "usepeerdns\n");   
 
-       	fprintf(fp, "persist\n");        
-       	fprintf(fp, "ipcp-accept-remote\n");  
-       	fprintf(fp, "ipcp-accept-local\n");        
-       	fprintf(fp, "noipdefault\n");  
-       	fprintf(fp, "ktune\n");      
-    	fprintf(fp, "default-asyncmap\n"); 
-	fprintf(fp, "nopcomp\n");	
-	fprintf(fp, "noaccomp\n");	
-       	fprintf(fp, "noccp\n");  
-       	fprintf(fp, "novj\n");       
-       	fprintf(fp, "nobsdcomp\n");   
-       	fprintf(fp, "nodeflate\n");     
+       	if (nvram_invmatch(strcat_r(prefix, "proto", tmp), "l2tp")) 
+		fprintf(fp, "persist\n");
+       	
+       	fprintf(fp, "ipcp-accept-remote ipcp-accept-local noipdefault\n");
+       	fprintf(fp, "ktune\n");
+       	
+       	/* pppoe set these options automatically */
+       	/* looks like pptp also likes them */
+    	fprintf(fp, "default-asyncmap nopcomp noaccomp\n");
+
+	/* pppoe disables "vj bsdcomp deflate" automagically */
+	/* ccp should still be enabled - mppe/mppc requires this */
+       	fprintf(fp, "novj nobsdcomp nodeflate\n");
+       	
+       	/* echo failures */
 	fprintf(fp, "lcp-echo-interval 10\n");
-	fprintf(fp, "lcp-echo-failure 3\n");	
-       	fprintf(fp, "lock\n");
+	fprintf(fp, "lcp-echo-failure 6\n");
 
-       	fclose(fp);
-
-       	/* Generate pap-secrets file */
-       	if (!(fp = fopen("/tmp/ppp/pap-secrets", "w"))) {
-       	        perror("/tmp/ppp/pap-secrets");
-        	return -1;
-       	}
-       	fprintf(fp, "\"%s\" * \"%s\" *\n",
-		username,
-		passwd);
-       	fclose(fp);
-	chmod("/tmp/ppp/pap-secrets", 0600);
+	fprintf(fp, "unit %s\n", 
+		nvram_get(strcat_r(prefix, "unit", tmp)) ? : "0");
 
-       	/* Generate chap-secrets file */
-       	if (!(fp = fopen("/tmp/ppp/chap-secrets", "w"))) {
-        	perror("/tmp/ppp/chap-secrets");
-               	return -1;
-       	}
-
-       	fprintf(fp, "\"%s\" * \"%s\" *\n",
-		username,
-		passwd);
+	/* user specific options */
+	fprintf(fp, "%s\n", 
+		nvram_safe_get(strcat_r(prefix, "pppoe_options_x", tmp)));
+		
        	fclose(fp);
 
-	chmod("/tmp/ppp/chap-secrets", 0600);
-
-	/* Enable Forwarding */
-	if ((fp = fopen("/proc/sys/net/ipv4/ip_forward", "r+"))) {
-		fputc('1', fp);
+       	if (nvram_match(strcat_r(prefix, "proto", tmp), "l2tp")) 
+       	{
+       		mkdir("/etc/l2tp", 0755);
+       		
+		if (!(fp = fopen("/etc/l2tp/l2tp.conf", "w"))) {
+	       	        perror(options);
+	       	        return -1;
+		}
+		
+		fprintf(fp, "# automagically generated\n"
+			"global\n\n"
+			"load-handler \"sync-pppd.so\"\n"
+			"load-handler \"cmd.so\"\n\n"
+			"section sync-pppd\n\n"
+			"lac-pppd-opts \"file %s\"\n\n"
+			"section peer\n"
+			"peername %s\n"
+			"lac-handler sync-pppd\n"
+			"persist yes\n"
+			"maxfail %s\n"
+			"holdoff %s\n"
+			"section cmd\n\n",
+			options,
+			nvram_invmatch("wan_heartbeat_x", "") ?
+   				nvram_safe_get("wan_heartbeat_x") : 
+   				nvram_safe_get(strcat_r(prefix, "pppoe_gateway", tmp)),
+			nvram_invmatch(strcat_r(prefix, "pppoe_maxfail", tmp), "") ?
+				nvram_safe_get(strcat_r(prefix, "pppoe_maxfail", tmp)) : "32767",
+			nvram_invmatch(strcat_r(prefix, "pppoe_holdoff", tmp), "") ?
+				nvram_safe_get(strcat_r(prefix, "pppoe_holdoff", tmp)) : "30");
+			
 		fclose(fp);
-	} else
-	{	
-		perror("/proc/sys/net/ipv4/ip_forward");
-	}
-	
-	/* Bring up  WAN interface */
-	ifconfig(nvram_safe_get(strcat_r(prefix, "ifname", tmp)), 
-		 IFUP,
-		 nvram_safe_get("wanx_ipaddr"), 
-		 nvram_safe_get("wanx_netmask"));
-
-	ret = _eval(pptp_argv, NULL, 0, NULL);
+		
+		/* launch l2tp */
+		eval("l2tpd");
+		
+		sleep(1);
+		
+		/* start-session */
+		ret = eval("l2tp-control", "start-session 0.0.0.0");
+		
+		/* pppd sync nodetach noaccomp nobsdcomp nodeflate */
+		/* nopcomp novj novjccomp file /tmp/ppp/options.l2tp */
+		
+       	} else
+		ret = _eval(pppd_argv, NULL, 0, NULL);
+		
+	return ret;
 }
 
 void start_pppoe_relay(char *wan_if)
@@ -213,8 +270,15 @@ void start_pppoe_relay(char *wan_if)
 
 void setup_ethernet(char *wan_if)
 {
-	//if (nvram_invmatch("wan_etherspeed_x", "auto"))
+	if (nvram_invmatch("wan_etherspeed_x", "auto"))
 	{
-		eval("et", "-i", wan_if, "speed", nvram_safe_get("wan_etherspeed_x"));	
+		char *speed = nvram_safe_get("wan_etherspeed_x");
+		
+		if (nvram_match("vlan1ports", "0 5") || nvram_match("vlan1ports", "0 5u"))
+			eval("mii-tool", "eth0", "-p", "0", "-A", 
+				!strcmp(speed, "100full") ? "100baseTx-FD" :
+				!strcmp(speed, "100half") ? "100baseTx-HD" :
+				!strcmp(speed, "10full") ? "10baseT-FD" : "10baseT-HD");
+		else eval("et", "-i", wan_if, "speed", speed);	
 	}	
 } 
diff -BurpN -x'*.o' router/rc/ntp.c gateway/rc/ntp.c
--- router/rc/ntp.c	2004-11-15 14:55:13.000000000 +0300
+++ gateway/rc/ntp.c	2008-12-28 10:27:34.000000000 +0300
@@ -16,6 +16,7 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #include <bcmnvram.h>
@@ -52,7 +53,7 @@ int ntp_main(void)
 
 	while(1)
 	{
-		ret=eval("ntpclient", "-h", servers, "-i", "3", "-l", "-s");
+		ret=eval("ntpclient", "-h", servers, "-i", "3", "-c", "1", "-l", "-s");
 		pause();
 	}	
 }
diff -BurpN -x'*.o' router/rc/ppp.c gateway/rc/ppp.c
--- router/rc/ppp.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/ppp.c	2008-03-19 20:07:24.000000000 +0300
@@ -56,6 +56,8 @@ ipup_main(int argc, char **argv)
 	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
 
 	dprintf("%s\n", argv[0]);
+	
+	umask(022);
 
 	if ((unit = ppp_ifunit(wan_ifname)) < 0)
 		return -1;
@@ -68,6 +70,9 @@ ipup_main(int argc, char **argv)
 		return errno;
 	}
 	fclose(fp);
+	
+	if (!nvram_get(strcat_r(prefix, "ifname", tmp)))
+		return -1;
 
 	if ((value = getenv("IPLOCAL"))) {
 		ifconfig(wan_ifname, IFUP,
@@ -103,16 +108,21 @@ ipdown_main(int argc, char **argv)
 	char *wan_ifname = safe_getenv("IFNAME");
 	int unit;
 	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
+
+	umask(022);
 	
 	if ((unit = ppp_ifunit(wan_ifname)) < 0)
 		return -1;
 	
 	snprintf(prefix, sizeof(prefix), "wan%d_", unit);
 
+	if (!nvram_get(strcat_r(prefix, "ifname", tmp)))
+		return -1;
+
 	wan_down(wan_ifname);
 
 	unlink(strcat_r("/tmp/ppp/link.", wan_ifname, tmp));
-
+	
 	preset_wan_routes(wan_ifname);
 
 	logmessage(nvram_safe_get("wan_proto_t"), "Disconnected");
diff -BurpN -x'*.o' router/rc/qos.c gateway/rc/qos.c
--- router/rc/qos.c	2004-11-11 10:32:06.000000000 +0300
+++ gateway/rc/qos.c	2008-03-19 20:07:24.000000000 +0300
@@ -73,8 +73,8 @@ void tc_class(char *network, char *idx, 
 		minBW=maxBW;
 	}
 	sprintf(flowid, "%s%s", "1:1", idx);
-	sprintf(max_bw, "%s%s", maxBW, "Kbps");
-	sprintf(min_bw, "%s%s", minBW, "Kbps");
+	sprintf(max_bw, "%s%s", maxBW, "kbit");
+	sprintf(min_bw, "%s%s", minBW, "kbit");
 	eval("tc","class","add","dev",network,"parent","1:1","classid",flowid,"htb","rate",min_bw,"ceil",max_bw);
 }
 
diff -BurpN -x'*.o' router/rc/rcamd.c gateway/rc/rcamd.c
--- router/rc/rcamd.c	2004-11-15 15:08:00.000000000 +0300
+++ gateway/rc/rcamd.c	2008-12-28 10:27:47.000000000 +0300
@@ -16,6 +16,7 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #include <bcmnvram.h>
diff -BurpN -x'*.o' router/rc/rc.c gateway/rc/rc.c
--- router/rc/rc.c	2004-12-03 05:16:28.000000000 +0300
+++ gateway/rc/rc.c	2009-01-19 12:52:01.000000000 +0300
@@ -31,6 +31,9 @@
 #include <sys/socket.h>
 #include <net/if_arp.h>
 #include <dirent.h>
+#if defined(__UCLIBC__)
+#include <crypt.h>
+#endif
 
 #include <epivers.h>
 #include <bcmnvram.h>
@@ -49,7 +52,7 @@ static void rc_signal(int sig);
 
 extern struct nvram_tuple router_defaults[];
 
-static int restore_defaults_g=0;
+//static int restore_defaults_g=0;
 
 static int
 build_ifnames(char *type, char *names, int *size)
@@ -124,6 +127,9 @@ build_ifnames(char *type, char *names, i
 
 			/* append interface name to list */
 			len += snprintf(&names[len], *size - len, "%s ", ifr.ifr_name);
+			
+			/* first match only (et and wl macs are the same */
+			break;
 		}
 	}
 	
@@ -134,6 +140,125 @@ build_ifnames(char *type, char *names, i
 }	
 
 static void
+early_defaults(void)
+{
+	/* wl700ge -- boardflags are not set correctly */
+	if (nvram_match("boardflags", "0x10") && nvram_get("default_boardflags")) 
+	{
+		nvram_set("boardflags", nvram_get("default_boardflags"));
+	}
+
+	/* fix Sentry5 config */
+	if (nvram_match("boardtype", "bcm95365r") && !nvram_get("vlan0ports"))
+	{
+		nvram_set("lan_ifname", "br0");
+		nvram_set("lan_ifnames", "vlan0 eth1");
+		nvram_set("wan_ifname", "vlan1");
+		nvram_set("wan_ifnames", "vlan1");
+		
+		nvram_set("vlan0hwname", "et0");
+		nvram_set("vlan0ports", "1 2 3 4 5*");
+		nvram_set("vlan1hwname", "et0");
+		nvram_set("vlan1ports", "0 5");
+	}
+
+	/* bcm95350rg -- use vlans (wl550ge, wl500gp, wl700ge) vs wl320g - no vlans */
+	if (nvram_match("wandevs", "et0") && 	/* ... wl500gpv2 */
+	    (nvram_match("vlan1ports", "0 5u") || nvram_match("vlan1ports", "4 5u")) &&
+	    (strtoul(nvram_safe_get("boardflags"), NULL, 0) & BFL_ENETVLAN) != 0)
+	{
+		nvram_set("wandevs", "vlan1");
+		nvram_set("wan_ifname", "vlan1");
+		nvram_set("wan_ifnames", "vlan1");
+		
+		/* data should be tagged for WAN port too */
+		nvram_set("vlan1ports",
+			nvram_match("vlan1ports", "0 5u") ? "0 5" : "4 5");
+	}
+	
+	/* fix DLINK DIR-320 vlans */
+	if (nvram_match("boardtype", "0x048e") && !nvram_match("boardnum", "45") &&
+		 !nvram_get("vlan2hwname"))
+	{
+		nvram_set("vlan2hwname", "et0");
+		nvram_set("wan0_ifnames", "vlan2");
+		nvram_set("wan0_ifname", "vlan2");
+		nvram_set("wan_ifnames", "vlan2");
+		nvram_set("wan_ifname_t", "vlan2");
+		nvram_set("wan_ifname", "vlan2");
+		nvram_set("wandevs", "vlan2");
+	}
+
+	/* wl550ge -- missing wl0gpio values */
+	if (nvram_match("boardtype", "0x467") && nvram_match("boardnum", "45") &&
+		!nvram_get("wl0gpio0"))
+	{
+		nvram_set("wl0gpio0", "2");
+		nvram_set("wl0gpio1", "0");
+		nvram_set("wl0gpio2", "0");
+		nvram_set("wl0gpio3", "0");
+	}
+	
+	/* fix AIR LED -- override default SROM setting and fix wl550ge config */
+	if (!nvram_get("wl0gpio0") || nvram_match("wl0gpio0", "2"))
+		nvram_set("wl0gpio0", "0x88");
+	
+	/* WL520gu/gc/gp/330ge */
+	if (nvram_match("wl0gpio1", "0x02"))
+		nvram_set("wl0gpio1", "0x88");
+
+	/* wl500gp -- 16mb memory activated, 32 available */
+	if (nvram_match("boardtype", "0x042f") && nvram_match("boardnum", "45") &&
+	    nvram_match("sdram_init", "0x000b") && nvram_match("sdram_config", "0x0062"))
+	{
+		nvram_set("sdram_init", "0x0009");
+		nvram_set("sdram_ncdl", "0");
+	}
+
+	/* fix WL500W mac adresses for WAN port */
+	if (nvram_match("et1macaddr", "00:90:4c:a1:00:2d")) 
+		nvram_set("et1macaddr", nvram_get("et0macaddr"));
+
+#if 0	/* leave it commented out until VLANs will work */
+	/* WL500W could have vlans enabled */
+	if (nvram_match("boardtype", "0x0472") && nvram_match("boardnum", "45"))
+	{
+		if (strtoul(nvram_safe_get("boardflags"), NULL, 0) & BFL_ENETVLAN)
+		{
+			if (!nvram_get("vlan0ports")) {
+				nvram_set("vlan0hwname", "et0");
+				nvram_set("vlan0ports", "0 1 2 3 5*");
+				nvram_set("vlan1hwname", "et0");
+				nvram_set("vlan1ports", "4 5");
+			}
+			nvram_set("lan_ifnames", "vlan0 eth2");
+			nvram_set("wan_ifname", "vlan1");
+		} else {
+			nvram_set("lan_ifnames", "eth0 eth2");
+			nvram_set("wan_ifname", "eth1");
+		}
+		nvram_set("lan_ifname", "br0");
+		nvram_set("wan_ifnames", nvram_get("wan_ifname"));
+	}
+#endif
+
+	/* set lan_hostname */
+	if (!nvram_invmatch("lan_hostname", ""))
+	{
+		/* derive from et0 mac addr */
+		char *mac = nvram_get("et0macaddr");
+		if (mac && strlen(mac) == 17)
+		{
+			char hostname[16];
+			sprintf(hostname, "WL-%c%c%c%c%c%c%c%c%c%c%c%c",
+				mac[0], mac[1], mac[3], mac[4], mac[6], mac[7],
+				mac[9], mac[10], mac[12], mac[13], mac[15], mac[16]);
+			nvram_set("lan_hostname", hostname);
+		}
+	}
+}
+
+static void
 restore_defaults(void)
 {
 	struct nvram_tuple generic[] = {
@@ -155,6 +280,9 @@ restore_defaults(void)
 		{ "lan_ifnames", "", 0 },
 		{ "wan_ifname", "", 0 },
 		{ "wan_ifnames", "", 0 },
+		/* default with vlans disabled */
+		{ "wan_nat_x", "0", 0},
+		{ "wan_route_x", "IP_Bridged", 0},
 		{ 0, 0, 0 }
 	};
 
@@ -162,7 +290,7 @@ restore_defaults(void)
 #ifdef CONFIG_WL300G
 	struct nvram_tuple wl300g[] = {
 		{ "lan_ifname", "br0", 0 },
-		{ "lan_ifnames", "eth0 eth2", 0 },
+		{ "lan_ifnames", "eth2", 0 },
 		{ "wan_ifname", "eth0", 0 },
 		{ "wan_ifnames", "eth0", 0 },
 		{ "wan_nat_x", "0", 0},
@@ -196,6 +324,18 @@ restore_defaults(void)
 #endif
 
 
+#ifdef CONFIG_WLHDD
+	struct nvram_tuple wlhdd[] = {
+		{ "lan_ifname", "br0", 0 },
+		{ "lan_ifnames", "eth2", 0 },
+		{ "wan_ifname", "eth1", 0 },
+		{ "wan_ifnames", "eth1", 0 },
+		{ "wan_nat_x", "0", 0},
+		{ "wan_route_x", "IP_Bridged", 0},
+		{ 0, 0, 0 }
+	};
+#endif
+
 #ifdef CONFIG_SENTRY5
 #include "rcs5.h"
 #else
@@ -266,6 +406,11 @@ restore_defaults(void)
 		}
 		else
 			ap = 1;
+		
+		/* if vlans enabled -- enable router mode */
+		if ((strtoul(nvram_safe_get("boardflags"), 
+			NULL, 0) & BFL_ENETVLAN) != 0) dyna[4].name = NULL;
+
 		linux_overrides = dyna;
 	}
 	/* override lan i/f name list and wan i/f name list with default values */
@@ -292,6 +437,14 @@ canned_config:
 #ifdef CONFIG_WL331G
 	linux_overrides = wl331g;
 #endif
+
+#ifdef CONFIG_WLHDD
+	linux_overrides = wlhdd;
+#endif
+
+	if (nvram_match("boardtype", "bcm95365r"))
+		linux_overrides = vlan;
+	
 	/* Restore defaults */
 	for (t = router_defaults; t->name; t++) {
 		if (restore_defaults || !nvram_get(t->name)) {
@@ -357,6 +510,56 @@ set_wan0_vars(void)
 		nvram_set(strcat_r(prefix, "desc", tmp), "Default Connection");
 		nvram_set(strcat_r(prefix, "primary", tmp), "1");
 	}
+	/* reconfigure wan0 for client mode */
+	if (nvram_invmatch("wl_mode_ex", "ap")) {
+		nvram_set("wan0_ifname", nvram_safe_get("wl0_ifname"));
+		nvram_set("wan0_ifnames", nvram_safe_get("wl0_ifname"));
+	} else {
+		nvram_set("wan0_ifname", nvram_get("wan_ifname"));
+		nvram_set("wan0_ifnames", nvram_get("wan_ifnames"));
+	}
+}
+
+/*
+ * create /etc/passwd and /etc/group files
+ */
+ 
+static void 
+make_etc(void)
+{
+	FILE *f;
+	char *name, *pass;
+	
+	/* crypt using md5, no salt */
+	name = nvram_get("http_username") ? : "admin";
+	pass = crypt(nvram_get("http_passwd") ? : "admin", "$1$");
+	
+	if ((f = fopen("/etc/passwd", "w"))) {
+		fprintf(f, "%s:%s:0:0:root:/usr/local/root:/bin/sh\n"
+			"nobody:x:99:99:nobody:/:/sbin/nologin\n", name, pass);
+		fclose(f);
+	}
+	
+	if ((f = fopen("/etc/group", "w"))) {
+		fprintf(f, "root:x:0:%s\nnobody:x:99:\n", name);
+		fclose(f);
+	}
+	
+	/* uClibc TZ */
+	if ((f = fopen("/etc/TZ", "w"))) {
+		fprintf(f, "%s\n", nvram_safe_get("time_zone"));
+		fclose(f);
+	}
+	
+	/* /etc/resolv.conf compatibility */
+	symlink("/tmp/resolv.conf", "/etc/resolv.conf");
+	
+	/* hostname */
+	if ((f = fopen("/proc/sys/kernel/hostname", "w"))) {
+		fputs(nvram_safe_get("lan_hostname"), f);
+		fclose(f);
+	}
+
 }
 
 static int noconsole = 0;
@@ -367,7 +570,11 @@ sysinit(void)
 	char buf[PATH_MAX];
 	struct utsname name;
 	struct stat tmp_stat;
-	time_t tm = 0;
+	
+	time_t now;
+	struct tm gm, local;
+	struct timezone tz;
+	struct timeval tv = { 0 };
 
 	/* /proc */
 	mount("proc", "/proc", "proc", MS_MGC_VAL, NULL);
@@ -381,13 +588,24 @@ sysinit(void)
 	mkdir("/var/log", 0777);
 	mkdir("/var/run", 0777);
 	mkdir("/var/tmp", 0777);
+	
+	/* /usr/local */
+	mkdir("/tmp/local", 0755);
+	mkdir("/tmp/local/root", 0700);
+	
+	/* /etc contents */
+	eval("cp", "-dpR", "/usr/etc", "/tmp");
 
+	/* create /etc/{passwd,group,TZ} */
+	make_etc();
+	
 	/* Setup console */
 	if (console_init())
 		noconsole = 1;
 
-	// for debug 
-	//nvram_set("console_loglevel", "0");
+	/* load flashfs */
+	if (!eval("flashfs", "start"))
+		eval("/usr/local/sbin/pre-boot");
 
 	klogctl(8, NULL, atoi(nvram_safe_get("console_loglevel")));
 
@@ -397,26 +615,31 @@ sysinit(void)
 	if (stat("/proc/modules", &tmp_stat) == 0 &&
 	    stat(buf, &tmp_stat) == 0) {
 		char module[80], *modules, *next;
-#ifdef WL500GX
-		modules = nvram_get("kernel_mods") ? : "et robo il wl";
+#if defined(CONFIG_WLHDD) || defined(CONFIG_WL700G)
+		modules = nvram_get("kernel_mods") ? : "ide-mod ide-probe-mod ide-disk et wl";
 #else
-		modules = nvram_get("kernel_mods") ? : "et il wl";
+		modules = nvram_get("kernel_mods") ? : "et wl";
 #endif
 		foreach(module, modules, next)
 			eval("insmod", module);
 	}
 
-#ifdef ASUS_EXT
-	//eval("insmod", "/lib/modules/2.4.20/splink_led.o");
-	//eval("mknod", "/dev/led0", "c", "244", "0");
-	//eval("mknod", "/dev/led1", "c", "244", "1");
-	//eval("mknod", "/dev/led2", "c", "244", "2");
-	//eval("mknod", "/dev/led3", "c", "244", "3");
-	//eval("mknod", "/dev/led4", "c", "244", "4");
-#endif
+	/* Update kernel timezone and time */
+	setenv("TZ", nvram_safe_get("time_zone"), 1);
+	time(&now);
+	gmtime_r(&now, &gm);
+	localtime_r(&now, &local);
+	tz.tz_minuteswest = (mktime(&gm) - mktime(&local)) / 60;
+	settimeofday(&tv, &tz);
 
-	/* Set a sane date */
-	stime(&tm);
+#if defined(CONFIG_WLHDD)
+	eval("insmod", "gpiortc", "sda_mask=0x10", "scl_mask=0x20");
+#elif defined(CONFIG_WL700G)
+	eval("insmod", "gpiortc", "sda_mask=0x04", "scl_mask=0x20");
+#endif
+	
+	if (exists("/dev/misc/rtc"))
+		eval("/sbin/hwclock", "-s");
 
 	dprintf("done\n");
 }
@@ -514,6 +737,9 @@ main_loop(void)
 	pid_t shell_pid = 0;
 	uint boardflags;
 
+	/* Convert vital config before loading modules */
+	early_defaults();
+
 	/* Basic initialization */
 	sysinit();
 
@@ -531,18 +757,9 @@ main_loop(void)
 	if (!noconsole)
 		run_shell(1, 0);
 
-#ifdef WL500GX
-	if (!nvram_match("restore_defaults", "0"))
-	{
-		nvram_set("vlan_enable", "1");
-		restore_defaults();
-		set_wan0_vars();
-		RC1_START();
-	}
-#endif
-
 	/* Add vlan */
-	boardflags = strtoul(nvram_safe_get("boardflags"), NULL, 0);
+	boardflags = nvram_match("boardtype", "bcm95365r") ? BFL_ENETVLAN :
+		strtoul(nvram_safe_get("boardflags"), NULL, 0);
 
 	/* Add loopback */
 	config_loopback();
@@ -559,8 +776,7 @@ main_loop(void)
 
 	/* Setup wan0 variables if necessary */
 	set_wan0_vars();
-
-
+	
 	/* Loop forever */
 	for (;;) {
 		switch (state) {
@@ -582,12 +798,8 @@ main_loop(void)
 			stop_wan();
 			stop_lan();
 
-#ifndef WL500GX
 			if (boardflags & BFL_ENETVLAN)
 				stop_vlan();
-#else
-			RC1_STOP();
-#endif
 
 			if (state == STOP) {
 				state = IDLE;
@@ -597,12 +809,8 @@ main_loop(void)
 		case START:
 			dprintf("START\n");
 
-#ifndef WL500GX
 			if (boardflags & BFL_ENETVLAN)
 				start_vlan();
-#else
-			RC1_START();
-#endif
 
 			start_lan();
 			//if (restore_defaults_g) 
@@ -615,6 +823,9 @@ main_loop(void)
 
 #ifdef ASUS_EXT
 			start_misc();
+#endif
+			eval("/usr/local/sbin/post-boot");
+#ifdef ASUS_EXT
 			sleep(5);
 			diag_PaN();
 #endif
@@ -711,6 +922,16 @@ main(int argc, char **argv)
 		}
 	}
 
+	/* flash [path] [device] */
+	else if (strstr(base, "flash")) {
+		if (argc >= 3)
+			return mtd_flash(argv[1], argv[2]);
+		else {
+			fprintf(stderr, "usage: flash [path] [device]\n");
+			return EINVAL;
+		}
+	}
+
 	/* hotplug [event] */
 	else if (strstr(base, "hotplug")) {
 		if (argc >= 2) {
@@ -842,7 +1063,13 @@ main(int argc, char **argv)
 			fprintf(stderr, "usage: rc [start|stop|restart]\n");
 			return EINVAL;
 		}
+	} else if (strstr(base, "halt")) {
+		kill(1, SIGQUIT);
+	} else if (strstr(base, "reboot")) {
+		kill(1, SIGTERM);
+	} else if (strstr(base, "poweron")) {
+		return poweron_main(argc, argv);
 	}
-
+	
 	return EINVAL;
 }
diff -BurpN -x'*.o' router/rc/rc.h gateway/rc/rc.h
--- router/rc/rc.h	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/rc.h	2008-12-28 11:59:11.000000000 +0300
@@ -22,61 +22,108 @@
 
 #define sin_addr(s) (((struct sockaddr_in *)(s))->sin_addr)
 
+/* common */
+in_addr_t inet_addr_(const char *cp);
+char *trim_r(char *str);
+void logmessage(char *logheader, char *fmt, ...);
+void wanmessage(char *fmt, ...);
+int kill_pidfile_s(char *pidfile, int sig);
+void update_lan_status(int isup);
+void update_wan_status(int isup);
+char *pppstatus(char *buf);
+void convert_asus_values();
+char *mac_conv(char *mac_name, int idx, char *buf);
+
+/* dns */
+void dns_query(char *svrip, char *hostname, char qtype, char *ret);
+
 /* udhcpc scripts */
-extern int udhcpc_main(int argc, char **argv);
+int udhcpc_main(int argc, char **argv);
 
 /* ppp scripts */
-extern int ipup_main(int argc, char **argv);
-extern int ipdown_main(int argc, char **argv);
-extern int ppp_ifunit(char *ifname);
+int ipup_main(int argc, char **argv);
+int ipdown_main(int argc, char **argv);
+int ppp_ifunit(char *ifname);
 
 /* http functions */
-extern int http_get(const char *server, char *buf, size_t count, off_t offset);
-extern int http_post(const char *server, char *buf, size_t count);
-extern int http_stats(const char *url);
+int http_get(const char *server, char *buf, size_t count, off_t offset);
+int http_post(const char *server, char *buf, size_t count);
+int http_stats(const char *url);
+int http_check(const char *server, char *buf, size_t count, off_t offset);
 
 /* init */
-extern int console_init(void);
-extern pid_t run_shell(int timeout, int nowait);
-extern void signal_init(void);
-extern void fatal_signal(int sig);
+int console_init(void);
+pid_t run_shell(int timeout, int nowait);
+void signal_init(void);
+void fatal_signal(int sig);
 
 /* interface */
-extern int ifconfig(char *ifname, int flags, char *addr, char *netmask);
-extern int route_add(char *name, int metric, char *dst, char *gateway, char *genmask);
-extern int route_del(char *name, int metric, char *dst, char *gateway, char *genmask);
-extern void config_loopback(void);
-extern int config_vlan(void);
+int ifconfig(char *ifname, int flags, char *addr, char *netmask);
+int route_add(char *name, int metric, char *dst, char *gateway, char *genmask);
+int route_del(char *name, int metric, char *dst, char *gateway, char *genmask);
+void config_loopback(void);
+int config_vlan(void);
+int start_vlan(void);
+int stop_vlan(void);
 
 /* network */
-extern void start_lan(void);
-extern void stop_lan(void);
-extern void start_wan(void);
-extern void stop_wan(void);
-extern void wan_up(char *ifname);
-extern void wan_down(char *ifname);
-extern int hotplug_net(void);
-extern int wan_ifunit(char *ifname);
-extern int wan_primary_ifunit(void);
+void start_lan(void);
+void stop_lan(void);
+void start_wan(void);
+void stop_wan(void);
+void wan_up(char *ifname);
+void wan_down(char *ifname);
+void lan_up_ex(char *lan_ifname);
+void lan_down_ex(char *lan_ifname);
+int hotplug_net(void);
+int wan_ifunit(char *ifname);
+int wan_primary_ifunit(void);
+int start_bpalogin(void);
+int stop_bpalogin(void);
+void start_qos(char *wan_ipaddr);
+void setup_ethernet(char *wan_if);
 
 /* services */
-extern int start_dhcpd(void);
-extern int stop_dhcpd(void);
-extern int start_dns(void);
-extern int stop_dns(void);
-extern int start_ntpc(void);
-extern int stop_ntpc(void);
-extern int start_nas(char *type);
-extern int stop_nas(void);
-extern int start_services(void);
-extern int stop_services(void);
+int start_httpd(void);
+int start_dhcpd(void);
+int stop_dhcpd(void);
+int stop_snmpd(void);
+int start_dns(void);
+int stop_dns(void);
+int start_upnp(void);
+int stop_upnp(void);
+int start_ddns(void);
+int stop_ddns(void);
+int start_ntpc(void);
+int stop_ntpc(void);
+int start_nas(char *type);
+int stop_nas(void);
+int start_usb(void);
+int stop_usb(void);
+int start_rcamd(void);
+int stop_rcamd(void);
+int start_audio(void);
+int stop_audio(void);
+int start_services(void);
+int stop_services(void);
+int start_logger(void);
+int stop_logger(void);
+int start_misc(void);
+int stop_misc(void);
+int hotplug_usb(void);
+int hotplug_usb_mass(char *product);
+int hotplug_usb_webcam(char *product, int webflag);
+int hotplug_usb_audio(char *product);
+int service_handle(void);
+int mkdir_if_none(char *dir);
 
 /* firewall */
 #ifdef __CONFIG_NETCONF__
-extern int start_firewall(void);
-extern int stop_firewall(void);
-extern int start_firewall2(char *ifname);
-extern int stop_firewall2(char *ifname);
+int start_firewall(void);
+int stop_firewall(void);
+int start_firewall2(char *ifname);
+int stop_firewall2(char *ifname);
+int start_firewall_ex(char *wan_if, char *wan_ip, char *lan_if, char *lan_ip);
 #else
 #define start_firewall() do {} while (0)
 #define stop_firewall() do {} while (0)
@@ -85,6 +132,6 @@ extern int stop_firewall2(char *ifname);
 #endif
 
 /* routes */
-extern int preset_wan_routes(char *ifname);
+int preset_wan_routes(char *ifname);
 
 #endif /* _rc_h_ */
diff -BurpN -x'*.o' router/rc/sendalarm.c gateway/rc/sendalarm.c
--- router/rc/sendalarm.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/sendalarm.c	2008-03-19 20:07:24.000000000 +0300
@@ -130,7 +130,9 @@ sendalarm_main(int argc, char *argv[])
 			if (!(imagebase=rindex(image, '/'))) imagebase = image;
 			else imagebase++;
 			
-			eval("uuencode", "-m", image, imagebase, "-f", "/var/tmp/uuencode");
+			//eval("uuencode", "-m", image, imagebase, "-f", "/var/tmp/uuencode");
+			sprintf(command, "uuencode -m %s %s > /var/tmp/uuencode", image, imagebase);
+			system(command);
 			
 			fprintf(fp, "--%s\n", boundry);
 			fprintf(fp, "Content-Type: application/unknown\n");
diff -BurpN -x'*.o' router/rc/services.c gateway/rc/services.c
--- router/rc/services.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/services.c	2008-03-19 20:07:24.000000000 +0300
@@ -18,6 +18,7 @@
 #include <signal.h>
 #include <unistd.h>
 #include <errno.h>
+#include <sys/stat.h>
 
 #include <bcmnvram.h>
 #include <netconf.h>
@@ -142,6 +143,74 @@ stop_dns(void)
 #endif
 
 int
+start_telnetd(void)
+{
+	int ret;
+	
+	/* telnet is enabled by default */
+	if (nvram_invmatch("telnet_enable", "1"))
+		return 0;
+
+	char *argv[] = {"telnetd", NULL};
+	pid_t pid;
+
+	ret = _eval(argv, NULL, 0, &pid);
+
+	dprintf("done\n");
+	return ret;
+}
+
+int
+stop_telnetd(void)
+{
+	int ret = eval("killall", "telnetd");
+
+	dprintf("done\n");
+	return ret;
+}
+
+
+int
+start_snmpd(void)
+{
+	static char *snmpd_conf = "/tmp/snmpd.conf";
+	
+	int ret;
+	FILE *fp;
+	
+	if (!nvram_match("snmp_enable", "1"))
+		return 0;
+		
+	/* create snmpd.conf  */
+	if ((fp = fopen(snmpd_conf, "w")) == NULL) {
+		perror(snmpd_conf);
+		return 1;
+	}
+
+	fprintf(fp, "# automagically generated from web settings\n");
+
+	fprintf(fp, "community %s\n", nvram_get("snmp_community") ? : "public");
+	fprintf(fp, "syscontact %s\n", nvram_get("snmp_contact") ? : "Administrator");
+	fprintf(fp, "syslocation %s\n", nvram_get("snmp_location") ? : "Unknown");
+
+	fclose(fp);
+	
+	ret = eval("snmpd", "-c", snmpd_conf);
+
+	dprintf("done\n");
+	return ret;
+}
+
+int
+stop_snmpd(void)
+{
+	int ret = eval("killall", "snmpd");
+
+	dprintf("done\n");
+	return ret;
+}
+
+int
 start_httpd(void)
 {
 	int ret;
@@ -172,7 +241,7 @@ stop_httpd(void)
 int
 start_upnp(void)
 {
-	char *wan_ifname;
+	char *wan_ifname, *wan_proto;
 	int ret;
 	char var[100], prefix[] = "wanXXXXXXXXXX_";
 
@@ -182,7 +251,9 @@ start_upnp(void)
 	ret = eval("killall", "-SIGUSR1", "upnp");
 	if (ret != 0) {
 	    snprintf(prefix, sizeof(prefix), "wan%d_", wan_primary_ifunit());
-	    wan_ifname = nvram_match(strcat_r(prefix, "proto", var), "pppoe") ? 
+	    wan_proto = nvram_safe_get(strcat_r(prefix, "proto", var));
+	    wan_ifname = nvram_match("upnp_enable", "1") && (strcmp(wan_proto, "pppoe") == 0 || 
+	    	strcmp(wan_proto, "pptp") ==0 || strcmp(wan_proto, "l2tp") == 0) ? 
 					nvram_safe_get(strcat_r(prefix, "pppoe_ifname", var)) :
 					nvram_safe_get(strcat_r(prefix, "ifname", var));
 	    ret = eval("upnp", "-D",
@@ -246,7 +317,7 @@ start_ntpc(void)
 	char *servers = nvram_safe_get("ntp_server");
 	
 	if (strlen(servers)) {
-		char *nas_argv[] = {"ntpclient", "-h", servers, "-i", "3", "-l", "-s", NULL};
+		char *nas_argv[] = {"ntpclient", "-h", servers, "-i", "3", "-c", "1", "-l", "-s", NULL};
 		_eval(nas_argv, NULL, 0, NULL);
 	}
 	
@@ -271,12 +342,14 @@ stop_ntpc(void)
 int
 start_services(void)
 {
+	start_telnetd();
 	start_httpd();
 	start_dns();
 	start_dhcpd();
 #ifdef ASUS_EXT
 	start_logger();
 #endif
+	start_snmpd();
 	start_upnp();
 	start_nas("lan");
 
@@ -296,12 +369,14 @@ stop_services(void)
 #endif
 	stop_nas();
 	stop_upnp();
+	stop_snmpd();
 #ifdef ASUS_EXT
 	stop_logger();
 #endif
 	stop_dhcpd();
 	stop_dns();
 	stop_httpd();
+	stop_telnetd();
 
 	dprintf("done\n");
 	return 0;
diff -BurpN -x'*.o' router/rc/services_ex.c gateway/rc/services_ex.c
--- router/rc/services_ex.c	2004-11-21 17:45:24.000000000 +0300
+++ gateway/rc/services_ex.c	2008-12-28 11:47:40.000000000 +0300
@@ -10,6 +10,9 @@
  * $Id$
  */
 
+#define DNSMASQ
+#define DDNSCONF
+
 #ifdef ASUS_EXT
 #include <stdio.h>
 #include <stdlib.h>
@@ -25,6 +28,13 @@
 #include <shutils.h>
 #include <rc.h>
 #include <syslog.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#if defined(__UCLIBC__)
+#include <crypt.h>
+#endif
+#include <mntent.h>
 #include "iboxcom.h"
 #include "lp.h"
 
@@ -137,6 +147,28 @@ void diag_PaN(void)
    fprintf(stderr, "echo for PaN ::: &&&PaN\r\n");
 }
 
+#if defined(DNSMASQ) || defined(DDNSCONF)
+size_t
+fappend(char *name, FILE *f)
+{
+	size_t size = 0, count;
+	
+	FILE *fp = fopen(name, "r");
+
+	if (fp != NULL) {
+		char buf[4096];
+		
+		while ((count = fread(buf, 1, sizeof(buf), fp)) > 0)
+			size += fwrite(buf, 1, count, f);
+	
+		fclose(fp);
+	}
+	
+	return size;
+}
+#endif
+
+#ifndef DNSMASQ
 int
 start_dhcpd(void)
 {
@@ -343,6 +375,165 @@ stop_dns(void)
 	return ret;
 }
 
+#else
+
+int
+start_dns(void)
+{
+	FILE *fp;
+	char *argv[] = {"dnsmasq", NULL};
+	pid_t pid;
+
+	size_t ethers = 0;
+	
+	int ret;
+
+	/* Create resolv.conf with empty nameserver list */
+	if (!(fp = fopen("/tmp/resolv.conf", "a"))) {
+		perror("/tmp/resolv.conf");
+		return errno;
+	}
+
+	// if user want to set dns server by himself
+	if (nvram_invmatch("wan_dnsenable_x", "1"))	
+	{
+		/* Write resolv.conf with upstream nameservers */
+		if (nvram_invmatch("wan_dns1_x",""))
+			fprintf(fp, "nameserver %s\n", nvram_safe_get("wan_dns1_x"));		
+		if (nvram_invmatch("wan_dns2_x",""))
+			fprintf(fp, "nameserver %s\n", nvram_safe_get("wan_dns2_x"));
+	}
+
+	fclose(fp);
+
+	/* create /etc/hosts */
+	if (!(fp = fopen("/etc/hosts", "a"))) {
+		perror("/etc/hosts");
+		return errno;
+	}
+
+	fprintf(fp, "127.0.0.1 localhost.localdomain localhost\n");
+	fprintf(fp, "%s %s my.router my.%s\n", nvram_safe_get("lan_ipaddr"),
+			nvram_safe_get("lan_hostname"), nvram_safe_get("productid"));
+
+	if (nvram_match("dhcp_static_x","1"))
+	{	
+		int i;
+		char ip[32], name[32];
+		for (i = 0; i < atoi(nvram_safe_get("dhcp_staticnum_x")); i++) 
+		{
+			sprintf(ip, "dhcp_staticip_x%d", i);
+			sprintf(name, "dhcp_staticname_x%d", i);
+
+			if (inet_addr_(nvram_safe_get(ip)) != INADDR_ANY && 
+				nvram_invmatch(name, "")) 
+			{
+				fprintf(fp, "%s %s\n", nvram_get(ip), nvram_get(name));
+			}
+		}
+	}
+	
+	fappend("/usr/local/etc/hosts", fp);
+	fclose(fp);
+
+	if (nvram_match("router_disable", "1"))
+		return 0;
+
+	/* create /etc/ethers */
+	if (!(fp = fopen("/etc/ethers", "w"))) {
+		perror("/etc/ethers");
+	} else {
+		if (nvram_match("dhcp_static_x","1"))
+		{	
+			int i;
+			char buf[32], *mac;
+			for (i = 0; i < atoi(nvram_safe_get("dhcp_staticnum_x")); i++) 
+			{
+				sprintf(buf, "dhcp_staticmac_x%d", i);
+				
+				if (strlen(mac = nvram_safe_get(buf)) == 12) {
+					sprintf(buf, "dhcp_staticip_x%d", i);
+					ethers += fprintf(fp, "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c %s\n", 
+						mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], 
+						mac[6], mac[7], mac[8], mac[9], mac[10], mac[11],
+						nvram_safe_get(buf));
+				}
+				
+			}
+		}
+	
+		ethers += fappend("/usr/local/etc/ethers", fp);
+		fclose(fp);
+	}
+
+	/* start playing with conf file */
+	if (!(fp = fopen("/etc/dnsmasq.conf", "w"))) {
+		perror("/etc/dnsmasq.conf");
+		return errno;
+	}
+
+	fprintf(fp, "user=nobody\n");
+	fprintf(fp, "resolv-file=/tmp/resolv.conf\nno-poll\n");
+	fprintf(fp, "interface=%s\n", nvram_safe_get("lan_ifname"));
+
+	if (nvram_invmatch("lan_domain", "")) {
+		fprintf(fp, "domain=%s\n", nvram_safe_get("lan_domain"));
+		fprintf(fp, "expand-hosts\n");
+	}
+	
+	fprintf(fp, "no-negcache\n");
+	
+	if (nvram_match("lan_proto", "dhcp")) {
+		fprintf(fp, "dhcp-leasefile=/tmp/dnsmasq.log\n");
+		fprintf(fp, "dhcp-range=lan,%s,%s,%s\n", nvram_safe_get("dhcp_start"), 
+			nvram_safe_get("dhcp_end"), nvram_safe_get("dhcp_lease"));
+
+		if (nvram_invmatch("dhcp_dns1_x",""))
+			fprintf(fp, "dhcp-option=lan,6,%s,0.0.0.0\n", nvram_safe_get("dhcp_dns1_x"));
+		if (nvram_invmatch("dhcp_wins_x",""))		
+			fprintf(fp, "dhcp-option=lan,44,%s\n", nvram_safe_get("dhcp_wins_x"));		
+		if (nvram_invmatch("lan_domain", ""))
+			fprintf(fp, "dhcp-option=lan,15,%s\n", nvram_safe_get("lan_domain"));
+		if (nvram_invmatch("dhcp_gateway_x",""))
+			fprintf(fp, "dhcp-option=lan,3,%s\n", nvram_safe_get("dhcp_gateway_x"));
+			
+		if (ethers)
+			fprintf(fp, "read-ethers\n");
+			
+		fprintf(fp, "dhcp-authoritative\n");
+	}
+	
+	fappend("/usr/local/etc/dnsmasq.conf", fp);
+	fclose(fp);
+
+	/* launch it */		
+	ret = _eval(argv, NULL, 0, &pid);
+
+	dprintf("done\n");
+	return ret;
+}	
+
+int
+stop_dns(void)
+{
+	int ret = eval("killall", "dnsmasq");
+
+	dprintf("done\n");
+	return ret;
+}
+
+int start_dhcpd(void)
+{
+	return 0;
+}
+
+int stop_dhcpd(void)
+{
+	return 0;
+}
+
+#endif // DNSMASQ
+
 int
 ddns_updated_main(int argc, char *argv[])
 {
@@ -373,7 +564,7 @@ int 
 start_ddns(void)
 {
 	FILE *fp;
-	char buf[64];
+//	char buf[64];
 	char *wan_ip, *ddns_cache;
 	char server[32];
 	char user[32];
@@ -422,9 +613,9 @@ start_ddns(void)
 	if (strcmp(server, "WWW.DYNDNS.ORG")==0)
 		strcpy(service, "dyndns");			
 	else if (strcmp(server, "WWW.DYNDNS.ORG(CUSTOM)")==0)
-		strcpy(service, "dyndns");			
+		strcpy(service, "dyndns-custom");			
 	else if (strcmp(server, "WWW.DYNDNS.ORG(STATIC)")==0)
-		strcpy(service, "dyndns");			
+		strcpy(service, "dyndns-static");			
 	else if (strcmp(server, "WWW.TZO.COM")==0)
 		strcpy(service, "tzo");			
 	else if (strcmp(server, "WWW.ZONEEDIT.COM")==0)
@@ -437,7 +628,8 @@ start_ddns(void)
 			
 	sprintf(usrstr, "%s:%s", user, passwd);
 	
-	if (nvram_match("wan_proto", "pppoe") || nvram_match("wan_proto", "pptp"))
+	if (nvram_match("wan_proto", "pppoe") || nvram_match("wan_proto", "pptp") ||
+		nvram_match("wan_proto", "l2tp"))
 	{
 		strcpy(wan_ifname, nvram_safe_get("wan0_pppoe_ifname"));
 	}
@@ -448,16 +640,33 @@ start_ddns(void)
 
 	dprintf("wan_ifname: %s\n\n\n\n", wan_ifname);
 
+#ifdef DDNSCONF
+	if (!(fp = fopen("/etc/ddns.conf", "w"))) {
+		perror("/etc/ddns.conf");
+		return errno;
+	}
+	fprintf(fp, "service-type=%s\n", service);
+	fprintf(fp, "interface=%s\n", wan_ifname);
+	fprintf(fp, "user=%s\n", usrstr);
+	fprintf(fp, "host=%s\n", host);
+	if (wild) fprintf(fp, "wildcard\n");
+	fappend("/usr/local/etc/ddns.conf", fp);
+	fclose(fp);
+#endif
 	if (strlen(service)>0)
 	{
 		char *ddns_argv[] = {"ez-ipupdate", 
+#ifdef DDNSCONF
+		"-c", "/etc/ddns.conf",
+#else
 		"-S", service,
 	        "-i", wan_ifname,
  		"-u", usrstr,
 		"-h", host,
+		wild ? "-w" : NULL,
+#endif
 		"-e", "/sbin/ddns_updated",
 		"-b", "/tmp/ddns.cache",
-		wild ? "-w" : NULL,
 		NULL};	
 		pid_t pid;
 
@@ -486,36 +695,22 @@ start_logger(void)
 {		
 	pid_t pid;
 
+#if 0
 	if (nvram_match("router_disable", "1"))
 		return 0;
-
-	if (nvram_invmatch("log_ipaddr", ""))
-	{
-		char *syslogd_argv[] = {"syslogd", "-m", "0", "-t", nvram_safe_get("time_zone"), "-O", "/tmp/syslog.log", "-R", nvram_safe_get("log_ipaddr"), "-L", NULL};
-#ifdef KERNEL_DBG
-		char *klogd_argv[] = {"klogd", "-d", NULL};
-#else
-		char *klogd_argv[] = {"klogd", NULL};
 #endif
 
-		//while(syslogd_argv[i]) printf("log: %s\n", syslogd_argv[i++]);
-	
-		_eval(syslogd_argv, NULL, 0, &pid);
-		_eval(klogd_argv, NULL, 0, &pid);
-	}
-	else
-	{
-		char *syslogd_argv[] = {"syslogd", "-m", "0", "-t", nvram_safe_get("time_zone"), "-O", "/tmp/syslog.log", NULL};
+	char *syslogd_argv[] = {"syslogd", "-m", "0", "-O", "/tmp/syslog.log", "-S",
+		"-l", "7", "-R", nvram_safe_get("log_ipaddr"), "-L", NULL};
+	char *klogd_argv[] = {"klogd", NULL};
 
-#ifdef KERNEL_DBG
-		char *klogd_argv[] = {"klogd", "-d", NULL};
-#else
-		char *klogd_argv[] = {"klogd", NULL};
-#endif
+	syslogd_argv[7] = nvram_get("log_level_x") ? : "7";
 
-		_eval(syslogd_argv, NULL, 0, &pid);
-		_eval(klogd_argv, NULL, 0, &pid);
-	}
+	if (!*syslogd_argv[9])
+		syslogd_argv[8] = NULL;
+		
+	_eval(syslogd_argv, NULL, 0, &pid);
+	_eval(klogd_argv, NULL, 0, &pid);
 	// remote log not easy to ok
 	sleep(1);
 	return 0;
@@ -538,20 +733,21 @@ start_misc(void)
 	char *watchdog_argv[] = {"watchdog", NULL};
 	pid_t pid;
 	
-	_eval(infosvr_argv, NULL, 0, &pid);
+	if (!nvram_invmatch("infosvr_enable", "1"))
+		_eval(infosvr_argv, NULL, 0, &pid);
 	_eval(watchdog_argv, NULL, 0, &pid);
 
-	/* adjust some special parameters here */
-	/* tx power */
-	if (nvram_invmatch("wl_radio_power_x", "19"))
+	/* try to adjust wifi tx power */
+	if (nvram_invmatch("wl_radio_power_x", ""))
 	{
-		eval("wl", "txpwr", nvram_safe_get("wl_radio_power_x"));
+		eval("wl", "txpwr1", "-m", nvram_safe_get("wl_radio_power_x"), "-o");
 	}
 
-
+#if 1
 	// for all product, fix antdiv
-	eval("wl", "antdiv", "0");
-	eval("wl", "txant", "0");
+	if (eval("wl", "antdiv", "0") == 0)
+		eval("wl", "txant", "0");
+#endif
 
 	return 0;
 }
@@ -583,14 +779,72 @@ int hotplug_usb(void)
 	return 0;
 }
 #else
+
+int start_nfsd(void)
+{
+	struct stat	st_buf;
+	FILE 		*fp;
+
+	/* create directories/files */
+	mkdir("/var/lib", 0755);
+	mkdir("/var/lib/nfs", 0755);
+	close(creat("/var/lib/nfs/etab", 0644));
+	close(creat("/var/lib/nfs/xtab", 0644));
+	close(creat("/var/lib/nfs/rmtab", 0644));
+	
+	/* create /etc/exports, if it does not exists yet */
+	if (stat("/etc/exports", &st_buf) != 0) 
+	{
+		int i, count;
+		char tmp[] = "usb_nfslist_xXXXXX";
+		
+		if ((fp = fopen("/etc/exports", "w")) == NULL) {
+			perror("/etc/exports");
+			return 1;
+		}
+		
+		fprintf(fp, "# automagically generated from web settings\n");
+
+		for (i = 0, count = atoi(nvram_safe_get("usb_nfsnum_x")); i < count; i++) 
+		{
+			sprintf(tmp, "usb_nfslist_x%d", i);
+			if (nvram_safe_get(tmp)[0] == '/')
+				fprintf(fp, "%s\n", nvram_safe_get(tmp));
+			else	fprintf(fp, "/tmp/harddisk/%s\n", nvram_safe_get(tmp));
+		}
+		
+		fclose(fp);
+	}
+
+	eval("/usr/sbin/portmap");
+	eval("/usr/sbin/lockd");
+	eval("/usr/sbin/statd");
+	eval("/usr/sbin/nfsd");
+	eval("/usr/sbin/mountd");
+	eval("/usr/sbin/exportfs", "-a");
+
+	return 0;	
+}
+
+int restart_nfsd(void)
+{
+	eval("/usr/sbin/exportfs", "-au");
+	eval("/usr/sbin/exportfs", "-a");
+
+	return 0;	
+}
+
 int 
 start_usb(void)
 {
 	eval("insmod", "usbcore");
 	eval("insmod", "usb-ohci");
-	eval("insmod", "uhci");
+	eval("insmod", "usb-uhci");
 	eval("insmod", "ehci-hcd");
 
+	/* mount usbfs */
+	mount("usbfs", "/proc/bus/usb", "usbfs", MS_MGC_VAL, NULL);
+
 #ifdef PRINTER_SUPPORT
 #ifdef PARPORT_SUPPORT	
 	symlink("/dev/printers/0", "/dev/lp0");
@@ -602,7 +856,7 @@ start_usb(void)
 	eval("insmod", "printer.o");
 	mkdir("/var/state", 0777);
 	mkdir("/var/state/parport", 0777);
-	mkdir("/var/state/parport/svr_statue", 0777);
+	if (!nvram_invmatch("lpr_enable", "1"))
 	{
 		char *lpd_argv[]={"lpd", NULL};
 		pid_t pid;
@@ -610,11 +864,21 @@ start_usb(void)
 		sleep(1);
 		_eval(lpd_argv, ">/dev/null", 0, &pid);	
 	}
+	if (!nvram_invmatch("raw_enable", "1"))
+	{
+		eval("p910nd", "-f", "/dev/usb/lp0", "0");
+#ifdef PARPORT_SUPPORT	
+		eval("p910nd", "-f", "/dev/printers/0", "1");
+#endif
+	}
 #endif	
+	if (!nvram_invmatch("audio_enable", "1"))
+	{
 #ifdef AUDIO_SUPPORT
-	eval("insmod", "soundcore.o");
-	eval("insmod", "audio.o");
-	start_audio();
+		eval("insmod", "soundcore.o");
+		eval("insmod", "audio.o");
+		start_audio();
+	}
 #endif
 #ifdef WEBCAM_SUPPORT	
 	if (nvram_invmatch("usb_webenable_x", "0"))
@@ -627,23 +891,47 @@ start_usb(void)
 	}
 #endif
 #ifdef MASSSTORAGE_SUPPORT
-	if (nvram_invmatch("usb_ftpenable_x", "0"))
+	mkdir("/tmp/mnt", 0755);
+
+	if (!nvram_match("usb_storage_x", "0"))
 	{
 		eval("insmod", "scsi_mod.o");
 		eval("insmod", "sd_mod.o");
 		eval("insmod", "usb-storage.o");
-		mkdir("/tmp/harddisk", 0444);
 	}	
 #endif
+	if (nvram_match("usb_nfsenable_x", "1"))
+	{	
+		eval("insmod", "sunrpc.o");
+		eval("insmod", "lockd.o");
+		eval("insmod", "nfsd.o");
+		
+		start_nfsd();
+	}
+	return 0;
 }
 
 int
 stop_usb(void)
 {
+	if (nvram_match("usb_nfsenable_x", "1"))
+	{	
+		eval("killall", "mountd");
+		eval("killall", "-9", "nfsd");
+		eval("killall", "-9", "lockd");
+		eval("killall", "portmap");
+		
+		eval("rmmod", "nfsd");
+		eval("rmmod", "lockd");
+		eval("rmmod", "sunrpc");
+	}
+	
 #ifdef MASSSTORAGE_SUPPORT
-	if (nvram_invmatch("usb_ftpenable_x", "0"))
+	if (!nvram_match("usb_storage_x", "0"))
 	{
 		eval("killall", "stupid-fptd");
+		eval("killall", "smbd");
+		eval("killall", "nmbd");
 		eval("rmmod", "usb-storage");
 		eval("rmmod", "sd_mod");
 		eval("rmmod", "scsi_mod");
@@ -670,6 +958,7 @@ stop_usb(void)
 #endif
 #ifdef PRINTER_SUPPORT	
 	eval("killall", "lpd");
+	eval("killall", "p910nd");
 	eval("rmmod", "printer");
 #ifdef PARPORT_SUPPORT
 	eval("rmmod", "lp.o");
@@ -677,9 +966,14 @@ stop_usb(void)
 	eval("rmmod", "parport.o");
 #endif
 #endif	
-	eval("rmmod", "usb-ehci");
+
+	umount("/proc/bus/usb");
+
+	eval("rmmod", "ehci-hcd");
+	eval("rmmod", "usb-uhci");
 	eval("rmmod", "usb-ohci");
 	eval("rmmod", "usbcore");
+	return 0;
 }
 
 void start_script(void)
@@ -706,60 +1000,292 @@ void start_script(void)
 	}	
 }
 
-void start_ftpd()
+/* get full storage path */
+char *nvram_storage_path(char *var)
 {
-	FILE *fp;
-	char *ftpd_argv[] = {"stupid-ftpd", NULL};
-	char user[32], user1[32], password[32], path[32];
-	char tmpstr[32];
-	char rright[128], wright[128], maxuser[16];
-	int snum, unum, i, j;
-	pid_t pid;
+	static char buf[256];
+	char *val = nvram_safe_get(var);
+	int len = sprintf(buf, "%s%s", 
+		val[0] == '/' ? "" : "/tmp/harddisk/", val);
+	
+	if (len > 1 && buf[len - 1] == '/')
+		buf[len - 1] = 0;
 
+	return buf;
+}
 
-	fp=fopen("/tmp/stupid-ftpd.mtd", "w");
-	if (fp==NULL) return;	
-	fprintf(fp, "Welcom to My FTP Site:\n");
-	fclose(fp);
+void restart_ftpd()
+{
+	char vsftpd_users[] = "/etc/vsftpd.users";
+	char vsftpd_passwd[] = "/etc/vsftpd.passwd";
+	int i, count;
+
+	char tmp[256];
+	FILE *fp, *f;
+
+	eval("killall", "vsftpd");
+	
+	mkdir_if_none(vsftpd_users);
+
+	if ((fp = fopen("/etc/vsftpd.conf", "w")) == NULL)
+		return;
+
+	if (nvram_match("usb_ftpsuper_x", "1"))
+	{
+		/* rights */
+		sprintf(tmp, "%s/%s", vsftpd_users,
+			nvram_get("http_username") ? : "admin");
+		if ((f = fopen(tmp, "w")))
+		{
+			fprintf(f, 
+				"dirlist_enable=yes\n"
+				"write_enable=yes\n"
+				"download_enable=yes\n");
+			fclose(f);
+		}
+	}
+
+	if (nvram_invmatch("usb_ftpanonymous_x", "0"))
+	{
+		fprintf(fp, 
+			"anon_allow_writable_root=yes\n"
+			"anon_world_readable_only=no\n"
+			"anon_umask=022\n");
 		
-	fp=fopen("/tmp/stupid-ftpd.bye", "w");
-	if (fp==NULL) return;	
-	fprintf(fp, "Thanks for your coming. Byte Byte!!\n");
+		/* rights */
+		sprintf(tmp, "%s/ftp", vsftpd_users);
+		if ((f = fopen(tmp, "w")))
+		{
+			if (nvram_match("usb_ftpdirlist_x", "0"))
+				fprintf(f, "dirlist_enable=yes\n");
+			if (nvram_match("usb_ftpanonymous_x", "1") || 
+			    nvram_match("usb_ftpanonymous_x", "3"))
+				fprintf(f, "write_enable=yes\n");
+			if (nvram_match("usb_ftpanonymous_x", "1") || 
+			    nvram_match("usb_ftpanonymous_x", "2"))
+				fprintf(f, "download_enable=yes\n");
+			fclose(f);
+		}
+		if (nvram_match("usb_ftpanonymous_x", "1") || 
+		    nvram_match("usb_ftpanonymous_x", "3"))
+			fprintf(fp, 
+				"anon_upload_enable=yes\n"
+				"anon_mkdir_write_enable=yes\n"
+				"anon_other_write_enable=yes\n");
+	} else {
+		fprintf(fp, "anonymous_enable=no\n");
+	}
+	
+	fprintf(fp,
+		"dirmessage_enable=yes\n"
+		"download_enable=no\n"
+		"dirlist_enable=no\n"
+		"hide_ids=yes\n"
+		"syslog_enable=yes\n"
+		"local_enable=yes\n"
+		"local_umask=022\n"
+		"chmod_enable=no\n"
+		"chroot_local_user=yes\n"
+		"check_shell=no\n"
+		"user_config_dir=%s\n"
+		"passwd_file=%s\n",
+		vsftpd_users, vsftpd_passwd);
+
+	fprintf(fp, "listen=yes\nlisten_port=%s\nbackground=yes\n", 
+		nvram_get("usb_ftpport_x") ? : "21");
+	fprintf(fp, "max_clients=%s\n", nvram_get("usb_ftpmax_x") ? : "0");	
+
+	/* fprintf(fp, "login-timeout=%s\n", nvram_safe_get("usb_ftptimeout_x")); */
+	fprintf(fp, "idle_session_timeout=%s\n", nvram_get("usb_ftpstaytimeout_x") ? : "300");
+
+	if (nvram_match("usb_smbcset_x", "utf8"))
+		fprintf(fp, "utf8=yes\n");
+
+	/* ntfs does not support sendfile at the moment */
+	fprintf(fp, "use_sendfile=no\n");
+
+	/* bandwidth */
+	fprintf(fp, "anon_max_rate=%d\nlocal_max_rate=%d\n",
+		atoi(nvram_safe_get("usb_ftpanonrate_x")) * 1024,
+		atoi(nvram_safe_get("usb_ftprate_x")) * 1024);		
+	
 	fclose(fp);
+	
+	/* prepare passwd file and default users */
+	if ((fp = fopen(vsftpd_passwd, "w")) == NULL)
+		return;
+
+	fprintf(fp, /* anonymous, admin, nobody */
+		"ftp:x:0:0:ftp:%s:/sbin/nologin\n"
+		"%s:%s:0:0:root:/tmp/mnt/:/sbin/nologin\n"
+		"nobody:x:99:99:nobody:/usr/share/empty:/sbin/nologin\n",
+		nvram_storage_path("usb_ftpanonroot_x"), 
+		nvram_get("http_username") ? : "admin",
+		nvram_match("usb_ftpsuper_x", "1") ? 
+			crypt(nvram_get("http_passwd") ? : "admin", "$1$") : "x");
+
+	for (i = 0, count = atoi(nvram_safe_get("usb_ftpnum_x")); i < count; i++) 
+	{
+		char *user = (sprintf(tmp, "usb_ftpusername_x%d", i), nvram_get(tmp));
+		char *pass = (sprintf(tmp, "usb_ftppasswd_x%d", i), nvram_get(tmp));
+		char *rights = (sprintf(tmp, "usb_ftprights_x%d", i), nvram_get(tmp));
+		
+		if (user && pass && rights)
+		{
+			/* directory */
+			if (strncmp(rights, "Private", 7) == 0)
+			{
+				sprintf(tmp, "%s/%s", nvram_storage_path("usb_ftppvtroot_x"), user);
+				mkdir_if_none(tmp);
+			}
+			else	sprintf(tmp, "%s", nvram_storage_path("usb_ftppubroot_x"));
 
-	fp=fopen("/tmp/stupid-ftpd.conf", "w");
-	if (fp==NULL) return;
+
+			fprintf(fp, "%s:%s:0:0:%s:%s:/sbin/nologin\n",
+				user, crypt(pass, "$1$"), user, tmp);
+
+			/* rights */
+			sprintf(tmp, "%s/%s", vsftpd_users, user);
+			if ((f = fopen(tmp, "w")))
+			{
+				if (nvram_invmatch("usb_ftpdirlist_x", "1"))
+					strcpy(tmp, "dirlist_enable=yes\n");
+				if (strstr(rights, "Read") || !strcmp(rights, "Private"))
+					strcat(tmp, "download_enable=yes\n");
+				if (strstr(rights, "Write") || !strncmp(rights, "Private", 7))
+					strcat(tmp, "write_enable=yes\n");
+					
+				fputs(tmp, f);
+				fclose(f);
+			}
+		}
+	}
 	
-	fprintf(fp, "mode=daemon\n");
-	fprintf(fp, "serverroot=/tmp/harddisk\n");
-	fprintf(fp, "changeroottype=real\n");
-
-	fprintf(fp, "motd=/tmp/stupid-ftpd.motd\n");
-	fprintf(fp, "byemsg=/tmp/stupid-ftpd.bye\n");
-	fprintf(fp, "banmsg=You have no permission\n");
-	fprintf(fp, "log=/tmp/stupid-ftpd.log\n");
-	fprintf(fp, "port=%s\n", nvram_safe_get("usb_ftpport_x"));
-	fprintf(fp, "maxusers=%s\n", nvram_safe_get("usb_ftpmax_x"));	
-	fprintf(fp, "login-timeout=%s\n", nvram_safe_get("usb_ftptimeout_x"));
-	fprintf(fp, "timeout=%s\n", nvram_safe_get("usb_ftpstaytimeout_x"));
+	fclose(fp);
+	
+	eval("/usr/sbin/vsftpd");
+}
 
+void restart_smbd()
+{
+	FILE *fp;
+	DIR *dir = NULL;
+	struct dirent *dp;
+	
+	kill_pidfile("/var/lock/nmbd.pid");
+	if (!kill_pidfile("/var/lock/smbd.pid"))
+		sleep(2);	/* wait for smbd to finish */
+
+	if ((fp = fopen("/etc/smb.conf", "w")) == NULL) {
+		perror("/etc/smb.conf");
+		return;
+	}
+		
+	fprintf(fp, "[global]\n"
+		"\tinterfaces = %s\n"
+		"\tbind interfaces only = yes\n"
+		"\tworkgroup = %s\n"
+		"\tserver string = %s\n"
+		"\tguest account = nobody\n"
+		"\tsecurity = share\n"
+		"\tbrowseable = yes\n"
+		"\tguest ok = yes\n"
+		"\tguest only = yes\n"
+		"\tlog level = 1\n"
+		"\tmax log size = 100\n"
+		"\tencrypt passwords = no\n"
+		"\tpreserve case = yes\n"
+		"\tshort preserve case = yes\n",
+		nvram_get("lan_ifname") ? : "br0",
+		nvram_get("usb_smbwrkgrp_x") ? : "WORKGROUP",
+		nvram_get("productid") ? : "Samba");
+
+	if (nvram_invmatch("usb_smbcpage_x", ""))
+		fprintf(fp, "\tclient code page = %s\n", nvram_get("usb_smbcpage_x"));
+	if (nvram_match("usb_smbcset_x", "utf8"))
+		fprintf(fp, "\tcoding system = utf8\n");
+	else if (nvram_invmatch("usb_smbcset_x", ""))
+		fprintf(fp, "\tcharacter set = %s\n", nvram_get("usb_smbcset_x"));
 
-	if (nvram_match("usb_ftpanonymous_x", "1"))
+	if (nvram_match("usb_smbenable_x", "1"))
 	{
-		fprintf(fp, "user=anonymous * // 0 A\n");
+		fprintf(fp, "\n[share]\n"
+			"\tpath = /tmp/harddisk\n");
+		
+		if (nvram_match("usb_smbhidden_x", "1"))
+			fprintf(fp, "\n[share$]\n"
+				"\tpath = /tmp/harddisk\n"
+				"\tbrowseable = no\n");
+		
+		if (nvram_match("usb_smbhidden_x", "1") || 
+		    nvram_match("usb_smbhidden_x", "2"))
+			fprintf(fp, 
+				"\twritable = yes\n"
+				"\tforce user = %s\n",
+				nvram_get("http_username") ? : "root");
 	}
-	if (nvram_match("usb_ftpsuper_x", "1"))
+
+	/* share everything below /tmp/mnt */
+	if (nvram_match("usb_smbenable_x", "2") && (dir = opendir("/tmp/mnt")))
+		while ((dp = readdir(dir)))
 	{
-		fprintf(fp, "user=%s %s // 0 A\n", nvram_safe_get("http_username"), nvram_safe_get("http_passwd"));
+		if (strcmp(dp->d_name, ".") && strcmp(dp->d_name, ".."))
+		{
+			fprintf(fp, "\n[%s]\n"
+				"\tpath = /tmp/mnt/%s\n", dp->d_name, dp->d_name);
+
+			if (nvram_match("usb_smbhidden_x", "1"))
+				fprintf(fp, "\n[%s$]\n"
+					"\tpath = /tmp/mnt/%s\n"
+					"\tbrowseable = no\n", dp->d_name, dp->d_name);
+		
+			if (nvram_match("usb_smbhidden_x", "1") || nvram_match("usb_smbhidden_x", "2"))
+				fprintf(fp, 
+					"\twritable = yes\n"
+					"\tforce user = %s\n",
+					nvram_get("http_username") ? : "root");
+		}
 	}
 
-	write_ftp_banip(fp);
-	write_ftp_userlist(fp);
+	if (dir) closedir(dir);
+
+	if (nvram_match("usb_smbenable_x", "3"))
+	{
+		int i, count;
+		char tmp[] = "usb_smblist_xXXXXX";
+		
+		for (i = 0, count = atoi(nvram_safe_get("usb_smbnum_x")); i < count; i++) 
+		{
+			/* share name */
+			sprintf(tmp, "usb_smbshare_x%d", i);
+			if (!nvram_invmatch(tmp, ""))
+				continue;
+			fprintf(fp, "\n[%s]\n", nvram_get(tmp));
+		
+			/* path */
+			sprintf(tmp, "usb_smbdir_x%d", i);
+			fprintf(fp, "\tpath = %s\n", 
+				nvram_storage_path(tmp));
+
+			/* access level */
+			sprintf(tmp, "usb_smblevel_x%d", i);
+			if (nvram_match(tmp, "Read/Write"))
+				fprintf(fp, 
+					"\twritable = yes\n"
+					"\tforce user = %s\n",
+					nvram_get("http_username") ? : "root");
+			/* comment */
+			sprintf(tmp, "usb_smbdesc_x%d", i);
+			if (nvram_invmatch(tmp, ""))
+				fprintf(fp, "\tcomment = %s\n", nvram_get(tmp));
+		}
+	}
+			
 	fclose(fp);
 
-	//_eval(ftpd_argv, NULL, 0, &pid); 
-	eval("stupid-ftpd");
-}	
+	eval("/usr/sbin/nmbd", "-D");
+	eval("/usr/sbin/smbd", "-D");
+}
 
 int
 hotplug_usb_webcam(char *product, int webflag)
@@ -779,12 +1305,13 @@ hotplug_usb_webcam(char *product, int we
 	char **arg;
 	pid_t pid;
 
-	if (nvram_match("usb_webenable_x", "0") || strlen(product)==0 || webflag==0) return;
+	if (nvram_match("usb_webenable_x", "0") || strlen(product)==0 || webflag==0) return 1;
 	for (arg = rcamd_argv; *arg; arg++);
 	
 	if (webflag == WEB_PWCWEB)
 	{
-		eval("insmod", "pwc.o", "power_save=0");
+		eval("insmod", "pwc.o", "power_save=0", "size=vga");
+		eval("insmod", "pwcx.o");
 		nvram_set("usb_webdriver_x", "0");
 
 		*arg++ = "-t";
@@ -826,8 +1353,8 @@ hotplug_usb_webcam(char *product, int we
 	if (nvram_match("usb_webimage_x", "0"))
 	{
 		*arg++ = "-f";
-		if (webflag==WEB_PWCWEB) *arg++="320x240";
-		else *arg++="640x480";
+
+		*arg++="640x480";
 	}
 	else if (nvram_match("usb_webimage_x", "1"))
 	{
@@ -892,7 +1419,7 @@ hotplug_usb_webcam(char *product, int we
 	//_eval(httpd_argv, NULL, 0, &pid);
 	eval("httpd", nvram_safe_get("wan0_ifname"), nvram_safe_get("usb_webhttpport_x"));
 	chdir("/");
-	_eval(rcamd_argv, ">/dev/null", 0, NULL);
+	_eval(rcamd_argv, ">/dev/null", 0, &pid);
 
 	return 0;
 }
@@ -948,14 +1475,14 @@ start_rcamd(void)
 	char *rcamd_argv[] = {"rcamdmain", NULL};
 	pid_t pid;
 
-	_eval(rcamd_argv, NULL, 0, &pid);
-	return 0;
+	return _eval(rcamd_argv, NULL, 0, &pid);
 }
 
 int
 stop_rcamd(void)
 {
-	int ret = eval("killall", "rcamdmain");
+	eval("killall", "rcamdmain");
+	return 0;
 }
 
 
@@ -963,43 +1490,26 @@ stop_rcamd(void)
 int
 umount_all_part(char *usbdevice)
 {
-	int n;
 	DIR *dir_to_open;
 	struct dirent *dp;
 	char umount_dir[32];
 	
-
-	if(!(dir_to_open = opendir("/tmp/harddisk")))
-		perror("***cannot open /tmp/harddisk\n");
-
-	while(dir_to_open && (dp=readdir(dir_to_open)))
+	for (dir_to_open = opendir("/tmp/mnt");
+		dir_to_open && (dp=readdir(dir_to_open)); )
 	{
-		if(strncmp(dp->d_name, "..", NAME_MAX) == 0 ||
-		strncmp(dp->d_name, ".", NAME_MAX) == 0 ||
-		strncmp(dp->d_name, "part", 4) != 0)
-			continue;
-		
-		sprintf(umount_dir, "/tmp/harddisk/%s", dp->d_name);
-		if(umount(umount_dir))
+		if (strncmp(dp->d_name, "disc", 4) == 0)
 		{
-			//perror("umount failed");
+			sprintf(umount_dir, "/tmp/mnt/%s", dp->d_name);
+			if (!umount(umount_dir))
+				unlink(umount_dir);
 		}
-		//eval("umount", umount_dir);
 	}
 
 	if (dir_to_open)
 		closedir(dir_to_open);
 	
-	sprintf(umount_dir, "/tmp/harddisk");
-
-	//logs(umount_dir);
+	unlink("/tmp/harddisk");
 
-	// retry 3 times
-	if(umount(umount_dir))
-	{
-		//perror("umount failed");
-	}
-	//eval("umount", umount_dir);
 	return 0;
 }
 
@@ -1016,7 +1526,15 @@ remove_usb_mass(char *product)
 
 	if (product==NULL || nvram_match("usb_ftp_device", product))
 	{
-		eval("killall", "stupid-ftpd");
+		if (nvram_invmatch("usb_ftpenable_x", "0")) {
+			eval("killall", "stupid-ftpd");
+			eval("killall", "vsftpd");
+		}
+		if (nvram_invmatch("usb_smbenable_x", "0")) {
+			eval("killall", "smbd");
+			eval("killall", "nmbd");
+		}
+		
 		sleep(1);
 		umount_all_part("usb");
 		nvram_set("usb_ftp_device", "");
@@ -1041,173 +1559,242 @@ remove_storage_main(void)
 	return 0;
 }
 
-#define MOUNT_VAL_FAIL 	0
-#define MOUNT_VAL_RONLY	1
-#define MOUNT_VAL_RW 	2
-
-int
-mount_r(char *usb_part, char *usb_file_part)
+/* stollen from the e2fsprogs/ismounted.c */
+static struct mntent *findmntent(char *file)
 {
-	char msg[64];
+	struct mntent 	*mnt;
+	struct stat	st_buf;
+	dev_t		file_dev=0, file_rdev=0;
+	ino_t		file_ino=0;
+	FILE 		*f;
+	
+	if ((f = setmntent ("/proc/mounts", "r")) == NULL)
+		return NULL;
+
+	if (stat(file, &st_buf) == 0) {
+		if (S_ISBLK(st_buf.st_mode)) {
+			file_rdev = st_buf.st_rdev;
+		} else {
+			file_dev = st_buf.st_dev;
+			file_ino = st_buf.st_ino;
+		}
+	}
+	while ((mnt = getmntent (f)) != NULL) {
+		if (strcmp(file, mnt->mnt_fsname) == 0)
+			break;
+		if (stat(mnt->mnt_fsname, &st_buf) == 0) {
+			if (S_ISBLK(st_buf.st_mode)) {
+				if (file_rdev && (file_rdev == st_buf.st_rdev))
+					break;
+			} else {
+				if (file_dev && ((file_dev == st_buf.st_dev) &&
+						 (file_ino == st_buf.st_ino)))
+					break;
+			}
+		}
+	}
+
+	fclose(f);
+	return mnt;
+}
 
-	if(!mount(usb_part, usb_file_part, "ext2", MS_SYNCHRONOUS, NULL)) 
+char *detect_fs_type(char *device)
+{
+	int fd;
+	unsigned char buf[4096];
+	
+	if ((fd = open(device, O_RDONLY)) < 0)
+		return NULL;
+		
+	if (read(fd, buf, sizeof(buf)) != sizeof(buf))
 	{
-		sprintf(msg, "ext2 fs mounted to %s\n", usb_file_part);		
-		logmessage("USB storage", msg);
-		return MOUNT_VAL_RW;
+		close(fd);
+		return NULL;
 	}
-	if(!mount(usb_part, usb_file_part, "vfat", MS_SYNCHRONOUS, "codepage=950,iocharset=cp950")) 
+	
+	close(fd);
+	
+	/* first check for mbr */
+	if (*device && device[strlen(device) - 1] > '9' &&
+	    buf[510] == 0x55 && buf[511] == 0xAA && /* signature */
+	    ((buf[0x1be] | buf[0x1ce] | buf[0x1de] | buf[0x1ee]) & 0x7f) == 0) /* boot flags */
+	{
+		return "mbr";
+	} else
+	/* detect swap */
+	if (memcmp(buf + 4086, "SWAPSPACE2", 10) == 0 ||
+	    memcmp(buf + 4086, "SWAP-SPACE", 10) == 0)
+	{
+		return "swap";
+	} else
+	/* detect ext2/3 */
+	if (buf[0x438] == 0x53 && buf[0x439] == 0xEF)
+	{
+		return	((buf[0x460] & 0x0008 /* JOURNAL_DEV */) != 0 ||
+			 (buf[0x45c] & 0x0004 /* HAS_JOURNAL */) != 0) ? "ext3" : "ext2";
+	} else 
+	/* detect ntfs */
+	if (buf[510] == 0x55 && buf[511] == 0xAA && /* signature */
+	    memcmp(buf + 3, "NTFS    ", 8) == 0)
+	{
+		return "ntfs";
+	} else
+	/* detect vfat */
+	if (buf[510] == 0x55 && buf[511] == 0xAA && /* signature */
+	    buf[11] == 0 && buf[12] >= 1 && buf[12] <= 8 /* sector size 512 - 4096 */ &&
+	    buf[13] != 0 && (buf[13] & (buf[13] - 1)) == 0) /* sectors per cluster */
 	{
-		sprintf(msg, "vfat fs mounted to %s\n", usb_file_part);		
-		logmessage("USB storage", msg);
-		return MOUNT_VAL_RW;
+	 	return "vfat";
 	}
-	if(!mount(usb_part, usb_file_part, "msdos", MS_SYNCHRONOUS, NULL))
-	{
-		sprintf(msg, "msdos fs mounted to %s\n", usb_file_part);	
-		logmessage("USB storage", msg);
-		return MOUNT_VAL_RW;
+
+	return NULL;
+}
+
+#define MOUNT_VAL_FAIL 	0
+#define MOUNT_VAL_RONLY	1
+#define MOUNT_VAL_RW 	2
+
+int
+mount_r(char *mnt_dev, char *mnt_dir)
+{
+	struct mntent *mnt = findmntent(mnt_dev);
+	char *type;
+	
+	if (mnt) {
+		return strcmp(mnt->mnt_dir, mnt_dir) ? 
+			MOUNT_VAL_FAIL : MOUNT_VAL_RW;
 	}
-	if(!mount(usb_part, usb_file_part, "ntfs", MS_SYNCHRONOUS, "iocharset=cp950"))
+	
+	if ((type = detect_fs_type(mnt_dev))) 
 	{
-		sprintf(msg, "ntfs(ro) fs mounted to %s\n", usb_file_part);	
-		logmessage("USB storage", msg);
-		return MOUNT_VAL_RONLY;
+		char options[40];
+		unsigned long flags = MS_NOATIME;
+
+		options[0] = 0;
+		
+		if (strcmp(type, "swap") == 0 || strcmp(type, "mbr") == 0)
+			flags = 0; /* not a mountable partition */
+		else if (strcmp(type, "vfat") == 0)
+		{
+			if (nvram_invmatch("usb_smbcset_x", ""))
+				sprintf(options, "iocharset=%s%s", 
+					isdigit(nvram_get("usb_smbcset_x")[0]) ? "cp" : "",
+						nvram_get("usb_smbcset_x"));
+			if (nvram_invmatch("usb_smbcpage_x", ""))
+				sprintf(options + strlen(options), ",codepage=%s" + (options[0] ? 0 : 1), 
+					nvram_get("usb_smbcpage_x"));
+		}
+		else if (strcmp(type, "ntfs") == 0)
+		{
+			flags = MS_RDONLY;
+			if (nvram_invmatch("usb_smbcset_x", ""))
+				sprintf(options, "iocharset=%s%s", 
+					isdigit(nvram_get("usb_smbcset_x")[0]) ? "cp" : "",
+						nvram_get("usb_smbcset_x"));
+		}
+
+		if (flags && !mkdir_if_none(mnt_dir) &&
+			!mount(mnt_dev, mnt_dir, type, flags, options[0] ? options : NULL)) 
+		{
+			logmessage("USB storage", "%s%s fs at %s mounted to %s", 
+				type, (flags & MS_RDONLY) ? "(ro)" : "", mnt_dev, mnt_dir);
+			return (flags & MS_RDONLY) ? MOUNT_VAL_RONLY : MOUNT_VAL_RW;
+		}
+
+		rmdir(mnt_dir);
 	}
+	
 	return MOUNT_VAL_FAIL;
 }
 
 /* insert usb mass storage */
-hotplug_usb_mass(char *product)
+int hotplug_usb_mass(char *product)
 {	
-	DIR *dir_to_open, *dir_of_usb, *usb_dev_disc, *usb_dev_part;
-	char usb_disc[128], usb_part[128], usb_file_part[128];
-	int n = 0, m;
-	struct dirent *dp, *dp_disc, **dpopen;
+	DIR *dir_to_open, *usb_dev_disc, *usb_dev_part;
+	char usb_disc[128], mnt_dev[128], mnt_dir[128];
+	struct dirent *dp, *dp_disc;
 
-	if (nvram_match("usb_ftpenable_x", "0")) return;
-
-	dir_to_open=dir_of_usb=usb_dev_disc=usb_dev_part=NULL;
+	dir_to_open = usb_dev_disc = usb_dev_part = NULL;
 	
 	// Mount USB to system
 	if((usb_dev_disc = opendir("/dev/discs")))
 	{
+		eval("/usr/local/sbin/pre-mount", product);
+
+		struct stat st_buf;
+		if (stat("/etc/fstab", &st_buf) == 0) {
+			eval("swapon", "-a");
+			eval("mount", "-a");
+		}
+		
 		while(usb_dev_disc && (dp=readdir(usb_dev_disc)))
 		{
-			if(!strncmp(dp->d_name, "..", NAME_MAX) || !strncmp(dp->d_name, ".", NAME_MAX) /*|| !strncmp(dp->d_name, "disc0", NAME_MAX)*/)
+			if(!strcmp(dp->d_name, "..") || !strcmp(dp->d_name, "."))
 				continue;
 
 			sprintf(usb_disc, "/dev/discs/%s", dp->d_name);
 
-			//logs(usb_disc);
-
 			if((usb_dev_part = opendir(usb_disc)))
 			{
-				m = 0;
-
 				while(usb_dev_part && (dp_disc=readdir(usb_dev_part)))
 				{
-					//logs(dp_disc->d_name);
-
-					if(!strncmp(dp_disc->d_name, "..", NAME_MAX) || !strncmp(dp_disc->d_name, ".", NAME_MAX) ||
-!strncmp(dp_disc->d_name, "disc", NAME_MAX))
+					/* assume disc is the first entry */
+					int disc = !strcmp(dp_disc->d_name, "disc");
+					
+					if (!strcmp(dp_disc->d_name, "..") || !strcmp(dp_disc->d_name, "."))
 						continue;
 					
-					sprintf(usb_part, "/dev/discs/%s/%s", dp->d_name, dp_disc->d_name);
+					sprintf(mnt_dev, "/dev/discs/%s/%s", dp->d_name, dp_disc->d_name);
 
-					if (n==0)
-						sprintf(usb_file_part, "/tmp/harddisk");
-					else 
-						sprintf(usb_file_part, "/tmp/harddisk/part%d", n);
-
-					mkdir_if_none(usb_file_part);
-#if MOUNTALL
-					eval("mount", usb_part, usb_file_part);
-#else
-					if (mount_r(usb_part, usb_file_part))
-					{
-						n++;
-						m++;
-					}
-#endif	
-				}
+					if (disc) sprintf(mnt_dir, "/tmp/mnt/%s", dp->d_name);
+					else sprintf(mnt_dir, "/tmp/mnt/%s_%s", dp->d_name, 
+						dp_disc->d_name + (strncmp(dp_disc->d_name, "part", 4) ? 0 : 4));
 
-				if (!m) // There is no other partition
-				{
-										
-					sprintf(usb_part, "/dev/discs/%s/disc", dp->d_name);
-					if (n==0)
-						sprintf(usb_file_part, "/tmp/harddisk");
-					else 
-						sprintf(usb_file_part, "/tmp/harddisk/part%d", n++);
-#ifdef MOUNTALL
-					eval("mount", usb_part, usb_file_part);
-#else
-					if(mount_r(usb_part, usb_file_part))
+					if (mount_r(mnt_dev, mnt_dir))
 					{
-						n++;	
+						if (disc) break; /* no mbr -- no partitions */
 					}
-#endif
 				}
 			}
-				
 		}
-	}
-
-	if (n) 
-	{
-		nvram_set("usb_ftp_device", product);
-		start_ftpd();
-		//logmessage("USB storage", "attached");
-		start_script();
-		//run script if any
-	}
-	else
-	{
 		
-	}
-
-#ifdef USBCOPY_SUPPORT
-	n = 1;
-	if((dir_to_open = opendir("/tmp/harddisk")))
-	{
-		while(dir_to_open && (dp=readdir(dir_to_open)))
+		/* create /tmp/harddisk pointing to first partition */
+		usb_disc[0] = 0;	/* alphabetical sort minimum */
+		for (dir_to_open = opendir("/tmp/mnt");
+			dir_to_open && (dp = readdir(dir_to_open)); )
 		{
-			if(!strncmp(dp->d_name, "..", NAME_MAX) || !strncmp(dp->d_name, ".", NAME_MAX) || !strncmp(dp->d_name, "part", 4))
-				continue;
-			sprintf(usb_part, "/tmp/harddisk/%s", dp->d_name);
-			if(scandir(usb_part, &dpopen, 0, alphasort) <= 2)
-				continue;
-			while(1)
-			{
-				sprintf(path_copy_to, "/tmp/harddisk/part1/USBpart%03d", n);
-				if(!opendir(path_copy_to))
-				{
-					if(mkdir(path_copy_to, 0777))
-					{
-						perror("error on creating usb directory");
-					}
-					eval("echo", path_copy_to);
-					break;
-				}
-				else
-					n++;
+			if (!strncmp(dp->d_name, "disc", 4) &&
+			    (usb_disc[0] == 0 || strcmp(dp->d_name, usb_disc) < 0))
+				strcpy(usb_disc, dp->d_name);
+		}
+		
+		if (usb_disc[0])
+		{
+			sprintf(mnt_dir, "/tmp/mnt/%s", usb_disc);
+			symlink(mnt_dir, "/tmp/harddisk");
+
+			nvram_set("usb_ftp_device", product);
+			if (nvram_invmatch("usb_ftpenable_x", "0")) {
+				restart_ftpd();
 			}
-			if((dir_of_usb = opendir(usb_part)))
-			{
-				while(dir_of_usb && (dp_disc=readdir(dir_of_usb)))
-				{
-					if(!strncmp(dp_disc->d_name, "..", NAME_MAX) || !strncmp(dp_disc->d_name, ".", NAME_MAX))
-						continue;
-					sprintf(path_to_copy, "/tmp/harddisk/%s/%s", dp->d_name, dp_disc->d_name);
-					eval("cp", "-Rf", path_to_copy, path_copy_to);
-					sync();
-				}
+
+			if (nvram_invmatch("usb_smbenable_x", "0") && nvram_invmatch("lan_hostname", "")) {
+				restart_smbd();
+			}
+
+			if (nvram_match("usb_nfsenable_x", "1"))
+			{	
+				restart_nfsd();
 			}
-			n++;
+			
+			//logmessage("USB storage", "attached");
+			start_script();
 		}
+
+		//run script if any
+		eval("/usr/local/sbin/post-mount", product);
 	}
-#endif
+
 	if(usb_dev_disc)
 		closedir(usb_dev_disc);
 	if(usb_dev_part)
@@ -1226,7 +1813,7 @@ hotplug_usb_mass(char *product)
 int
 hotplug_usb(void)
 {
-	char *action, *interface, *product, *type;
+	char *action, *interface, *product;
 	int i;
 	int isweb;
 	char flag[6];
@@ -1236,6 +1823,16 @@ hotplug_usb(void)
 
 	if ((product=getenv("PRODUCT")))
 	{
+		/* usb storage */
+		if (strncmp(interface, "8/", 2) == 0)
+		{
+			if (strcmp(action, "add") == 0)
+				nvram_set("usb_storage_device", product);
+			else
+				remove_usb_mass(product);
+			return 0;
+		}
+
 		if (strncmp(interface, "1/1", 3)==0)
 		{
 			// if the audio device is the same with web cam,
@@ -1277,10 +1874,7 @@ usbhandler:	
 		nvram_set("usb_device", "1");
 		if (isweb==WEB_NONE)
 		{
-			if (nvram_match("usb_ftp_device", "")) // Treat it as USB storage
-			{
-				nvram_set("usb_storage_device", product);
-			}
+			/* old usb-storage handler */
 		}
 		else if (isweb==WEB_AUDIO)
 		{
@@ -1304,7 +1898,7 @@ usbhandler:	
 	{
 		if (isweb==WEB_NONE) // Treat it as USB Storage
 		{
-			remove_usb_mass(product);
+			/* old usb-storage handler */
 		}
 		else if(isweb==WEB_AUDIO)
 		{
@@ -1330,11 +1924,13 @@ usbhandler:	
 int
 stop_service_main(int argc, char *argv[])
 {
+	stop_snmpd();
 	stop_misc();
 	stop_logger();
 	stop_usb();
 
-	stop_nas();
+	/* nas is still needed for upgrade over WiFI with WPA enabled */
+	/* stop_nas();*/
 	stop_upnp();
 	stop_dhcpd();
 	stop_dns();
@@ -1349,7 +1945,6 @@ int service_handle(void)
 	char tmp[100], *str;
 	int unit;
 	int pid;
-	char *ping_argv[] = { "ping", "140.113.1.1", NULL};
 	FILE *fp;
 
 	service = nvram_get("rc_service");
@@ -1396,19 +1991,11 @@ int service_handle(void)
 		}
 		else 
 		{
-			// pppoe or ppptp, check if /tmp/ppp exist
-			if (nvram_invmatch("wan0_proto", "static") && (fp=fopen("/tmp/ppp/ip-up", "r"))!=NULL)
-			{
-				fclose(fp);
-				_eval(ping_argv, NULL, 0, &pid);
-
-			}
-			else
-			{
-				stop_wan();
-				start_wan();
-				_eval(ping_argv, NULL, 0, &pid);
-			}
+			stop_wan();
+			sleep(5);
+			start_wan();
+			/* trigger connect */
+			eval("nslookup", "localhost");
 		}
 	}
 	nvram_unset("rc_service");
@@ -1420,13 +2007,14 @@ int hotplug_usb_audio(char *product)
 	char *wave_argv[]={"waveserver", NULL};
 	pid_t pid;
 
-	if (strlen(product)==0) return;
-	_eval(wave_argv, ">/dev/null", 0, NULL);
+	if (strlen(product)==0) return 1;
+	return _eval(wave_argv, ">/dev/null", 0, &pid);
 }
 
 int remove_usb_audio(char *product)
 {
 	eval("killall", "waveserver");
+	return 0;
 }
 
 int
@@ -1435,14 +2023,14 @@ start_audio(void)
 	char *wave_argv[] = {"waveservermain", NULL};
 	pid_t pid;
 
-	_eval(wave_argv, NULL, 0, &pid);
-	return 0;
+	return _eval(wave_argv, NULL, 0, &pid);
 }
 
 int
 stop_audio(void)
 {
-	int ret = eval("killall", "waveserver");
+	eval("killall", "waveserver");
+	return 0;
 }
 
 
diff -BurpN -x'*.o' router/rc/udhcpc.c gateway/rc/udhcpc.c
--- router/rc/udhcpc.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/udhcpc.c	2008-03-19 20:07:24.000000000 +0300
@@ -88,10 +88,10 @@ bound(void)
 	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
 	int unit;
 
-	if ((unit = wan_ifunit(wan_ifname)) < 0)
-		return -1;
-
-	snprintf(prefix, sizeof(prefix), "wan%d_", unit);
+	if ((unit = wan_ifunit(wan_ifname)) < 0) 
+		strcpy(prefix, "wanx_");
+	else
+		snprintf(prefix, sizeof(prefix), "wan%d_", unit);
 	
 	if ((value = getenv("ip")))
 		nvram_set(strcat_r(prefix, "ipaddr", tmp), trim_r(value));
@@ -103,8 +103,13 @@ bound(void)
 		nvram_set(strcat_r(prefix, "dns", tmp), trim_r(value));
 	if ((value = getenv("wins")))
 		nvram_set(strcat_r(prefix, "wins", tmp), trim_r(value));
+
+	nvram_set(strcat_r(prefix, "routes", tmp), getenv("routes"));
+	nvram_set(strcat_r(prefix, "msroutes", tmp), getenv("msroutes"));
+#if 0
 	if ((value = getenv("hostname")))
 		sethostname(trim_r(value), strlen(value) + 1);
+#endif
 	if ((value = getenv("domain")))
 		nvram_set(strcat_r(prefix, "domain", tmp), trim_r(value));
 	if ((value = getenv("lease"))) {
@@ -138,7 +143,8 @@ bound(void)
 static int
 renew(void)
 {
-	bound();
+	/* XXX: add checks at some day... */
+	/* bound(); */
 
 	dprintf("done\n");
 	return 0;
@@ -158,5 +164,7 @@ udhcpc_main(int argc, char **argv)
 		return bound();
 	else if (strstr(argv[1], "renew"))
 		return renew();
+	else if (strstr(argv[1], "leasefail"))
+		return 0;
 	else return deconfig();
 }
diff -BurpN -x'*.o' router/rc/udhcpc_ex.c gateway/rc/udhcpc_ex.c
--- router/rc/udhcpc_ex.c	2004-11-11 10:32:05.000000000 +0300
+++ gateway/rc/udhcpc_ex.c	2008-03-19 20:07:24.000000000 +0300
@@ -98,8 +98,10 @@ bound(void)
 		nvram_set(strcat_r(prefix, "dns_t", tmp), value);
 	if ((value = getenv("wins")))
 		nvram_set(strcat_r(prefix, "wins_t", tmp), value);
+#if 0
 	if ((value = getenv("hostname")))
 		sethostname(value, strlen(value) + 1);
+#endif
 	if ((value = getenv("domain")))
 		nvram_set(strcat_r(prefix, "domain_t", tmp), value);
 	if ((value = getenv("lease"))) {
@@ -153,5 +155,7 @@ udhcpc_ex_main(int argc, char **argv)
 		return bound();
 	else if (strstr(argv[1], "renew"))
 		return renew();
+	else if (strstr(argv[1], "leasefail"))
+		return 0;
 	else return deconfig();
 }
diff -BurpN -x'*.o' router/rc/vlan.c gateway/rc/vlan.c
--- router/rc/vlan.c	2004-12-01 21:53:06.000000000 +0300
+++ gateway/rc/vlan.c	2008-03-19 20:07:24.000000000 +0300
@@ -81,6 +81,20 @@ int vlan_configured = 0;
 int brcm_tag_driver_enabled = 0;
 #define IFUP (IFF_UP | IFF_RUNNING | IFF_BROADCAST | IFF_MULTICAST)
 
+static void
+enable_wan_port(void)
+{
+	char val8 = 0;
+	
+	if ((bcm_api_init()) < 0)
+		return;
+
+	/* enable physical WAN port */
+	bcm_write_reg(0, ROBO_CTRL_PAGE, ROBO_PORT0_CTRL, &val8, 1);
+
+	bcm_api_deinit();
+}
+
 static int
 vlan_configure(void)
 
@@ -89,7 +103,7 @@ vlan_configure(void)
     char *vlan_enable = nvram_safe_get("vlan_enable");
     char *lan_ifname = nvram_safe_get("lan_ifname");
     char *lan_ifnames = nvram_safe_get("lan_ifnames");
-    char *wan_hwaddr = nvram_safe_get("wan_hwaddr");
+    char *wan_hwaddr = nvram_safe_get("wan0_hwaddr"); /* BUG */
     char *wan_ifname = NULL;
 	char *wan_proto;
 	char tmp[100], prefix[] = "wanXXXXXXXXXX_";
@@ -163,6 +177,7 @@ vlan_configure(void)
         if (bcm_is_robo())
         {
         	dprintf("No active, configured WAN interface found\n");
+        	enable_wan_port();
         }
         return -1;
     }
@@ -213,7 +228,7 @@ vlan_configure(void)
 	    return -1;
     }
     if (strlen(restore_wan_hwaddr)) {
-	if (nvram_set(strcat_r(prefix, "wan_hwaddr", tmp), restore_wan_hwaddr))
+	if (nvram_set(strcat_r(prefix, "hwaddr", tmp), restore_wan_hwaddr))
 	    return -1;
 	if (nvram_unset("restore_wan_hwaddr"))
 	    return -1;
@@ -221,8 +236,10 @@ vlan_configure(void)
 
     /* now check to see if vlan disabled */
     /* disabled, just exit */
-    if (!bVlan)
+    if (!bVlan) {
+	enable_wan_port();
 	return 0;
+    }
     
     /* activate interface to Robo switch */
     if ((bcm_api_init())<0) {
@@ -638,7 +655,7 @@ vlan_deconfigure(void)
 	    return -1;
     }
     if (strlen(restore_wan_hwaddr)) {
-	if (nvram_set(strcat_r(prefix, "wan_hwaddr", tmp), restore_wan_hwaddr))
+	if (nvram_set(strcat_r(prefix, "hwaddr", tmp), restore_wan_hwaddr))
 	    return -1;
 	if (nvram_unset("restore_wan_hwaddr"))
 	    return -1;
diff -BurpN -x'*.o' router/rc/watchdog.c gateway/rc/watchdog.c
--- router/rc/watchdog.c	2004-11-21 19:55:46.000000000 +0300
+++ gateway/rc/watchdog.c	2009-01-19 12:55:48.000000000 +0300
@@ -17,7 +17,9 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
+#include <fcntl.h>
 
 #include <bcmnvram.h>
 #include <shutils.h>
@@ -33,7 +35,11 @@
 
 #define BCM47XX_SOFTWARE_RESET  0x40		/* GPIO 6 */
 #define RESET_WAIT		3		/* seconds */
-#define RESET_WAIT_COUNT	RESET_WAIT * 10 /* 10 times a second */
+#define RESET_STATE		5		/* seconds */
+#define RESET_WAIT_COUNT	(RESET_WAIT * 10) /* 10 times a second */
+#define RESET_STATE_COUNT	(RESET_STATE * 10)/* 10 times a second */
+#define SETUP_WAIT_COUNT	3
+#define SETUP_STATE_COUNT	5
 
 #define NORMAL_PERIOD		1		/* second */
 #define URGENT_PERIOD		100 * 1000	/* microsecond */	
@@ -49,68 +55,195 @@
 #define GPIO5 0x0020
 #define GPIO6 0x0040
 #define GPIO7 0x0080
+#define GPIO15 0x8000
 
-#define LED_ON 	0
-#define LED_OFF 1
+// failsafe defaults, independent of nvram state
+#if defined(CONFIG_WL550GE)
+
+static int reset_mask	= GPIO1;
+static int reset_value	= GPIO1;
+static int ready_mask	= GPIO2;
+static int ready_value	= 0;
+static int setup_mask	= GPIO15;
+static int setup_value	= GPIO15;
+static int power_mask	= 0;
+static int power_value	= 0;
+
+#elif defined(CONFIG_WL500GP)
+
+static int reset_mask	= GPIO0;
+static int reset_value	= GPIO0;
+static int ready_mask	= GPIO1;
+static int ready_value	= 0;
+static int setup_mask	= GPIO4;
+static int setup_value	= GPIO4;
+static int power_mask	= 0;
+static int power_value	= 0;
+
+#elif defined(CONFIG_WL500W)
+
+static int reset_mask	= GPIO6;
+static int reset_value	= GPIO6;
+static int ready_mask	= GPIO5;
+static int ready_value	= 0;
+static int setup_mask	= GPIO7;
+static int setup_value	= GPIO7;
+static int power_mask	= 0;
+static int power_value	= 0;
+/* -robo_reset is GPIO0 */
+
+#elif defined(CONFIG_WL700G)
+
+static int reset_mask	= GPIO0; /* PWR */
+static int reset_value	= GPIO0;
+static int ready_mask	= GPIO1; /* GPIO3 - PWR */
+static int ready_value	= 0;
+static int setup_mask	= GPIO4;
+static int setup_value	= GPIO4;
+static int power_mask	= GPIO3;	/* POWER button light */
+static int power_value  = GPIO3;
+/* copy is GPIO6, ez is GPIO4, pwr is GPIO0 */
+/* hwpower is GPIO7, pwr is GPIO3, -ready is GPIO1 */
+/* GPIO2 is SDA, GPIO5 is SCL */
+
+#elif defined(CONFIG_WL520GX)
+
+static int reset_mask	= GPIO2;
+static int reset_value	= 0;
+static int ready_mask	= GPIO0;
+static int ready_value	= 0;
+static int setup_mask	= GPIO3;
+static int setup_value	= 0;
+static int power_mask	= 0;
+static int power_value	= 0;
+
+#else
+
+static int reset_mask = GPIO6;
+#ifdef CONFIG_WLHDD
+static int reset_value = 0;
+/* GPIO4 is SDA, GPIO5 is SCL */
+#else
+static int reset_value = GPIO6;
+#endif
+
+static int ready_mask = GPIO0;	/* Ready or Power LED */
+static int ready_value = 0;
+static int setup_mask = 0;	/* EZ-Setup button */
+static int setup_value = 0;
+static int power_mask = 0;	/* POWER button light */
+static int power_value = 0;
+
+#endif
+
+#define LED_READY_ON 	(ready_value)
+#define LED_READY_OFF (~ready_value)
+
+#define LED_READY	ready_mask
 
-#define LED_POWER	GPIO0
-#define BTN_RESET	GPIO6
 #define LED_CONTROL(led,flag) gpio_write("/dev/gpio/out", led, flag)
 
-struct itimerval itv; 
+static struct itimerval itv; 
 int watchdog_period=0;
-static int btn_pressed=0;
-static int btn_count = 0;
 long sync_interval=-1; // every 30 seconds a unit
 int sync_flag=0;
 long timestamp_g=0;
 int stacheck_interval=-1;
 
 
-void gpio_write(char *dev, int gpio, int flag)
+void gpio_write(char *dev, int mask, int value)
 {
-	unsigned int val;
-	FILE *fp;	
-
-	val = gpio_read(dev, 0xffff);
-
-	fp=fopen(dev, "w");
-	if (fp!=NULL)
+	unsigned int val = 0;
+	int fd = open(dev, O_RDWR);
+	
+	if (fd != -1)
 	{
-		if (flag) val|=gpio;
-		else val&=~gpio;
-
-		fwrite(&val, 4, 1, fp);
-		fclose(fp);
-	}	
+		if (read(fd, &val, sizeof(val)) == sizeof(val))
+		{
+			val = (val & ~mask) | (value & mask);
+			write(fd, &val, sizeof(val));
+		}
+		close(fd);
+	}
 }
 
-int gpio_read(char *dev, int gpio)
+unsigned int gpio_read(char *dev)
 {
-	unsigned int val;
-	FILE *fp;
-
-	fp=fopen(dev, "r");
-
-	if (fp!=NULL)
+	unsigned int val = 0;
+	int fd = open(dev, O_RDONLY);
+	
+	if (fd != -1) 
 	{
-		fread(&val, 4, 1, fp);
-		fclose(fp);
-		return(val&gpio);		
+		read(fd, &val, sizeof(val));
+		close(fd);
 	}
-	return 0;
+	
+	return val;
 }
 
 
 /* Functions used to control led and button */
-gpio_init()
+void gpio_init(void)
 {
-	unsigned int outen;
-
-	// gpio 0 as output
-	// gpio 6 as input
-	gpio_write("/dev/gpio/outen", LED_POWER, 1);
-	gpio_write("/dev/gpio/outen", BTN_RESET, 0);
+	// overrides based on nvram
+	if (nvram_match("boardnum", "mn700")) {
+		reset_mask = GPIO7, reset_value = 0;
+		ready_mask = GPIO6, ready_value = GPIO6;
+	} else
+	// wl550gE
+	if (nvram_match("boardtype", "0x467") && 
+		nvram_match("boardnum", "45")) 
+	{
+		reset_mask = GPIO1, reset_value = GPIO1;
+		ready_mask = GPIO2, ready_value = 0;
+		setup_mask = GPIO15, setup_value = GPIO15;
+	} else
+	// wl500gp
+	if (nvram_match("boardtype", "0x042f") && 
+		nvram_match("boardnum", "45")) 
+	{
+		reset_mask = GPIO0, reset_value = GPIO0;
+		ready_mask = GPIO1, ready_value = 0;
+		setup_mask = GPIO4, setup_value = GPIO4;
+	} else
+	// wl500w
+	if (nvram_match("boardtype", "0x0472") && 
+		nvram_match("boardnum", "45")) 
+	{
+		reset_mask = GPIO6, reset_value = GPIO6;
+		ready_mask = GPIO5, ready_value = 0;
+		setup_mask = GPIO7, setup_value = GPIO7;
+	} else
+	// wl700g
+	if (nvram_match("boardtype", "0x042f") && 
+		nvram_match("boardnum", "44")) 
+	{
+		reset_mask = GPIO0, reset_value = GPIO0;
+		ready_mask = GPIO1, ready_value = 0;
+		/* enable copy button too */
+		setup_mask = GPIO4 | GPIO6, setup_value = GPIO4;
+		power_mask = GPIO3, power_value = GPIO3;
+	} else
+	// wl520gU
+	if (nvram_match("boardtype", "0x48E") && 
+		nvram_match("boardnum", "45")) 
+	{
+		reset_mask = GPIO2, reset_value = 0;
+		ready_mask = GPIO0, ready_value = 0;
+		setup_mask = GPIO3, setup_value = 0;
+	}
+	// DLINK DIR-320
+	if (nvram_match("boardtype", "0x048e") &&
+		!nvram_match("boardnum", "45"))
+	{
+		reset_mask = GPIO7, reset_value = 0;
+		ready_mask = GPIO1, ready_value = 0;
+		setup_mask = GPIO6, setup_value = 0;
+	}
+	gpio_write("/dev/gpio/outen", ready_mask | power_mask | 
+		reset_mask | setup_mask, ready_mask | power_mask);
+	gpio_write("/dev/gpio/control", ready_mask | power_mask |
+		reset_mask | setup_mask, 0);
 }
 
 static void
@@ -124,48 +257,94 @@ alarmtimer(unsigned long sec,unsigned lo
 
 void btn_check(void)
 {
-	//printf("btn :  %d %d\n", btn_pressed, btn_count);	
-	if (gpio_read("/dev/gpio/in", BTN_RESET))
+	static int pressed;
+
+	if ((gpio_read("/dev/gpio/in") & reset_mask) == reset_value)
 	{
-		if (!btn_pressed)
-		{
-			btn_pressed=1;
-			btn_count=0;
-			alarmtimer(0, URGENT_PERIOD);
+		/* Whenever it is pushed steady */
+		if (++pressed < RESET_WAIT_COUNT) {
+			if (pressed == 1) alarmtimer(0, URGENT_PERIOD);
+		} else {
+			switch ((pressed - RESET_WAIT_COUNT) / RESET_STATE_COUNT) {
+			case 0: /* power off indication */
+#if defined(CONFIG_WLHDD) || defined(CONFIG_WL700G)
+				LED_CONTROL(LED_READY, LED_READY_OFF);
+				break;
+#endif
+			case 1:	/* restore to defaults indication */
+				LED_CONTROL(LED_READY, (pressed & 1) ? LED_READY_OFF : LED_READY_ON);
+				break;
+			default: /* start over */
+				pressed = 0;
+				LED_CONTROL(LED_READY, LED_READY_ON);
+				break;
+			}
 		}
-		else {	/* Whenever it is pushed steady */
-			if( ++btn_count > RESET_WAIT_COUNT )
-			{
-				btn_pressed=2;
+	}
+	else
+	{
+		if (pressed < RESET_WAIT_COUNT) {
+			if (pressed) {
+				alarmtimer(NORMAL_PERIOD, 0);
+				LED_CONTROL(LED_READY, LED_READY_ON);
 			}
+		} else {
+			switch ((pressed - RESET_WAIT_COUNT) / RESET_STATE_COUNT) {
+			case 0: /* power off */
+#if defined(CONFIG_WLHDD) || defined(CONFIG_WL700G)
+				alarmtimer(0, 0);
+				kill(1, SIGQUIT);
+				break;
+#endif
+			case 1:	/* restore to defaults */
+				alarmtimer(0, 0);
+				eval("erase", "/dev/mtd/3");
+				kill(1, SIGTERM);
+				break;
+			}
+		}		
+		pressed = 0;
+	}
+}
 
-			if (btn_pressed==2)
-			{
-				/* 0123456789 */
-				/* 0011100111 */
-				if ((btn_count%10)<1 ||
-				    ((btn_count%10)>4 && (btn_count%10)<7)) LED_CONTROL(LED_POWER, LED_OFF);
-				else LED_CONTROL(LED_POWER, LED_ON);
-
+void setup_check(void)
+{
+	static int pressed;
 
+	if ((gpio_read("/dev/gpio/in") & setup_mask) == setup_value)
+	{
+		/* Whenever it is pushed steady */
+		if (++pressed < SETUP_WAIT_COUNT) {
+			//if (pressed == 1) alarmtimer(0, URGENT_PERIOD);
+		} else {
+			switch ((pressed - SETUP_WAIT_COUNT) / SETUP_STATE_COUNT) {
+			case 0:	/* action indication */
+				LED_CONTROL(LED_READY, (pressed & 1) ? LED_READY_OFF : LED_READY_ON);
+				break;
+			default: /* start over */
+				pressed = 0;
+				LED_CONTROL(LED_READY, LED_READY_ON);
+				break;
 			}
 		}
 	}
 	else
 	{
-		if(btn_pressed==1)
-		{
-			btn_count = 0;
-			btn_pressed = 0;			
-			LED_CONTROL(LED_POWER, LED_ON);
-			alarmtimer(NORMAL_PERIOD, 0);
-		}
-		else if(btn_pressed==2)
-		{
-			alarmtimer(0, 0);
-			eval("erase", "/dev/mtd/3");
-			kill(1, SIGTERM);
-		}
+		if (pressed < SETUP_WAIT_COUNT) {
+			if (pressed) {
+				//alarmtimer(NORMAL_PERIOD, 0);
+				LED_CONTROL(LED_READY, LED_READY_ON);
+			}
+		} else {
+			switch ((pressed - SETUP_WAIT_COUNT) / SETUP_STATE_COUNT) {
+			case 0: /* action */
+				//alarmtimer(0, 0);
+				LED_CONTROL(LED_READY, LED_READY_ON);
+				eval("/usr/local/sbin/ez-setup");
+				break;
+			}
+		}		
+		pressed = 0;
 	}
 }
 
@@ -202,8 +381,8 @@ int ntp_timesync(void)
 
 		   	if (tm.tm_year>100) // More than 2000 
 		   	{	 
-		      		sync_interval=60*60/5;
-			  	logmessage("ntp client", "time is synchronized to %s", nvram_safe_get("ntp_servers"));
+		      		sync_interval = (atoi(nvram_safe_get("ntp_interval_x")) ? : 2) * 360;
+			  	logmessage("ntp client", "Synchronizing time with %s...", nvram_safe_get("ntp_servers"));
 
 				stop_upnp();
 				start_upnp();
@@ -213,6 +392,7 @@ int ntp_timesync(void)
 			refresh_ntpc();	
 		}
 	}	
+	return 0;
 }
 
 enum 
@@ -226,7 +406,7 @@ enum 
 int svcStatus[ACTIVEITEMS] = { -1, -1, -1};
 int extStatus[ACTIVEITEMS] = { 0, 0, 0};
 char svcDate[ACTIVEITEMS][10];
-char *svcTime[ACTIVEITEMS][20];
+char svcTime[ACTIVEITEMS][20];
 
 int timecheck_item(char *activeDate, char *activeTime)
 {
@@ -303,8 +483,8 @@ int svc_timecheck(void)
 		{
 			//printf("url time change: %d\n", activeNow);
 			svcStatus[URLACTIVE] = activeNow;
-			stop_dns();
-			start_dns();
+			//stop_dns();
+			//start_dns();
 		}
 	}
 
@@ -359,7 +539,7 @@ int http_processcheck(void)
 	char buf[256];
 
 	//printf("http check\n");
-	sprintf(http_cmd, "http://127.0.0.1/");
+	sprintf(http_cmd, "http://127.0.0.1:%s/", nvram_safe_get("http_lanport"));
 	if (!http_check(http_cmd, buf, sizeof(buf), 0))
 	{
 		dprintf("http rerun\n");
@@ -403,11 +583,7 @@ int rcamd_processcheck()
 	{
 		while(fgets(buf, sizeof(buf), fp))
 		{
-#ifdef WL500GX
-			if (strstr(buf, "ehci"))
-#else
-			if (strstr(buf, "ohci"))
-#endif
+			if (strstr(buf, "ehci") || strstr(buf, "ohci"))
 			{
 				//logmessage("web camera", buf);
 
@@ -581,12 +757,14 @@ void sta_check(void)
  *      3. http-process
  *      4. usb hotplug status
  */
-void watchdog(void)
+void watchdog(int signum)
 {
 	time_t now;
 	/* handle button */
-	btn_check();
-
+	if (reset_mask) btn_check();
+	/* handle ezsetup */
+	if (setup_mask) setup_check();
+	
 	/* if timer is set to less than 1 sec, then bypass the following */
 	if (itv.it_value.tv_sec==0) return;
 
@@ -641,6 +819,30 @@ void watchdog(void)
 }
 
 int 
+poweron_main(int argc, char *argv[])
+{
+	/* Start GPIO function */
+	gpio_init();
+	
+	if (power_mask) {
+		gpio_write("/dev/gpio/out", power_mask,	power_value);
+		/* sleep to allow hdd to spin up */
+		sleep(2);
+	}
+	
+	return 0;
+}
+
+static int running = 1;
+
+static void readyoff(int sig)
+{
+	gpio_write("/dev/gpio/out", ready_mask, ~ready_value);
+	
+	running = 0;
+}
+
+int 
 watchdog_main(int argc, char *argv[])
 {
 	FILE *fp;
@@ -672,22 +874,24 @@ watchdog_main(int argc, char *argv[])
 	signal(SIGUSR1, catch_sig);
 	signal(SIGUSR2, catch_sig);
 	signal(SIGALRM, watchdog);
-
-	/* set timer */
-	alarmtimer(NORMAL_PERIOD, 0);
+	signal(SIGTERM, readyoff);
 
 	/* Start GPIO function */
 	gpio_init();
 
-	/* Start POWER LED */
-	LED_CONTROL(LED_POWER, LED_ON);
+	/* turn on POWER and READY LEDs */
+	gpio_write("/dev/gpio/out", power_mask | ready_mask,
+		power_value | ready_value);
 
 	/* Start sync time */
 	sync_interval=1;
 	start_ntpc();
 
+	/* set timer */
+	alarmtimer(NORMAL_PERIOD, 0);
+
 	/* Most of time it goes to sleep */
-	while(1)
+	while (running)
 	{
 		pause();
 	}
diff -BurpN -x'*.o' router/rc/waveserver.c gateway/rc/waveserver.c
--- router/rc/waveserver.c	2004-11-16 15:54:35.000000000 +0300
+++ gateway/rc/waveserver.c	2008-12-28 10:28:04.000000000 +0300
@@ -16,6 +16,7 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #include <bcmnvram.h>
